/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/public/js/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Vue = __webpack_require__(1)
	var md = __webpack_require__(3)
	var katex = __webpack_require__(4)
	var ace = __webpack_require__(95);
	__webpack_require__(98);
	__webpack_require__(103);

	window.katex = katex;

	var formula = {
	  'common': {
	    name: '常用',
	    value: [
	      "{/}frac{a}{b}", "^{a}/_{b}", "a^{b}", "a_{b}", "x^{a}_{b}", "{/}bar{a}", "{/}sqrt{x}",
	      "{/}sum_x^xx", "{/}sum", "{/}log_{x}", "{/}ln", "{/}int_{a}^{b}", "{/}oint_{a}^{b}", "\\left\\{_1^1\\right\\}", "^{\\frown}_{AB}"
	    ]
	  },
	  'symbol': {
	    name: '符号',
	    value: [
	      "+", "-", "{/}pm", "{/}times", "{/}ast", "{/}div", "/", "{/}bigtriangleup",
	      "=", "{/}ne", "{/}approx", ">", "<", "{/}ge", "{/}le", "{/}infty",
	      "{/}cap", "{/}cup", "{/}because", "{/}therefore", "{/}subset", "{/}supset", "{/}subseteq", "{/}supseteq",
	      "{/}nsubseteq", "{/}nsupseteq", "{/}in", "{/}ni", "{/}notin", "{/}mapsto", "{/}leftarrow", "{/}rightarrow",
	      "{/}Leftarrow", "{/}Rightarrow", "{/}leftrightarrow", "{/}Leftrightarrow", "∠", "º", '{/}perp', '{/}odot'
	    ]
	  },
	  'letter': {
	    name: '字母',
	    value: [
	      "{/}alpha", "{/}beta", "{/}gamma", "{/}delta", "{/}varepsilon", "{/}varphi", "{/}lambda", "{/}mu",
	      "{/}rho", "{/}sigma", "{/}omega", "{/}Gamma", "{/}Delta", "{/}Theta", "{/}Lambda", "{/}Xi",
	      "{/}Pi", "{/}Sigma", "{/}Upsilon", "{/}Phi", "{/}Psi", "{/}Omega", "{/}pi"
	    ]
	  }
	};

	var testVal = '![XXX](http://img.jyeoo.net/quiz/images/201204/4/53aae10e.png#right)如图，长方形ABCD，设其长AD=a，宽AB=b（a＞b），在BC边上选取一点E，将△ABE沿AE翻折后B至直线BD上的O点，若O为长方形ABCD的对称中心，则 $\\frac{a}{b}$ 的值是_____．'

	new Vue({
	  el: '#editorWrap',
	  data: {
	    input: '',
	    formula: formula,
	    initFormula: false
	  },
	  filters: {
	    toLatexHtml: function(str){
	      try {
	        return '<span class="math inline">' + katex.renderToString (str) + '</span>';
	      } catch (e) {
	        return '<span class="math inline">' + str + '</span>';
	      }
	    },
	    latex: function(latex){
	      return latex.replace("{/}", "\\")
	    }
	  },
	  ready: function(){
	    var that = this;

	    that.initFormula = true;
	    this.initEditor(this.$els.editor);

	    setTimeout(function(){
	      that._editor.setValue(testVal)
	    }, 1000);

	  },
	  methods:{
	    onClickLatex: function(e){
	      var la = e.currentTarget.dataset.value;
	      la = '$' + la + '$'
	      this._editor.insert(la)
	    },
	    initEditor: function($el){
	      this._editor = ace.edit($el)
	      this._editor.getSession().setMode("ace/mode/markdown")
	      this._editor.setTheme('ace/theme/eclipse')
	      this._editor.renderer.setShowGutter(false);
	      this._editor.getSession().setUseWrapMode(true);

	      // this._editor.on('focus', this.onAceFocus);
	      // this._editor.on('blur', this.onAceBlur);
	      // this._editor.on('copy', this.onAceCopy);
	      this._editor.on('paste', this.onAcePaste);
	      this._editor.on('change', this.onAceChange.bind(this));
	    },
	    onAceChange: function(){
	      var val = this._editor.getValue();

	      val = val.replace(/\_\_\_\_\_/g, '\\_\\_\\_\\_\\_');


	      this.input = md.render(val)
	    },
	    onAcePaste: function(){

	    }
	  }
	});

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/*!
	 * Vue.js v1.0.21
	 * (c) 2016 Evan You
	 * Released under the MIT License.
	 */
	'use strict';

	function set(obj, key, val) {
	  if (hasOwn(obj, key)) {
	    obj[key] = val;
	    return;
	  }
	  if (obj._isVue) {
	    set(obj._data, key, val);
	    return;
	  }
	  var ob = obj.__ob__;
	  if (!ob) {
	    obj[key] = val;
	    return;
	  }
	  ob.convert(key, val);
	  ob.dep.notify();
	  if (ob.vms) {
	    var i = ob.vms.length;
	    while (i--) {
	      var vm = ob.vms[i];
	      vm._proxy(key);
	      vm._digest();
	    }
	  }
	  return val;
	}

	/**
	 * Delete a property and trigger change if necessary.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 */

	function del(obj, key) {
	  if (!hasOwn(obj, key)) {
	    return;
	  }
	  delete obj[key];
	  var ob = obj.__ob__;
	  if (!ob) {
	    return;
	  }
	  ob.dep.notify();
	  if (ob.vms) {
	    var i = ob.vms.length;
	    while (i--) {
	      var vm = ob.vms[i];
	      vm._unproxy(key);
	      vm._digest();
	    }
	  }
	}

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	/**
	 * Check whether the object has the property.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @return {Boolean}
	 */

	function hasOwn(obj, key) {
	  return hasOwnProperty.call(obj, key);
	}

	/**
	 * Check if an expression is a literal value.
	 *
	 * @param {String} exp
	 * @return {Boolean}
	 */

	var literalValueRE = /^\s?(true|false|-?[\d\.]+|'[^']*'|"[^"]*")\s?$/;

	function isLiteral(exp) {
	  return literalValueRE.test(exp);
	}

	/**
	 * Check if a string starts with $ or _
	 *
	 * @param {String} str
	 * @return {Boolean}
	 */

	function isReserved(str) {
	  var c = (str + '').charCodeAt(0);
	  return c === 0x24 || c === 0x5F;
	}

	/**
	 * Guard text output, make sure undefined outputs
	 * empty string
	 *
	 * @param {*} value
	 * @return {String}
	 */

	function _toString(value) {
	  return value == null ? '' : value.toString();
	}

	/**
	 * Check and convert possible numeric strings to numbers
	 * before setting back to data
	 *
	 * @param {*} value
	 * @return {*|Number}
	 */

	function toNumber(value) {
	  if (typeof value !== 'string') {
	    return value;
	  } else {
	    var parsed = Number(value);
	    return isNaN(parsed) ? value : parsed;
	  }
	}

	/**
	 * Convert string boolean literals into real booleans.
	 *
	 * @param {*} value
	 * @return {*|Boolean}
	 */

	function toBoolean(value) {
	  return value === 'true' ? true : value === 'false' ? false : value;
	}

	/**
	 * Strip quotes from a string
	 *
	 * @param {String} str
	 * @return {String | false}
	 */

	function stripQuotes(str) {
	  var a = str.charCodeAt(0);
	  var b = str.charCodeAt(str.length - 1);
	  return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;
	}

	/**
	 * Camelize a hyphen-delmited string.
	 *
	 * @param {String} str
	 * @return {String}
	 */

	var camelizeRE = /-(\w)/g;

	function camelize(str) {
	  return str.replace(camelizeRE, toUpper);
	}

	function toUpper(_, c) {
	  return c ? c.toUpperCase() : '';
	}

	/**
	 * Hyphenate a camelCase string.
	 *
	 * @param {String} str
	 * @return {String}
	 */

	var hyphenateRE = /([a-z\d])([A-Z])/g;

	function hyphenate(str) {
	  return str.replace(hyphenateRE, '$1-$2').toLowerCase();
	}

	/**
	 * Converts hyphen/underscore/slash delimitered names into
	 * camelized classNames.
	 *
	 * e.g. my-component => MyComponent
	 *      some_else    => SomeElse
	 *      some/comp    => SomeComp
	 *
	 * @param {String} str
	 * @return {String}
	 */

	var classifyRE = /(?:^|[-_\/])(\w)/g;

	function classify(str) {
	  return str.replace(classifyRE, toUpper);
	}

	/**
	 * Simple bind, faster than native
	 *
	 * @param {Function} fn
	 * @param {Object} ctx
	 * @return {Function}
	 */

	function bind(fn, ctx) {
	  return function (a) {
	    var l = arguments.length;
	    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
	  };
	}

	/**
	 * Convert an Array-like object to a real Array.
	 *
	 * @param {Array-like} list
	 * @param {Number} [start] - start index
	 * @return {Array}
	 */

	function toArray(list, start) {
	  start = start || 0;
	  var i = list.length - start;
	  var ret = new Array(i);
	  while (i--) {
	    ret[i] = list[i + start];
	  }
	  return ret;
	}

	/**
	 * Mix properties into target object.
	 *
	 * @param {Object} to
	 * @param {Object} from
	 */

	function extend(to, from) {
	  var keys = Object.keys(from);
	  var i = keys.length;
	  while (i--) {
	    to[keys[i]] = from[keys[i]];
	  }
	  return to;
	}

	/**
	 * Quick object check - this is primarily used to tell
	 * Objects from primitive values when we know the value
	 * is a JSON-compliant type.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */

	function isObject(obj) {
	  return obj !== null && typeof obj === 'object';
	}

	/**
	 * Strict object type check. Only returns true
	 * for plain JavaScript objects.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */

	var toString = Object.prototype.toString;
	var OBJECT_STRING = '[object Object]';

	function isPlainObject(obj) {
	  return toString.call(obj) === OBJECT_STRING;
	}

	/**
	 * Array type check.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */

	var isArray = Array.isArray;

	/**
	 * Define a property.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @param {*} val
	 * @param {Boolean} [enumerable]
	 */

	function def(obj, key, val, enumerable) {
	  Object.defineProperty(obj, key, {
	    value: val,
	    enumerable: !!enumerable,
	    writable: true,
	    configurable: true
	  });
	}

	/**
	 * Debounce a function so it only gets called after the
	 * input stops arriving after the given wait period.
	 *
	 * @param {Function} func
	 * @param {Number} wait
	 * @return {Function} - the debounced function
	 */

	function _debounce(func, wait) {
	  var timeout, args, context, timestamp, result;
	  var later = function later() {
	    var last = Date.now() - timestamp;
	    if (last < wait && last >= 0) {
	      timeout = setTimeout(later, wait - last);
	    } else {
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    }
	  };
	  return function () {
	    context = this;
	    args = arguments;
	    timestamp = Date.now();
	    if (!timeout) {
	      timeout = setTimeout(later, wait);
	    }
	    return result;
	  };
	}

	/**
	 * Manual indexOf because it's slightly faster than
	 * native.
	 *
	 * @param {Array} arr
	 * @param {*} obj
	 */

	function indexOf(arr, obj) {
	  var i = arr.length;
	  while (i--) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	}

	/**
	 * Make a cancellable version of an async callback.
	 *
	 * @param {Function} fn
	 * @return {Function}
	 */

	function cancellable(fn) {
	  var cb = function cb() {
	    if (!cb.cancelled) {
	      return fn.apply(this, arguments);
	    }
	  };
	  cb.cancel = function () {
	    cb.cancelled = true;
	  };
	  return cb;
	}

	/**
	 * Check if two values are loosely equal - that is,
	 * if they are plain objects, do they have the same shape?
	 *
	 * @param {*} a
	 * @param {*} b
	 * @return {Boolean}
	 */

	function looseEqual(a, b) {
	  /* eslint-disable eqeqeq */
	  return a == b || (isObject(a) && isObject(b) ? JSON.stringify(a) === JSON.stringify(b) : false);
	  /* eslint-enable eqeqeq */
	}

	var hasProto = ('__proto__' in {});

	// Browser environment sniffing
	var inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';

	// detect devtools
	var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

	// UA sniffing for working around browser-specific quirks
	var UA = inBrowser && window.navigator.userAgent.toLowerCase();
	var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
	var isAndroid = UA && UA.indexOf('android') > 0;

	var transitionProp = undefined;
	var transitionEndEvent = undefined;
	var animationProp = undefined;
	var animationEndEvent = undefined;

	// Transition property/event sniffing
	if (inBrowser && !isIE9) {
	  var isWebkitTrans = window.ontransitionend === undefined && window.onwebkittransitionend !== undefined;
	  var isWebkitAnim = window.onanimationend === undefined && window.onwebkitanimationend !== undefined;
	  transitionProp = isWebkitTrans ? 'WebkitTransition' : 'transition';
	  transitionEndEvent = isWebkitTrans ? 'webkitTransitionEnd' : 'transitionend';
	  animationProp = isWebkitAnim ? 'WebkitAnimation' : 'animation';
	  animationEndEvent = isWebkitAnim ? 'webkitAnimationEnd' : 'animationend';
	}

	/**
	 * Defer a task to execute it asynchronously. Ideally this
	 * should be executed as a microtask, so we leverage
	 * MutationObserver if it's available, and fallback to
	 * setTimeout(0).
	 *
	 * @param {Function} cb
	 * @param {Object} ctx
	 */

	var nextTick = (function () {
	  var callbacks = [];
	  var pending = false;
	  var timerFunc;
	  function nextTickHandler() {
	    pending = false;
	    var copies = callbacks.slice(0);
	    callbacks = [];
	    for (var i = 0; i < copies.length; i++) {
	      copies[i]();
	    }
	  }

	  /* istanbul ignore if */
	  if (typeof MutationObserver !== 'undefined') {
	    var counter = 1;
	    var observer = new MutationObserver(nextTickHandler);
	    var textNode = document.createTextNode(counter);
	    observer.observe(textNode, {
	      characterData: true
	    });
	    timerFunc = function () {
	      counter = (counter + 1) % 2;
	      textNode.data = counter;
	    };
	  } else {
	    // webpack attempts to inject a shim for setImmediate
	    // if it is used as a global, so we have to work around that to
	    // avoid bundling unnecessary code.
	    var context = inBrowser ? window : typeof global !== 'undefined' ? global : {};
	    timerFunc = context.setImmediate || setTimeout;
	  }
	  return function (cb, ctx) {
	    var func = ctx ? function () {
	      cb.call(ctx);
	    } : cb;
	    callbacks.push(func);
	    if (pending) return;
	    pending = true;
	    timerFunc(nextTickHandler, 0);
	  };
	})();

	function Cache(limit) {
	  this.size = 0;
	  this.limit = limit;
	  this.head = this.tail = undefined;
	  this._keymap = Object.create(null);
	}

	var p = Cache.prototype;

	/**
	 * Put <value> into the cache associated with <key>.
	 * Returns the entry which was removed to make room for
	 * the new entry. Otherwise undefined is returned.
	 * (i.e. if there was enough room already).
	 *
	 * @param {String} key
	 * @param {*} value
	 * @return {Entry|undefined}
	 */

	p.put = function (key, value) {
	  var removed;
	  if (this.size === this.limit) {
	    removed = this.shift();
	  }

	  var entry = this.get(key, true);
	  if (!entry) {
	    entry = {
	      key: key
	    };
	    this._keymap[key] = entry;
	    if (this.tail) {
	      this.tail.newer = entry;
	      entry.older = this.tail;
	    } else {
	      this.head = entry;
	    }
	    this.tail = entry;
	    this.size++;
	  }
	  entry.value = value;

	  return removed;
	};

	/**
	 * Purge the least recently used (oldest) entry from the
	 * cache. Returns the removed entry or undefined if the
	 * cache was empty.
	 */

	p.shift = function () {
	  var entry = this.head;
	  if (entry) {
	    this.head = this.head.newer;
	    this.head.older = undefined;
	    entry.newer = entry.older = undefined;
	    this._keymap[entry.key] = undefined;
	    this.size--;
	  }
	  return entry;
	};

	/**
	 * Get and register recent use of <key>. Returns the value
	 * associated with <key> or undefined if not in cache.
	 *
	 * @param {String} key
	 * @param {Boolean} returnEntry
	 * @return {Entry|*}
	 */

	p.get = function (key, returnEntry) {
	  var entry = this._keymap[key];
	  if (entry === undefined) return;
	  if (entry === this.tail) {
	    return returnEntry ? entry : entry.value;
	  }
	  // HEAD--------------TAIL
	  //   <.older   .newer>
	  //  <--- add direction --
	  //   A  B  C  <D>  E
	  if (entry.newer) {
	    if (entry === this.head) {
	      this.head = entry.newer;
	    }
	    entry.newer.older = entry.older; // C <-- E.
	  }
	  if (entry.older) {
	    entry.older.newer = entry.newer; // C. --> E
	  }
	  entry.newer = undefined; // D --x
	  entry.older = this.tail; // D. --> E
	  if (this.tail) {
	    this.tail.newer = entry; // E. <-- D
	  }
	  this.tail = entry;
	  return returnEntry ? entry : entry.value;
	};

	var cache$1 = new Cache(1000);
	var filterTokenRE = /[^\s'"]+|'[^']*'|"[^"]*"/g;
	var reservedArgRE = /^in$|^-?\d+/;

	/**
	 * Parser state
	 */

	var str;
	var dir;
	var c;
	var prev;
	var i;
	var l;
	var lastFilterIndex;
	var inSingle;
	var inDouble;
	var curly;
	var square;
	var paren;
	/**
	 * Push a filter to the current directive object
	 */

	function pushFilter() {
	  var exp = str.slice(lastFilterIndex, i).trim();
	  var filter;
	  if (exp) {
	    filter = {};
	    var tokens = exp.match(filterTokenRE);
	    filter.name = tokens[0];
	    if (tokens.length > 1) {
	      filter.args = tokens.slice(1).map(processFilterArg);
	    }
	  }
	  if (filter) {
	    (dir.filters = dir.filters || []).push(filter);
	  }
	  lastFilterIndex = i + 1;
	}

	/**
	 * Check if an argument is dynamic and strip quotes.
	 *
	 * @param {String} arg
	 * @return {Object}
	 */

	function processFilterArg(arg) {
	  if (reservedArgRE.test(arg)) {
	    return {
	      value: toNumber(arg),
	      dynamic: false
	    };
	  } else {
	    var stripped = stripQuotes(arg);
	    var dynamic = stripped === arg;
	    return {
	      value: dynamic ? arg : stripped,
	      dynamic: dynamic
	    };
	  }
	}

	/**
	 * Parse a directive value and extract the expression
	 * and its filters into a descriptor.
	 *
	 * Example:
	 *
	 * "a + 1 | uppercase" will yield:
	 * {
	 *   expression: 'a + 1',
	 *   filters: [
	 *     { name: 'uppercase', args: null }
	 *   ]
	 * }
	 *
	 * @param {String} s
	 * @return {Object}
	 */

	function parseDirective(s) {
	  var hit = cache$1.get(s);
	  if (hit) {
	    return hit;
	  }

	  // reset parser state
	  str = s;
	  inSingle = inDouble = false;
	  curly = square = paren = 0;
	  lastFilterIndex = 0;
	  dir = {};

	  for (i = 0, l = str.length; i < l; i++) {
	    prev = c;
	    c = str.charCodeAt(i);
	    if (inSingle) {
	      // check single quote
	      if (c === 0x27 && prev !== 0x5C) inSingle = !inSingle;
	    } else if (inDouble) {
	      // check double quote
	      if (c === 0x22 && prev !== 0x5C) inDouble = !inDouble;
	    } else if (c === 0x7C && // pipe
	    str.charCodeAt(i + 1) !== 0x7C && str.charCodeAt(i - 1) !== 0x7C) {
	      if (dir.expression == null) {
	        // first filter, end of expression
	        lastFilterIndex = i + 1;
	        dir.expression = str.slice(0, i).trim();
	      } else {
	        // already has filter
	        pushFilter();
	      }
	    } else {
	      switch (c) {
	        case 0x22:
	          inDouble = true;break; // "
	        case 0x27:
	          inSingle = true;break; // '
	        case 0x28:
	          paren++;break; // (
	        case 0x29:
	          paren--;break; // )
	        case 0x5B:
	          square++;break; // [
	        case 0x5D:
	          square--;break; // ]
	        case 0x7B:
	          curly++;break; // {
	        case 0x7D:
	          curly--;break; // }
	      }
	    }
	  }

	  if (dir.expression == null) {
	    dir.expression = str.slice(0, i).trim();
	  } else if (lastFilterIndex !== 0) {
	    pushFilter();
	  }

	  cache$1.put(s, dir);
	  return dir;
	}

	var directive = Object.freeze({
	  parseDirective: parseDirective
	});

	var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
	var cache = undefined;
	var tagRE = undefined;
	var htmlRE = undefined;
	/**
	 * Escape a string so it can be used in a RegExp
	 * constructor.
	 *
	 * @param {String} str
	 */

	function escapeRegex(str) {
	  return str.replace(regexEscapeRE, '\\$&');
	}

	function compileRegex() {
	  var open = escapeRegex(config.delimiters[0]);
	  var close = escapeRegex(config.delimiters[1]);
	  var unsafeOpen = escapeRegex(config.unsafeDelimiters[0]);
	  var unsafeClose = escapeRegex(config.unsafeDelimiters[1]);
	  tagRE = new RegExp(unsafeOpen + '((?:.|\\n)+?)' + unsafeClose + '|' + open + '((?:.|\\n)+?)' + close, 'g');
	  htmlRE = new RegExp('^' + unsafeOpen + '.*' + unsafeClose + '$');
	  // reset cache
	  cache = new Cache(1000);
	}

	/**
	 * Parse a template text string into an array of tokens.
	 *
	 * @param {String} text
	 * @return {Array<Object> | null}
	 *               - {String} type
	 *               - {String} value
	 *               - {Boolean} [html]
	 *               - {Boolean} [oneTime]
	 */

	function parseText(text) {
	  if (!cache) {
	    compileRegex();
	  }
	  var hit = cache.get(text);
	  if (hit) {
	    return hit;
	  }
	  if (!tagRE.test(text)) {
	    return null;
	  }
	  var tokens = [];
	  var lastIndex = tagRE.lastIndex = 0;
	  var match, index, html, value, first, oneTime;
	  /* eslint-disable no-cond-assign */
	  while (match = tagRE.exec(text)) {
	    /* eslint-enable no-cond-assign */
	    index = match.index;
	    // push text token
	    if (index > lastIndex) {
	      tokens.push({
	        value: text.slice(lastIndex, index)
	      });
	    }
	    // tag token
	    html = htmlRE.test(match[0]);
	    value = html ? match[1] : match[2];
	    first = value.charCodeAt(0);
	    oneTime = first === 42; // *
	    value = oneTime ? value.slice(1) : value;
	    tokens.push({
	      tag: true,
	      value: value.trim(),
	      html: html,
	      oneTime: oneTime
	    });
	    lastIndex = index + match[0].length;
	  }
	  if (lastIndex < text.length) {
	    tokens.push({
	      value: text.slice(lastIndex)
	    });
	  }
	  cache.put(text, tokens);
	  return tokens;
	}

	/**
	 * Format a list of tokens into an expression.
	 * e.g. tokens parsed from 'a {{b}} c' can be serialized
	 * into one single expression as '"a " + b + " c"'.
	 *
	 * @param {Array} tokens
	 * @param {Vue} [vm]
	 * @return {String}
	 */

	function tokensToExp(tokens, vm) {
	  if (tokens.length > 1) {
	    return tokens.map(function (token) {
	      return formatToken(token, vm);
	    }).join('+');
	  } else {
	    return formatToken(tokens[0], vm, true);
	  }
	}

	/**
	 * Format a single token.
	 *
	 * @param {Object} token
	 * @param {Vue} [vm]
	 * @param {Boolean} [single]
	 * @return {String}
	 */

	function formatToken(token, vm, single) {
	  return token.tag ? token.oneTime && vm ? '"' + vm.$eval(token.value) + '"' : inlineFilters(token.value, single) : '"' + token.value + '"';
	}

	/**
	 * For an attribute with multiple interpolation tags,
	 * e.g. attr="some-{{thing | filter}}", in order to combine
	 * the whole thing into a single watchable expression, we
	 * have to inline those filters. This function does exactly
	 * that. This is a bit hacky but it avoids heavy changes
	 * to directive parser and watcher mechanism.
	 *
	 * @param {String} exp
	 * @param {Boolean} single
	 * @return {String}
	 */

	var filterRE = /[^|]\|[^|]/;
	function inlineFilters(exp, single) {
	  if (!filterRE.test(exp)) {
	    return single ? exp : '(' + exp + ')';
	  } else {
	    var dir = parseDirective(exp);
	    if (!dir.filters) {
	      return '(' + exp + ')';
	    } else {
	      return 'this._applyFilters(' + dir.expression + // value
	      ',null,' + // oldValue (null for read)
	      JSON.stringify(dir.filters) + // filter descriptors
	      ',false)'; // write?
	    }
	  }
	}

	var text = Object.freeze({
	  compileRegex: compileRegex,
	  parseText: parseText,
	  tokensToExp: tokensToExp
	});

	var delimiters = ['{{', '}}'];
	var unsafeDelimiters = ['{{{', '}}}'];

	var config = Object.defineProperties({

	  /**
	   * Whether to print debug messages.
	   * Also enables stack trace for warnings.
	   *
	   * @type {Boolean}
	   */

	  debug: false,

	  /**
	   * Whether to suppress warnings.
	   *
	   * @type {Boolean}
	   */

	  silent: false,

	  /**
	   * Whether to use async rendering.
	   */

	  async: true,

	  /**
	   * Whether to warn against errors caught when evaluating
	   * expressions.
	   */

	  warnExpressionErrors: true,

	  /**
	   * Whether to allow devtools inspection.
	   * Disabled by default in production builds.
	   */

	  devtools: process.env.NODE_ENV !== 'production',

	  /**
	   * Internal flag to indicate the delimiters have been
	   * changed.
	   *
	   * @type {Boolean}
	   */

	  _delimitersChanged: true,

	  /**
	   * List of asset types that a component can own.
	   *
	   * @type {Array}
	   */

	  _assetTypes: ['component', 'directive', 'elementDirective', 'filter', 'transition', 'partial'],

	  /**
	   * prop binding modes
	   */

	  _propBindingModes: {
	    ONE_WAY: 0,
	    TWO_WAY: 1,
	    ONE_TIME: 2
	  },

	  /**
	   * Max circular updates allowed in a batcher flush cycle.
	   */

	  _maxUpdateCount: 100

	}, {
	  delimiters: { /**
	                 * Interpolation delimiters. Changing these would trigger
	                 * the text parser to re-compile the regular expressions.
	                 *
	                 * @type {Array<String>}
	                 */

	    get: function get() {
	      return delimiters;
	    },
	    set: function set(val) {
	      delimiters = val;
	      compileRegex();
	    },
	    configurable: true,
	    enumerable: true
	  },
	  unsafeDelimiters: {
	    get: function get() {
	      return unsafeDelimiters;
	    },
	    set: function set(val) {
	      unsafeDelimiters = val;
	      compileRegex();
	    },
	    configurable: true,
	    enumerable: true
	  }
	});

	var warn = undefined;
	var formatComponentName = undefined;

	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var hasConsole = typeof console !== 'undefined';

	    warn = function (msg, vm) {
	      if (hasConsole && !config.silent) {
	        console.error('[Vue warn]: ' + msg + (vm ? formatComponentName(vm) : ''));
	      }
	    };

	    formatComponentName = function (vm) {
	      var name = vm._isVue ? vm.$options.name : vm.name;
	      return name ? ' (found in component: <' + hyphenate(name) + '>)' : '';
	    };
	  })();
	}

	/**
	 * Append with transition.
	 *
	 * @param {Element} el
	 * @param {Element} target
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */

	function appendWithTransition(el, target, vm, cb) {
	  applyTransition(el, 1, function () {
	    target.appendChild(el);
	  }, vm, cb);
	}

	/**
	 * InsertBefore with transition.
	 *
	 * @param {Element} el
	 * @param {Element} target
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */

	function beforeWithTransition(el, target, vm, cb) {
	  applyTransition(el, 1, function () {
	    before(el, target);
	  }, vm, cb);
	}

	/**
	 * Remove with transition.
	 *
	 * @param {Element} el
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */

	function removeWithTransition(el, vm, cb) {
	  applyTransition(el, -1, function () {
	    remove(el);
	  }, vm, cb);
	}

	/**
	 * Apply transitions with an operation callback.
	 *
	 * @param {Element} el
	 * @param {Number} direction
	 *                  1: enter
	 *                 -1: leave
	 * @param {Function} op - the actual DOM operation
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */

	function applyTransition(el, direction, op, vm, cb) {
	  var transition = el.__v_trans;
	  if (!transition ||
	  // skip if there are no js hooks and CSS transition is
	  // not supported
	  !transition.hooks && !transitionEndEvent ||
	  // skip transitions for initial compile
	  !vm._isCompiled ||
	  // if the vm is being manipulated by a parent directive
	  // during the parent's compilation phase, skip the
	  // animation.
	  vm.$parent && !vm.$parent._isCompiled) {
	    op();
	    if (cb) cb();
	    return;
	  }
	  var action = direction > 0 ? 'enter' : 'leave';
	  transition[action](op, cb);
	}

	var transition = Object.freeze({
	  appendWithTransition: appendWithTransition,
	  beforeWithTransition: beforeWithTransition,
	  removeWithTransition: removeWithTransition,
	  applyTransition: applyTransition
	});

	/**
	 * Query an element selector if it's not an element already.
	 *
	 * @param {String|Element} el
	 * @return {Element}
	 */

	function query(el) {
	  if (typeof el === 'string') {
	    var selector = el;
	    el = document.querySelector(el);
	    if (!el) {
	      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + selector);
	    }
	  }
	  return el;
	}

	/**
	 * Check if a node is in the document.
	 * Note: document.documentElement.contains should work here
	 * but always returns false for comment nodes in phantomjs,
	 * making unit tests difficult. This is fixed by doing the
	 * contains() check on the node's parentNode instead of
	 * the node itself.
	 *
	 * @param {Node} node
	 * @return {Boolean}
	 */

	function inDoc(node) {
	  var doc = document.documentElement;
	  var parent = node && node.parentNode;
	  return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));
	}

	/**
	 * Get and remove an attribute from a node.
	 *
	 * @param {Node} node
	 * @param {String} _attr
	 */

	function getAttr(node, _attr) {
	  var val = node.getAttribute(_attr);
	  if (val !== null) {
	    node.removeAttribute(_attr);
	  }
	  return val;
	}

	/**
	 * Get an attribute with colon or v-bind: prefix.
	 *
	 * @param {Node} node
	 * @param {String} name
	 * @return {String|null}
	 */

	function getBindAttr(node, name) {
	  var val = getAttr(node, ':' + name);
	  if (val === null) {
	    val = getAttr(node, 'v-bind:' + name);
	  }
	  return val;
	}

	/**
	 * Check the presence of a bind attribute.
	 *
	 * @param {Node} node
	 * @param {String} name
	 * @return {Boolean}
	 */

	function hasBindAttr(node, name) {
	  return node.hasAttribute(name) || node.hasAttribute(':' + name) || node.hasAttribute('v-bind:' + name);
	}

	/**
	 * Insert el before target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */

	function before(el, target) {
	  target.parentNode.insertBefore(el, target);
	}

	/**
	 * Insert el after target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */

	function after(el, target) {
	  if (target.nextSibling) {
	    before(el, target.nextSibling);
	  } else {
	    target.parentNode.appendChild(el);
	  }
	}

	/**
	 * Remove el from DOM
	 *
	 * @param {Element} el
	 */

	function remove(el) {
	  el.parentNode.removeChild(el);
	}

	/**
	 * Prepend el to target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */

	function prepend(el, target) {
	  if (target.firstChild) {
	    before(el, target.firstChild);
	  } else {
	    target.appendChild(el);
	  }
	}

	/**
	 * Replace target with el
	 *
	 * @param {Element} target
	 * @param {Element} el
	 */

	function replace(target, el) {
	  var parent = target.parentNode;
	  if (parent) {
	    parent.replaceChild(el, target);
	  }
	}

	/**
	 * Add event listener shorthand.
	 *
	 * @param {Element} el
	 * @param {String} event
	 * @param {Function} cb
	 * @param {Boolean} [useCapture]
	 */

	function on(el, event, cb, useCapture) {
	  el.addEventListener(event, cb, useCapture);
	}

	/**
	 * Remove event listener shorthand.
	 *
	 * @param {Element} el
	 * @param {String} event
	 * @param {Function} cb
	 */

	function off(el, event, cb) {
	  el.removeEventListener(event, cb);
	}

	/**
	 * For IE9 compat: when both class and :class are present
	 * getAttribute('class') returns wrong value...
	 *
	 * @param {Element} el
	 * @return {String}
	 */

	function getClass(el) {
	  var classname = el.className;
	  if (typeof classname === 'object') {
	    classname = classname.baseVal || '';
	  }
	  return classname;
	}

	/**
	 * In IE9, setAttribute('class') will result in empty class
	 * if the element also has the :class attribute; However in
	 * PhantomJS, setting `className` does not work on SVG elements...
	 * So we have to do a conditional check here.
	 *
	 * @param {Element} el
	 * @param {String} cls
	 */

	function setClass(el, cls) {
	  /* istanbul ignore if */
	  if (isIE9 && !/svg$/.test(el.namespaceURI)) {
	    el.className = cls;
	  } else {
	    el.setAttribute('class', cls);
	  }
	}

	/**
	 * Add class with compatibility for IE & SVG
	 *
	 * @param {Element} el
	 * @param {String} cls
	 */

	function addClass(el, cls) {
	  if (el.classList) {
	    el.classList.add(cls);
	  } else {
	    var cur = ' ' + getClass(el) + ' ';
	    if (cur.indexOf(' ' + cls + ' ') < 0) {
	      setClass(el, (cur + cls).trim());
	    }
	  }
	}

	/**
	 * Remove class with compatibility for IE & SVG
	 *
	 * @param {Element} el
	 * @param {String} cls
	 */

	function removeClass(el, cls) {
	  if (el.classList) {
	    el.classList.remove(cls);
	  } else {
	    var cur = ' ' + getClass(el) + ' ';
	    var tar = ' ' + cls + ' ';
	    while (cur.indexOf(tar) >= 0) {
	      cur = cur.replace(tar, ' ');
	    }
	    setClass(el, cur.trim());
	  }
	  if (!el.className) {
	    el.removeAttribute('class');
	  }
	}

	/**
	 * Extract raw content inside an element into a temporary
	 * container div
	 *
	 * @param {Element} el
	 * @param {Boolean} asFragment
	 * @return {Element|DocumentFragment}
	 */

	function extractContent(el, asFragment) {
	  var child;
	  var rawContent;
	  /* istanbul ignore if */
	  if (isTemplate(el) && isFragment(el.content)) {
	    el = el.content;
	  }
	  if (el.hasChildNodes()) {
	    trimNode(el);
	    rawContent = asFragment ? document.createDocumentFragment() : document.createElement('div');
	    /* eslint-disable no-cond-assign */
	    while (child = el.firstChild) {
	      /* eslint-enable no-cond-assign */
	      rawContent.appendChild(child);
	    }
	  }
	  return rawContent;
	}

	/**
	 * Trim possible empty head/tail text and comment
	 * nodes inside a parent.
	 *
	 * @param {Node} node
	 */

	function trimNode(node) {
	  var child;
	  /* eslint-disable no-sequences */
	  while ((child = node.firstChild, isTrimmable(child))) {
	    node.removeChild(child);
	  }
	  while ((child = node.lastChild, isTrimmable(child))) {
	    node.removeChild(child);
	  }
	  /* eslint-enable no-sequences */
	}

	function isTrimmable(node) {
	  return node && (node.nodeType === 3 && !node.data.trim() || node.nodeType === 8);
	}

	/**
	 * Check if an element is a template tag.
	 * Note if the template appears inside an SVG its tagName
	 * will be in lowercase.
	 *
	 * @param {Element} el
	 */

	function isTemplate(el) {
	  return el.tagName && el.tagName.toLowerCase() === 'template';
	}

	/**
	 * Create an "anchor" for performing dom insertion/removals.
	 * This is used in a number of scenarios:
	 * - fragment instance
	 * - v-html
	 * - v-if
	 * - v-for
	 * - component
	 *
	 * @param {String} content
	 * @param {Boolean} persist - IE trashes empty textNodes on
	 *                            cloneNode(true), so in certain
	 *                            cases the anchor needs to be
	 *                            non-empty to be persisted in
	 *                            templates.
	 * @return {Comment|Text}
	 */

	function createAnchor(content, persist) {
	  var anchor = config.debug ? document.createComment(content) : document.createTextNode(persist ? ' ' : '');
	  anchor.__v_anchor = true;
	  return anchor;
	}

	/**
	 * Find a component ref attribute that starts with $.
	 *
	 * @param {Element} node
	 * @return {String|undefined}
	 */

	var refRE = /^v-ref:/;

	function findRef(node) {
	  if (node.hasAttributes()) {
	    var attrs = node.attributes;
	    for (var i = 0, l = attrs.length; i < l; i++) {
	      var name = attrs[i].name;
	      if (refRE.test(name)) {
	        return camelize(name.replace(refRE, ''));
	      }
	    }
	  }
	}

	/**
	 * Map a function to a range of nodes .
	 *
	 * @param {Node} node
	 * @param {Node} end
	 * @param {Function} op
	 */

	function mapNodeRange(node, end, op) {
	  var next;
	  while (node !== end) {
	    next = node.nextSibling;
	    op(node);
	    node = next;
	  }
	  op(end);
	}

	/**
	 * Remove a range of nodes with transition, store
	 * the nodes in a fragment with correct ordering,
	 * and call callback when done.
	 *
	 * @param {Node} start
	 * @param {Node} end
	 * @param {Vue} vm
	 * @param {DocumentFragment} frag
	 * @param {Function} cb
	 */

	function removeNodeRange(start, end, vm, frag, cb) {
	  var done = false;
	  var removed = 0;
	  var nodes = [];
	  mapNodeRange(start, end, function (node) {
	    if (node === end) done = true;
	    nodes.push(node);
	    removeWithTransition(node, vm, onRemoved);
	  });
	  function onRemoved() {
	    removed++;
	    if (done && removed >= nodes.length) {
	      for (var i = 0; i < nodes.length; i++) {
	        frag.appendChild(nodes[i]);
	      }
	      cb && cb();
	    }
	  }
	}

	/**
	 * Check if a node is a DocumentFragment.
	 *
	 * @param {Node} node
	 * @return {Boolean}
	 */

	function isFragment(node) {
	  return node && node.nodeType === 11;
	}

	/**
	 * Get outerHTML of elements, taking care
	 * of SVG elements in IE as well.
	 *
	 * @param {Element} el
	 * @return {String}
	 */

	function getOuterHTML(el) {
	  if (el.outerHTML) {
	    return el.outerHTML;
	  } else {
	    var container = document.createElement('div');
	    container.appendChild(el.cloneNode(true));
	    return container.innerHTML;
	  }
	}

	var commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i;
	var reservedTagRE = /^(slot|partial|component)$/i;

	var isUnknownElement = undefined;
	if (process.env.NODE_ENV !== 'production') {
	  isUnknownElement = function (el, tag) {
	    if (tag.indexOf('-') > -1) {
	      // http://stackoverflow.com/a/28210364/1070244
	      return el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
	    } else {
	      return (/HTMLUnknownElement/.test(el.toString()) &&
	        // Chrome returns unknown for several HTML5 elements.
	        // https://code.google.com/p/chromium/issues/detail?id=540526
	        !/^(data|time|rtc|rb)$/.test(tag)
	      );
	    }
	  };
	}

	/**
	 * Check if an element is a component, if yes return its
	 * component id.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Object|undefined}
	 */

	function checkComponentAttr(el, options) {
	  var tag = el.tagName.toLowerCase();
	  var hasAttrs = el.hasAttributes();
	  if (!commonTagRE.test(tag) && !reservedTagRE.test(tag)) {
	    if (resolveAsset(options, 'components', tag)) {
	      return { id: tag };
	    } else {
	      var is = hasAttrs && getIsBinding(el);
	      if (is) {
	        return is;
	      } else if (process.env.NODE_ENV !== 'production') {
	        var expectedTag = options._componentNameMap && options._componentNameMap[tag];
	        if (expectedTag) {
	          warn('Unknown custom element: <' + tag + '> - ' + 'did you mean <' + expectedTag + '>? ' + 'HTML is case-insensitive, remember to use kebab-case in templates.');
	        } else if (isUnknownElement(el, tag)) {
	          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.');
	        }
	      }
	    }
	  } else if (hasAttrs) {
	    return getIsBinding(el);
	  }
	}

	/**
	 * Get "is" binding from an element.
	 *
	 * @param {Element} el
	 * @return {Object|undefined}
	 */

	function getIsBinding(el) {
	  // dynamic syntax
	  var exp = getAttr(el, 'is');
	  if (exp != null) {
	    return { id: exp };
	  } else {
	    exp = getBindAttr(el, 'is');
	    if (exp != null) {
	      return { id: exp, dynamic: true };
	    }
	  }
	}

	/**
	 * Option overwriting strategies are functions that handle
	 * how to merge a parent option value and a child option
	 * value into the final value.
	 *
	 * All strategy functions follow the same signature:
	 *
	 * @param {*} parentVal
	 * @param {*} childVal
	 * @param {Vue} [vm]
	 */

	var strats = config.optionMergeStrategies = Object.create(null);

	/**
	 * Helper that recursively merges two data objects together.
	 */

	function mergeData(to, from) {
	  var key, toVal, fromVal;
	  for (key in from) {
	    toVal = to[key];
	    fromVal = from[key];
	    if (!hasOwn(to, key)) {
	      set(to, key, fromVal);
	    } else if (isObject(toVal) && isObject(fromVal)) {
	      mergeData(toVal, fromVal);
	    }
	  }
	  return to;
	}

	/**
	 * Data
	 */

	strats.data = function (parentVal, childVal, vm) {
	  if (!vm) {
	    // in a Vue.extend merge, both should be functions
	    if (!childVal) {
	      return parentVal;
	    }
	    if (typeof childVal !== 'function') {
	      process.env.NODE_ENV !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
	      return parentVal;
	    }
	    if (!parentVal) {
	      return childVal;
	    }
	    // when parentVal & childVal are both present,
	    // we need to return a function that returns the
	    // merged result of both functions... no need to
	    // check if parentVal is a function here because
	    // it has to be a function to pass previous merges.
	    return function mergedDataFn() {
	      return mergeData(childVal.call(this), parentVal.call(this));
	    };
	  } else if (parentVal || childVal) {
	    return function mergedInstanceDataFn() {
	      // instance merge
	      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
	      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;
	      if (instanceData) {
	        return mergeData(instanceData, defaultData);
	      } else {
	        return defaultData;
	      }
	    };
	  }
	};

	/**
	 * El
	 */

	strats.el = function (parentVal, childVal, vm) {
	  if (!vm && childVal && typeof childVal !== 'function') {
	    process.env.NODE_ENV !== 'production' && warn('The "el" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
	    return;
	  }
	  var ret = childVal || parentVal;
	  // invoke the element factory if this is instance merge
	  return vm && typeof ret === 'function' ? ret.call(vm) : ret;
	};

	/**
	 * Hooks and param attributes are merged as arrays.
	 */

	strats.init = strats.created = strats.ready = strats.attached = strats.detached = strats.beforeCompile = strats.compiled = strats.beforeDestroy = strats.destroyed = strats.activate = function (parentVal, childVal) {
	  return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;
	};

	/**
	 * Assets
	 *
	 * When a vm is present (instance creation), we need to do
	 * a three-way merge between constructor options, instance
	 * options and parent options.
	 */

	function mergeAssets(parentVal, childVal) {
	  var res = Object.create(parentVal);
	  return childVal ? extend(res, guardArrayAssets(childVal)) : res;
	}

	config._assetTypes.forEach(function (type) {
	  strats[type + 's'] = mergeAssets;
	});

	/**
	 * Events & Watchers.
	 *
	 * Events & watchers hashes should not overwrite one
	 * another, so we merge them as arrays.
	 */

	strats.watch = strats.events = function (parentVal, childVal) {
	  if (!childVal) return parentVal;
	  if (!parentVal) return childVal;
	  var ret = {};
	  extend(ret, parentVal);
	  for (var key in childVal) {
	    var parent = ret[key];
	    var child = childVal[key];
	    if (parent && !isArray(parent)) {
	      parent = [parent];
	    }
	    ret[key] = parent ? parent.concat(child) : [child];
	  }
	  return ret;
	};

	/**
	 * Other object hashes.
	 */

	strats.props = strats.methods = strats.computed = function (parentVal, childVal) {
	  if (!childVal) return parentVal;
	  if (!parentVal) return childVal;
	  var ret = Object.create(null);
	  extend(ret, parentVal);
	  extend(ret, childVal);
	  return ret;
	};

	/**
	 * Default strategy.
	 */

	var defaultStrat = function defaultStrat(parentVal, childVal) {
	  return childVal === undefined ? parentVal : childVal;
	};

	/**
	 * Make sure component options get converted to actual
	 * constructors.
	 *
	 * @param {Object} options
	 */

	function guardComponents(options) {
	  if (options.components) {
	    var components = options.components = guardArrayAssets(options.components);
	    var ids = Object.keys(components);
	    var def;
	    if (process.env.NODE_ENV !== 'production') {
	      var map = options._componentNameMap = {};
	    }
	    for (var i = 0, l = ids.length; i < l; i++) {
	      var key = ids[i];
	      if (commonTagRE.test(key) || reservedTagRE.test(key)) {
	        process.env.NODE_ENV !== 'production' && warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
	        continue;
	      }
	      // record a all lowercase <-> kebab-case mapping for
	      // possible custom element case error warning
	      if (process.env.NODE_ENV !== 'production') {
	        map[key.replace(/-/g, '').toLowerCase()] = hyphenate(key);
	      }
	      def = components[key];
	      if (isPlainObject(def)) {
	        components[key] = Vue.extend(def);
	      }
	    }
	  }
	}

	/**
	 * Ensure all props option syntax are normalized into the
	 * Object-based format.
	 *
	 * @param {Object} options
	 */

	function guardProps(options) {
	  var props = options.props;
	  var i, val;
	  if (isArray(props)) {
	    options.props = {};
	    i = props.length;
	    while (i--) {
	      val = props[i];
	      if (typeof val === 'string') {
	        options.props[val] = null;
	      } else if (val.name) {
	        options.props[val.name] = val;
	      }
	    }
	  } else if (isPlainObject(props)) {
	    var keys = Object.keys(props);
	    i = keys.length;
	    while (i--) {
	      val = props[keys[i]];
	      if (typeof val === 'function') {
	        props[keys[i]] = { type: val };
	      }
	    }
	  }
	}

	/**
	 * Guard an Array-format assets option and converted it
	 * into the key-value Object format.
	 *
	 * @param {Object|Array} assets
	 * @return {Object}
	 */

	function guardArrayAssets(assets) {
	  if (isArray(assets)) {
	    var res = {};
	    var i = assets.length;
	    var asset;
	    while (i--) {
	      asset = assets[i];
	      var id = typeof asset === 'function' ? asset.options && asset.options.name || asset.id : asset.name || asset.id;
	      if (!id) {
	        process.env.NODE_ENV !== 'production' && warn('Array-syntax assets must provide a "name" or "id" field.');
	      } else {
	        res[id] = asset;
	      }
	    }
	    return res;
	  }
	  return assets;
	}

	/**
	 * Merge two option objects into a new one.
	 * Core utility used in both instantiation and inheritance.
	 *
	 * @param {Object} parent
	 * @param {Object} child
	 * @param {Vue} [vm] - if vm is present, indicates this is
	 *                     an instantiation merge.
	 */

	function mergeOptions(parent, child, vm) {
	  guardComponents(child);
	  guardProps(child);
	  var options = {};
	  var key;
	  if (child.mixins) {
	    for (var i = 0, l = child.mixins.length; i < l; i++) {
	      parent = mergeOptions(parent, child.mixins[i], vm);
	    }
	  }
	  for (key in parent) {
	    mergeField(key);
	  }
	  for (key in child) {
	    if (!hasOwn(parent, key)) {
	      mergeField(key);
	    }
	  }
	  function mergeField(key) {
	    var strat = strats[key] || defaultStrat;
	    options[key] = strat(parent[key], child[key], vm, key);
	  }
	  return options;
	}

	/**
	 * Resolve an asset.
	 * This function is used because child instances need access
	 * to assets defined in its ancestor chain.
	 *
	 * @param {Object} options
	 * @param {String} type
	 * @param {String} id
	 * @param {Boolean} warnMissing
	 * @return {Object|Function}
	 */

	function resolveAsset(options, type, id, warnMissing) {
	  /* istanbul ignore if */
	  if (typeof id !== 'string') {
	    return;
	  }
	  var assets = options[type];
	  var camelizedId;
	  var res = assets[id] ||
	  // camelCase ID
	  assets[camelizedId = camelize(id)] ||
	  // Pascal Case ID
	  assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)];
	  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
	    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
	  }
	  return res;
	}

	var uid$1 = 0;

	/**
	 * A dep is an observable that can have multiple
	 * directives subscribing to it.
	 *
	 * @constructor
	 */
	function Dep() {
	  this.id = uid$1++;
	  this.subs = [];
	}

	// the current target watcher being evaluated.
	// this is globally unique because there could be only one
	// watcher being evaluated at any time.
	Dep.target = null;

	/**
	 * Add a directive subscriber.
	 *
	 * @param {Directive} sub
	 */

	Dep.prototype.addSub = function (sub) {
	  this.subs.push(sub);
	};

	/**
	 * Remove a directive subscriber.
	 *
	 * @param {Directive} sub
	 */

	Dep.prototype.removeSub = function (sub) {
	  this.subs.$remove(sub);
	};

	/**
	 * Add self as a dependency to the target watcher.
	 */

	Dep.prototype.depend = function () {
	  Dep.target.addDep(this);
	};

	/**
	 * Notify all subscribers of a new value.
	 */

	Dep.prototype.notify = function () {
	  // stablize the subscriber list first
	  var subs = toArray(this.subs);
	  for (var i = 0, l = subs.length; i < l; i++) {
	    subs[i].update();
	  }
	};

	var arrayProto = Array.prototype;
	var arrayMethods = Object.create(arrayProto)

	/**
	 * Intercept mutating methods and emit events
	 */

	;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
	  // cache original method
	  var original = arrayProto[method];
	  def(arrayMethods, method, function mutator() {
	    // avoid leaking arguments:
	    // http://jsperf.com/closure-with-arguments
	    var i = arguments.length;
	    var args = new Array(i);
	    while (i--) {
	      args[i] = arguments[i];
	    }
	    var result = original.apply(this, args);
	    var ob = this.__ob__;
	    var inserted;
	    switch (method) {
	      case 'push':
	        inserted = args;
	        break;
	      case 'unshift':
	        inserted = args;
	        break;
	      case 'splice':
	        inserted = args.slice(2);
	        break;
	    }
	    if (inserted) ob.observeArray(inserted);
	    // notify change
	    ob.dep.notify();
	    return result;
	  });
	});

	/**
	 * Swap the element at the given index with a new value
	 * and emits corresponding event.
	 *
	 * @param {Number} index
	 * @param {*} val
	 * @return {*} - replaced element
	 */

	def(arrayProto, '$set', function $set(index, val) {
	  if (index >= this.length) {
	    this.length = Number(index) + 1;
	  }
	  return this.splice(index, 1, val)[0];
	});

	/**
	 * Convenience method to remove the element at given index or target element reference.
	 *
	 * @param {*} item
	 */

	def(arrayProto, '$remove', function $remove(item) {
	  /* istanbul ignore if */
	  if (!this.length) return;
	  var index = indexOf(this, item);
	  if (index > -1) {
	    return this.splice(index, 1);
	  }
	});

	var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

	/**
	 * By default, when a reactive property is set, the new value is
	 * also converted to become reactive. However in certain cases, e.g.
	 * v-for scope alias and props, we don't want to force conversion
	 * because the value may be a nested value under a frozen data structure.
	 *
	 * So whenever we want to set a reactive property without forcing
	 * conversion on the new value, we wrap that call inside this function.
	 */

	var shouldConvert = true;

	function withoutConversion(fn) {
	  shouldConvert = false;
	  fn();
	  shouldConvert = true;
	}

	/**
	 * Observer class that are attached to each observed
	 * object. Once attached, the observer converts target
	 * object's property keys into getter/setters that
	 * collect dependencies and dispatches updates.
	 *
	 * @param {Array|Object} value
	 * @constructor
	 */

	function Observer(value) {
	  this.value = value;
	  this.dep = new Dep();
	  def(value, '__ob__', this);
	  if (isArray(value)) {
	    var augment = hasProto ? protoAugment : copyAugment;
	    augment(value, arrayMethods, arrayKeys);
	    this.observeArray(value);
	  } else {
	    this.walk(value);
	  }
	}

	// Instance methods

	/**
	 * Walk through each property and convert them into
	 * getter/setters. This method should only be called when
	 * value type is Object.
	 *
	 * @param {Object} obj
	 */

	Observer.prototype.walk = function (obj) {
	  var keys = Object.keys(obj);
	  for (var i = 0, l = keys.length; i < l; i++) {
	    this.convert(keys[i], obj[keys[i]]);
	  }
	};

	/**
	 * Observe a list of Array items.
	 *
	 * @param {Array} items
	 */

	Observer.prototype.observeArray = function (items) {
	  for (var i = 0, l = items.length; i < l; i++) {
	    observe(items[i]);
	  }
	};

	/**
	 * Convert a property into getter/setter so we can emit
	 * the events when the property is accessed/changed.
	 *
	 * @param {String} key
	 * @param {*} val
	 */

	Observer.prototype.convert = function (key, val) {
	  defineReactive(this.value, key, val);
	};

	/**
	 * Add an owner vm, so that when $set/$delete mutations
	 * happen we can notify owner vms to proxy the keys and
	 * digest the watchers. This is only called when the object
	 * is observed as an instance's root $data.
	 *
	 * @param {Vue} vm
	 */

	Observer.prototype.addVm = function (vm) {
	  (this.vms || (this.vms = [])).push(vm);
	};

	/**
	 * Remove an owner vm. This is called when the object is
	 * swapped out as an instance's $data object.
	 *
	 * @param {Vue} vm
	 */

	Observer.prototype.removeVm = function (vm) {
	  this.vms.$remove(vm);
	};

	// helpers

	/**
	 * Augment an target Object or Array by intercepting
	 * the prototype chain using __proto__
	 *
	 * @param {Object|Array} target
	 * @param {Object} src
	 */

	function protoAugment(target, src) {
	  /* eslint-disable no-proto */
	  target.__proto__ = src;
	  /* eslint-enable no-proto */
	}

	/**
	 * Augment an target Object or Array by defining
	 * hidden properties.
	 *
	 * @param {Object|Array} target
	 * @param {Object} proto
	 */

	function copyAugment(target, src, keys) {
	  for (var i = 0, l = keys.length; i < l; i++) {
	    var key = keys[i];
	    def(target, key, src[key]);
	  }
	}

	/**
	 * Attempt to create an observer instance for a value,
	 * returns the new observer if successfully observed,
	 * or the existing observer if the value already has one.
	 *
	 * @param {*} value
	 * @param {Vue} [vm]
	 * @return {Observer|undefined}
	 * @static
	 */

	function observe(value, vm) {
	  if (!value || typeof value !== 'object') {
	    return;
	  }
	  var ob;
	  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
	    ob = value.__ob__;
	  } else if (shouldConvert && (isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
	    ob = new Observer(value);
	  }
	  if (ob && vm) {
	    ob.addVm(vm);
	  }
	  return ob;
	}

	/**
	 * Define a reactive property on an Object.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @param {*} val
	 */

	function defineReactive(obj, key, val) {
	  var dep = new Dep();

	  var property = Object.getOwnPropertyDescriptor(obj, key);
	  if (property && property.configurable === false) {
	    return;
	  }

	  // cater for pre-defined getter/setters
	  var getter = property && property.get;
	  var setter = property && property.set;

	  var childOb = observe(val);
	  Object.defineProperty(obj, key, {
	    enumerable: true,
	    configurable: true,
	    get: function reactiveGetter() {
	      var value = getter ? getter.call(obj) : val;
	      if (Dep.target) {
	        dep.depend();
	        if (childOb) {
	          childOb.dep.depend();
	        }
	        if (isArray(value)) {
	          for (var e, i = 0, l = value.length; i < l; i++) {
	            e = value[i];
	            e && e.__ob__ && e.__ob__.dep.depend();
	          }
	        }
	      }
	      return value;
	    },
	    set: function reactiveSetter(newVal) {
	      var value = getter ? getter.call(obj) : val;
	      if (newVal === value) {
	        return;
	      }
	      if (setter) {
	        setter.call(obj, newVal);
	      } else {
	        val = newVal;
	      }
	      childOb = observe(newVal);
	      dep.notify();
	    }
	  });
	}



	var util = Object.freeze({
		defineReactive: defineReactive,
		set: set,
		del: del,
		hasOwn: hasOwn,
		isLiteral: isLiteral,
		isReserved: isReserved,
		_toString: _toString,
		toNumber: toNumber,
		toBoolean: toBoolean,
		stripQuotes: stripQuotes,
		camelize: camelize,
		hyphenate: hyphenate,
		classify: classify,
		bind: bind,
		toArray: toArray,
		extend: extend,
		isObject: isObject,
		isPlainObject: isPlainObject,
		def: def,
		debounce: _debounce,
		indexOf: indexOf,
		cancellable: cancellable,
		looseEqual: looseEqual,
		isArray: isArray,
		hasProto: hasProto,
		inBrowser: inBrowser,
		devtools: devtools,
		isIE9: isIE9,
		isAndroid: isAndroid,
		get transitionProp () { return transitionProp; },
		get transitionEndEvent () { return transitionEndEvent; },
		get animationProp () { return animationProp; },
		get animationEndEvent () { return animationEndEvent; },
		nextTick: nextTick,
		query: query,
		inDoc: inDoc,
		getAttr: getAttr,
		getBindAttr: getBindAttr,
		hasBindAttr: hasBindAttr,
		before: before,
		after: after,
		remove: remove,
		prepend: prepend,
		replace: replace,
		on: on,
		off: off,
		setClass: setClass,
		addClass: addClass,
		removeClass: removeClass,
		extractContent: extractContent,
		trimNode: trimNode,
		isTemplate: isTemplate,
		createAnchor: createAnchor,
		findRef: findRef,
		mapNodeRange: mapNodeRange,
		removeNodeRange: removeNodeRange,
		isFragment: isFragment,
		getOuterHTML: getOuterHTML,
		mergeOptions: mergeOptions,
		resolveAsset: resolveAsset,
		checkComponentAttr: checkComponentAttr,
		commonTagRE: commonTagRE,
		reservedTagRE: reservedTagRE,
		get warn () { return warn; }
	});

	var uid = 0;

	function initMixin (Vue) {
	  /**
	   * The main init sequence. This is called for every
	   * instance, including ones that are created from extended
	   * constructors.
	   *
	   * @param {Object} options - this options object should be
	   *                           the result of merging class
	   *                           options and the options passed
	   *                           in to the constructor.
	   */

	  Vue.prototype._init = function (options) {
	    options = options || {};

	    this.$el = null;
	    this.$parent = options.parent;
	    this.$root = this.$parent ? this.$parent.$root : this;
	    this.$children = [];
	    this.$refs = {}; // child vm references
	    this.$els = {}; // element references
	    this._watchers = []; // all watchers as an array
	    this._directives = []; // all directives

	    // a uid
	    this._uid = uid++;

	    // a flag to avoid this being observed
	    this._isVue = true;

	    // events bookkeeping
	    this._events = {}; // registered callbacks
	    this._eventsCount = {}; // for $broadcast optimization

	    // fragment instance properties
	    this._isFragment = false;
	    this._fragment = // @type {DocumentFragment}
	    this._fragmentStart = // @type {Text|Comment}
	    this._fragmentEnd = null; // @type {Text|Comment}

	    // lifecycle state
	    this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = this._vForRemoving = false;
	    this._unlinkFn = null;

	    // context:
	    // if this is a transcluded component, context
	    // will be the common parent vm of this instance
	    // and its host.
	    this._context = options._context || this.$parent;

	    // scope:
	    // if this is inside an inline v-for, the scope
	    // will be the intermediate scope created for this
	    // repeat fragment. this is used for linking props
	    // and container directives.
	    this._scope = options._scope;

	    // fragment:
	    // if this instance is compiled inside a Fragment, it
	    // needs to reigster itself as a child of that fragment
	    // for attach/detach to work properly.
	    this._frag = options._frag;
	    if (this._frag) {
	      this._frag.children.push(this);
	    }

	    // push self into parent / transclusion host
	    if (this.$parent) {
	      this.$parent.$children.push(this);
	    }

	    // merge options.
	    options = this.$options = mergeOptions(this.constructor.options, options, this);

	    // set ref
	    this._updateRef();

	    // initialize data as empty object.
	    // it will be filled up in _initScope().
	    this._data = {};

	    // save raw constructor data before merge
	    // so that we know which properties are provided at
	    // instantiation.
	    this._runtimeData = options.data;

	    // call init hook
	    this._callHook('init');

	    // initialize data observation and scope inheritance.
	    this._initState();

	    // setup event system and option events.
	    this._initEvents();

	    // call created hook
	    this._callHook('created');

	    // if `el` option is passed, start compilation.
	    if (options.el) {
	      this.$mount(options.el);
	    }
	  };
	}

	var pathCache = new Cache(1000);

	// actions
	var APPEND = 0;
	var PUSH = 1;
	var INC_SUB_PATH_DEPTH = 2;
	var PUSH_SUB_PATH = 3;

	// states
	var BEFORE_PATH = 0;
	var IN_PATH = 1;
	var BEFORE_IDENT = 2;
	var IN_IDENT = 3;
	var IN_SUB_PATH = 4;
	var IN_SINGLE_QUOTE = 5;
	var IN_DOUBLE_QUOTE = 6;
	var AFTER_PATH = 7;
	var ERROR = 8;

	var pathStateMachine = [];

	pathStateMachine[BEFORE_PATH] = {
	  'ws': [BEFORE_PATH],
	  'ident': [IN_IDENT, APPEND],
	  '[': [IN_SUB_PATH],
	  'eof': [AFTER_PATH]
	};

	pathStateMachine[IN_PATH] = {
	  'ws': [IN_PATH],
	  '.': [BEFORE_IDENT],
	  '[': [IN_SUB_PATH],
	  'eof': [AFTER_PATH]
	};

	pathStateMachine[BEFORE_IDENT] = {
	  'ws': [BEFORE_IDENT],
	  'ident': [IN_IDENT, APPEND]
	};

	pathStateMachine[IN_IDENT] = {
	  'ident': [IN_IDENT, APPEND],
	  '0': [IN_IDENT, APPEND],
	  'number': [IN_IDENT, APPEND],
	  'ws': [IN_PATH, PUSH],
	  '.': [BEFORE_IDENT, PUSH],
	  '[': [IN_SUB_PATH, PUSH],
	  'eof': [AFTER_PATH, PUSH]
	};

	pathStateMachine[IN_SUB_PATH] = {
	  "'": [IN_SINGLE_QUOTE, APPEND],
	  '"': [IN_DOUBLE_QUOTE, APPEND],
	  '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],
	  ']': [IN_PATH, PUSH_SUB_PATH],
	  'eof': ERROR,
	  'else': [IN_SUB_PATH, APPEND]
	};

	pathStateMachine[IN_SINGLE_QUOTE] = {
	  "'": [IN_SUB_PATH, APPEND],
	  'eof': ERROR,
	  'else': [IN_SINGLE_QUOTE, APPEND]
	};

	pathStateMachine[IN_DOUBLE_QUOTE] = {
	  '"': [IN_SUB_PATH, APPEND],
	  'eof': ERROR,
	  'else': [IN_DOUBLE_QUOTE, APPEND]
	};

	/**
	 * Determine the type of a character in a keypath.
	 *
	 * @param {Char} ch
	 * @return {String} type
	 */

	function getPathCharType(ch) {
	  if (ch === undefined) {
	    return 'eof';
	  }

	  var code = ch.charCodeAt(0);

	  switch (code) {
	    case 0x5B: // [
	    case 0x5D: // ]
	    case 0x2E: // .
	    case 0x22: // "
	    case 0x27: // '
	    case 0x30:
	      // 0
	      return ch;

	    case 0x5F: // _
	    case 0x24:
	      // $
	      return 'ident';

	    case 0x20: // Space
	    case 0x09: // Tab
	    case 0x0A: // Newline
	    case 0x0D: // Return
	    case 0xA0: // No-break space
	    case 0xFEFF: // Byte Order Mark
	    case 0x2028: // Line Separator
	    case 0x2029:
	      // Paragraph Separator
	      return 'ws';
	  }

	  // a-z, A-Z
	  if (code >= 0x61 && code <= 0x7A || code >= 0x41 && code <= 0x5A) {
	    return 'ident';
	  }

	  // 1-9
	  if (code >= 0x31 && code <= 0x39) {
	    return 'number';
	  }

	  return 'else';
	}

	/**
	 * Format a subPath, return its plain form if it is
	 * a literal string or number. Otherwise prepend the
	 * dynamic indicator (*).
	 *
	 * @param {String} path
	 * @return {String}
	 */

	function formatSubPath(path) {
	  var trimmed = path.trim();
	  // invalid leading 0
	  if (path.charAt(0) === '0' && isNaN(path)) {
	    return false;
	  }
	  return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed;
	}

	/**
	 * Parse a string path into an array of segments
	 *
	 * @param {String} path
	 * @return {Array|undefined}
	 */

	function parse(path) {
	  var keys = [];
	  var index = -1;
	  var mode = BEFORE_PATH;
	  var subPathDepth = 0;
	  var c, newChar, key, type, transition, action, typeMap;

	  var actions = [];

	  actions[PUSH] = function () {
	    if (key !== undefined) {
	      keys.push(key);
	      key = undefined;
	    }
	  };

	  actions[APPEND] = function () {
	    if (key === undefined) {
	      key = newChar;
	    } else {
	      key += newChar;
	    }
	  };

	  actions[INC_SUB_PATH_DEPTH] = function () {
	    actions[APPEND]();
	    subPathDepth++;
	  };

	  actions[PUSH_SUB_PATH] = function () {
	    if (subPathDepth > 0) {
	      subPathDepth--;
	      mode = IN_SUB_PATH;
	      actions[APPEND]();
	    } else {
	      subPathDepth = 0;
	      key = formatSubPath(key);
	      if (key === false) {
	        return false;
	      } else {
	        actions[PUSH]();
	      }
	    }
	  };

	  function maybeUnescapeQuote() {
	    var nextChar = path[index + 1];
	    if (mode === IN_SINGLE_QUOTE && nextChar === "'" || mode === IN_DOUBLE_QUOTE && nextChar === '"') {
	      index++;
	      newChar = '\\' + nextChar;
	      actions[APPEND]();
	      return true;
	    }
	  }

	  while (mode != null) {
	    index++;
	    c = path[index];

	    if (c === '\\' && maybeUnescapeQuote()) {
	      continue;
	    }

	    type = getPathCharType(c);
	    typeMap = pathStateMachine[mode];
	    transition = typeMap[type] || typeMap['else'] || ERROR;

	    if (transition === ERROR) {
	      return; // parse error
	    }

	    mode = transition[0];
	    action = actions[transition[1]];
	    if (action) {
	      newChar = transition[2];
	      newChar = newChar === undefined ? c : newChar;
	      if (action() === false) {
	        return;
	      }
	    }

	    if (mode === AFTER_PATH) {
	      keys.raw = path;
	      return keys;
	    }
	  }
	}

	/**
	 * External parse that check for a cache hit first
	 *
	 * @param {String} path
	 * @return {Array|undefined}
	 */

	function parsePath(path) {
	  var hit = pathCache.get(path);
	  if (!hit) {
	    hit = parse(path);
	    if (hit) {
	      pathCache.put(path, hit);
	    }
	  }
	  return hit;
	}

	/**
	 * Get from an object from a path string
	 *
	 * @param {Object} obj
	 * @param {String} path
	 */

	function getPath(obj, path) {
	  return parseExpression(path).get(obj);
	}

	/**
	 * Warn against setting non-existent root path on a vm.
	 */

	var warnNonExistent;
	if (process.env.NODE_ENV !== 'production') {
	  warnNonExistent = function (path, vm) {
	    warn('You are setting a non-existent path "' + path.raw + '" ' + 'on a vm instance. Consider pre-initializing the property ' + 'with the "data" option for more reliable reactivity ' + 'and better performance.', vm);
	  };
	}

	/**
	 * Set on an object from a path
	 *
	 * @param {Object} obj
	 * @param {String | Array} path
	 * @param {*} val
	 */

	function setPath(obj, path, val) {
	  var original = obj;
	  if (typeof path === 'string') {
	    path = parse(path);
	  }
	  if (!path || !isObject(obj)) {
	    return false;
	  }
	  var last, key;
	  for (var i = 0, l = path.length; i < l; i++) {
	    last = obj;
	    key = path[i];
	    if (key.charAt(0) === '*') {
	      key = parseExpression(key.slice(1)).get.call(original, original);
	    }
	    if (i < l - 1) {
	      obj = obj[key];
	      if (!isObject(obj)) {
	        obj = {};
	        if (process.env.NODE_ENV !== 'production' && last._isVue) {
	          warnNonExistent(path, last);
	        }
	        set(last, key, obj);
	      }
	    } else {
	      if (isArray(obj)) {
	        obj.$set(key, val);
	      } else if (key in obj) {
	        obj[key] = val;
	      } else {
	        if (process.env.NODE_ENV !== 'production' && obj._isVue) {
	          warnNonExistent(path, obj);
	        }
	        set(obj, key, val);
	      }
	    }
	  }
	  return true;
	}

	var path = Object.freeze({
	  parsePath: parsePath,
	  getPath: getPath,
	  setPath: setPath
	});

	var expressionCache = new Cache(1000);

	var allowedKeywords = 'Math,Date,this,true,false,null,undefined,Infinity,NaN,' + 'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' + 'encodeURIComponent,parseInt,parseFloat';
	var allowedKeywordsRE = new RegExp('^(' + allowedKeywords.replace(/,/g, '\\b|') + '\\b)');

	// keywords that don't make sense inside expressions
	var improperKeywords = 'break,case,class,catch,const,continue,debugger,default,' + 'delete,do,else,export,extends,finally,for,function,if,' + 'import,in,instanceof,let,return,super,switch,throw,try,' + 'var,while,with,yield,enum,await,implements,package,' + 'protected,static,interface,private,public';
	var improperKeywordsRE = new RegExp('^(' + improperKeywords.replace(/,/g, '\\b|') + '\\b)');

	var wsRE = /\s/g;
	var newlineRE = /\n/g;
	var saveRE = /[\{,]\s*[\w\$_]+\s*:|('(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`)|new |typeof |void /g;
	var restoreRE = /"(\d+)"/g;
	var pathTestRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?'\]|\[".*?"\]|\[\d+\]|\[[A-Za-z_$][\w$]*\])*$/;
	var identRE = /[^\w$\.](?:[A-Za-z_$][\w$]*)/g;
	var booleanLiteralRE = /^(?:true|false)$/;

	/**
	 * Save / Rewrite / Restore
	 *
	 * When rewriting paths found in an expression, it is
	 * possible for the same letter sequences to be found in
	 * strings and Object literal property keys. Therefore we
	 * remove and store these parts in a temporary array, and
	 * restore them after the path rewrite.
	 */

	var saved = [];

	/**
	 * Save replacer
	 *
	 * The save regex can match two possible cases:
	 * 1. An opening object literal
	 * 2. A string
	 * If matched as a plain string, we need to escape its
	 * newlines, since the string needs to be preserved when
	 * generating the function body.
	 *
	 * @param {String} str
	 * @param {String} isString - str if matched as a string
	 * @return {String} - placeholder with index
	 */

	function save(str, isString) {
	  var i = saved.length;
	  saved[i] = isString ? str.replace(newlineRE, '\\n') : str;
	  return '"' + i + '"';
	}

	/**
	 * Path rewrite replacer
	 *
	 * @param {String} raw
	 * @return {String}
	 */

	function rewrite(raw) {
	  var c = raw.charAt(0);
	  var path = raw.slice(1);
	  if (allowedKeywordsRE.test(path)) {
	    return raw;
	  } else {
	    path = path.indexOf('"') > -1 ? path.replace(restoreRE, restore) : path;
	    return c + 'scope.' + path;
	  }
	}

	/**
	 * Restore replacer
	 *
	 * @param {String} str
	 * @param {String} i - matched save index
	 * @return {String}
	 */

	function restore(str, i) {
	  return saved[i];
	}

	/**
	 * Rewrite an expression, prefixing all path accessors with
	 * `scope.` and generate getter/setter functions.
	 *
	 * @param {String} exp
	 * @return {Function}
	 */

	function compileGetter(exp) {
	  if (improperKeywordsRE.test(exp)) {
	    process.env.NODE_ENV !== 'production' && warn('Avoid using reserved keywords in expression: ' + exp);
	  }
	  // reset state
	  saved.length = 0;
	  // save strings and object literal keys
	  var body = exp.replace(saveRE, save).replace(wsRE, '');
	  // rewrite all paths
	  // pad 1 space here becaue the regex matches 1 extra char
	  body = (' ' + body).replace(identRE, rewrite).replace(restoreRE, restore);
	  return makeGetterFn(body);
	}

	/**
	 * Build a getter function. Requires eval.
	 *
	 * We isolate the try/catch so it doesn't affect the
	 * optimization of the parse function when it is not called.
	 *
	 * @param {String} body
	 * @return {Function|undefined}
	 */

	function makeGetterFn(body) {
	  try {
	    /* eslint-disable no-new-func */
	    return new Function('scope', 'return ' + body + ';');
	    /* eslint-enable no-new-func */
	  } catch (e) {
	    process.env.NODE_ENV !== 'production' && warn('Invalid expression. ' + 'Generated function body: ' + body);
	  }
	}

	/**
	 * Compile a setter function for the expression.
	 *
	 * @param {String} exp
	 * @return {Function|undefined}
	 */

	function compileSetter(exp) {
	  var path = parsePath(exp);
	  if (path) {
	    return function (scope, val) {
	      setPath(scope, path, val);
	    };
	  } else {
	    process.env.NODE_ENV !== 'production' && warn('Invalid setter expression: ' + exp);
	  }
	}

	/**
	 * Parse an expression into re-written getter/setters.
	 *
	 * @param {String} exp
	 * @param {Boolean} needSet
	 * @return {Function}
	 */

	function parseExpression(exp, needSet) {
	  exp = exp.trim();
	  // try cache
	  var hit = expressionCache.get(exp);
	  if (hit) {
	    if (needSet && !hit.set) {
	      hit.set = compileSetter(hit.exp);
	    }
	    return hit;
	  }
	  var res = { exp: exp };
	  res.get = isSimplePath(exp) && exp.indexOf('[') < 0
	  // optimized super simple getter
	  ? makeGetterFn('scope.' + exp)
	  // dynamic getter
	  : compileGetter(exp);
	  if (needSet) {
	    res.set = compileSetter(exp);
	  }
	  expressionCache.put(exp, res);
	  return res;
	}

	/**
	 * Check if an expression is a simple path.
	 *
	 * @param {String} exp
	 * @return {Boolean}
	 */

	function isSimplePath(exp) {
	  return pathTestRE.test(exp) &&
	  // don't treat true/false as paths
	  !booleanLiteralRE.test(exp) &&
	  // Math constants e.g. Math.PI, Math.E etc.
	  exp.slice(0, 5) !== 'Math.';
	}

	var expression = Object.freeze({
	  parseExpression: parseExpression,
	  isSimplePath: isSimplePath
	});

	// we have two separate queues: one for directive updates
	// and one for user watcher registered via $watch().
	// we want to guarantee directive updates to be called
	// before user watchers so that when user watchers are
	// triggered, the DOM would have already been in updated
	// state.

	var queueIndex;
	var queue = [];
	var userQueue = [];
	var has = {};
	var circular = {};
	var waiting = false;
	var internalQueueDepleted = false;

	/**
	 * Reset the batcher's state.
	 */

	function resetBatcherState() {
	  queue = [];
	  userQueue = [];
	  has = {};
	  circular = {};
	  waiting = internalQueueDepleted = false;
	}

	/**
	 * Flush both queues and run the watchers.
	 */

	function flushBatcherQueue() {
	  runBatcherQueue(queue);
	  internalQueueDepleted = true;
	  runBatcherQueue(userQueue);
	  // dev tool hook
	  /* istanbul ignore if */
	  if (devtools && config.devtools) {
	    devtools.emit('flush');
	  }
	  resetBatcherState();
	}

	/**
	 * Run the watchers in a single queue.
	 *
	 * @param {Array} queue
	 */

	function runBatcherQueue(queue) {
	  // do not cache length because more watchers might be pushed
	  // as we run existing watchers
	  for (queueIndex = 0; queueIndex < queue.length; queueIndex++) {
	    var watcher = queue[queueIndex];
	    var id = watcher.id;
	    has[id] = null;
	    watcher.run();
	    // in dev build, check and stop circular updates.
	    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
	      circular[id] = (circular[id] || 0) + 1;
	      if (circular[id] > config._maxUpdateCount) {
	        warn('You may have an infinite update loop for watcher ' + 'with expression "' + watcher.expression + '"', watcher.vm);
	        break;
	      }
	    }
	  }
	}

	/**
	 * Push a watcher into the watcher queue.
	 * Jobs with duplicate IDs will be skipped unless it's
	 * pushed when the queue is being flushed.
	 *
	 * @param {Watcher} watcher
	 *   properties:
	 *   - {Number} id
	 *   - {Function} run
	 */

	function pushWatcher(watcher) {
	  var id = watcher.id;
	  if (has[id] == null) {
	    if (internalQueueDepleted && !watcher.user) {
	      // an internal watcher triggered by a user watcher...
	      // let's run it immediately after current user watcher is done.
	      userQueue.splice(queueIndex + 1, 0, watcher);
	    } else {
	      // push watcher into appropriate queue
	      var q = watcher.user ? userQueue : queue;
	      has[id] = q.length;
	      q.push(watcher);
	      // queue the flush
	      if (!waiting) {
	        waiting = true;
	        nextTick(flushBatcherQueue);
	      }
	    }
	  }
	}

	var uid$2 = 0;

	/**
	 * A watcher parses an expression, collects dependencies,
	 * and fires callback when the expression value changes.
	 * This is used for both the $watch() api and directives.
	 *
	 * @param {Vue} vm
	 * @param {String|Function} expOrFn
	 * @param {Function} cb
	 * @param {Object} options
	 *                 - {Array} filters
	 *                 - {Boolean} twoWay
	 *                 - {Boolean} deep
	 *                 - {Boolean} user
	 *                 - {Boolean} sync
	 *                 - {Boolean} lazy
	 *                 - {Function} [preProcess]
	 *                 - {Function} [postProcess]
	 * @constructor
	 */
	function Watcher(vm, expOrFn, cb, options) {
	  // mix in options
	  if (options) {
	    extend(this, options);
	  }
	  var isFn = typeof expOrFn === 'function';
	  this.vm = vm;
	  vm._watchers.push(this);
	  this.expression = expOrFn;
	  this.cb = cb;
	  this.id = ++uid$2; // uid for batching
	  this.active = true;
	  this.dirty = this.lazy; // for lazy watchers
	  this.deps = [];
	  this.newDeps = [];
	  this.depIds = Object.create(null);
	  this.newDepIds = null;
	  this.prevError = null; // for async error stacks
	  // parse expression for getter/setter
	  if (isFn) {
	    this.getter = expOrFn;
	    this.setter = undefined;
	  } else {
	    var res = parseExpression(expOrFn, this.twoWay);
	    this.getter = res.get;
	    this.setter = res.set;
	  }
	  this.value = this.lazy ? undefined : this.get();
	  // state for avoiding false triggers for deep and Array
	  // watchers during vm._digest()
	  this.queued = this.shallow = false;
	}

	/**
	 * Evaluate the getter, and re-collect dependencies.
	 */

	Watcher.prototype.get = function () {
	  this.beforeGet();
	  var scope = this.scope || this.vm;
	  var value;
	  try {
	    value = this.getter.call(scope, scope);
	  } catch (e) {
	    if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {
	      warn('Error when evaluating expression ' + '"' + this.expression + '": ' + e.toString(), this.vm);
	    }
	  }
	  // "touch" every property so they are all tracked as
	  // dependencies for deep watching
	  if (this.deep) {
	    traverse(value);
	  }
	  if (this.preProcess) {
	    value = this.preProcess(value);
	  }
	  if (this.filters) {
	    value = scope._applyFilters(value, null, this.filters, false);
	  }
	  if (this.postProcess) {
	    value = this.postProcess(value);
	  }
	  this.afterGet();
	  return value;
	};

	/**
	 * Set the corresponding value with the setter.
	 *
	 * @param {*} value
	 */

	Watcher.prototype.set = function (value) {
	  var scope = this.scope || this.vm;
	  if (this.filters) {
	    value = scope._applyFilters(value, this.value, this.filters, true);
	  }
	  try {
	    this.setter.call(scope, scope, value);
	  } catch (e) {
	    if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {
	      warn('Error when evaluating setter ' + '"' + this.expression + '": ' + e.toString(), this.vm);
	    }
	  }
	  // two-way sync for v-for alias
	  var forContext = scope.$forContext;
	  if (forContext && forContext.alias === this.expression) {
	    if (forContext.filters) {
	      process.env.NODE_ENV !== 'production' && warn('It seems you are using two-way binding on ' + 'a v-for alias (' + this.expression + '), and the ' + 'v-for has filters. This will not work properly. ' + 'Either remove the filters or use an array of ' + 'objects and bind to object properties instead.', this.vm);
	      return;
	    }
	    forContext._withLock(function () {
	      if (scope.$key) {
	        // original is an object
	        forContext.rawValue[scope.$key] = value;
	      } else {
	        forContext.rawValue.$set(scope.$index, value);
	      }
	    });
	  }
	};

	/**
	 * Prepare for dependency collection.
	 */

	Watcher.prototype.beforeGet = function () {
	  Dep.target = this;
	  this.newDepIds = Object.create(null);
	  this.newDeps.length = 0;
	};

	/**
	 * Add a dependency to this directive.
	 *
	 * @param {Dep} dep
	 */

	Watcher.prototype.addDep = function (dep) {
	  var id = dep.id;
	  if (!this.newDepIds[id]) {
	    this.newDepIds[id] = true;
	    this.newDeps.push(dep);
	    if (!this.depIds[id]) {
	      dep.addSub(this);
	    }
	  }
	};

	/**
	 * Clean up for dependency collection.
	 */

	Watcher.prototype.afterGet = function () {
	  Dep.target = null;
	  var i = this.deps.length;
	  while (i--) {
	    var dep = this.deps[i];
	    if (!this.newDepIds[dep.id]) {
	      dep.removeSub(this);
	    }
	  }
	  this.depIds = this.newDepIds;
	  var tmp = this.deps;
	  this.deps = this.newDeps;
	  this.newDeps = tmp;
	};

	/**
	 * Subscriber interface.
	 * Will be called when a dependency changes.
	 *
	 * @param {Boolean} shallow
	 */

	Watcher.prototype.update = function (shallow) {
	  if (this.lazy) {
	    this.dirty = true;
	  } else if (this.sync || !config.async) {
	    this.run();
	  } else {
	    // if queued, only overwrite shallow with non-shallow,
	    // but not the other way around.
	    this.shallow = this.queued ? shallow ? this.shallow : false : !!shallow;
	    this.queued = true;
	    // record before-push error stack in debug mode
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production' && config.debug) {
	      this.prevError = new Error('[vue] async stack trace');
	    }
	    pushWatcher(this);
	  }
	};

	/**
	 * Batcher job interface.
	 * Will be called by the batcher.
	 */

	Watcher.prototype.run = function () {
	  if (this.active) {
	    var value = this.get();
	    if (value !== this.value ||
	    // Deep watchers and watchers on Object/Arrays should fire even
	    // when the value is the same, because the value may
	    // have mutated; but only do so if this is a
	    // non-shallow update (caused by a vm digest).
	    (isObject(value) || this.deep) && !this.shallow) {
	      // set new value
	      var oldValue = this.value;
	      this.value = value;
	      // in debug + async mode, when a watcher callbacks
	      // throws, we also throw the saved before-push error
	      // so the full cross-tick stack trace is available.
	      var prevError = this.prevError;
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production' && config.debug && prevError) {
	        this.prevError = null;
	        try {
	          this.cb.call(this.vm, value, oldValue);
	        } catch (e) {
	          nextTick(function () {
	            throw prevError;
	          }, 0);
	          throw e;
	        }
	      } else {
	        this.cb.call(this.vm, value, oldValue);
	      }
	    }
	    this.queued = this.shallow = false;
	  }
	};

	/**
	 * Evaluate the value of the watcher.
	 * This only gets called for lazy watchers.
	 */

	Watcher.prototype.evaluate = function () {
	  // avoid overwriting another watcher that is being
	  // collected.
	  var current = Dep.target;
	  this.value = this.get();
	  this.dirty = false;
	  Dep.target = current;
	};

	/**
	 * Depend on all deps collected by this watcher.
	 */

	Watcher.prototype.depend = function () {
	  var i = this.deps.length;
	  while (i--) {
	    this.deps[i].depend();
	  }
	};

	/**
	 * Remove self from all dependencies' subcriber list.
	 */

	Watcher.prototype.teardown = function () {
	  if (this.active) {
	    // remove self from vm's watcher list
	    // this is a somewhat expensive operation so we skip it
	    // if the vm is being destroyed or is performing a v-for
	    // re-render (the watcher list is then filtered by v-for).
	    if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {
	      this.vm._watchers.$remove(this);
	    }
	    var i = this.deps.length;
	    while (i--) {
	      this.deps[i].removeSub(this);
	    }
	    this.active = false;
	    this.vm = this.cb = this.value = null;
	  }
	};

	/**
	 * Recrusively traverse an object to evoke all converted
	 * getters, so that every nested property inside the object
	 * is collected as a "deep" dependency.
	 *
	 * @param {*} val
	 */

	function traverse(val) {
	  var i, keys;
	  if (isArray(val)) {
	    i = val.length;
	    while (i--) traverse(val[i]);
	  } else if (isObject(val)) {
	    keys = Object.keys(val);
	    i = keys.length;
	    while (i--) traverse(val[keys[i]]);
	  }
	}

	var text$1 = {

	  bind: function bind() {
	    this.attr = this.el.nodeType === 3 ? 'data' : 'textContent';
	  },

	  update: function update(value) {
	    this.el[this.attr] = _toString(value);
	  }
	};

	var templateCache = new Cache(1000);
	var idSelectorCache = new Cache(1000);

	var map = {
	  efault: [0, '', ''],
	  legend: [1, '<fieldset>', '</fieldset>'],
	  tr: [2, '<table><tbody>', '</tbody></table>'],
	  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>']
	};

	map.td = map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

	map.option = map.optgroup = [1, '<select multiple="multiple">', '</select>'];

	map.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, '<table>', '</table>'];

	map.g = map.defs = map.symbol = map.use = map.image = map.text = map.circle = map.ellipse = map.line = map.path = map.polygon = map.polyline = map.rect = [1, '<svg ' + 'xmlns="http://www.w3.org/2000/svg" ' + 'xmlns:xlink="http://www.w3.org/1999/xlink" ' + 'xmlns:ev="http://www.w3.org/2001/xml-events"' + 'version="1.1">', '</svg>'];

	/**
	 * Check if a node is a supported template node with a
	 * DocumentFragment content.
	 *
	 * @param {Node} node
	 * @return {Boolean}
	 */

	function isRealTemplate(node) {
	  return isTemplate(node) && isFragment(node.content);
	}

	var tagRE$1 = /<([\w:-]+)/;
	var entityRE = /&#?\w+?;/;

	/**
	 * Convert a string template to a DocumentFragment.
	 * Determines correct wrapping by tag types. Wrapping
	 * strategy found in jQuery & component/domify.
	 *
	 * @param {String} templateString
	 * @param {Boolean} raw
	 * @return {DocumentFragment}
	 */

	function stringToFragment(templateString, raw) {
	  // try a cache hit first
	  var cacheKey = raw ? templateString : templateString.trim();
	  var hit = templateCache.get(cacheKey);
	  if (hit) {
	    return hit;
	  }

	  var frag = document.createDocumentFragment();
	  var tagMatch = templateString.match(tagRE$1);
	  var entityMatch = entityRE.test(templateString);

	  if (!tagMatch && !entityMatch) {
	    // text only, return a single text node.
	    frag.appendChild(document.createTextNode(templateString));
	  } else {
	    var tag = tagMatch && tagMatch[1];
	    var wrap = map[tag] || map.efault;
	    var depth = wrap[0];
	    var prefix = wrap[1];
	    var suffix = wrap[2];
	    var node = document.createElement('div');

	    node.innerHTML = prefix + templateString + suffix;
	    while (depth--) {
	      node = node.lastChild;
	    }

	    var child;
	    /* eslint-disable no-cond-assign */
	    while (child = node.firstChild) {
	      /* eslint-enable no-cond-assign */
	      frag.appendChild(child);
	    }
	  }
	  if (!raw) {
	    trimNode(frag);
	  }
	  templateCache.put(cacheKey, frag);
	  return frag;
	}

	/**
	 * Convert a template node to a DocumentFragment.
	 *
	 * @param {Node} node
	 * @return {DocumentFragment}
	 */

	function nodeToFragment(node) {
	  // if its a template tag and the browser supports it,
	  // its content is already a document fragment.
	  if (isRealTemplate(node)) {
	    trimNode(node.content);
	    return node.content;
	  }
	  // script template
	  if (node.tagName === 'SCRIPT') {
	    return stringToFragment(node.textContent);
	  }
	  // normal node, clone it to avoid mutating the original
	  var clonedNode = cloneNode(node);
	  var frag = document.createDocumentFragment();
	  var child;
	  /* eslint-disable no-cond-assign */
	  while (child = clonedNode.firstChild) {
	    /* eslint-enable no-cond-assign */
	    frag.appendChild(child);
	  }
	  trimNode(frag);
	  return frag;
	}

	// Test for the presence of the Safari template cloning bug
	// https://bugs.webkit.org/showug.cgi?id=137755
	var hasBrokenTemplate = (function () {
	  /* istanbul ignore else */
	  if (inBrowser) {
	    var a = document.createElement('div');
	    a.innerHTML = '<template>1</template>';
	    return !a.cloneNode(true).firstChild.innerHTML;
	  } else {
	    return false;
	  }
	})();

	// Test for IE10/11 textarea placeholder clone bug
	var hasTextareaCloneBug = (function () {
	  /* istanbul ignore else */
	  if (inBrowser) {
	    var t = document.createElement('textarea');
	    t.placeholder = 't';
	    return t.cloneNode(true).value === 't';
	  } else {
	    return false;
	  }
	})();

	/**
	 * 1. Deal with Safari cloning nested <template> bug by
	 *    manually cloning all template instances.
	 * 2. Deal with IE10/11 textarea placeholder bug by setting
	 *    the correct value after cloning.
	 *
	 * @param {Element|DocumentFragment} node
	 * @return {Element|DocumentFragment}
	 */

	function cloneNode(node) {
	  /* istanbul ignore if */
	  if (!node.querySelectorAll) {
	    return node.cloneNode();
	  }
	  var res = node.cloneNode(true);
	  var i, original, cloned;
	  /* istanbul ignore if */
	  if (hasBrokenTemplate) {
	    var tempClone = res;
	    if (isRealTemplate(node)) {
	      node = node.content;
	      tempClone = res.content;
	    }
	    original = node.querySelectorAll('template');
	    if (original.length) {
	      cloned = tempClone.querySelectorAll('template');
	      i = cloned.length;
	      while (i--) {
	        cloned[i].parentNode.replaceChild(cloneNode(original[i]), cloned[i]);
	      }
	    }
	  }
	  /* istanbul ignore if */
	  if (hasTextareaCloneBug) {
	    if (node.tagName === 'TEXTAREA') {
	      res.value = node.value;
	    } else {
	      original = node.querySelectorAll('textarea');
	      if (original.length) {
	        cloned = res.querySelectorAll('textarea');
	        i = cloned.length;
	        while (i--) {
	          cloned[i].value = original[i].value;
	        }
	      }
	    }
	  }
	  return res;
	}

	/**
	 * Process the template option and normalizes it into a
	 * a DocumentFragment that can be used as a partial or a
	 * instance template.
	 *
	 * @param {*} template
	 *        Possible values include:
	 *        - DocumentFragment object
	 *        - Node object of type Template
	 *        - id selector: '#some-template-id'
	 *        - template string: '<div><span>{{msg}}</span></div>'
	 * @param {Boolean} shouldClone
	 * @param {Boolean} raw
	 *        inline HTML interpolation. Do not check for id
	 *        selector and keep whitespace in the string.
	 * @return {DocumentFragment|undefined}
	 */

	function parseTemplate(template, shouldClone, raw) {
	  var node, frag;

	  // if the template is already a document fragment,
	  // do nothing
	  if (isFragment(template)) {
	    trimNode(template);
	    return shouldClone ? cloneNode(template) : template;
	  }

	  if (typeof template === 'string') {
	    // id selector
	    if (!raw && template.charAt(0) === '#') {
	      // id selector can be cached too
	      frag = idSelectorCache.get(template);
	      if (!frag) {
	        node = document.getElementById(template.slice(1));
	        if (node) {
	          frag = nodeToFragment(node);
	          // save selector to cache
	          idSelectorCache.put(template, frag);
	        }
	      }
	    } else {
	      // normal string template
	      frag = stringToFragment(template, raw);
	    }
	  } else if (template.nodeType) {
	    // a direct node
	    frag = nodeToFragment(template);
	  }

	  return frag && shouldClone ? cloneNode(frag) : frag;
	}

	var template = Object.freeze({
	  cloneNode: cloneNode,
	  parseTemplate: parseTemplate
	});

	var html = {

	  bind: function bind() {
	    // a comment node means this is a binding for
	    // {{{ inline unescaped html }}}
	    if (this.el.nodeType === 8) {
	      // hold nodes
	      this.nodes = [];
	      // replace the placeholder with proper anchor
	      this.anchor = createAnchor('v-html');
	      replace(this.el, this.anchor);
	    }
	  },

	  update: function update(value) {
	    value = _toString(value);
	    if (this.nodes) {
	      this.swap(value);
	    } else {
	      this.el.innerHTML = value;
	    }
	  },

	  swap: function swap(value) {
	    // remove old nodes
	    var i = this.nodes.length;
	    while (i--) {
	      remove(this.nodes[i]);
	    }
	    // convert new value to a fragment
	    // do not attempt to retrieve from id selector
	    var frag = parseTemplate(value, true, true);
	    // save a reference to these nodes so we can remove later
	    this.nodes = toArray(frag.childNodes);
	    before(frag, this.anchor);
	  }
	};

	/**
	 * Abstraction for a partially-compiled fragment.
	 * Can optionally compile content with a child scope.
	 *
	 * @param {Function} linker
	 * @param {Vue} vm
	 * @param {DocumentFragment} frag
	 * @param {Vue} [host]
	 * @param {Object} [scope]
	 * @param {Fragment} [parentFrag]
	 */
	function Fragment(linker, vm, frag, host, scope, parentFrag) {
	  this.children = [];
	  this.childFrags = [];
	  this.vm = vm;
	  this.scope = scope;
	  this.inserted = false;
	  this.parentFrag = parentFrag;
	  if (parentFrag) {
	    parentFrag.childFrags.push(this);
	  }
	  this.unlink = linker(vm, frag, host, scope, this);
	  var single = this.single = frag.childNodes.length === 1 &&
	  // do not go single mode if the only node is an anchor
	  !frag.childNodes[0].__v_anchor;
	  if (single) {
	    this.node = frag.childNodes[0];
	    this.before = singleBefore;
	    this.remove = singleRemove;
	  } else {
	    this.node = createAnchor('fragment-start');
	    this.end = createAnchor('fragment-end');
	    this.frag = frag;
	    prepend(this.node, frag);
	    frag.appendChild(this.end);
	    this.before = multiBefore;
	    this.remove = multiRemove;
	  }
	  this.node.__v_frag = this;
	}

	/**
	 * Call attach/detach for all components contained within
	 * this fragment. Also do so recursively for all child
	 * fragments.
	 *
	 * @param {Function} hook
	 */

	Fragment.prototype.callHook = function (hook) {
	  var i, l;
	  for (i = 0, l = this.childFrags.length; i < l; i++) {
	    this.childFrags[i].callHook(hook);
	  }
	  for (i = 0, l = this.children.length; i < l; i++) {
	    hook(this.children[i]);
	  }
	};

	/**
	 * Insert fragment before target, single node version
	 *
	 * @param {Node} target
	 * @param {Boolean} withTransition
	 */

	function singleBefore(target, withTransition) {
	  this.inserted = true;
	  var method = withTransition !== false ? beforeWithTransition : before;
	  method(this.node, target, this.vm);
	  if (inDoc(this.node)) {
	    this.callHook(attach);
	  }
	}

	/**
	 * Remove fragment, single node version
	 */

	function singleRemove() {
	  this.inserted = false;
	  var shouldCallRemove = inDoc(this.node);
	  var self = this;
	  this.beforeRemove();
	  removeWithTransition(this.node, this.vm, function () {
	    if (shouldCallRemove) {
	      self.callHook(detach);
	    }
	    self.destroy();
	  });
	}

	/**
	 * Insert fragment before target, multi-nodes version
	 *
	 * @param {Node} target
	 * @param {Boolean} withTransition
	 */

	function multiBefore(target, withTransition) {
	  this.inserted = true;
	  var vm = this.vm;
	  var method = withTransition !== false ? beforeWithTransition : before;
	  mapNodeRange(this.node, this.end, function (node) {
	    method(node, target, vm);
	  });
	  if (inDoc(this.node)) {
	    this.callHook(attach);
	  }
	}

	/**
	 * Remove fragment, multi-nodes version
	 */

	function multiRemove() {
	  this.inserted = false;
	  var self = this;
	  var shouldCallRemove = inDoc(this.node);
	  this.beforeRemove();
	  removeNodeRange(this.node, this.end, this.vm, this.frag, function () {
	    if (shouldCallRemove) {
	      self.callHook(detach);
	    }
	    self.destroy();
	  });
	}

	/**
	 * Prepare the fragment for removal.
	 */

	Fragment.prototype.beforeRemove = function () {
	  var i, l;
	  for (i = 0, l = this.childFrags.length; i < l; i++) {
	    // call the same method recursively on child
	    // fragments, depth-first
	    this.childFrags[i].beforeRemove(false);
	  }
	  for (i = 0, l = this.children.length; i < l; i++) {
	    // Call destroy for all contained instances,
	    // with remove:false and defer:true.
	    // Defer is necessary because we need to
	    // keep the children to call detach hooks
	    // on them.
	    this.children[i].$destroy(false, true);
	  }
	  var dirs = this.unlink.dirs;
	  for (i = 0, l = dirs.length; i < l; i++) {
	    // disable the watchers on all the directives
	    // so that the rendered content stays the same
	    // during removal.
	    dirs[i]._watcher && dirs[i]._watcher.teardown();
	  }
	};

	/**
	 * Destroy the fragment.
	 */

	Fragment.prototype.destroy = function () {
	  if (this.parentFrag) {
	    this.parentFrag.childFrags.$remove(this);
	  }
	  this.node.__v_frag = null;
	  this.unlink();
	};

	/**
	 * Call attach hook for a Vue instance.
	 *
	 * @param {Vue} child
	 */

	function attach(child) {
	  if (!child._isAttached && inDoc(child.$el)) {
	    child._callHook('attached');
	  }
	}

	/**
	 * Call detach hook for a Vue instance.
	 *
	 * @param {Vue} child
	 */

	function detach(child) {
	  if (child._isAttached && !inDoc(child.$el)) {
	    child._callHook('detached');
	  }
	}

	var linkerCache = new Cache(5000);

	/**
	 * A factory that can be used to create instances of a
	 * fragment. Caches the compiled linker if possible.
	 *
	 * @param {Vue} vm
	 * @param {Element|String} el
	 */
	function FragmentFactory(vm, el) {
	  this.vm = vm;
	  var template;
	  var isString = typeof el === 'string';
	  if (isString || isTemplate(el)) {
	    template = parseTemplate(el, true);
	  } else {
	    template = document.createDocumentFragment();
	    template.appendChild(el);
	  }
	  this.template = template;
	  // linker can be cached, but only for components
	  var linker;
	  var cid = vm.constructor.cid;
	  if (cid > 0) {
	    var cacheId = cid + (isString ? el : getOuterHTML(el));
	    linker = linkerCache.get(cacheId);
	    if (!linker) {
	      linker = compile(template, vm.$options, true);
	      linkerCache.put(cacheId, linker);
	    }
	  } else {
	    linker = compile(template, vm.$options, true);
	  }
	  this.linker = linker;
	}

	/**
	 * Create a fragment instance with given host and scope.
	 *
	 * @param {Vue} host
	 * @param {Object} scope
	 * @param {Fragment} parentFrag
	 */

	FragmentFactory.prototype.create = function (host, scope, parentFrag) {
	  var frag = cloneNode(this.template);
	  return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag);
	};

	var ON = 700;
	var MODEL = 800;
	var BIND = 850;
	var TRANSITION = 1100;
	var EL = 1500;
	var COMPONENT = 1500;
	var PARTIAL = 1750;
	var IF = 2100;
	var FOR = 2200;
	var SLOT = 2300;

	var uid$3 = 0;

	var vFor = {

	  priority: FOR,
	  terminal: true,

	  params: ['track-by', 'stagger', 'enter-stagger', 'leave-stagger'],

	  bind: function bind() {
	    // support "item in/of items" syntax
	    var inMatch = this.expression.match(/(.*) (?:in|of) (.*)/);
	    if (inMatch) {
	      var itMatch = inMatch[1].match(/\((.*),(.*)\)/);
	      if (itMatch) {
	        this.iterator = itMatch[1].trim();
	        this.alias = itMatch[2].trim();
	      } else {
	        this.alias = inMatch[1].trim();
	      }
	      this.expression = inMatch[2];
	    }

	    if (!this.alias) {
	      process.env.NODE_ENV !== 'production' && warn('Invalid v-for expression "' + this.descriptor.raw + '": ' + 'alias is required.', this.vm);
	      return;
	    }

	    // uid as a cache identifier
	    this.id = '__v-for__' + ++uid$3;

	    // check if this is an option list,
	    // so that we know if we need to update the <select>'s
	    // v-model when the option list has changed.
	    // because v-model has a lower priority than v-for,
	    // the v-model is not bound here yet, so we have to
	    // retrive it in the actual updateModel() function.
	    var tag = this.el.tagName;
	    this.isOption = (tag === 'OPTION' || tag === 'OPTGROUP') && this.el.parentNode.tagName === 'SELECT';

	    // setup anchor nodes
	    this.start = createAnchor('v-for-start');
	    this.end = createAnchor('v-for-end');
	    replace(this.el, this.end);
	    before(this.start, this.end);

	    // cache
	    this.cache = Object.create(null);

	    // fragment factory
	    this.factory = new FragmentFactory(this.vm, this.el);
	  },

	  update: function update(data) {
	    this.diff(data);
	    this.updateRef();
	    this.updateModel();
	  },

	  /**
	   * Diff, based on new data and old data, determine the
	   * minimum amount of DOM manipulations needed to make the
	   * DOM reflect the new data Array.
	   *
	   * The algorithm diffs the new data Array by storing a
	   * hidden reference to an owner vm instance on previously
	   * seen data. This allows us to achieve O(n) which is
	   * better than a levenshtein distance based algorithm,
	   * which is O(m * n).
	   *
	   * @param {Array} data
	   */

	  diff: function diff(data) {
	    // check if the Array was converted from an Object
	    var item = data[0];
	    var convertedFromObject = this.fromObject = isObject(item) && hasOwn(item, '$key') && hasOwn(item, '$value');

	    var trackByKey = this.params.trackBy;
	    var oldFrags = this.frags;
	    var frags = this.frags = new Array(data.length);
	    var alias = this.alias;
	    var iterator = this.iterator;
	    var start = this.start;
	    var end = this.end;
	    var inDocument = inDoc(start);
	    var init = !oldFrags;
	    var i, l, frag, key, value, primitive;

	    // First pass, go through the new Array and fill up
	    // the new frags array. If a piece of data has a cached
	    // instance for it, we reuse it. Otherwise build a new
	    // instance.
	    for (i = 0, l = data.length; i < l; i++) {
	      item = data[i];
	      key = convertedFromObject ? item.$key : null;
	      value = convertedFromObject ? item.$value : item;
	      primitive = !isObject(value);
	      frag = !init && this.getCachedFrag(value, i, key);
	      if (frag) {
	        // reusable fragment
	        frag.reused = true;
	        // update $index
	        frag.scope.$index = i;
	        // update $key
	        if (key) {
	          frag.scope.$key = key;
	        }
	        // update iterator
	        if (iterator) {
	          frag.scope[iterator] = key !== null ? key : i;
	        }
	        // update data for track-by, object repeat &
	        // primitive values.
	        if (trackByKey || convertedFromObject || primitive) {
	          withoutConversion(function () {
	            frag.scope[alias] = value;
	          });
	        }
	      } else {
	        // new isntance
	        frag = this.create(value, alias, i, key);
	        frag.fresh = !init;
	      }
	      frags[i] = frag;
	      if (init) {
	        frag.before(end);
	      }
	    }

	    // we're done for the initial render.
	    if (init) {
	      return;
	    }

	    // Second pass, go through the old fragments and
	    // destroy those who are not reused (and remove them
	    // from cache)
	    var removalIndex = 0;
	    var totalRemoved = oldFrags.length - frags.length;
	    // when removing a large number of fragments, watcher removal
	    // turns out to be a perf bottleneck, so we batch the watcher
	    // removals into a single filter call!
	    this.vm._vForRemoving = true;
	    for (i = 0, l = oldFrags.length; i < l; i++) {
	      frag = oldFrags[i];
	      if (!frag.reused) {
	        this.deleteCachedFrag(frag);
	        this.remove(frag, removalIndex++, totalRemoved, inDocument);
	      }
	    }
	    this.vm._vForRemoving = false;
	    if (removalIndex) {
	      this.vm._watchers = this.vm._watchers.filter(function (w) {
	        return w.active;
	      });
	    }

	    // Final pass, move/insert new fragments into the
	    // right place.
	    var targetPrev, prevEl, currentPrev;
	    var insertionIndex = 0;
	    for (i = 0, l = frags.length; i < l; i++) {
	      frag = frags[i];
	      // this is the frag that we should be after
	      targetPrev = frags[i - 1];
	      prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;
	      if (frag.reused && !frag.staggerCb) {
	        currentPrev = findPrevFrag(frag, start, this.id);
	        if (currentPrev !== targetPrev && (!currentPrev ||
	        // optimization for moving a single item.
	        // thanks to suggestions by @livoras in #1807
	        findPrevFrag(currentPrev, start, this.id) !== targetPrev)) {
	          this.move(frag, prevEl);
	        }
	      } else {
	        // new instance, or still in stagger.
	        // insert with updated stagger index.
	        this.insert(frag, insertionIndex++, prevEl, inDocument);
	      }
	      frag.reused = frag.fresh = false;
	    }
	  },

	  /**
	   * Create a new fragment instance.
	   *
	   * @param {*} value
	   * @param {String} alias
	   * @param {Number} index
	   * @param {String} [key]
	   * @return {Fragment}
	   */

	  create: function create(value, alias, index, key) {
	    var host = this._host;
	    // create iteration scope
	    var parentScope = this._scope || this.vm;
	    var scope = Object.create(parentScope);
	    // ref holder for the scope
	    scope.$refs = Object.create(parentScope.$refs);
	    scope.$els = Object.create(parentScope.$els);
	    // make sure point $parent to parent scope
	    scope.$parent = parentScope;
	    // for two-way binding on alias
	    scope.$forContext = this;
	    // define scope properties
	    // important: define the scope alias without forced conversion
	    // so that frozen data structures remain non-reactive.
	    withoutConversion(function () {
	      defineReactive(scope, alias, value);
	    });
	    defineReactive(scope, '$index', index);
	    if (key) {
	      defineReactive(scope, '$key', key);
	    } else if (scope.$key) {
	      // avoid accidental fallback
	      def(scope, '$key', null);
	    }
	    if (this.iterator) {
	      defineReactive(scope, this.iterator, key !== null ? key : index);
	    }
	    var frag = this.factory.create(host, scope, this._frag);
	    frag.forId = this.id;
	    this.cacheFrag(value, frag, index, key);
	    return frag;
	  },

	  /**
	   * Update the v-ref on owner vm.
	   */

	  updateRef: function updateRef() {
	    var ref = this.descriptor.ref;
	    if (!ref) return;
	    var hash = (this._scope || this.vm).$refs;
	    var refs;
	    if (!this.fromObject) {
	      refs = this.frags.map(findVmFromFrag);
	    } else {
	      refs = {};
	      this.frags.forEach(function (frag) {
	        refs[frag.scope.$key] = findVmFromFrag(frag);
	      });
	    }
	    hash[ref] = refs;
	  },

	  /**
	   * For option lists, update the containing v-model on
	   * parent <select>.
	   */

	  updateModel: function updateModel() {
	    if (this.isOption) {
	      var parent = this.start.parentNode;
	      var model = parent && parent.__v_model;
	      if (model) {
	        model.forceUpdate();
	      }
	    }
	  },

	  /**
	   * Insert a fragment. Handles staggering.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Node} prevEl
	   * @param {Boolean} inDocument
	   */

	  insert: function insert(frag, index, prevEl, inDocument) {
	    if (frag.staggerCb) {
	      frag.staggerCb.cancel();
	      frag.staggerCb = null;
	    }
	    var staggerAmount = this.getStagger(frag, index, null, 'enter');
	    if (inDocument && staggerAmount) {
	      // create an anchor and insert it synchronously,
	      // so that we can resolve the correct order without
	      // worrying about some elements not inserted yet
	      var anchor = frag.staggerAnchor;
	      if (!anchor) {
	        anchor = frag.staggerAnchor = createAnchor('stagger-anchor');
	        anchor.__v_frag = frag;
	      }
	      after(anchor, prevEl);
	      var op = frag.staggerCb = cancellable(function () {
	        frag.staggerCb = null;
	        frag.before(anchor);
	        remove(anchor);
	      });
	      setTimeout(op, staggerAmount);
	    } else {
	      frag.before(prevEl.nextSibling);
	    }
	  },

	  /**
	   * Remove a fragment. Handles staggering.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Number} total
	   * @param {Boolean} inDocument
	   */

	  remove: function remove(frag, index, total, inDocument) {
	    if (frag.staggerCb) {
	      frag.staggerCb.cancel();
	      frag.staggerCb = null;
	      // it's not possible for the same frag to be removed
	      // twice, so if we have a pending stagger callback,
	      // it means this frag is queued for enter but removed
	      // before its transition started. Since it is already
	      // destroyed, we can just leave it in detached state.
	      return;
	    }
	    var staggerAmount = this.getStagger(frag, index, total, 'leave');
	    if (inDocument && staggerAmount) {
	      var op = frag.staggerCb = cancellable(function () {
	        frag.staggerCb = null;
	        frag.remove();
	      });
	      setTimeout(op, staggerAmount);
	    } else {
	      frag.remove();
	    }
	  },

	  /**
	   * Move a fragment to a new position.
	   * Force no transition.
	   *
	   * @param {Fragment} frag
	   * @param {Node} prevEl
	   */

	  move: function move(frag, prevEl) {
	    // fix a common issue with Sortable:
	    // if prevEl doesn't have nextSibling, this means it's
	    // been dragged after the end anchor. Just re-position
	    // the end anchor to the end of the container.
	    /* istanbul ignore if */
	    if (!prevEl.nextSibling) {
	      this.end.parentNode.appendChild(this.end);
	    }
	    frag.before(prevEl.nextSibling, false);
	  },

	  /**
	   * Cache a fragment using track-by or the object key.
	   *
	   * @param {*} value
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {String} [key]
	   */

	  cacheFrag: function cacheFrag(value, frag, index, key) {
	    var trackByKey = this.params.trackBy;
	    var cache = this.cache;
	    var primitive = !isObject(value);
	    var id;
	    if (key || trackByKey || primitive) {
	      id = trackByKey ? trackByKey === '$index' ? index : getPath(value, trackByKey) : key || value;
	      if (!cache[id]) {
	        cache[id] = frag;
	      } else if (trackByKey !== '$index') {
	        process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
	      }
	    } else {
	      id = this.id;
	      if (hasOwn(value, id)) {
	        if (value[id] === null) {
	          value[id] = frag;
	        } else {
	          process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
	        }
	      } else {
	        def(value, id, frag);
	      }
	    }
	    frag.raw = value;
	  },

	  /**
	   * Get a cached fragment from the value/index/key
	   *
	   * @param {*} value
	   * @param {Number} index
	   * @param {String} key
	   * @return {Fragment}
	   */

	  getCachedFrag: function getCachedFrag(value, index, key) {
	    var trackByKey = this.params.trackBy;
	    var primitive = !isObject(value);
	    var frag;
	    if (key || trackByKey || primitive) {
	      var id = trackByKey ? trackByKey === '$index' ? index : getPath(value, trackByKey) : key || value;
	      frag = this.cache[id];
	    } else {
	      frag = value[this.id];
	    }
	    if (frag && (frag.reused || frag.fresh)) {
	      process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
	    }
	    return frag;
	  },

	  /**
	   * Delete a fragment from cache.
	   *
	   * @param {Fragment} frag
	   */

	  deleteCachedFrag: function deleteCachedFrag(frag) {
	    var value = frag.raw;
	    var trackByKey = this.params.trackBy;
	    var scope = frag.scope;
	    var index = scope.$index;
	    // fix #948: avoid accidentally fall through to
	    // a parent repeater which happens to have $key.
	    var key = hasOwn(scope, '$key') && scope.$key;
	    var primitive = !isObject(value);
	    if (trackByKey || key || primitive) {
	      var id = trackByKey ? trackByKey === '$index' ? index : getPath(value, trackByKey) : key || value;
	      this.cache[id] = null;
	    } else {
	      value[this.id] = null;
	      frag.raw = null;
	    }
	  },

	  /**
	   * Get the stagger amount for an insertion/removal.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Number} total
	   * @param {String} type
	   */

	  getStagger: function getStagger(frag, index, total, type) {
	    type = type + 'Stagger';
	    var trans = frag.node.__v_trans;
	    var hooks = trans && trans.hooks;
	    var hook = hooks && (hooks[type] || hooks.stagger);
	    return hook ? hook.call(frag, index, total) : index * parseInt(this.params[type] || this.params.stagger, 10);
	  },

	  /**
	   * Pre-process the value before piping it through the
	   * filters. This is passed to and called by the watcher.
	   */

	  _preProcess: function _preProcess(value) {
	    // regardless of type, store the un-filtered raw value.
	    this.rawValue = value;
	    return value;
	  },

	  /**
	   * Post-process the value after it has been piped through
	   * the filters. This is passed to and called by the watcher.
	   *
	   * It is necessary for this to be called during the
	   * wathcer's dependency collection phase because we want
	   * the v-for to update when the source Object is mutated.
	   */

	  _postProcess: function _postProcess(value) {
	    if (isArray(value)) {
	      return value;
	    } else if (isPlainObject(value)) {
	      // convert plain object to array.
	      var keys = Object.keys(value);
	      var i = keys.length;
	      var res = new Array(i);
	      var key;
	      while (i--) {
	        key = keys[i];
	        res[i] = {
	          $key: key,
	          $value: value[key]
	        };
	      }
	      return res;
	    } else {
	      if (typeof value === 'number' && !isNaN(value)) {
	        value = range(value);
	      }
	      return value || [];
	    }
	  },

	  unbind: function unbind() {
	    if (this.descriptor.ref) {
	      (this._scope || this.vm).$refs[this.descriptor.ref] = null;
	    }
	    if (this.frags) {
	      var i = this.frags.length;
	      var frag;
	      while (i--) {
	        frag = this.frags[i];
	        this.deleteCachedFrag(frag);
	        frag.destroy();
	      }
	    }
	  }
	};

	/**
	 * Helper to find the previous element that is a fragment
	 * anchor. This is necessary because a destroyed frag's
	 * element could still be lingering in the DOM before its
	 * leaving transition finishes, but its inserted flag
	 * should have been set to false so we can skip them.
	 *
	 * If this is a block repeat, we want to make sure we only
	 * return frag that is bound to this v-for. (see #929)
	 *
	 * @param {Fragment} frag
	 * @param {Comment|Text} anchor
	 * @param {String} id
	 * @return {Fragment}
	 */

	function findPrevFrag(frag, anchor, id) {
	  var el = frag.node.previousSibling;
	  /* istanbul ignore if */
	  if (!el) return;
	  frag = el.__v_frag;
	  while ((!frag || frag.forId !== id || !frag.inserted) && el !== anchor) {
	    el = el.previousSibling;
	    /* istanbul ignore if */
	    if (!el) return;
	    frag = el.__v_frag;
	  }
	  return frag;
	}

	/**
	 * Find a vm from a fragment.
	 *
	 * @param {Fragment} frag
	 * @return {Vue|undefined}
	 */

	function findVmFromFrag(frag) {
	  var node = frag.node;
	  // handle multi-node frag
	  if (frag.end) {
	    while (!node.__vue__ && node !== frag.end && node.nextSibling) {
	      node = node.nextSibling;
	    }
	  }
	  return node.__vue__;
	}

	/**
	 * Create a range array from given number.
	 *
	 * @param {Number} n
	 * @return {Array}
	 */

	function range(n) {
	  var i = -1;
	  var ret = new Array(Math.floor(n));
	  while (++i < n) {
	    ret[i] = i;
	  }
	  return ret;
	}

	if (process.env.NODE_ENV !== 'production') {
	  vFor.warnDuplicate = function (value) {
	    warn('Duplicate value found in v-for="' + this.descriptor.raw + '": ' + JSON.stringify(value) + '. Use track-by="$index" if ' + 'you are expecting duplicate values.', this.vm);
	  };
	}

	var vIf = {

	  priority: IF,
	  terminal: true,

	  bind: function bind() {
	    var el = this.el;
	    if (!el.__vue__) {
	      // check else block
	      var next = el.nextElementSibling;
	      if (next && getAttr(next, 'v-else') !== null) {
	        remove(next);
	        this.elseEl = next;
	      }
	      // check main block
	      this.anchor = createAnchor('v-if');
	      replace(el, this.anchor);
	    } else {
	      process.env.NODE_ENV !== 'production' && warn('v-if="' + this.expression + '" cannot be ' + 'used on an instance root element.', this.vm);
	      this.invalid = true;
	    }
	  },

	  update: function update(value) {
	    if (this.invalid) return;
	    if (value) {
	      if (!this.frag) {
	        this.insert();
	      }
	    } else {
	      this.remove();
	    }
	  },

	  insert: function insert() {
	    if (this.elseFrag) {
	      this.elseFrag.remove();
	      this.elseFrag = null;
	    }
	    // lazy init factory
	    if (!this.factory) {
	      this.factory = new FragmentFactory(this.vm, this.el);
	    }
	    this.frag = this.factory.create(this._host, this._scope, this._frag);
	    this.frag.before(this.anchor);
	  },

	  remove: function remove() {
	    if (this.frag) {
	      this.frag.remove();
	      this.frag = null;
	    }
	    if (this.elseEl && !this.elseFrag) {
	      if (!this.elseFactory) {
	        this.elseFactory = new FragmentFactory(this.elseEl._context || this.vm, this.elseEl);
	      }
	      this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag);
	      this.elseFrag.before(this.anchor);
	    }
	  },

	  unbind: function unbind() {
	    if (this.frag) {
	      this.frag.destroy();
	    }
	    if (this.elseFrag) {
	      this.elseFrag.destroy();
	    }
	  }
	};

	var show = {

	  bind: function bind() {
	    // check else block
	    var next = this.el.nextElementSibling;
	    if (next && getAttr(next, 'v-else') !== null) {
	      this.elseEl = next;
	    }
	  },

	  update: function update(value) {
	    this.apply(this.el, value);
	    if (this.elseEl) {
	      this.apply(this.elseEl, !value);
	    }
	  },

	  apply: function apply(el, value) {
	    if (inDoc(el)) {
	      applyTransition(el, value ? 1 : -1, toggle, this.vm);
	    } else {
	      toggle();
	    }
	    function toggle() {
	      el.style.display = value ? '' : 'none';
	    }
	  }
	};

	var text$2 = {

	  bind: function bind() {
	    var self = this;
	    var el = this.el;
	    var isRange = el.type === 'range';
	    var lazy = this.params.lazy;
	    var number = this.params.number;
	    var debounce = this.params.debounce;

	    // handle composition events.
	    //   http://blog.evanyou.me/2014/01/03/composition-event/
	    // skip this for Android because it handles composition
	    // events quite differently. Android doesn't trigger
	    // composition events for language input methods e.g.
	    // Chinese, but instead triggers them for spelling
	    // suggestions... (see Discussion/#162)
	    var composing = false;
	    if (!isAndroid && !isRange) {
	      this.on('compositionstart', function () {
	        composing = true;
	      });
	      this.on('compositionend', function () {
	        composing = false;
	        // in IE11 the "compositionend" event fires AFTER
	        // the "input" event, so the input handler is blocked
	        // at the end... have to call it here.
	        //
	        // #1327: in lazy mode this is unecessary.
	        if (!lazy) {
	          self.listener();
	        }
	      });
	    }

	    // prevent messing with the input when user is typing,
	    // and force update on blur.
	    this.focused = false;
	    if (!isRange && !lazy) {
	      this.on('focus', function () {
	        self.focused = true;
	      });
	      this.on('blur', function () {
	        self.focused = false;
	        // do not sync value after fragment removal (#2017)
	        if (!self._frag || self._frag.inserted) {
	          self.rawListener();
	        }
	      });
	    }

	    // Now attach the main listener
	    this.listener = this.rawListener = function () {
	      if (composing || !self._bound) {
	        return;
	      }
	      var val = number || isRange ? toNumber(el.value) : el.value;
	      self.set(val);
	      // force update on next tick to avoid lock & same value
	      // also only update when user is not typing
	      nextTick(function () {
	        if (self._bound && !self.focused) {
	          self.update(self._watcher.value);
	        }
	      });
	    };

	    // apply debounce
	    if (debounce) {
	      this.listener = _debounce(this.listener, debounce);
	    }

	    // Support jQuery events, since jQuery.trigger() doesn't
	    // trigger native events in some cases and some plugins
	    // rely on $.trigger()
	    //
	    // We want to make sure if a listener is attached using
	    // jQuery, it is also removed with jQuery, that's why
	    // we do the check for each directive instance and
	    // store that check result on itself. This also allows
	    // easier test coverage control by unsetting the global
	    // jQuery variable in tests.
	    this.hasjQuery = typeof jQuery === 'function';
	    if (this.hasjQuery) {
	      var method = jQuery.fn.on ? 'on' : 'bind';
	      jQuery(el)[method]('change', this.rawListener);
	      if (!lazy) {
	        jQuery(el)[method]('input', this.listener);
	      }
	    } else {
	      this.on('change', this.rawListener);
	      if (!lazy) {
	        this.on('input', this.listener);
	      }
	    }

	    // IE9 doesn't fire input event on backspace/del/cut
	    if (!lazy && isIE9) {
	      this.on('cut', function () {
	        nextTick(self.listener);
	      });
	      this.on('keyup', function (e) {
	        if (e.keyCode === 46 || e.keyCode === 8) {
	          self.listener();
	        }
	      });
	    }

	    // set initial value if present
	    if (el.hasAttribute('value') || el.tagName === 'TEXTAREA' && el.value.trim()) {
	      this.afterBind = this.listener;
	    }
	  },

	  update: function update(value) {
	    this.el.value = _toString(value);
	  },

	  unbind: function unbind() {
	    var el = this.el;
	    if (this.hasjQuery) {
	      var method = jQuery.fn.off ? 'off' : 'unbind';
	      jQuery(el)[method]('change', this.listener);
	      jQuery(el)[method]('input', this.listener);
	    }
	  }
	};

	var radio = {

	  bind: function bind() {
	    var self = this;
	    var el = this.el;

	    this.getValue = function () {
	      // value overwrite via v-bind:value
	      if (el.hasOwnProperty('_value')) {
	        return el._value;
	      }
	      var val = el.value;
	      if (self.params.number) {
	        val = toNumber(val);
	      }
	      return val;
	    };

	    this.listener = function () {
	      self.set(self.getValue());
	    };
	    this.on('change', this.listener);

	    if (el.hasAttribute('checked')) {
	      this.afterBind = this.listener;
	    }
	  },

	  update: function update(value) {
	    this.el.checked = looseEqual(value, this.getValue());
	  }
	};

	var select = {

	  bind: function bind() {
	    var self = this;
	    var el = this.el;

	    // method to force update DOM using latest value.
	    this.forceUpdate = function () {
	      if (self._watcher) {
	        self.update(self._watcher.get());
	      }
	    };

	    // check if this is a multiple select
	    var multiple = this.multiple = el.hasAttribute('multiple');

	    // attach listener
	    this.listener = function () {
	      var value = getValue(el, multiple);
	      value = self.params.number ? isArray(value) ? value.map(toNumber) : toNumber(value) : value;
	      self.set(value);
	    };
	    this.on('change', this.listener);

	    // if has initial value, set afterBind
	    var initValue = getValue(el, multiple, true);
	    if (multiple && initValue.length || !multiple && initValue !== null) {
	      this.afterBind = this.listener;
	    }

	    // All major browsers except Firefox resets
	    // selectedIndex with value -1 to 0 when the element
	    // is appended to a new parent, therefore we have to
	    // force a DOM update whenever that happens...
	    this.vm.$on('hook:attached', this.forceUpdate);
	  },

	  update: function update(value) {
	    var el = this.el;
	    el.selectedIndex = -1;
	    var multi = this.multiple && isArray(value);
	    var options = el.options;
	    var i = options.length;
	    var op, val;
	    while (i--) {
	      op = options[i];
	      val = op.hasOwnProperty('_value') ? op._value : op.value;
	      /* eslint-disable eqeqeq */
	      op.selected = multi ? indexOf$1(value, val) > -1 : looseEqual(value, val);
	      /* eslint-enable eqeqeq */
	    }
	  },

	  unbind: function unbind() {
	    /* istanbul ignore next */
	    this.vm.$off('hook:attached', this.forceUpdate);
	  }
	};

	/**
	 * Get select value
	 *
	 * @param {SelectElement} el
	 * @param {Boolean} multi
	 * @param {Boolean} init
	 * @return {Array|*}
	 */

	function getValue(el, multi, init) {
	  var res = multi ? [] : null;
	  var op, val, selected;
	  for (var i = 0, l = el.options.length; i < l; i++) {
	    op = el.options[i];
	    selected = init ? op.hasAttribute('selected') : op.selected;
	    if (selected) {
	      val = op.hasOwnProperty('_value') ? op._value : op.value;
	      if (multi) {
	        res.push(val);
	      } else {
	        return val;
	      }
	    }
	  }
	  return res;
	}

	/**
	 * Native Array.indexOf uses strict equal, but in this
	 * case we need to match string/numbers with custom equal.
	 *
	 * @param {Array} arr
	 * @param {*} val
	 */

	function indexOf$1(arr, val) {
	  var i = arr.length;
	  while (i--) {
	    if (looseEqual(arr[i], val)) {
	      return i;
	    }
	  }
	  return -1;
	}

	var checkbox = {

	  bind: function bind() {
	    var self = this;
	    var el = this.el;

	    this.getValue = function () {
	      return el.hasOwnProperty('_value') ? el._value : self.params.number ? toNumber(el.value) : el.value;
	    };

	    function getBooleanValue() {
	      var val = el.checked;
	      if (val && el.hasOwnProperty('_trueValue')) {
	        return el._trueValue;
	      }
	      if (!val && el.hasOwnProperty('_falseValue')) {
	        return el._falseValue;
	      }
	      return val;
	    }

	    this.listener = function () {
	      var model = self._watcher.value;
	      if (isArray(model)) {
	        var val = self.getValue();
	        if (el.checked) {
	          if (indexOf(model, val) < 0) {
	            model.push(val);
	          }
	        } else {
	          model.$remove(val);
	        }
	      } else {
	        self.set(getBooleanValue());
	      }
	    };

	    this.on('change', this.listener);
	    if (el.hasAttribute('checked')) {
	      this.afterBind = this.listener;
	    }
	  },

	  update: function update(value) {
	    var el = this.el;
	    if (isArray(value)) {
	      el.checked = indexOf(value, this.getValue()) > -1;
	    } else {
	      if (el.hasOwnProperty('_trueValue')) {
	        el.checked = looseEqual(value, el._trueValue);
	      } else {
	        el.checked = !!value;
	      }
	    }
	  }
	};

	var handlers = {
	  text: text$2,
	  radio: radio,
	  select: select,
	  checkbox: checkbox
	};

	var model = {

	  priority: MODEL,
	  twoWay: true,
	  handlers: handlers,
	  params: ['lazy', 'number', 'debounce'],

	  /**
	   * Possible elements:
	   *   <select>
	   *   <textarea>
	   *   <input type="*">
	   *     - text
	   *     - checkbox
	   *     - radio
	   *     - number
	   */

	  bind: function bind() {
	    // friendly warning...
	    this.checkFilters();
	    if (this.hasRead && !this.hasWrite) {
	      process.env.NODE_ENV !== 'production' && warn('It seems you are using a read-only filter with ' + 'v-model="' + this.descriptor.raw + '". ' + 'You might want to use a two-way filter to ensure correct behavior.', this.vm);
	    }
	    var el = this.el;
	    var tag = el.tagName;
	    var handler;
	    if (tag === 'INPUT') {
	      handler = handlers[el.type] || handlers.text;
	    } else if (tag === 'SELECT') {
	      handler = handlers.select;
	    } else if (tag === 'TEXTAREA') {
	      handler = handlers.text;
	    } else {
	      process.env.NODE_ENV !== 'production' && warn('v-model does not support element type: ' + tag, this.vm);
	      return;
	    }
	    el.__v_model = this;
	    handler.bind.call(this);
	    this.update = handler.update;
	    this._unbind = handler.unbind;
	  },

	  /**
	   * Check read/write filter stats.
	   */

	  checkFilters: function checkFilters() {
	    var filters = this.filters;
	    if (!filters) return;
	    var i = filters.length;
	    while (i--) {
	      var filter = resolveAsset(this.vm.$options, 'filters', filters[i].name);
	      if (typeof filter === 'function' || filter.read) {
	        this.hasRead = true;
	      }
	      if (filter.write) {
	        this.hasWrite = true;
	      }
	    }
	  },

	  unbind: function unbind() {
	    this.el.__v_model = null;
	    this._unbind && this._unbind();
	  }
	};

	// keyCode aliases
	var keyCodes = {
	  esc: 27,
	  tab: 9,
	  enter: 13,
	  space: 32,
	  'delete': [8, 46],
	  up: 38,
	  left: 37,
	  right: 39,
	  down: 40
	};

	function keyFilter(handler, keys) {
	  var codes = keys.map(function (key) {
	    var charCode = key.charCodeAt(0);
	    if (charCode > 47 && charCode < 58) {
	      return parseInt(key, 10);
	    }
	    if (key.length === 1) {
	      charCode = key.toUpperCase().charCodeAt(0);
	      if (charCode > 64 && charCode < 91) {
	        return charCode;
	      }
	    }
	    return keyCodes[key];
	  });
	  codes = [].concat.apply([], codes);
	  return function keyHandler(e) {
	    if (codes.indexOf(e.keyCode) > -1) {
	      return handler.call(this, e);
	    }
	  };
	}

	function stopFilter(handler) {
	  return function stopHandler(e) {
	    e.stopPropagation();
	    return handler.call(this, e);
	  };
	}

	function preventFilter(handler) {
	  return function preventHandler(e) {
	    e.preventDefault();
	    return handler.call(this, e);
	  };
	}

	function selfFilter(handler) {
	  return function selfHandler(e) {
	    if (e.target === e.currentTarget) {
	      return handler.call(this, e);
	    }
	  };
	}

	var on$1 = {

	  priority: ON,
	  acceptStatement: true,
	  keyCodes: keyCodes,

	  bind: function bind() {
	    // deal with iframes
	    if (this.el.tagName === 'IFRAME' && this.arg !== 'load') {
	      var self = this;
	      this.iframeBind = function () {
	        on(self.el.contentWindow, self.arg, self.handler, self.modifiers.capture);
	      };
	      this.on('load', this.iframeBind);
	    }
	  },

	  update: function update(handler) {
	    // stub a noop for v-on with no value,
	    // e.g. @mousedown.prevent
	    if (!this.descriptor.raw) {
	      handler = function () {};
	    }

	    if (typeof handler !== 'function') {
	      process.env.NODE_ENV !== 'production' && warn('v-on:' + this.arg + '="' + this.expression + '" expects a function value, ' + 'got ' + handler, this.vm);
	      return;
	    }

	    // apply modifiers
	    if (this.modifiers.stop) {
	      handler = stopFilter(handler);
	    }
	    if (this.modifiers.prevent) {
	      handler = preventFilter(handler);
	    }
	    if (this.modifiers.self) {
	      handler = selfFilter(handler);
	    }
	    // key filter
	    var keys = Object.keys(this.modifiers).filter(function (key) {
	      return key !== 'stop' && key !== 'prevent' && key !== 'self';
	    });
	    if (keys.length) {
	      handler = keyFilter(handler, keys);
	    }

	    this.reset();
	    this.handler = handler;

	    if (this.iframeBind) {
	      this.iframeBind();
	    } else {
	      on(this.el, this.arg, this.handler, this.modifiers.capture);
	    }
	  },

	  reset: function reset() {
	    var el = this.iframeBind ? this.el.contentWindow : this.el;
	    if (this.handler) {
	      off(el, this.arg, this.handler);
	    }
	  },

	  unbind: function unbind() {
	    this.reset();
	  }
	};

	var prefixes = ['-webkit-', '-moz-', '-ms-'];
	var camelPrefixes = ['Webkit', 'Moz', 'ms'];
	var importantRE = /!important;?$/;
	var propCache = Object.create(null);

	var testEl = null;

	var style = {

	  deep: true,

	  update: function update(value) {
	    if (typeof value === 'string') {
	      this.el.style.cssText = value;
	    } else if (isArray(value)) {
	      this.handleObject(value.reduce(extend, {}));
	    } else {
	      this.handleObject(value || {});
	    }
	  },

	  handleObject: function handleObject(value) {
	    // cache object styles so that only changed props
	    // are actually updated.
	    var cache = this.cache || (this.cache = {});
	    var name, val;
	    for (name in cache) {
	      if (!(name in value)) {
	        this.handleSingle(name, null);
	        delete cache[name];
	      }
	    }
	    for (name in value) {
	      val = value[name];
	      if (val !== cache[name]) {
	        cache[name] = val;
	        this.handleSingle(name, val);
	      }
	    }
	  },

	  handleSingle: function handleSingle(prop, value) {
	    prop = normalize(prop);
	    if (!prop) return; // unsupported prop
	    // cast possible numbers/booleans into strings
	    if (value != null) value += '';
	    if (value) {
	      var isImportant = importantRE.test(value) ? 'important' : '';
	      if (isImportant) {
	        /* istanbul ignore if */
	        if (process.env.NODE_ENV !== 'production') {
	          warn('It\'s probably a bad idea to use !important with inline rules. ' + 'This feature will be deprecated in a future version of Vue.');
	        }
	        value = value.replace(importantRE, '').trim();
	        this.el.style.setProperty(prop.kebab, value, isImportant);
	      } else {
	        this.el.style[prop.camel] = value;
	      }
	    } else {
	      this.el.style[prop.camel] = '';
	    }
	  }

	};

	/**
	 * Normalize a CSS property name.
	 * - cache result
	 * - auto prefix
	 * - camelCase -> dash-case
	 *
	 * @param {String} prop
	 * @return {String}
	 */

	function normalize(prop) {
	  if (propCache[prop]) {
	    return propCache[prop];
	  }
	  var res = prefix(prop);
	  propCache[prop] = propCache[res] = res;
	  return res;
	}

	/**
	 * Auto detect the appropriate prefix for a CSS property.
	 * https://gist.github.com/paulirish/523692
	 *
	 * @param {String} prop
	 * @return {String}
	 */

	function prefix(prop) {
	  prop = hyphenate(prop);
	  var camel = camelize(prop);
	  var upper = camel.charAt(0).toUpperCase() + camel.slice(1);
	  if (!testEl) {
	    testEl = document.createElement('div');
	  }
	  var i = prefixes.length;
	  var prefixed;
	  while (i--) {
	    prefixed = camelPrefixes[i] + upper;
	    if (prefixed in testEl.style) {
	      return {
	        kebab: prefixes[i] + prop,
	        camel: prefixed
	      };
	    }
	  }
	  if (camel in testEl.style) {
	    return {
	      kebab: prop,
	      camel: camel
	    };
	  }
	}

	// xlink
	var xlinkNS = 'http://www.w3.org/1999/xlink';
	var xlinkRE = /^xlink:/;

	// check for attributes that prohibit interpolations
	var disallowedInterpAttrRE = /^v-|^:|^@|^(?:is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/;
	// these attributes should also set their corresponding properties
	// because they only affect the initial state of the element
	var attrWithPropsRE = /^(?:value|checked|selected|muted)$/;
	// these attributes expect enumrated values of "true" or "false"
	// but are not boolean attributes
	var enumeratedAttrRE = /^(?:draggable|contenteditable|spellcheck)$/;

	// these attributes should set a hidden property for
	// binding v-model to object values
	var modelProps = {
	  value: '_value',
	  'true-value': '_trueValue',
	  'false-value': '_falseValue'
	};

	var bind$1 = {

	  priority: BIND,

	  bind: function bind() {
	    var attr = this.arg;
	    var tag = this.el.tagName;
	    // should be deep watch on object mode
	    if (!attr) {
	      this.deep = true;
	    }
	    // handle interpolation bindings
	    var descriptor = this.descriptor;
	    var tokens = descriptor.interp;
	    if (tokens) {
	      // handle interpolations with one-time tokens
	      if (descriptor.hasOneTime) {
	        this.expression = tokensToExp(tokens, this._scope || this.vm);
	      }

	      // only allow binding on native attributes
	      if (disallowedInterpAttrRE.test(attr) || attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT')) {
	        process.env.NODE_ENV !== 'production' && warn(attr + '="' + descriptor.raw + '": ' + 'attribute interpolation is not allowed in Vue.js ' + 'directives and special attributes.', this.vm);
	        this.el.removeAttribute(attr);
	        this.invalid = true;
	      }

	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production') {
	        var raw = attr + '="' + descriptor.raw + '": ';
	        // warn src
	        if (attr === 'src') {
	          warn(raw + 'interpolation in "src" attribute will cause ' + 'a 404 request. Use v-bind:src instead.', this.vm);
	        }

	        // warn style
	        if (attr === 'style') {
	          warn(raw + 'interpolation in "style" attribute will cause ' + 'the attribute to be discarded in Internet Explorer. ' + 'Use v-bind:style instead.', this.vm);
	        }
	      }
	    }
	  },

	  update: function update(value) {
	    if (this.invalid) {
	      return;
	    }
	    var attr = this.arg;
	    if (this.arg) {
	      this.handleSingle(attr, value);
	    } else {
	      this.handleObject(value || {});
	    }
	  },

	  // share object handler with v-bind:class
	  handleObject: style.handleObject,

	  handleSingle: function handleSingle(attr, value) {
	    var el = this.el;
	    var interp = this.descriptor.interp;
	    if (this.modifiers.camel) {
	      attr = camelize(attr);
	    }
	    if (!interp && attrWithPropsRE.test(attr) && attr in el) {
	      el[attr] = attr === 'value' ? value == null // IE9 will set input.value to "null" for null...
	      ? '' : value : value;
	    }
	    // set model props
	    var modelProp = modelProps[attr];
	    if (!interp && modelProp) {
	      el[modelProp] = value;
	      // update v-model if present
	      var model = el.__v_model;
	      if (model) {
	        model.listener();
	      }
	    }
	    // do not set value attribute for textarea
	    if (attr === 'value' && el.tagName === 'TEXTAREA') {
	      el.removeAttribute(attr);
	      return;
	    }
	    // update attribute
	    if (enumeratedAttrRE.test(attr)) {
	      el.setAttribute(attr, value ? 'true' : 'false');
	    } else if (value != null && value !== false) {
	      if (attr === 'class') {
	        // handle edge case #1960:
	        // class interpolation should not overwrite Vue transition class
	        if (el.__v_trans) {
	          value += ' ' + el.__v_trans.id + '-transition';
	        }
	        setClass(el, value);
	      } else if (xlinkRE.test(attr)) {
	        el.setAttributeNS(xlinkNS, attr, value === true ? '' : value);
	      } else {
	        el.setAttribute(attr, value === true ? '' : value);
	      }
	    } else {
	      el.removeAttribute(attr);
	    }
	  }
	};

	var el = {

	  priority: EL,

	  bind: function bind() {
	    /* istanbul ignore if */
	    if (!this.arg) {
	      return;
	    }
	    var id = this.id = camelize(this.arg);
	    var refs = (this._scope || this.vm).$els;
	    if (hasOwn(refs, id)) {
	      refs[id] = this.el;
	    } else {
	      defineReactive(refs, id, this.el);
	    }
	  },

	  unbind: function unbind() {
	    var refs = (this._scope || this.vm).$els;
	    if (refs[this.id] === this.el) {
	      refs[this.id] = null;
	    }
	  }
	};

	var ref = {
	  bind: function bind() {
	    process.env.NODE_ENV !== 'production' && warn('v-ref:' + this.arg + ' must be used on a child ' + 'component. Found on <' + this.el.tagName.toLowerCase() + '>.', this.vm);
	  }
	};

	var cloak = {
	  bind: function bind() {
	    var el = this.el;
	    this.vm.$once('pre-hook:compiled', function () {
	      el.removeAttribute('v-cloak');
	    });
	  }
	};

	// must export plain object
	var directives = {
	  text: text$1,
	  html: html,
	  'for': vFor,
	  'if': vIf,
	  show: show,
	  model: model,
	  on: on$1,
	  bind: bind$1,
	  el: el,
	  ref: ref,
	  cloak: cloak
	};

	var vClass = {

	  deep: true,

	  update: function update(value) {
	    if (value && typeof value === 'string') {
	      this.handleObject(stringToObject(value));
	    } else if (isPlainObject(value)) {
	      this.handleObject(value);
	    } else if (isArray(value)) {
	      this.handleArray(value);
	    } else {
	      this.cleanup();
	    }
	  },

	  handleObject: function handleObject(value) {
	    this.cleanup(value);
	    this.prevKeys = Object.keys(value);
	    setObjectClasses(this.el, value);
	  },

	  handleArray: function handleArray(value) {
	    this.cleanup(value);
	    for (var i = 0, l = value.length; i < l; i++) {
	      var val = value[i];
	      if (val && isPlainObject(val)) {
	        setObjectClasses(this.el, val);
	      } else if (val && typeof val === 'string') {
	        addClass(this.el, val);
	      }
	    }
	    this.prevKeys = value.slice();
	  },

	  cleanup: function cleanup(value) {
	    if (!this.prevKeys) return;

	    var i = this.prevKeys.length;
	    while (i--) {
	      var key = this.prevKeys[i];
	      if (!key) continue;

	      var keys = isPlainObject(key) ? Object.keys(key) : [key];
	      for (var j = 0, l = keys.length; j < l; j++) {
	        toggleClasses(this.el, keys[j], removeClass);
	      }
	    }
	  }
	};

	function setObjectClasses(el, obj) {
	  var keys = Object.keys(obj);
	  for (var i = 0, l = keys.length; i < l; i++) {
	    var key = keys[i];
	    if (!obj[key]) continue;
	    toggleClasses(el, key, addClass);
	  }
	}

	function stringToObject(value) {
	  var res = {};
	  var keys = value.trim().split(/\s+/);
	  for (var i = 0, l = keys.length; i < l; i++) {
	    res[keys[i]] = true;
	  }
	  return res;
	}

	/**
	 * Add or remove a class/classes on an element
	 *
	 * @param {Element} el
	 * @param {String} key The class name. This may or may not
	 *                     contain a space character, in such a
	 *                     case we'll deal with multiple class
	 *                     names at once.
	 * @param {Function} fn
	 */

	function toggleClasses(el, key, fn) {
	  key = key.trim();

	  if (key.indexOf(' ') === -1) {
	    fn(el, key);
	    return;
	  }

	  // The key contains one or more space characters.
	  // Since a class name doesn't accept such characters, we
	  // treat it as multiple classes.
	  var keys = key.split(/\s+/);
	  for (var i = 0, l = keys.length; i < l; i++) {
	    fn(el, keys[i]);
	  }
	}

	var component = {

	  priority: COMPONENT,

	  params: ['keep-alive', 'transition-mode', 'inline-template'],

	  /**
	   * Setup. Two possible usages:
	   *
	   * - static:
	   *   <comp> or <div v-component="comp">
	   *
	   * - dynamic:
	   *   <component :is="view">
	   */

	  bind: function bind() {
	    if (!this.el.__vue__) {
	      // keep-alive cache
	      this.keepAlive = this.params.keepAlive;
	      if (this.keepAlive) {
	        this.cache = {};
	      }
	      // check inline-template
	      if (this.params.inlineTemplate) {
	        // extract inline template as a DocumentFragment
	        this.inlineTemplate = extractContent(this.el, true);
	      }
	      // component resolution related state
	      this.pendingComponentCb = this.Component = null;
	      // transition related state
	      this.pendingRemovals = 0;
	      this.pendingRemovalCb = null;
	      // create a ref anchor
	      this.anchor = createAnchor('v-component');
	      replace(this.el, this.anchor);
	      // remove is attribute.
	      // this is removed during compilation, but because compilation is
	      // cached, when the component is used elsewhere this attribute
	      // will remain at link time.
	      this.el.removeAttribute('is');
	      // remove ref, same as above
	      if (this.descriptor.ref) {
	        this.el.removeAttribute('v-ref:' + hyphenate(this.descriptor.ref));
	      }
	      // if static, build right now.
	      if (this.literal) {
	        this.setComponent(this.expression);
	      }
	    } else {
	      process.env.NODE_ENV !== 'production' && warn('cannot mount component "' + this.expression + '" ' + 'on already mounted element: ' + this.el);
	    }
	  },

	  /**
	   * Public update, called by the watcher in the dynamic
	   * literal scenario, e.g. <component :is="view">
	   */

	  update: function update(value) {
	    if (!this.literal) {
	      this.setComponent(value);
	    }
	  },

	  /**
	   * Switch dynamic components. May resolve the component
	   * asynchronously, and perform transition based on
	   * specified transition mode. Accepts a few additional
	   * arguments specifically for vue-router.
	   *
	   * The callback is called when the full transition is
	   * finished.
	   *
	   * @param {String} value
	   * @param {Function} [cb]
	   */

	  setComponent: function setComponent(value, cb) {
	    this.invalidatePending();
	    if (!value) {
	      // just remove current
	      this.unbuild(true);
	      this.remove(this.childVM, cb);
	      this.childVM = null;
	    } else {
	      var self = this;
	      this.resolveComponent(value, function () {
	        self.mountComponent(cb);
	      });
	    }
	  },

	  /**
	   * Resolve the component constructor to use when creating
	   * the child vm.
	   *
	   * @param {String|Function} value
	   * @param {Function} cb
	   */

	  resolveComponent: function resolveComponent(value, cb) {
	    var self = this;
	    this.pendingComponentCb = cancellable(function (Component) {
	      self.ComponentName = Component.options.name || (typeof value === 'string' ? value : null);
	      self.Component = Component;
	      cb();
	    });
	    this.vm._resolveComponent(value, this.pendingComponentCb);
	  },

	  /**
	   * Create a new instance using the current constructor and
	   * replace the existing instance. This method doesn't care
	   * whether the new component and the old one are actually
	   * the same.
	   *
	   * @param {Function} [cb]
	   */

	  mountComponent: function mountComponent(cb) {
	    // actual mount
	    this.unbuild(true);
	    var self = this;
	    var activateHooks = this.Component.options.activate;
	    var cached = this.getCached();
	    var newComponent = this.build();
	    if (activateHooks && !cached) {
	      this.waitingFor = newComponent;
	      callActivateHooks(activateHooks, newComponent, function () {
	        if (self.waitingFor !== newComponent) {
	          return;
	        }
	        self.waitingFor = null;
	        self.transition(newComponent, cb);
	      });
	    } else {
	      // update ref for kept-alive component
	      if (cached) {
	        newComponent._updateRef();
	      }
	      this.transition(newComponent, cb);
	    }
	  },

	  /**
	   * When the component changes or unbinds before an async
	   * constructor is resolved, we need to invalidate its
	   * pending callback.
	   */

	  invalidatePending: function invalidatePending() {
	    if (this.pendingComponentCb) {
	      this.pendingComponentCb.cancel();
	      this.pendingComponentCb = null;
	    }
	  },

	  /**
	   * Instantiate/insert a new child vm.
	   * If keep alive and has cached instance, insert that
	   * instance; otherwise build a new one and cache it.
	   *
	   * @param {Object} [extraOptions]
	   * @return {Vue} - the created instance
	   */

	  build: function build(extraOptions) {
	    var cached = this.getCached();
	    if (cached) {
	      return cached;
	    }
	    if (this.Component) {
	      // default options
	      var options = {
	        name: this.ComponentName,
	        el: cloneNode(this.el),
	        template: this.inlineTemplate,
	        // make sure to add the child with correct parent
	        // if this is a transcluded component, its parent
	        // should be the transclusion host.
	        parent: this._host || this.vm,
	        // if no inline-template, then the compiled
	        // linker can be cached for better performance.
	        _linkerCachable: !this.inlineTemplate,
	        _ref: this.descriptor.ref,
	        _asComponent: true,
	        _isRouterView: this._isRouterView,
	        // if this is a transcluded component, context
	        // will be the common parent vm of this instance
	        // and its host.
	        _context: this.vm,
	        // if this is inside an inline v-for, the scope
	        // will be the intermediate scope created for this
	        // repeat fragment. this is used for linking props
	        // and container directives.
	        _scope: this._scope,
	        // pass in the owner fragment of this component.
	        // this is necessary so that the fragment can keep
	        // track of its contained components in order to
	        // call attach/detach hooks for them.
	        _frag: this._frag
	      };
	      // extra options
	      // in 1.0.0 this is used by vue-router only
	      /* istanbul ignore if */
	      if (extraOptions) {
	        extend(options, extraOptions);
	      }
	      var child = new this.Component(options);
	      if (this.keepAlive) {
	        this.cache[this.Component.cid] = child;
	      }
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production' && this.el.hasAttribute('transition') && child._isFragment) {
	        warn('Transitions will not work on a fragment instance. ' + 'Template: ' + child.$options.template, child);
	      }
	      return child;
	    }
	  },

	  /**
	   * Try to get a cached instance of the current component.
	   *
	   * @return {Vue|undefined}
	   */

	  getCached: function getCached() {
	    return this.keepAlive && this.cache[this.Component.cid];
	  },

	  /**
	   * Teardown the current child, but defers cleanup so
	   * that we can separate the destroy and removal steps.
	   *
	   * @param {Boolean} defer
	   */

	  unbuild: function unbuild(defer) {
	    if (this.waitingFor) {
	      if (!this.keepAlive) {
	        this.waitingFor.$destroy();
	      }
	      this.waitingFor = null;
	    }
	    var child = this.childVM;
	    if (!child || this.keepAlive) {
	      if (child) {
	        // remove ref
	        child._inactive = true;
	        child._updateRef(true);
	      }
	      return;
	    }
	    // the sole purpose of `deferCleanup` is so that we can
	    // "deactivate" the vm right now and perform DOM removal
	    // later.
	    child.$destroy(false, defer);
	  },

	  /**
	   * Remove current destroyed child and manually do
	   * the cleanup after removal.
	   *
	   * @param {Function} cb
	   */

	  remove: function remove(child, cb) {
	    var keepAlive = this.keepAlive;
	    if (child) {
	      // we may have a component switch when a previous
	      // component is still being transitioned out.
	      // we want to trigger only one lastest insertion cb
	      // when the existing transition finishes. (#1119)
	      this.pendingRemovals++;
	      this.pendingRemovalCb = cb;
	      var self = this;
	      child.$remove(function () {
	        self.pendingRemovals--;
	        if (!keepAlive) child._cleanup();
	        if (!self.pendingRemovals && self.pendingRemovalCb) {
	          self.pendingRemovalCb();
	          self.pendingRemovalCb = null;
	        }
	      });
	    } else if (cb) {
	      cb();
	    }
	  },

	  /**
	   * Actually swap the components, depending on the
	   * transition mode. Defaults to simultaneous.
	   *
	   * @param {Vue} target
	   * @param {Function} [cb]
	   */

	  transition: function transition(target, cb) {
	    var self = this;
	    var current = this.childVM;
	    // for devtool inspection
	    if (current) current._inactive = true;
	    target._inactive = false;
	    this.childVM = target;
	    switch (self.params.transitionMode) {
	      case 'in-out':
	        target.$before(self.anchor, function () {
	          self.remove(current, cb);
	        });
	        break;
	      case 'out-in':
	        self.remove(current, function () {
	          target.$before(self.anchor, cb);
	        });
	        break;
	      default:
	        self.remove(current);
	        target.$before(self.anchor, cb);
	    }
	  },

	  /**
	   * Unbind.
	   */

	  unbind: function unbind() {
	    this.invalidatePending();
	    // Do not defer cleanup when unbinding
	    this.unbuild();
	    // destroy all keep-alive cached instances
	    if (this.cache) {
	      for (var key in this.cache) {
	        this.cache[key].$destroy();
	      }
	      this.cache = null;
	    }
	  }
	};

	/**
	 * Call activate hooks in order (asynchronous)
	 *
	 * @param {Array} hooks
	 * @param {Vue} vm
	 * @param {Function} cb
	 */

	function callActivateHooks(hooks, vm, cb) {
	  var total = hooks.length;
	  var called = 0;
	  hooks[0].call(vm, next);
	  function next() {
	    if (++called >= total) {
	      cb();
	    } else {
	      hooks[called].call(vm, next);
	    }
	  }
	}

	var propBindingModes = config._propBindingModes;
	var empty = {};

	// regexes
	var identRE$1 = /^[$_a-zA-Z]+[\w$]*$/;
	var settablePathRE = /^[A-Za-z_$][\w$]*(\.[A-Za-z_$][\w$]*|\[[^\[\]]+\])*$/;

	/**
	 * Compile props on a root element and return
	 * a props link function.
	 *
	 * @param {Element|DocumentFragment} el
	 * @param {Array} propOptions
	 * @param {Vue} vm
	 * @return {Function} propsLinkFn
	 */

	function compileProps(el, propOptions, vm) {
	  var props = [];
	  var names = Object.keys(propOptions);
	  var i = names.length;
	  var options, name, attr, value, path, parsed, prop;
	  while (i--) {
	    name = names[i];
	    options = propOptions[name] || empty;

	    if (process.env.NODE_ENV !== 'production' && name === '$data') {
	      warn('Do not use $data as prop.', vm);
	      continue;
	    }

	    // props could contain dashes, which will be
	    // interpreted as minus calculations by the parser
	    // so we need to camelize the path here
	    path = camelize(name);
	    if (!identRE$1.test(path)) {
	      process.env.NODE_ENV !== 'production' && warn('Invalid prop key: "' + name + '". Prop keys ' + 'must be valid identifiers.', vm);
	      continue;
	    }

	    prop = {
	      name: name,
	      path: path,
	      options: options,
	      mode: propBindingModes.ONE_WAY,
	      raw: null
	    };

	    attr = hyphenate(name);
	    // first check dynamic version
	    if ((value = getBindAttr(el, attr)) === null) {
	      if ((value = getBindAttr(el, attr + '.sync')) !== null) {
	        prop.mode = propBindingModes.TWO_WAY;
	      } else if ((value = getBindAttr(el, attr + '.once')) !== null) {
	        prop.mode = propBindingModes.ONE_TIME;
	      }
	    }
	    if (value !== null) {
	      // has dynamic binding!
	      prop.raw = value;
	      parsed = parseDirective(value);
	      value = parsed.expression;
	      prop.filters = parsed.filters;
	      // check binding type
	      if (isLiteral(value) && !parsed.filters) {
	        // for expressions containing literal numbers and
	        // booleans, there's no need to setup a prop binding,
	        // so we can optimize them as a one-time set.
	        prop.optimizedLiteral = true;
	      } else {
	        prop.dynamic = true;
	        // check non-settable path for two-way bindings
	        if (process.env.NODE_ENV !== 'production' && prop.mode === propBindingModes.TWO_WAY && !settablePathRE.test(value)) {
	          prop.mode = propBindingModes.ONE_WAY;
	          warn('Cannot bind two-way prop with non-settable ' + 'parent path: ' + value, vm);
	        }
	      }
	      prop.parentPath = value;

	      // warn required two-way
	      if (process.env.NODE_ENV !== 'production' && options.twoWay && prop.mode !== propBindingModes.TWO_WAY) {
	        warn('Prop "' + name + '" expects a two-way binding type.', vm);
	      }
	    } else if ((value = getAttr(el, attr)) !== null) {
	      // has literal binding!
	      prop.raw = value;
	    } else if (process.env.NODE_ENV !== 'production') {
	      // check possible camelCase prop usage
	      var lowerCaseName = path.toLowerCase();
	      value = /[A-Z\-]/.test(name) && (el.getAttribute(lowerCaseName) || el.getAttribute(':' + lowerCaseName) || el.getAttribute('v-bind:' + lowerCaseName) || el.getAttribute(':' + lowerCaseName + '.once') || el.getAttribute('v-bind:' + lowerCaseName + '.once') || el.getAttribute(':' + lowerCaseName + '.sync') || el.getAttribute('v-bind:' + lowerCaseName + '.sync'));
	      if (value) {
	        warn('Possible usage error for prop `' + lowerCaseName + '` - ' + 'did you mean `' + attr + '`? HTML is case-insensitive, remember to use ' + 'kebab-case for props in templates.', vm);
	      } else if (options.required) {
	        // warn missing required
	        warn('Missing required prop: ' + name, vm);
	      }
	    }
	    // push prop
	    props.push(prop);
	  }
	  return makePropsLinkFn(props);
	}

	/**
	 * Build a function that applies props to a vm.
	 *
	 * @param {Array} props
	 * @return {Function} propsLinkFn
	 */

	function makePropsLinkFn(props) {
	  return function propsLinkFn(vm, scope) {
	    // store resolved props info
	    vm._props = {};
	    var i = props.length;
	    var prop, path, options, value, raw;
	    while (i--) {
	      prop = props[i];
	      raw = prop.raw;
	      path = prop.path;
	      options = prop.options;
	      vm._props[path] = prop;
	      if (raw === null) {
	        // initialize absent prop
	        initProp(vm, prop, undefined);
	      } else if (prop.dynamic) {
	        // dynamic prop
	        if (prop.mode === propBindingModes.ONE_TIME) {
	          // one time binding
	          value = (scope || vm._context || vm).$get(prop.parentPath);
	          initProp(vm, prop, value);
	        } else {
	          if (vm._context) {
	            // dynamic binding
	            vm._bindDir({
	              name: 'prop',
	              def: propDef,
	              prop: prop
	            }, null, null, scope); // el, host, scope
	          } else {
	              // root instance
	              initProp(vm, prop, vm.$get(prop.parentPath));
	            }
	        }
	      } else if (prop.optimizedLiteral) {
	        // optimized literal, cast it and just set once
	        var stripped = stripQuotes(raw);
	        value = stripped === raw ? toBoolean(toNumber(raw)) : stripped;
	        initProp(vm, prop, value);
	      } else {
	        // string literal, but we need to cater for
	        // Boolean props with no value, or with same
	        // literal value (e.g. disabled="disabled")
	        // see https://github.com/vuejs/vue-loader/issues/182
	        value = options.type === Boolean && (raw === '' || raw === hyphenate(prop.name)) ? true : raw;
	        initProp(vm, prop, value);
	      }
	    }
	  };
	}

	/**
	 * Process a prop with a rawValue, applying necessary coersions,
	 * default values & assertions and call the given callback with
	 * processed value.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @param {*} rawValue
	 * @param {Function} fn
	 */

	function processPropValue(vm, prop, rawValue, fn) {
	  var isSimple = prop.dynamic && isSimplePath(prop.parentPath);
	  var value = rawValue;
	  if (value === undefined) {
	    value = getPropDefaultValue(vm, prop);
	  }
	  value = coerceProp(prop, value);
	  var coerced = value !== rawValue;
	  if (!assertProp(prop, value, vm)) {
	    value = undefined;
	  }
	  if (isSimple && !coerced) {
	    withoutConversion(function () {
	      fn(value);
	    });
	  } else {
	    fn(value);
	  }
	}

	/**
	 * Set a prop's initial value on a vm and its data object.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @param {*} value
	 */

	function initProp(vm, prop, value) {
	  processPropValue(vm, prop, value, function (value) {
	    defineReactive(vm, prop.path, value);
	  });
	}

	/**
	 * Update a prop's value on a vm.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @param {*} value
	 */

	function updateProp(vm, prop, value) {
	  processPropValue(vm, prop, value, function (value) {
	    vm[prop.path] = value;
	  });
	}

	/**
	 * Get the default value of a prop.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @return {*}
	 */

	function getPropDefaultValue(vm, prop) {
	  // no default, return undefined
	  var options = prop.options;
	  if (!hasOwn(options, 'default')) {
	    // absent boolean value defaults to false
	    return options.type === Boolean ? false : undefined;
	  }
	  var def = options['default'];
	  // warn against non-factory defaults for Object & Array
	  if (isObject(def)) {
	    process.env.NODE_ENV !== 'production' && warn('Invalid default value for prop "' + prop.name + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
	  }
	  // call factory function for non-Function types
	  return typeof def === 'function' && options.type !== Function ? def.call(vm) : def;
	}

	/**
	 * Assert whether a prop is valid.
	 *
	 * @param {Object} prop
	 * @param {*} value
	 * @param {Vue} vm
	 */

	function assertProp(prop, value, vm) {
	  if (!prop.options.required && ( // non-required
	  prop.raw === null || // abscent
	  value == null) // null or undefined
	  ) {
	      return true;
	    }
	  var options = prop.options;
	  var type = options.type;
	  var valid = !type;
	  var expectedTypes = [];
	  if (type) {
	    if (!isArray(type)) {
	      type = [type];
	    }
	    for (var i = 0; i < type.length && !valid; i++) {
	      var assertedType = assertType(value, type[i]);
	      expectedTypes.push(assertedType.expectedType);
	      valid = assertedType.valid;
	    }
	  }
	  if (!valid) {
	    if (process.env.NODE_ENV !== 'production') {
	      warn('Invalid prop: type check failed for prop "' + prop.name + '".' + ' Expected ' + expectedTypes.map(formatType).join(', ') + ', got ' + formatValue(value) + '.', vm);
	    }
	    return false;
	  }
	  var validator = options.validator;
	  if (validator) {
	    if (!validator(value)) {
	      process.env.NODE_ENV !== 'production' && warn('Invalid prop: custom validator check failed for prop "' + prop.name + '".', vm);
	      return false;
	    }
	  }
	  return true;
	}

	/**
	 * Force parsing value with coerce option.
	 *
	 * @param {*} value
	 * @param {Object} options
	 * @return {*}
	 */

	function coerceProp(prop, value) {
	  var coerce = prop.options.coerce;
	  if (!coerce) {
	    return value;
	  }
	  // coerce is a function
	  return coerce(value);
	}

	/**
	 * Assert the type of a value
	 *
	 * @param {*} value
	 * @param {Function} type
	 * @return {Object}
	 */

	function assertType(value, type) {
	  var valid;
	  var expectedType;
	  if (type === String) {
	    expectedType = 'string';
	    valid = typeof value === expectedType;
	  } else if (type === Number) {
	    expectedType = 'number';
	    valid = typeof value === expectedType;
	  } else if (type === Boolean) {
	    expectedType = 'boolean';
	    valid = typeof value === expectedType;
	  } else if (type === Function) {
	    expectedType = 'function';
	    valid = typeof value === expectedType;
	  } else if (type === Object) {
	    expectedType = 'object';
	    valid = isPlainObject(value);
	  } else if (type === Array) {
	    expectedType = 'array';
	    valid = isArray(value);
	  } else {
	    valid = value instanceof type;
	  }
	  return {
	    valid: valid,
	    expectedType: expectedType
	  };
	}

	/**
	 * Format type for output
	 *
	 * @param {String} type
	 * @return {String}
	 */

	function formatType(type) {
	  return type ? type.charAt(0).toUpperCase() + type.slice(1) : 'custom type';
	}

	/**
	 * Format value
	 *
	 * @param {*} value
	 * @return {String}
	 */

	function formatValue(val) {
	  return Object.prototype.toString.call(val).slice(8, -1);
	}

	var bindingModes = config._propBindingModes;

	var propDef = {

	  bind: function bind() {
	    var child = this.vm;
	    var parent = child._context;
	    // passed in from compiler directly
	    var prop = this.descriptor.prop;
	    var childKey = prop.path;
	    var parentKey = prop.parentPath;
	    var twoWay = prop.mode === bindingModes.TWO_WAY;

	    var parentWatcher = this.parentWatcher = new Watcher(parent, parentKey, function (val) {
	      updateProp(child, prop, val);
	    }, {
	      twoWay: twoWay,
	      filters: prop.filters,
	      // important: props need to be observed on the
	      // v-for scope if present
	      scope: this._scope
	    });

	    // set the child initial value.
	    initProp(child, prop, parentWatcher.value);

	    // setup two-way binding
	    if (twoWay) {
	      // important: defer the child watcher creation until
	      // the created hook (after data observation)
	      var self = this;
	      child.$once('pre-hook:created', function () {
	        self.childWatcher = new Watcher(child, childKey, function (val) {
	          parentWatcher.set(val);
	        }, {
	          // ensure sync upward before parent sync down.
	          // this is necessary in cases e.g. the child
	          // mutates a prop array, then replaces it. (#1683)
	          sync: true
	        });
	      });
	    }
	  },

	  unbind: function unbind() {
	    this.parentWatcher.teardown();
	    if (this.childWatcher) {
	      this.childWatcher.teardown();
	    }
	  }
	};

	var queue$1 = [];
	var queued = false;

	/**
	 * Push a job into the queue.
	 *
	 * @param {Function} job
	 */

	function pushJob(job) {
	  queue$1.push(job);
	  if (!queued) {
	    queued = true;
	    nextTick(flush);
	  }
	}

	/**
	 * Flush the queue, and do one forced reflow before
	 * triggering transitions.
	 */

	function flush() {
	  // Force layout
	  var f = document.documentElement.offsetHeight;
	  for (var i = 0; i < queue$1.length; i++) {
	    queue$1[i]();
	  }
	  queue$1 = [];
	  queued = false;
	  // dummy return, so js linters don't complain about
	  // unused variable f
	  return f;
	}

	var TYPE_TRANSITION = 'transition';
	var TYPE_ANIMATION = 'animation';
	var transDurationProp = transitionProp + 'Duration';
	var animDurationProp = animationProp + 'Duration';

	/**
	 * If a just-entered element is applied the
	 * leave class while its enter transition hasn't started yet,
	 * and the transitioned property has the same value for both
	 * enter/leave, then the leave transition will be skipped and
	 * the transitionend event never fires. This function ensures
	 * its callback to be called after a transition has started
	 * by waiting for double raf.
	 *
	 * It falls back to setTimeout on devices that support CSS
	 * transitions but not raf (e.g. Android 4.2 browser) - since
	 * these environments are usually slow, we are giving it a
	 * relatively large timeout.
	 */

	var raf = inBrowser && window.requestAnimationFrame;
	var waitForTransitionStart = raf
	/* istanbul ignore next */
	? function (fn) {
	  raf(function () {
	    raf(fn);
	  });
	} : function (fn) {
	  setTimeout(fn, 50);
	};

	/**
	 * A Transition object that encapsulates the state and logic
	 * of the transition.
	 *
	 * @param {Element} el
	 * @param {String} id
	 * @param {Object} hooks
	 * @param {Vue} vm
	 */
	function Transition(el, id, hooks, vm) {
	  this.id = id;
	  this.el = el;
	  this.enterClass = hooks && hooks.enterClass || id + '-enter';
	  this.leaveClass = hooks && hooks.leaveClass || id + '-leave';
	  this.hooks = hooks;
	  this.vm = vm;
	  // async state
	  this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null;
	  this.justEntered = false;
	  this.entered = this.left = false;
	  this.typeCache = {};
	  // check css transition type
	  this.type = hooks && hooks.type;
	  /* istanbul ignore if */
	  if (process.env.NODE_ENV !== 'production') {
	    if (this.type && this.type !== TYPE_TRANSITION && this.type !== TYPE_ANIMATION) {
	      warn('invalid CSS transition type for transition="' + this.id + '": ' + this.type, vm);
	    }
	  }
	  // bind
	  var self = this;['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone'].forEach(function (m) {
	    self[m] = bind(self[m], self);
	  });
	}

	var p$1 = Transition.prototype;

	/**
	 * Start an entering transition.
	 *
	 * 1. enter transition triggered
	 * 2. call beforeEnter hook
	 * 3. add enter class
	 * 4. insert/show element
	 * 5. call enter hook (with possible explicit js callback)
	 * 6. reflow
	 * 7. based on transition type:
	 *    - transition:
	 *        remove class now, wait for transitionend,
	 *        then done if there's no explicit js callback.
	 *    - animation:
	 *        wait for animationend, remove class,
	 *        then done if there's no explicit js callback.
	 *    - no css transition:
	 *        done now if there's no explicit js callback.
	 * 8. wait for either done or js callback, then call
	 *    afterEnter hook.
	 *
	 * @param {Function} op - insert/show the element
	 * @param {Function} [cb]
	 */

	p$1.enter = function (op, cb) {
	  this.cancelPending();
	  this.callHook('beforeEnter');
	  this.cb = cb;
	  addClass(this.el, this.enterClass);
	  op();
	  this.entered = false;
	  this.callHookWithCb('enter');
	  if (this.entered) {
	    return; // user called done synchronously.
	  }
	  this.cancel = this.hooks && this.hooks.enterCancelled;
	  pushJob(this.enterNextTick);
	};

	/**
	 * The "nextTick" phase of an entering transition, which is
	 * to be pushed into a queue and executed after a reflow so
	 * that removing the class can trigger a CSS transition.
	 */

	p$1.enterNextTick = function () {
	  var _this = this;

	  // prevent transition skipping
	  this.justEntered = true;
	  waitForTransitionStart(function () {
	    _this.justEntered = false;
	  });
	  var enterDone = this.enterDone;
	  var type = this.getCssTransitionType(this.enterClass);
	  if (!this.pendingJsCb) {
	    if (type === TYPE_TRANSITION) {
	      // trigger transition by removing enter class now
	      removeClass(this.el, this.enterClass);
	      this.setupCssCb(transitionEndEvent, enterDone);
	    } else if (type === TYPE_ANIMATION) {
	      this.setupCssCb(animationEndEvent, enterDone);
	    } else {
	      enterDone();
	    }
	  } else if (type === TYPE_TRANSITION) {
	    removeClass(this.el, this.enterClass);
	  }
	};

	/**
	 * The "cleanup" phase of an entering transition.
	 */

	p$1.enterDone = function () {
	  this.entered = true;
	  this.cancel = this.pendingJsCb = null;
	  removeClass(this.el, this.enterClass);
	  this.callHook('afterEnter');
	  if (this.cb) this.cb();
	};

	/**
	 * Start a leaving transition.
	 *
	 * 1. leave transition triggered.
	 * 2. call beforeLeave hook
	 * 3. add leave class (trigger css transition)
	 * 4. call leave hook (with possible explicit js callback)
	 * 5. reflow if no explicit js callback is provided
	 * 6. based on transition type:
	 *    - transition or animation:
	 *        wait for end event, remove class, then done if
	 *        there's no explicit js callback.
	 *    - no css transition:
	 *        done if there's no explicit js callback.
	 * 7. wait for either done or js callback, then call
	 *    afterLeave hook.
	 *
	 * @param {Function} op - remove/hide the element
	 * @param {Function} [cb]
	 */

	p$1.leave = function (op, cb) {
	  this.cancelPending();
	  this.callHook('beforeLeave');
	  this.op = op;
	  this.cb = cb;
	  addClass(this.el, this.leaveClass);
	  this.left = false;
	  this.callHookWithCb('leave');
	  if (this.left) {
	    return; // user called done synchronously.
	  }
	  this.cancel = this.hooks && this.hooks.leaveCancelled;
	  // only need to handle leaveDone if
	  // 1. the transition is already done (synchronously called
	  //    by the user, which causes this.op set to null)
	  // 2. there's no explicit js callback
	  if (this.op && !this.pendingJsCb) {
	    // if a CSS transition leaves immediately after enter,
	    // the transitionend event never fires. therefore we
	    // detect such cases and end the leave immediately.
	    if (this.justEntered) {
	      this.leaveDone();
	    } else {
	      pushJob(this.leaveNextTick);
	    }
	  }
	};

	/**
	 * The "nextTick" phase of a leaving transition.
	 */

	p$1.leaveNextTick = function () {
	  var type = this.getCssTransitionType(this.leaveClass);
	  if (type) {
	    var event = type === TYPE_TRANSITION ? transitionEndEvent : animationEndEvent;
	    this.setupCssCb(event, this.leaveDone);
	  } else {
	    this.leaveDone();
	  }
	};

	/**
	 * The "cleanup" phase of a leaving transition.
	 */

	p$1.leaveDone = function () {
	  this.left = true;
	  this.cancel = this.pendingJsCb = null;
	  this.op();
	  removeClass(this.el, this.leaveClass);
	  this.callHook('afterLeave');
	  if (this.cb) this.cb();
	  this.op = null;
	};

	/**
	 * Cancel any pending callbacks from a previously running
	 * but not finished transition.
	 */

	p$1.cancelPending = function () {
	  this.op = this.cb = null;
	  var hasPending = false;
	  if (this.pendingCssCb) {
	    hasPending = true;
	    off(this.el, this.pendingCssEvent, this.pendingCssCb);
	    this.pendingCssEvent = this.pendingCssCb = null;
	  }
	  if (this.pendingJsCb) {
	    hasPending = true;
	    this.pendingJsCb.cancel();
	    this.pendingJsCb = null;
	  }
	  if (hasPending) {
	    removeClass(this.el, this.enterClass);
	    removeClass(this.el, this.leaveClass);
	  }
	  if (this.cancel) {
	    this.cancel.call(this.vm, this.el);
	    this.cancel = null;
	  }
	};

	/**
	 * Call a user-provided synchronous hook function.
	 *
	 * @param {String} type
	 */

	p$1.callHook = function (type) {
	  if (this.hooks && this.hooks[type]) {
	    this.hooks[type].call(this.vm, this.el);
	  }
	};

	/**
	 * Call a user-provided, potentially-async hook function.
	 * We check for the length of arguments to see if the hook
	 * expects a `done` callback. If true, the transition's end
	 * will be determined by when the user calls that callback;
	 * otherwise, the end is determined by the CSS transition or
	 * animation.
	 *
	 * @param {String} type
	 */

	p$1.callHookWithCb = function (type) {
	  var hook = this.hooks && this.hooks[type];
	  if (hook) {
	    if (hook.length > 1) {
	      this.pendingJsCb = cancellable(this[type + 'Done']);
	    }
	    hook.call(this.vm, this.el, this.pendingJsCb);
	  }
	};

	/**
	 * Get an element's transition type based on the
	 * calculated styles.
	 *
	 * @param {String} className
	 * @return {Number}
	 */

	p$1.getCssTransitionType = function (className) {
	  /* istanbul ignore if */
	  if (!transitionEndEvent ||
	  // skip CSS transitions if page is not visible -
	  // this solves the issue of transitionend events not
	  // firing until the page is visible again.
	  // pageVisibility API is supported in IE10+, same as
	  // CSS transitions.
	  document.hidden ||
	  // explicit js-only transition
	  this.hooks && this.hooks.css === false ||
	  // element is hidden
	  isHidden(this.el)) {
	    return;
	  }
	  var type = this.type || this.typeCache[className];
	  if (type) return type;
	  var inlineStyles = this.el.style;
	  var computedStyles = window.getComputedStyle(this.el);
	  var transDuration = inlineStyles[transDurationProp] || computedStyles[transDurationProp];
	  if (transDuration && transDuration !== '0s') {
	    type = TYPE_TRANSITION;
	  } else {
	    var animDuration = inlineStyles[animDurationProp] || computedStyles[animDurationProp];
	    if (animDuration && animDuration !== '0s') {
	      type = TYPE_ANIMATION;
	    }
	  }
	  if (type) {
	    this.typeCache[className] = type;
	  }
	  return type;
	};

	/**
	 * Setup a CSS transitionend/animationend callback.
	 *
	 * @param {String} event
	 * @param {Function} cb
	 */

	p$1.setupCssCb = function (event, cb) {
	  this.pendingCssEvent = event;
	  var self = this;
	  var el = this.el;
	  var onEnd = this.pendingCssCb = function (e) {
	    if (e.target === el) {
	      off(el, event, onEnd);
	      self.pendingCssEvent = self.pendingCssCb = null;
	      if (!self.pendingJsCb && cb) {
	        cb();
	      }
	    }
	  };
	  on(el, event, onEnd);
	};

	/**
	 * Check if an element is hidden - in that case we can just
	 * skip the transition alltogether.
	 *
	 * @param {Element} el
	 * @return {Boolean}
	 */

	function isHidden(el) {
	  if (/svg$/.test(el.namespaceURI)) {
	    // SVG elements do not have offset(Width|Height)
	    // so we need to check the client rect
	    var rect = el.getBoundingClientRect();
	    return !(rect.width || rect.height);
	  } else {
	    return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
	  }
	}

	var transition$1 = {

	  priority: TRANSITION,

	  update: function update(id, oldId) {
	    var el = this.el;
	    // resolve on owner vm
	    var hooks = resolveAsset(this.vm.$options, 'transitions', id);
	    id = id || 'v';
	    el.__v_trans = new Transition(el, id, hooks, this.vm);
	    if (oldId) {
	      removeClass(el, oldId + '-transition');
	    }
	    addClass(el, id + '-transition');
	  }
	};

	var internalDirectives = {
	  style: style,
	  'class': vClass,
	  component: component,
	  prop: propDef,
	  transition: transition$1
	};

	// special binding prefixes
	var bindRE = /^v-bind:|^:/;
	var onRE = /^v-on:|^@/;
	var dirAttrRE = /^v-([^:]+)(?:$|:(.*)$)/;
	var modifierRE = /\.[^\.]+/g;
	var transitionRE = /^(v-bind:|:)?transition$/;

	// default directive priority
	var DEFAULT_PRIORITY = 1000;
	var DEFAULT_TERMINAL_PRIORITY = 2000;

	/**
	 * Compile a template and return a reusable composite link
	 * function, which recursively contains more link functions
	 * inside. This top level compile function would normally
	 * be called on instance root nodes, but can also be used
	 * for partial compilation if the partial argument is true.
	 *
	 * The returned composite link function, when called, will
	 * return an unlink function that tearsdown all directives
	 * created during the linking phase.
	 *
	 * @param {Element|DocumentFragment} el
	 * @param {Object} options
	 * @param {Boolean} partial
	 * @return {Function}
	 */

	function compile(el, options, partial) {
	  // link function for the node itself.
	  var nodeLinkFn = partial || !options._asComponent ? compileNode(el, options) : null;
	  // link function for the childNodes
	  var childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && el.tagName !== 'SCRIPT' && el.hasChildNodes() ? compileNodeList(el.childNodes, options) : null;

	  /**
	   * A composite linker function to be called on a already
	   * compiled piece of DOM, which instantiates all directive
	   * instances.
	   *
	   * @param {Vue} vm
	   * @param {Element|DocumentFragment} el
	   * @param {Vue} [host] - host vm of transcluded content
	   * @param {Object} [scope] - v-for scope
	   * @param {Fragment} [frag] - link context fragment
	   * @return {Function|undefined}
	   */

	  return function compositeLinkFn(vm, el, host, scope, frag) {
	    // cache childNodes before linking parent, fix #657
	    var childNodes = toArray(el.childNodes);
	    // link
	    var dirs = linkAndCapture(function compositeLinkCapturer() {
	      if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag);
	      if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag);
	    }, vm);
	    return makeUnlinkFn(vm, dirs);
	  };
	}

	/**
	 * Apply a linker to a vm/element pair and capture the
	 * directives created during the process.
	 *
	 * @param {Function} linker
	 * @param {Vue} vm
	 */

	function linkAndCapture(linker, vm) {
	  /* istanbul ignore if */
	  if (process.env.NODE_ENV === 'production') {
	    // reset directives before every capture in production
	    // mode, so that when unlinking we don't need to splice
	    // them out (which turns out to be a perf hit).
	    // they are kept in development mode because they are
	    // useful for Vue's own tests.
	    vm._directives = [];
	  }
	  var originalDirCount = vm._directives.length;
	  linker();
	  var dirs = vm._directives.slice(originalDirCount);
	  dirs.sort(directiveComparator);
	  for (var i = 0, l = dirs.length; i < l; i++) {
	    dirs[i]._bind();
	  }
	  return dirs;
	}

	/**
	 * Directive priority sort comparator
	 *
	 * @param {Object} a
	 * @param {Object} b
	 */

	function directiveComparator(a, b) {
	  a = a.descriptor.def.priority || DEFAULT_PRIORITY;
	  b = b.descriptor.def.priority || DEFAULT_PRIORITY;
	  return a > b ? -1 : a === b ? 0 : 1;
	}

	/**
	 * Linker functions return an unlink function that
	 * tearsdown all directives instances generated during
	 * the process.
	 *
	 * We create unlink functions with only the necessary
	 * information to avoid retaining additional closures.
	 *
	 * @param {Vue} vm
	 * @param {Array} dirs
	 * @param {Vue} [context]
	 * @param {Array} [contextDirs]
	 * @return {Function}
	 */

	function makeUnlinkFn(vm, dirs, context, contextDirs) {
	  function unlink(destroying) {
	    teardownDirs(vm, dirs, destroying);
	    if (context && contextDirs) {
	      teardownDirs(context, contextDirs);
	    }
	  }
	  // expose linked directives
	  unlink.dirs = dirs;
	  return unlink;
	}

	/**
	 * Teardown partial linked directives.
	 *
	 * @param {Vue} vm
	 * @param {Array} dirs
	 * @param {Boolean} destroying
	 */

	function teardownDirs(vm, dirs, destroying) {
	  var i = dirs.length;
	  while (i--) {
	    dirs[i]._teardown();
	    if (process.env.NODE_ENV !== 'production' && !destroying) {
	      vm._directives.$remove(dirs[i]);
	    }
	  }
	}

	/**
	 * Compile link props on an instance.
	 *
	 * @param {Vue} vm
	 * @param {Element} el
	 * @param {Object} props
	 * @param {Object} [scope]
	 * @return {Function}
	 */

	function compileAndLinkProps(vm, el, props, scope) {
	  var propsLinkFn = compileProps(el, props, vm);
	  var propDirs = linkAndCapture(function () {
	    propsLinkFn(vm, scope);
	  }, vm);
	  return makeUnlinkFn(vm, propDirs);
	}

	/**
	 * Compile the root element of an instance.
	 *
	 * 1. attrs on context container (context scope)
	 * 2. attrs on the component template root node, if
	 *    replace:true (child scope)
	 *
	 * If this is a fragment instance, we only need to compile 1.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @param {Object} contextOptions
	 * @return {Function}
	 */

	function compileRoot(el, options, contextOptions) {
	  var containerAttrs = options._containerAttrs;
	  var replacerAttrs = options._replacerAttrs;
	  var contextLinkFn, replacerLinkFn;

	  // only need to compile other attributes for
	  // non-fragment instances
	  if (el.nodeType !== 11) {
	    // for components, container and replacer need to be
	    // compiled separately and linked in different scopes.
	    if (options._asComponent) {
	      // 2. container attributes
	      if (containerAttrs && contextOptions) {
	        contextLinkFn = compileDirectives(containerAttrs, contextOptions);
	      }
	      if (replacerAttrs) {
	        // 3. replacer attributes
	        replacerLinkFn = compileDirectives(replacerAttrs, options);
	      }
	    } else {
	      // non-component, just compile as a normal element.
	      replacerLinkFn = compileDirectives(el.attributes, options);
	    }
	  } else if (process.env.NODE_ENV !== 'production' && containerAttrs) {
	    // warn container directives for fragment instances
	    var names = containerAttrs.filter(function (attr) {
	      // allow vue-loader/vueify scoped css attributes
	      return attr.name.indexOf('_v-') < 0 &&
	      // allow event listeners
	      !onRE.test(attr.name) &&
	      // allow slots
	      attr.name !== 'slot';
	    }).map(function (attr) {
	      return '"' + attr.name + '"';
	    });
	    if (names.length) {
	      var plural = names.length > 1;
	      warn('Attribute' + (plural ? 's ' : ' ') + names.join(', ') + (plural ? ' are' : ' is') + ' ignored on component ' + '<' + options.el.tagName.toLowerCase() + '> because ' + 'the component is a fragment instance: ' + 'http://vuejs.org/guide/components.html#Fragment_Instance');
	    }
	  }

	  options._containerAttrs = options._replacerAttrs = null;
	  return function rootLinkFn(vm, el, scope) {
	    // link context scope dirs
	    var context = vm._context;
	    var contextDirs;
	    if (context && contextLinkFn) {
	      contextDirs = linkAndCapture(function () {
	        contextLinkFn(context, el, null, scope);
	      }, context);
	    }

	    // link self
	    var selfDirs = linkAndCapture(function () {
	      if (replacerLinkFn) replacerLinkFn(vm, el);
	    }, vm);

	    // return the unlink function that tearsdown context
	    // container directives.
	    return makeUnlinkFn(vm, selfDirs, context, contextDirs);
	  };
	}

	/**
	 * Compile a node and return a nodeLinkFn based on the
	 * node type.
	 *
	 * @param {Node} node
	 * @param {Object} options
	 * @return {Function|null}
	 */

	function compileNode(node, options) {
	  var type = node.nodeType;
	  if (type === 1 && node.tagName !== 'SCRIPT') {
	    return compileElement(node, options);
	  } else if (type === 3 && node.data.trim()) {
	    return compileTextNode(node, options);
	  } else {
	    return null;
	  }
	}

	/**
	 * Compile an element and return a nodeLinkFn.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Function|null}
	 */

	function compileElement(el, options) {
	  // preprocess textareas.
	  // textarea treats its text content as the initial value.
	  // just bind it as an attr directive for value.
	  if (el.tagName === 'TEXTAREA') {
	    var tokens = parseText(el.value);
	    if (tokens) {
	      el.setAttribute(':value', tokensToExp(tokens));
	      el.value = '';
	    }
	  }
	  var linkFn;
	  var hasAttrs = el.hasAttributes();
	  var attrs = hasAttrs && toArray(el.attributes);
	  // check terminal directives (for & if)
	  if (hasAttrs) {
	    linkFn = checkTerminalDirectives(el, attrs, options);
	  }
	  // check element directives
	  if (!linkFn) {
	    linkFn = checkElementDirectives(el, options);
	  }
	  // check component
	  if (!linkFn) {
	    linkFn = checkComponent(el, options);
	  }
	  // normal directives
	  if (!linkFn && hasAttrs) {
	    linkFn = compileDirectives(attrs, options);
	  }
	  return linkFn;
	}

	/**
	 * Compile a textNode and return a nodeLinkFn.
	 *
	 * @param {TextNode} node
	 * @param {Object} options
	 * @return {Function|null} textNodeLinkFn
	 */

	function compileTextNode(node, options) {
	  // skip marked text nodes
	  if (node._skip) {
	    return removeText;
	  }

	  var tokens = parseText(node.wholeText);
	  if (!tokens) {
	    return null;
	  }

	  // mark adjacent text nodes as skipped,
	  // because we are using node.wholeText to compile
	  // all adjacent text nodes together. This fixes
	  // issues in IE where sometimes it splits up a single
	  // text node into multiple ones.
	  var next = node.nextSibling;
	  while (next && next.nodeType === 3) {
	    next._skip = true;
	    next = next.nextSibling;
	  }

	  var frag = document.createDocumentFragment();
	  var el, token;
	  for (var i = 0, l = tokens.length; i < l; i++) {
	    token = tokens[i];
	    el = token.tag ? processTextToken(token, options) : document.createTextNode(token.value);
	    frag.appendChild(el);
	  }
	  return makeTextNodeLinkFn(tokens, frag, options);
	}

	/**
	 * Linker for an skipped text node.
	 *
	 * @param {Vue} vm
	 * @param {Text} node
	 */

	function removeText(vm, node) {
	  remove(node);
	}

	/**
	 * Process a single text token.
	 *
	 * @param {Object} token
	 * @param {Object} options
	 * @return {Node}
	 */

	function processTextToken(token, options) {
	  var el;
	  if (token.oneTime) {
	    el = document.createTextNode(token.value);
	  } else {
	    if (token.html) {
	      el = document.createComment('v-html');
	      setTokenType('html');
	    } else {
	      // IE will clean up empty textNodes during
	      // frag.cloneNode(true), so we have to give it
	      // something here...
	      el = document.createTextNode(' ');
	      setTokenType('text');
	    }
	  }
	  function setTokenType(type) {
	    if (token.descriptor) return;
	    var parsed = parseDirective(token.value);
	    token.descriptor = {
	      name: type,
	      def: directives[type],
	      expression: parsed.expression,
	      filters: parsed.filters
	    };
	  }
	  return el;
	}

	/**
	 * Build a function that processes a textNode.
	 *
	 * @param {Array<Object>} tokens
	 * @param {DocumentFragment} frag
	 */

	function makeTextNodeLinkFn(tokens, frag) {
	  return function textNodeLinkFn(vm, el, host, scope) {
	    var fragClone = frag.cloneNode(true);
	    var childNodes = toArray(fragClone.childNodes);
	    var token, value, node;
	    for (var i = 0, l = tokens.length; i < l; i++) {
	      token = tokens[i];
	      value = token.value;
	      if (token.tag) {
	        node = childNodes[i];
	        if (token.oneTime) {
	          value = (scope || vm).$eval(value);
	          if (token.html) {
	            replace(node, parseTemplate(value, true));
	          } else {
	            node.data = value;
	          }
	        } else {
	          vm._bindDir(token.descriptor, node, host, scope);
	        }
	      }
	    }
	    replace(el, fragClone);
	  };
	}

	/**
	 * Compile a node list and return a childLinkFn.
	 *
	 * @param {NodeList} nodeList
	 * @param {Object} options
	 * @return {Function|undefined}
	 */

	function compileNodeList(nodeList, options) {
	  var linkFns = [];
	  var nodeLinkFn, childLinkFn, node;
	  for (var i = 0, l = nodeList.length; i < l; i++) {
	    node = nodeList[i];
	    nodeLinkFn = compileNode(node, options);
	    childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && node.tagName !== 'SCRIPT' && node.hasChildNodes() ? compileNodeList(node.childNodes, options) : null;
	    linkFns.push(nodeLinkFn, childLinkFn);
	  }
	  return linkFns.length ? makeChildLinkFn(linkFns) : null;
	}

	/**
	 * Make a child link function for a node's childNodes.
	 *
	 * @param {Array<Function>} linkFns
	 * @return {Function} childLinkFn
	 */

	function makeChildLinkFn(linkFns) {
	  return function childLinkFn(vm, nodes, host, scope, frag) {
	    var node, nodeLinkFn, childrenLinkFn;
	    for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {
	      node = nodes[n];
	      nodeLinkFn = linkFns[i++];
	      childrenLinkFn = linkFns[i++];
	      // cache childNodes before linking parent, fix #657
	      var childNodes = toArray(node.childNodes);
	      if (nodeLinkFn) {
	        nodeLinkFn(vm, node, host, scope, frag);
	      }
	      if (childrenLinkFn) {
	        childrenLinkFn(vm, childNodes, host, scope, frag);
	      }
	    }
	  };
	}

	/**
	 * Check for element directives (custom elements that should
	 * be resovled as terminal directives).
	 *
	 * @param {Element} el
	 * @param {Object} options
	 */

	function checkElementDirectives(el, options) {
	  var tag = el.tagName.toLowerCase();
	  if (commonTagRE.test(tag)) {
	    return;
	  }
	  var def = resolveAsset(options, 'elementDirectives', tag);
	  if (def) {
	    return makeTerminalNodeLinkFn(el, tag, '', options, def);
	  }
	}

	/**
	 * Check if an element is a component. If yes, return
	 * a component link function.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Function|undefined}
	 */

	function checkComponent(el, options) {
	  var component = checkComponentAttr(el, options);
	  if (component) {
	    var ref = findRef(el);
	    var descriptor = {
	      name: 'component',
	      ref: ref,
	      expression: component.id,
	      def: internalDirectives.component,
	      modifiers: {
	        literal: !component.dynamic
	      }
	    };
	    var componentLinkFn = function componentLinkFn(vm, el, host, scope, frag) {
	      if (ref) {
	        defineReactive((scope || vm).$refs, ref, null);
	      }
	      vm._bindDir(descriptor, el, host, scope, frag);
	    };
	    componentLinkFn.terminal = true;
	    return componentLinkFn;
	  }
	}

	/**
	 * Check an element for terminal directives in fixed order.
	 * If it finds one, return a terminal link function.
	 *
	 * @param {Element} el
	 * @param {Array} attrs
	 * @param {Object} options
	 * @return {Function} terminalLinkFn
	 */

	function checkTerminalDirectives(el, attrs, options) {
	  // skip v-pre
	  if (getAttr(el, 'v-pre') !== null) {
	    return skip;
	  }
	  // skip v-else block, but only if following v-if
	  if (el.hasAttribute('v-else')) {
	    var prev = el.previousElementSibling;
	    if (prev && prev.hasAttribute('v-if')) {
	      return skip;
	    }
	  }

	  var attr, name, value, modifiers, matched, dirName, rawName, arg, def, termDef;
	  for (var i = 0, j = attrs.length; i < j; i++) {
	    attr = attrs[i];
	    modifiers = parseModifiers(attr.name);
	    name = attr.name.replace(modifierRE, '');
	    if (matched = name.match(dirAttrRE)) {
	      def = resolveAsset(options, 'directives', matched[1]);
	      if (def && def.terminal) {
	        if (!termDef || (def.priority || DEFAULT_TERMINAL_PRIORITY) > termDef.priority) {
	          termDef = def;
	          rawName = attr.name;
	          value = attr.value;
	          dirName = matched[1];
	          arg = matched[2];
	        }
	      }
	    }
	  }

	  if (termDef) {
	    return makeTerminalNodeLinkFn(el, dirName, value, options, termDef, rawName, arg, modifiers);
	  }
	}

	function skip() {}
	skip.terminal = true;

	/**
	 * Build a node link function for a terminal directive.
	 * A terminal link function terminates the current
	 * compilation recursion and handles compilation of the
	 * subtree in the directive.
	 *
	 * @param {Element} el
	 * @param {String} dirName
	 * @param {String} value
	 * @param {Object} options
	 * @param {Object} def
	 * @param {String} [rawName]
	 * @param {String} [arg]
	 * @param {Object} [modifiers]
	 * @return {Function} terminalLinkFn
	 */

	function makeTerminalNodeLinkFn(el, dirName, value, options, def, rawName, arg, modifiers) {
	  var parsed = parseDirective(value);
	  var descriptor = {
	    name: dirName,
	    arg: arg,
	    expression: parsed.expression,
	    filters: parsed.filters,
	    raw: value,
	    attr: rawName,
	    modifiers: modifiers,
	    def: def
	  };
	  // check ref for v-for and router-view
	  if (dirName === 'for' || dirName === 'router-view') {
	    descriptor.ref = findRef(el);
	  }
	  var fn = function terminalNodeLinkFn(vm, el, host, scope, frag) {
	    if (descriptor.ref) {
	      defineReactive((scope || vm).$refs, descriptor.ref, null);
	    }
	    vm._bindDir(descriptor, el, host, scope, frag);
	  };
	  fn.terminal = true;
	  return fn;
	}

	/**
	 * Compile the directives on an element and return a linker.
	 *
	 * @param {Array|NamedNodeMap} attrs
	 * @param {Object} options
	 * @return {Function}
	 */

	function compileDirectives(attrs, options) {
	  var i = attrs.length;
	  var dirs = [];
	  var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens, matched;
	  while (i--) {
	    attr = attrs[i];
	    name = rawName = attr.name;
	    value = rawValue = attr.value;
	    tokens = parseText(value);
	    // reset arg
	    arg = null;
	    // check modifiers
	    modifiers = parseModifiers(name);
	    name = name.replace(modifierRE, '');

	    // attribute interpolations
	    if (tokens) {
	      value = tokensToExp(tokens);
	      arg = name;
	      pushDir('bind', directives.bind, tokens);
	      // warn against mixing mustaches with v-bind
	      if (process.env.NODE_ENV !== 'production') {
	        if (name === 'class' && Array.prototype.some.call(attrs, function (attr) {
	          return attr.name === ':class' || attr.name === 'v-bind:class';
	        })) {
	          warn('class="' + rawValue + '": Do not mix mustache interpolation ' + 'and v-bind for "class" on the same element. Use one or the other.', options);
	        }
	      }
	    } else

	      // special attribute: transition
	      if (transitionRE.test(name)) {
	        modifiers.literal = !bindRE.test(name);
	        pushDir('transition', internalDirectives.transition);
	      } else

	        // event handlers
	        if (onRE.test(name)) {
	          arg = name.replace(onRE, '');
	          pushDir('on', directives.on);
	        } else

	          // attribute bindings
	          if (bindRE.test(name)) {
	            dirName = name.replace(bindRE, '');
	            if (dirName === 'style' || dirName === 'class') {
	              pushDir(dirName, internalDirectives[dirName]);
	            } else {
	              arg = dirName;
	              pushDir('bind', directives.bind);
	            }
	          } else

	            // normal directives
	            if (matched = name.match(dirAttrRE)) {
	              dirName = matched[1];
	              arg = matched[2];

	              // skip v-else (when used with v-show)
	              if (dirName === 'else') {
	                continue;
	              }

	              dirDef = resolveAsset(options, 'directives', dirName, true);
	              if (dirDef) {
	                pushDir(dirName, dirDef);
	              }
	            }
	  }

	  /**
	   * Push a directive.
	   *
	   * @param {String} dirName
	   * @param {Object|Function} def
	   * @param {Array} [interpTokens]
	   */

	  function pushDir(dirName, def, interpTokens) {
	    var hasOneTimeToken = interpTokens && hasOneTime(interpTokens);
	    var parsed = !hasOneTimeToken && parseDirective(value);
	    dirs.push({
	      name: dirName,
	      attr: rawName,
	      raw: rawValue,
	      def: def,
	      arg: arg,
	      modifiers: modifiers,
	      // conversion from interpolation strings with one-time token
	      // to expression is differed until directive bind time so that we
	      // have access to the actual vm context for one-time bindings.
	      expression: parsed && parsed.expression,
	      filters: parsed && parsed.filters,
	      interp: interpTokens,
	      hasOneTime: hasOneTimeToken
	    });
	  }

	  if (dirs.length) {
	    return makeNodeLinkFn(dirs);
	  }
	}

	/**
	 * Parse modifiers from directive attribute name.
	 *
	 * @param {String} name
	 * @return {Object}
	 */

	function parseModifiers(name) {
	  var res = Object.create(null);
	  var match = name.match(modifierRE);
	  if (match) {
	    var i = match.length;
	    while (i--) {
	      res[match[i].slice(1)] = true;
	    }
	  }
	  return res;
	}

	/**
	 * Build a link function for all directives on a single node.
	 *
	 * @param {Array} directives
	 * @return {Function} directivesLinkFn
	 */

	function makeNodeLinkFn(directives) {
	  return function nodeLinkFn(vm, el, host, scope, frag) {
	    // reverse apply because it's sorted low to high
	    var i = directives.length;
	    while (i--) {
	      vm._bindDir(directives[i], el, host, scope, frag);
	    }
	  };
	}

	/**
	 * Check if an interpolation string contains one-time tokens.
	 *
	 * @param {Array} tokens
	 * @return {Boolean}
	 */

	function hasOneTime(tokens) {
	  var i = tokens.length;
	  while (i--) {
	    if (tokens[i].oneTime) return true;
	  }
	}

	var specialCharRE = /[^\w\-:\.]/;

	/**
	 * Process an element or a DocumentFragment based on a
	 * instance option object. This allows us to transclude
	 * a template node/fragment before the instance is created,
	 * so the processed fragment can then be cloned and reused
	 * in v-for.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Element|DocumentFragment}
	 */

	function transclude(el, options) {
	  // extract container attributes to pass them down
	  // to compiler, because they need to be compiled in
	  // parent scope. we are mutating the options object here
	  // assuming the same object will be used for compile
	  // right after this.
	  if (options) {
	    options._containerAttrs = extractAttrs(el);
	  }
	  // for template tags, what we want is its content as
	  // a documentFragment (for fragment instances)
	  if (isTemplate(el)) {
	    el = parseTemplate(el);
	  }
	  if (options) {
	    if (options._asComponent && !options.template) {
	      options.template = '<slot></slot>';
	    }
	    if (options.template) {
	      options._content = extractContent(el);
	      el = transcludeTemplate(el, options);
	    }
	  }
	  if (isFragment(el)) {
	    // anchors for fragment instance
	    // passing in `persist: true` to avoid them being
	    // discarded by IE during template cloning
	    prepend(createAnchor('v-start', true), el);
	    el.appendChild(createAnchor('v-end', true));
	  }
	  return el;
	}

	/**
	 * Process the template option.
	 * If the replace option is true this will swap the $el.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Element|DocumentFragment}
	 */

	function transcludeTemplate(el, options) {
	  var template = options.template;
	  var frag = parseTemplate(template, true);
	  if (frag) {
	    var replacer = frag.firstChild;
	    var tag = replacer.tagName && replacer.tagName.toLowerCase();
	    if (options.replace) {
	      /* istanbul ignore if */
	      if (el === document.body) {
	        process.env.NODE_ENV !== 'production' && warn('You are mounting an instance with a template to ' + '<body>. This will replace <body> entirely. You ' + 'should probably use `replace: false` here.');
	      }
	      // there are many cases where the instance must
	      // become a fragment instance: basically anything that
	      // can create more than 1 root nodes.
	      if (
	      // multi-children template
	      frag.childNodes.length > 1 ||
	      // non-element template
	      replacer.nodeType !== 1 ||
	      // single nested component
	      tag === 'component' || resolveAsset(options, 'components', tag) || hasBindAttr(replacer, 'is') ||
	      // element directive
	      resolveAsset(options, 'elementDirectives', tag) ||
	      // for block
	      replacer.hasAttribute('v-for') ||
	      // if block
	      replacer.hasAttribute('v-if')) {
	        return frag;
	      } else {
	        options._replacerAttrs = extractAttrs(replacer);
	        mergeAttrs(el, replacer);
	        return replacer;
	      }
	    } else {
	      el.appendChild(frag);
	      return el;
	    }
	  } else {
	    process.env.NODE_ENV !== 'production' && warn('Invalid template option: ' + template);
	  }
	}

	/**
	 * Helper to extract a component container's attributes
	 * into a plain object array.
	 *
	 * @param {Element} el
	 * @return {Array}
	 */

	function extractAttrs(el) {
	  if (el.nodeType === 1 && el.hasAttributes()) {
	    return toArray(el.attributes);
	  }
	}

	/**
	 * Merge the attributes of two elements, and make sure
	 * the class names are merged properly.
	 *
	 * @param {Element} from
	 * @param {Element} to
	 */

	function mergeAttrs(from, to) {
	  var attrs = from.attributes;
	  var i = attrs.length;
	  var name, value;
	  while (i--) {
	    name = attrs[i].name;
	    value = attrs[i].value;
	    if (!to.hasAttribute(name) && !specialCharRE.test(name)) {
	      to.setAttribute(name, value);
	    } else if (name === 'class' && !parseText(value)) {
	      value.trim().split(/\s+/).forEach(function (cls) {
	        addClass(to, cls);
	      });
	    }
	  }
	}

	/**
	 * Scan and determine slot content distribution.
	 * We do this during transclusion instead at compile time so that
	 * the distribution is decoupled from the compilation order of
	 * the slots.
	 *
	 * @param {Element|DocumentFragment} template
	 * @param {Element} content
	 * @param {Vue} vm
	 */

	function resolveSlots(vm, content) {
	  if (!content) {
	    return;
	  }
	  var contents = vm._slotContents = Object.create(null);
	  var el, name;
	  for (var i = 0, l = content.children.length; i < l; i++) {
	    el = content.children[i];
	    /* eslint-disable no-cond-assign */
	    if (name = el.getAttribute('slot')) {
	      (contents[name] || (contents[name] = [])).push(el);
	    }
	    /* eslint-enable no-cond-assign */
	    if (process.env.NODE_ENV !== 'production' && getBindAttr(el, 'slot')) {
	      warn('The "slot" attribute must be static.', vm.$parent);
	    }
	  }
	  for (name in contents) {
	    contents[name] = extractFragment(contents[name], content);
	  }
	  if (content.hasChildNodes()) {
	    contents['default'] = extractFragment(content.childNodes, content);
	  }
	}

	/**
	 * Extract qualified content nodes from a node list.
	 *
	 * @param {NodeList} nodes
	 * @return {DocumentFragment}
	 */

	function extractFragment(nodes, parent) {
	  var frag = document.createDocumentFragment();
	  nodes = toArray(nodes);
	  for (var i = 0, l = nodes.length; i < l; i++) {
	    var node = nodes[i];
	    if (isTemplate(node) && !node.hasAttribute('v-if') && !node.hasAttribute('v-for')) {
	      parent.removeChild(node);
	      node = parseTemplate(node);
	    }
	    frag.appendChild(node);
	  }
	  return frag;
	}



	var compiler = Object.freeze({
		compile: compile,
		compileAndLinkProps: compileAndLinkProps,
		compileRoot: compileRoot,
		transclude: transclude,
		resolveSlots: resolveSlots
	});

	function stateMixin (Vue) {
	  /**
	   * Accessor for `$data` property, since setting $data
	   * requires observing the new object and updating
	   * proxied properties.
	   */

	  Object.defineProperty(Vue.prototype, '$data', {
	    get: function get() {
	      return this._data;
	    },
	    set: function set(newData) {
	      if (newData !== this._data) {
	        this._setData(newData);
	      }
	    }
	  });

	  /**
	   * Setup the scope of an instance, which contains:
	   * - observed data
	   * - computed properties
	   * - user methods
	   * - meta properties
	   */

	  Vue.prototype._initState = function () {
	    this._initProps();
	    this._initMeta();
	    this._initMethods();
	    this._initData();
	    this._initComputed();
	  };

	  /**
	   * Initialize props.
	   */

	  Vue.prototype._initProps = function () {
	    var options = this.$options;
	    var el = options.el;
	    var props = options.props;
	    if (props && !el) {
	      process.env.NODE_ENV !== 'production' && warn('Props will not be compiled if no `el` option is ' + 'provided at instantiation.', this);
	    }
	    // make sure to convert string selectors into element now
	    el = options.el = query(el);
	    this._propsUnlinkFn = el && el.nodeType === 1 && props
	    // props must be linked in proper scope if inside v-for
	    ? compileAndLinkProps(this, el, props, this._scope) : null;
	  };

	  /**
	   * Initialize the data.
	   */

	  Vue.prototype._initData = function () {
	    var dataFn = this.$options.data;
	    var data = this._data = dataFn ? dataFn() : {};
	    if (!isPlainObject(data)) {
	      data = {};
	      process.env.NODE_ENV !== 'production' && warn('data functions should return an object.', this);
	    }
	    var props = this._props;
	    var runtimeData = this._runtimeData ? typeof this._runtimeData === 'function' ? this._runtimeData() : this._runtimeData : null;
	    // proxy data on instance
	    var keys = Object.keys(data);
	    var i, key;
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      // there are two scenarios where we can proxy a data key:
	      // 1. it's not already defined as a prop
	      // 2. it's provided via a instantiation option AND there are no
	      //    template prop present
	      if (!props || !hasOwn(props, key) || runtimeData && hasOwn(runtimeData, key) && props[key].raw === null) {
	        this._proxy(key);
	      } else if (process.env.NODE_ENV !== 'production') {
	        warn('Data field "' + key + '" is already defined ' + 'as a prop. Use prop default value instead.', this);
	      }
	    }
	    // observe data
	    observe(data, this);
	  };

	  /**
	   * Swap the instance's $data. Called in $data's setter.
	   *
	   * @param {Object} newData
	   */

	  Vue.prototype._setData = function (newData) {
	    newData = newData || {};
	    var oldData = this._data;
	    this._data = newData;
	    var keys, key, i;
	    // unproxy keys not present in new data
	    keys = Object.keys(oldData);
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      if (!(key in newData)) {
	        this._unproxy(key);
	      }
	    }
	    // proxy keys not already proxied,
	    // and trigger change for changed values
	    keys = Object.keys(newData);
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      if (!hasOwn(this, key)) {
	        // new property
	        this._proxy(key);
	      }
	    }
	    oldData.__ob__.removeVm(this);
	    observe(newData, this);
	    this._digest();
	  };

	  /**
	   * Proxy a property, so that
	   * vm.prop === vm._data.prop
	   *
	   * @param {String} key
	   */

	  Vue.prototype._proxy = function (key) {
	    if (!isReserved(key)) {
	      // need to store ref to self here
	      // because these getter/setters might
	      // be called by child scopes via
	      // prototype inheritance.
	      var self = this;
	      Object.defineProperty(self, key, {
	        configurable: true,
	        enumerable: true,
	        get: function proxyGetter() {
	          return self._data[key];
	        },
	        set: function proxySetter(val) {
	          self._data[key] = val;
	        }
	      });
	    }
	  };

	  /**
	   * Unproxy a property.
	   *
	   * @param {String} key
	   */

	  Vue.prototype._unproxy = function (key) {
	    if (!isReserved(key)) {
	      delete this[key];
	    }
	  };

	  /**
	   * Force update on every watcher in scope.
	   */

	  Vue.prototype._digest = function () {
	    for (var i = 0, l = this._watchers.length; i < l; i++) {
	      this._watchers[i].update(true); // shallow updates
	    }
	  };

	  /**
	   * Setup computed properties. They are essentially
	   * special getter/setters
	   */

	  function noop() {}
	  Vue.prototype._initComputed = function () {
	    var computed = this.$options.computed;
	    if (computed) {
	      for (var key in computed) {
	        var userDef = computed[key];
	        var def = {
	          enumerable: true,
	          configurable: true
	        };
	        if (typeof userDef === 'function') {
	          def.get = makeComputedGetter(userDef, this);
	          def.set = noop;
	        } else {
	          def.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, this) : bind(userDef.get, this) : noop;
	          def.set = userDef.set ? bind(userDef.set, this) : noop;
	        }
	        Object.defineProperty(this, key, def);
	      }
	    }
	  };

	  function makeComputedGetter(getter, owner) {
	    var watcher = new Watcher(owner, getter, null, {
	      lazy: true
	    });
	    return function computedGetter() {
	      if (watcher.dirty) {
	        watcher.evaluate();
	      }
	      if (Dep.target) {
	        watcher.depend();
	      }
	      return watcher.value;
	    };
	  }

	  /**
	   * Setup instance methods. Methods must be bound to the
	   * instance since they might be passed down as a prop to
	   * child components.
	   */

	  Vue.prototype._initMethods = function () {
	    var methods = this.$options.methods;
	    if (methods) {
	      for (var key in methods) {
	        this[key] = bind(methods[key], this);
	      }
	    }
	  };

	  /**
	   * Initialize meta information like $index, $key & $value.
	   */

	  Vue.prototype._initMeta = function () {
	    var metas = this.$options._meta;
	    if (metas) {
	      for (var key in metas) {
	        defineReactive(this, key, metas[key]);
	      }
	    }
	  };
	}

	var eventRE = /^v-on:|^@/;

	function eventsMixin (Vue) {
	  /**
	   * Setup the instance's option events & watchers.
	   * If the value is a string, we pull it from the
	   * instance's methods by name.
	   */

	  Vue.prototype._initEvents = function () {
	    var options = this.$options;
	    if (options._asComponent) {
	      registerComponentEvents(this, options.el);
	    }
	    registerCallbacks(this, '$on', options.events);
	    registerCallbacks(this, '$watch', options.watch);
	  };

	  /**
	   * Register v-on events on a child component
	   *
	   * @param {Vue} vm
	   * @param {Element} el
	   */

	  function registerComponentEvents(vm, el) {
	    var attrs = el.attributes;
	    var name, handler;
	    for (var i = 0, l = attrs.length; i < l; i++) {
	      name = attrs[i].name;
	      if (eventRE.test(name)) {
	        name = name.replace(eventRE, '');
	        handler = (vm._scope || vm._context).$eval(attrs[i].value, true);
	        if (typeof handler === 'function') {
	          handler._fromParent = true;
	          vm.$on(name.replace(eventRE), handler);
	        } else if (process.env.NODE_ENV !== 'production') {
	          warn('v-on:' + name + '="' + attrs[i].value + '" ' + 'expects a function value, got ' + handler, vm);
	        }
	      }
	    }
	  }

	  /**
	   * Register callbacks for option events and watchers.
	   *
	   * @param {Vue} vm
	   * @param {String} action
	   * @param {Object} hash
	   */

	  function registerCallbacks(vm, action, hash) {
	    if (!hash) return;
	    var handlers, key, i, j;
	    for (key in hash) {
	      handlers = hash[key];
	      if (isArray(handlers)) {
	        for (i = 0, j = handlers.length; i < j; i++) {
	          register(vm, action, key, handlers[i]);
	        }
	      } else {
	        register(vm, action, key, handlers);
	      }
	    }
	  }

	  /**
	   * Helper to register an event/watch callback.
	   *
	   * @param {Vue} vm
	   * @param {String} action
	   * @param {String} key
	   * @param {Function|String|Object} handler
	   * @param {Object} [options]
	   */

	  function register(vm, action, key, handler, options) {
	    var type = typeof handler;
	    if (type === 'function') {
	      vm[action](key, handler, options);
	    } else if (type === 'string') {
	      var methods = vm.$options.methods;
	      var method = methods && methods[handler];
	      if (method) {
	        vm[action](key, method, options);
	      } else {
	        process.env.NODE_ENV !== 'production' && warn('Unknown method: "' + handler + '" when ' + 'registering callback for ' + action + ': "' + key + '".', vm);
	      }
	    } else if (handler && type === 'object') {
	      register(vm, action, key, handler.handler, handler);
	    }
	  }

	  /**
	   * Setup recursive attached/detached calls
	   */

	  Vue.prototype._initDOMHooks = function () {
	    this.$on('hook:attached', onAttached);
	    this.$on('hook:detached', onDetached);
	  };

	  /**
	   * Callback to recursively call attached hook on children
	   */

	  function onAttached() {
	    if (!this._isAttached) {
	      this._isAttached = true;
	      this.$children.forEach(callAttach);
	    }
	  }

	  /**
	   * Iterator to call attached hook
	   *
	   * @param {Vue} child
	   */

	  function callAttach(child) {
	    if (!child._isAttached && inDoc(child.$el)) {
	      child._callHook('attached');
	    }
	  }

	  /**
	   * Callback to recursively call detached hook on children
	   */

	  function onDetached() {
	    if (this._isAttached) {
	      this._isAttached = false;
	      this.$children.forEach(callDetach);
	    }
	  }

	  /**
	   * Iterator to call detached hook
	   *
	   * @param {Vue} child
	   */

	  function callDetach(child) {
	    if (child._isAttached && !inDoc(child.$el)) {
	      child._callHook('detached');
	    }
	  }

	  /**
	   * Trigger all handlers for a hook
	   *
	   * @param {String} hook
	   */

	  Vue.prototype._callHook = function (hook) {
	    this.$emit('pre-hook:' + hook);
	    var handlers = this.$options[hook];
	    if (handlers) {
	      for (var i = 0, j = handlers.length; i < j; i++) {
	        handlers[i].call(this);
	      }
	    }
	    this.$emit('hook:' + hook);
	  };
	}

	function noop() {}

	/**
	 * A directive links a DOM element with a piece of data,
	 * which is the result of evaluating an expression.
	 * It registers a watcher with the expression and calls
	 * the DOM update function when a change is triggered.
	 *
	 * @param {Object} descriptor
	 *                 - {String} name
	 *                 - {Object} def
	 *                 - {String} expression
	 *                 - {Array<Object>} [filters]
	 *                 - {Object} [modifiers]
	 *                 - {Boolean} literal
	 *                 - {String} attr
	 *                 - {String} arg
	 *                 - {String} raw
	 *                 - {String} [ref]
	 *                 - {Array<Object>} [interp]
	 *                 - {Boolean} [hasOneTime]
	 * @param {Vue} vm
	 * @param {Node} el
	 * @param {Vue} [host] - transclusion host component
	 * @param {Object} [scope] - v-for scope
	 * @param {Fragment} [frag] - owner fragment
	 * @constructor
	 */
	function Directive(descriptor, vm, el, host, scope, frag) {
	  this.vm = vm;
	  this.el = el;
	  // copy descriptor properties
	  this.descriptor = descriptor;
	  this.name = descriptor.name;
	  this.expression = descriptor.expression;
	  this.arg = descriptor.arg;
	  this.modifiers = descriptor.modifiers;
	  this.filters = descriptor.filters;
	  this.literal = this.modifiers && this.modifiers.literal;
	  // private
	  this._locked = false;
	  this._bound = false;
	  this._listeners = null;
	  // link context
	  this._host = host;
	  this._scope = scope;
	  this._frag = frag;
	  // store directives on node in dev mode
	  if (process.env.NODE_ENV !== 'production' && this.el) {
	    this.el._vue_directives = this.el._vue_directives || [];
	    this.el._vue_directives.push(this);
	  }
	}

	/**
	 * Initialize the directive, mixin definition properties,
	 * setup the watcher, call definition bind() and update()
	 * if present.
	 */

	Directive.prototype._bind = function () {
	  var name = this.name;
	  var descriptor = this.descriptor;

	  // remove attribute
	  if ((name !== 'cloak' || this.vm._isCompiled) && this.el && this.el.removeAttribute) {
	    var attr = descriptor.attr || 'v-' + name;
	    this.el.removeAttribute(attr);
	  }

	  // copy def properties
	  var def = descriptor.def;
	  if (typeof def === 'function') {
	    this.update = def;
	  } else {
	    extend(this, def);
	  }

	  // setup directive params
	  this._setupParams();

	  // initial bind
	  if (this.bind) {
	    this.bind();
	  }
	  this._bound = true;

	  if (this.literal) {
	    this.update && this.update(descriptor.raw);
	  } else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {
	    // wrapped updater for context
	    var dir = this;
	    if (this.update) {
	      this._update = function (val, oldVal) {
	        if (!dir._locked) {
	          dir.update(val, oldVal);
	        }
	      };
	    } else {
	      this._update = noop;
	    }
	    var preProcess = this._preProcess ? bind(this._preProcess, this) : null;
	    var postProcess = this._postProcess ? bind(this._postProcess, this) : null;
	    var watcher = this._watcher = new Watcher(this.vm, this.expression, this._update, // callback
	    {
	      filters: this.filters,
	      twoWay: this.twoWay,
	      deep: this.deep,
	      preProcess: preProcess,
	      postProcess: postProcess,
	      scope: this._scope
	    });
	    // v-model with inital inline value need to sync back to
	    // model instead of update to DOM on init. They would
	    // set the afterBind hook to indicate that.
	    if (this.afterBind) {
	      this.afterBind();
	    } else if (this.update) {
	      this.update(watcher.value);
	    }
	  }
	};

	/**
	 * Setup all param attributes, e.g. track-by,
	 * transition-mode, etc...
	 */

	Directive.prototype._setupParams = function () {
	  if (!this.params) {
	    return;
	  }
	  var params = this.params;
	  // swap the params array with a fresh object.
	  this.params = Object.create(null);
	  var i = params.length;
	  var key, val, mappedKey;
	  while (i--) {
	    key = hyphenate(params[i]);
	    mappedKey = camelize(key);
	    val = getBindAttr(this.el, key);
	    if (val != null) {
	      // dynamic
	      this._setupParamWatcher(mappedKey, val);
	    } else {
	      // static
	      val = getAttr(this.el, key);
	      if (val != null) {
	        this.params[mappedKey] = val === '' ? true : val;
	      }
	    }
	  }
	};

	/**
	 * Setup a watcher for a dynamic param.
	 *
	 * @param {String} key
	 * @param {String} expression
	 */

	Directive.prototype._setupParamWatcher = function (key, expression) {
	  var self = this;
	  var called = false;
	  var unwatch = (this._scope || this.vm).$watch(expression, function (val, oldVal) {
	    self.params[key] = val;
	    // since we are in immediate mode,
	    // only call the param change callbacks if this is not the first update.
	    if (called) {
	      var cb = self.paramWatchers && self.paramWatchers[key];
	      if (cb) {
	        cb.call(self, val, oldVal);
	      }
	    } else {
	      called = true;
	    }
	  }, {
	    immediate: true,
	    user: false
	  });(this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch);
	};

	/**
	 * Check if the directive is a function caller
	 * and if the expression is a callable one. If both true,
	 * we wrap up the expression and use it as the event
	 * handler.
	 *
	 * e.g. on-click="a++"
	 *
	 * @return {Boolean}
	 */

	Directive.prototype._checkStatement = function () {
	  var expression = this.expression;
	  if (expression && this.acceptStatement && !isSimplePath(expression)) {
	    var fn = parseExpression(expression).get;
	    var scope = this._scope || this.vm;
	    var handler = function handler(e) {
	      scope.$event = e;
	      fn.call(scope, scope);
	      scope.$event = null;
	    };
	    if (this.filters) {
	      handler = scope._applyFilters(handler, null, this.filters);
	    }
	    this.update(handler);
	    return true;
	  }
	};

	/**
	 * Set the corresponding value with the setter.
	 * This should only be used in two-way directives
	 * e.g. v-model.
	 *
	 * @param {*} value
	 * @public
	 */

	Directive.prototype.set = function (value) {
	  /* istanbul ignore else */
	  if (this.twoWay) {
	    this._withLock(function () {
	      this._watcher.set(value);
	    });
	  } else if (process.env.NODE_ENV !== 'production') {
	    warn('Directive.set() can only be used inside twoWay' + 'directives.');
	  }
	};

	/**
	 * Execute a function while preventing that function from
	 * triggering updates on this directive instance.
	 *
	 * @param {Function} fn
	 */

	Directive.prototype._withLock = function (fn) {
	  var self = this;
	  self._locked = true;
	  fn.call(self);
	  nextTick(function () {
	    self._locked = false;
	  });
	};

	/**
	 * Convenience method that attaches a DOM event listener
	 * to the directive element and autometically tears it down
	 * during unbind.
	 *
	 * @param {String} event
	 * @param {Function} handler
	 * @param {Boolean} [useCapture]
	 */

	Directive.prototype.on = function (event, handler, useCapture) {
	  on(this.el, event, handler, useCapture);(this._listeners || (this._listeners = [])).push([event, handler]);
	};

	/**
	 * Teardown the watcher and call unbind.
	 */

	Directive.prototype._teardown = function () {
	  if (this._bound) {
	    this._bound = false;
	    if (this.unbind) {
	      this.unbind();
	    }
	    if (this._watcher) {
	      this._watcher.teardown();
	    }
	    var listeners = this._listeners;
	    var i;
	    if (listeners) {
	      i = listeners.length;
	      while (i--) {
	        off(this.el, listeners[i][0], listeners[i][1]);
	      }
	    }
	    var unwatchFns = this._paramUnwatchFns;
	    if (unwatchFns) {
	      i = unwatchFns.length;
	      while (i--) {
	        unwatchFns[i]();
	      }
	    }
	    if (process.env.NODE_ENV !== 'production' && this.el) {
	      this.el._vue_directives.$remove(this);
	    }
	    this.vm = this.el = this._watcher = this._listeners = null;
	  }
	};

	function lifecycleMixin (Vue) {
	  /**
	   * Update v-ref for component.
	   *
	   * @param {Boolean} remove
	   */

	  Vue.prototype._updateRef = function (remove) {
	    var ref = this.$options._ref;
	    if (ref) {
	      var refs = (this._scope || this._context).$refs;
	      if (remove) {
	        if (refs[ref] === this) {
	          refs[ref] = null;
	        }
	      } else {
	        refs[ref] = this;
	      }
	    }
	  };

	  /**
	   * Transclude, compile and link element.
	   *
	   * If a pre-compiled linker is available, that means the
	   * passed in element will be pre-transcluded and compiled
	   * as well - all we need to do is to call the linker.
	   *
	   * Otherwise we need to call transclude/compile/link here.
	   *
	   * @param {Element} el
	   */

	  Vue.prototype._compile = function (el) {
	    var options = this.$options;

	    // transclude and init element
	    // transclude can potentially replace original
	    // so we need to keep reference; this step also injects
	    // the template and caches the original attributes
	    // on the container node and replacer node.
	    var original = el;
	    el = transclude(el, options);
	    this._initElement(el);

	    // handle v-pre on root node (#2026)
	    if (el.nodeType === 1 && getAttr(el, 'v-pre') !== null) {
	      return;
	    }

	    // root is always compiled per-instance, because
	    // container attrs and props can be different every time.
	    var contextOptions = this._context && this._context.$options;
	    var rootLinker = compileRoot(el, options, contextOptions);

	    // resolve slot distribution
	    resolveSlots(this, options._content);

	    // compile and link the rest
	    var contentLinkFn;
	    var ctor = this.constructor;
	    // component compilation can be cached
	    // as long as it's not using inline-template
	    if (options._linkerCachable) {
	      contentLinkFn = ctor.linker;
	      if (!contentLinkFn) {
	        contentLinkFn = ctor.linker = compile(el, options);
	      }
	    }

	    // link phase
	    // make sure to link root with prop scope!
	    var rootUnlinkFn = rootLinker(this, el, this._scope);
	    var contentUnlinkFn = contentLinkFn ? contentLinkFn(this, el) : compile(el, options)(this, el);

	    // register composite unlink function
	    // to be called during instance destruction
	    this._unlinkFn = function () {
	      rootUnlinkFn();
	      // passing destroying: true to avoid searching and
	      // splicing the directives
	      contentUnlinkFn(true);
	    };

	    // finally replace original
	    if (options.replace) {
	      replace(original, el);
	    }

	    this._isCompiled = true;
	    this._callHook('compiled');
	  };

	  /**
	   * Initialize instance element. Called in the public
	   * $mount() method.
	   *
	   * @param {Element} el
	   */

	  Vue.prototype._initElement = function (el) {
	    if (isFragment(el)) {
	      this._isFragment = true;
	      this.$el = this._fragmentStart = el.firstChild;
	      this._fragmentEnd = el.lastChild;
	      // set persisted text anchors to empty
	      if (this._fragmentStart.nodeType === 3) {
	        this._fragmentStart.data = this._fragmentEnd.data = '';
	      }
	      this._fragment = el;
	    } else {
	      this.$el = el;
	    }
	    this.$el.__vue__ = this;
	    this._callHook('beforeCompile');
	  };

	  /**
	   * Create and bind a directive to an element.
	   *
	   * @param {Object} descriptor - parsed directive descriptor
	   * @param {Node} node   - target node
	   * @param {Vue} [host] - transclusion host component
	   * @param {Object} [scope] - v-for scope
	   * @param {Fragment} [frag] - owner fragment
	   */

	  Vue.prototype._bindDir = function (descriptor, node, host, scope, frag) {
	    this._directives.push(new Directive(descriptor, this, node, host, scope, frag));
	  };

	  /**
	   * Teardown an instance, unobserves the data, unbind all the
	   * directives, turn off all the event listeners, etc.
	   *
	   * @param {Boolean} remove - whether to remove the DOM node.
	   * @param {Boolean} deferCleanup - if true, defer cleanup to
	   *                                 be called later
	   */

	  Vue.prototype._destroy = function (remove, deferCleanup) {
	    if (this._isBeingDestroyed) {
	      if (!deferCleanup) {
	        this._cleanup();
	      }
	      return;
	    }

	    var destroyReady;
	    var pendingRemoval;

	    var self = this;
	    // Cleanup should be called either synchronously or asynchronoysly as
	    // callback of this.$remove(), or if remove and deferCleanup are false.
	    // In any case it should be called after all other removing, unbinding and
	    // turning of is done
	    var cleanupIfPossible = function cleanupIfPossible() {
	      if (destroyReady && !pendingRemoval && !deferCleanup) {
	        self._cleanup();
	      }
	    };

	    // remove DOM element
	    if (remove && this.$el) {
	      pendingRemoval = true;
	      this.$remove(function () {
	        pendingRemoval = false;
	        cleanupIfPossible();
	      });
	    }

	    this._callHook('beforeDestroy');
	    this._isBeingDestroyed = true;
	    var i;
	    // remove self from parent. only necessary
	    // if parent is not being destroyed as well.
	    var parent = this.$parent;
	    if (parent && !parent._isBeingDestroyed) {
	      parent.$children.$remove(this);
	      // unregister ref (remove: true)
	      this._updateRef(true);
	    }
	    // destroy all children.
	    i = this.$children.length;
	    while (i--) {
	      this.$children[i].$destroy();
	    }
	    // teardown props
	    if (this._propsUnlinkFn) {
	      this._propsUnlinkFn();
	    }
	    // teardown all directives. this also tearsdown all
	    // directive-owned watchers.
	    if (this._unlinkFn) {
	      this._unlinkFn();
	    }
	    i = this._watchers.length;
	    while (i--) {
	      this._watchers[i].teardown();
	    }
	    // remove reference to self on $el
	    if (this.$el) {
	      this.$el.__vue__ = null;
	    }

	    destroyReady = true;
	    cleanupIfPossible();
	  };

	  /**
	   * Clean up to ensure garbage collection.
	   * This is called after the leave transition if there
	   * is any.
	   */

	  Vue.prototype._cleanup = function () {
	    if (this._isDestroyed) {
	      return;
	    }
	    // remove self from owner fragment
	    // do it in cleanup so that we can call $destroy with
	    // defer right when a fragment is about to be removed.
	    if (this._frag) {
	      this._frag.children.$remove(this);
	    }
	    // remove reference from data ob
	    // frozen object may not have observer.
	    if (this._data.__ob__) {
	      this._data.__ob__.removeVm(this);
	    }
	    // Clean up references to private properties and other
	    // instances. preserve reference to _data so that proxy
	    // accessors still work. The only potential side effect
	    // here is that mutating the instance after it's destroyed
	    // may affect the state of other components that are still
	    // observing the same object, but that seems to be a
	    // reasonable responsibility for the user rather than
	    // always throwing an error on them.
	    this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null;
	    // call the last hook...
	    this._isDestroyed = true;
	    this._callHook('destroyed');
	    // turn off all instance listeners.
	    this.$off();
	  };
	}

	function miscMixin (Vue) {
	  /**
	   * Apply a list of filter (descriptors) to a value.
	   * Using plain for loops here because this will be called in
	   * the getter of any watcher with filters so it is very
	   * performance sensitive.
	   *
	   * @param {*} value
	   * @param {*} [oldValue]
	   * @param {Array} filters
	   * @param {Boolean} write
	   * @return {*}
	   */

	  Vue.prototype._applyFilters = function (value, oldValue, filters, write) {
	    var filter, fn, args, arg, offset, i, l, j, k;
	    for (i = 0, l = filters.length; i < l; i++) {
	      filter = filters[write ? l - i - 1 : i];
	      fn = resolveAsset(this.$options, 'filters', filter.name, true);
	      if (!fn) continue;
	      fn = write ? fn.write : fn.read || fn;
	      if (typeof fn !== 'function') continue;
	      args = write ? [value, oldValue] : [value];
	      offset = write ? 2 : 1;
	      if (filter.args) {
	        for (j = 0, k = filter.args.length; j < k; j++) {
	          arg = filter.args[j];
	          args[j + offset] = arg.dynamic ? this.$get(arg.value) : arg.value;
	        }
	      }
	      value = fn.apply(this, args);
	    }
	    return value;
	  };

	  /**
	   * Resolve a component, depending on whether the component
	   * is defined normally or using an async factory function.
	   * Resolves synchronously if already resolved, otherwise
	   * resolves asynchronously and caches the resolved
	   * constructor on the factory.
	   *
	   * @param {String|Function} value
	   * @param {Function} cb
	   */

	  Vue.prototype._resolveComponent = function (value, cb) {
	    var factory;
	    if (typeof value === 'function') {
	      factory = value;
	    } else {
	      factory = resolveAsset(this.$options, 'components', value, true);
	    }
	    if (!factory) {
	      return;
	    }
	    // async component factory
	    if (!factory.options) {
	      if (factory.resolved) {
	        // cached
	        cb(factory.resolved);
	      } else if (factory.requested) {
	        // pool callbacks
	        factory.pendingCallbacks.push(cb);
	      } else {
	        factory.requested = true;
	        var cbs = factory.pendingCallbacks = [cb];
	        factory.call(this, function resolve(res) {
	          if (isPlainObject(res)) {
	            res = Vue.extend(res);
	          }
	          // cache resolved
	          factory.resolved = res;
	          // invoke callbacks
	          for (var i = 0, l = cbs.length; i < l; i++) {
	            cbs[i](res);
	          }
	        }, function reject(reason) {
	          process.env.NODE_ENV !== 'production' && warn('Failed to resolve async component' + (typeof value === 'string' ? ': ' + value : '') + '. ' + (reason ? '\nReason: ' + reason : ''));
	        });
	      }
	    } else {
	      // normal component
	      cb(factory);
	    }
	  };
	}

	var filterRE$1 = /[^|]\|[^|]/;

	function dataAPI (Vue) {
	  /**
	   * Get the value from an expression on this vm.
	   *
	   * @param {String} exp
	   * @param {Boolean} [asStatement]
	   * @return {*}
	   */

	  Vue.prototype.$get = function (exp, asStatement) {
	    var res = parseExpression(exp);
	    if (res) {
	      if (asStatement && !isSimplePath(exp)) {
	        var self = this;
	        return function statementHandler() {
	          self.$arguments = toArray(arguments);
	          var result = res.get.call(self, self);
	          self.$arguments = null;
	          return result;
	        };
	      } else {
	        try {
	          return res.get.call(this, this);
	        } catch (e) {}
	      }
	    }
	  };

	  /**
	   * Set the value from an expression on this vm.
	   * The expression must be a valid left-hand
	   * expression in an assignment.
	   *
	   * @param {String} exp
	   * @param {*} val
	   */

	  Vue.prototype.$set = function (exp, val) {
	    var res = parseExpression(exp, true);
	    if (res && res.set) {
	      res.set.call(this, this, val);
	    }
	  };

	  /**
	   * Delete a property on the VM
	   *
	   * @param {String} key
	   */

	  Vue.prototype.$delete = function (key) {
	    del(this._data, key);
	  };

	  /**
	   * Watch an expression, trigger callback when its
	   * value changes.
	   *
	   * @param {String|Function} expOrFn
	   * @param {Function} cb
	   * @param {Object} [options]
	   *                 - {Boolean} deep
	   *                 - {Boolean} immediate
	   * @return {Function} - unwatchFn
	   */

	  Vue.prototype.$watch = function (expOrFn, cb, options) {
	    var vm = this;
	    var parsed;
	    if (typeof expOrFn === 'string') {
	      parsed = parseDirective(expOrFn);
	      expOrFn = parsed.expression;
	    }
	    var watcher = new Watcher(vm, expOrFn, cb, {
	      deep: options && options.deep,
	      sync: options && options.sync,
	      filters: parsed && parsed.filters,
	      user: !options || options.user !== false
	    });
	    if (options && options.immediate) {
	      cb.call(vm, watcher.value);
	    }
	    return function unwatchFn() {
	      watcher.teardown();
	    };
	  };

	  /**
	   * Evaluate a text directive, including filters.
	   *
	   * @param {String} text
	   * @param {Boolean} [asStatement]
	   * @return {String}
	   */

	  Vue.prototype.$eval = function (text, asStatement) {
	    // check for filters.
	    if (filterRE$1.test(text)) {
	      var dir = parseDirective(text);
	      // the filter regex check might give false positive
	      // for pipes inside strings, so it's possible that
	      // we don't get any filters here
	      var val = this.$get(dir.expression, asStatement);
	      return dir.filters ? this._applyFilters(val, null, dir.filters) : val;
	    } else {
	      // no filter
	      return this.$get(text, asStatement);
	    }
	  };

	  /**
	   * Interpolate a piece of template text.
	   *
	   * @param {String} text
	   * @return {String}
	   */

	  Vue.prototype.$interpolate = function (text) {
	    var tokens = parseText(text);
	    var vm = this;
	    if (tokens) {
	      if (tokens.length === 1) {
	        return vm.$eval(tokens[0].value) + '';
	      } else {
	        return tokens.map(function (token) {
	          return token.tag ? vm.$eval(token.value) : token.value;
	        }).join('');
	      }
	    } else {
	      return text;
	    }
	  };

	  /**
	   * Log instance data as a plain JS object
	   * so that it is easier to inspect in console.
	   * This method assumes console is available.
	   *
	   * @param {String} [path]
	   */

	  Vue.prototype.$log = function (path) {
	    var data = path ? getPath(this._data, path) : this._data;
	    if (data) {
	      data = clean(data);
	    }
	    // include computed fields
	    if (!path) {
	      var key;
	      for (key in this.$options.computed) {
	        data[key] = clean(this[key]);
	      }
	      if (this._props) {
	        for (key in this._props) {
	          data[key] = clean(this[key]);
	        }
	      }
	    }
	    console.log(data);
	  };

	  /**
	   * "clean" a getter/setter converted object into a plain
	   * object copy.
	   *
	   * @param {Object} - obj
	   * @return {Object}
	   */

	  function clean(obj) {
	    return JSON.parse(JSON.stringify(obj));
	  }
	}

	function domAPI (Vue) {
	  /**
	   * Convenience on-instance nextTick. The callback is
	   * auto-bound to the instance, and this avoids component
	   * modules having to rely on the global Vue.
	   *
	   * @param {Function} fn
	   */

	  Vue.prototype.$nextTick = function (fn) {
	    nextTick(fn, this);
	  };

	  /**
	   * Append instance to target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */

	  Vue.prototype.$appendTo = function (target, cb, withTransition) {
	    return insert(this, target, cb, withTransition, append, appendWithTransition);
	  };

	  /**
	   * Prepend instance to target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */

	  Vue.prototype.$prependTo = function (target, cb, withTransition) {
	    target = query(target);
	    if (target.hasChildNodes()) {
	      this.$before(target.firstChild, cb, withTransition);
	    } else {
	      this.$appendTo(target, cb, withTransition);
	    }
	    return this;
	  };

	  /**
	   * Insert instance before target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */

	  Vue.prototype.$before = function (target, cb, withTransition) {
	    return insert(this, target, cb, withTransition, beforeWithCb, beforeWithTransition);
	  };

	  /**
	   * Insert instance after target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */

	  Vue.prototype.$after = function (target, cb, withTransition) {
	    target = query(target);
	    if (target.nextSibling) {
	      this.$before(target.nextSibling, cb, withTransition);
	    } else {
	      this.$appendTo(target.parentNode, cb, withTransition);
	    }
	    return this;
	  };

	  /**
	   * Remove instance from DOM
	   *
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */

	  Vue.prototype.$remove = function (cb, withTransition) {
	    if (!this.$el.parentNode) {
	      return cb && cb();
	    }
	    var inDocument = this._isAttached && inDoc(this.$el);
	    // if we are not in document, no need to check
	    // for transitions
	    if (!inDocument) withTransition = false;
	    var self = this;
	    var realCb = function realCb() {
	      if (inDocument) self._callHook('detached');
	      if (cb) cb();
	    };
	    if (this._isFragment) {
	      removeNodeRange(this._fragmentStart, this._fragmentEnd, this, this._fragment, realCb);
	    } else {
	      var op = withTransition === false ? removeWithCb : removeWithTransition;
	      op(this.$el, this, realCb);
	    }
	    return this;
	  };

	  /**
	   * Shared DOM insertion function.
	   *
	   * @param {Vue} vm
	   * @param {Element} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition]
	   * @param {Function} op1 - op for non-transition insert
	   * @param {Function} op2 - op for transition insert
	   * @return vm
	   */

	  function insert(vm, target, cb, withTransition, op1, op2) {
	    target = query(target);
	    var targetIsDetached = !inDoc(target);
	    var op = withTransition === false || targetIsDetached ? op1 : op2;
	    var shouldCallHook = !targetIsDetached && !vm._isAttached && !inDoc(vm.$el);
	    if (vm._isFragment) {
	      mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function (node) {
	        op(node, target, vm);
	      });
	      cb && cb();
	    } else {
	      op(vm.$el, target, vm, cb);
	    }
	    if (shouldCallHook) {
	      vm._callHook('attached');
	    }
	    return vm;
	  }

	  /**
	   * Check for selectors
	   *
	   * @param {String|Element} el
	   */

	  function query(el) {
	    return typeof el === 'string' ? document.querySelector(el) : el;
	  }

	  /**
	   * Append operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Node} target
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */

	  function append(el, target, vm, cb) {
	    target.appendChild(el);
	    if (cb) cb();
	  }

	  /**
	   * InsertBefore operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Node} target
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */

	  function beforeWithCb(el, target, vm, cb) {
	    before(el, target);
	    if (cb) cb();
	  }

	  /**
	   * Remove operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */

	  function removeWithCb(el, vm, cb) {
	    remove(el);
	    if (cb) cb();
	  }
	}

	function eventsAPI (Vue) {
	  /**
	   * Listen on the given `event` with `fn`.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */

	  Vue.prototype.$on = function (event, fn) {
	    (this._events[event] || (this._events[event] = [])).push(fn);
	    modifyListenerCount(this, event, 1);
	    return this;
	  };

	  /**
	   * Adds an `event` listener that will be invoked a single
	   * time then automatically removed.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */

	  Vue.prototype.$once = function (event, fn) {
	    var self = this;
	    function on() {
	      self.$off(event, on);
	      fn.apply(this, arguments);
	    }
	    on.fn = fn;
	    this.$on(event, on);
	    return this;
	  };

	  /**
	   * Remove the given callback for `event` or all
	   * registered callbacks.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */

	  Vue.prototype.$off = function (event, fn) {
	    var cbs;
	    // all
	    if (!arguments.length) {
	      if (this.$parent) {
	        for (event in this._events) {
	          cbs = this._events[event];
	          if (cbs) {
	            modifyListenerCount(this, event, -cbs.length);
	          }
	        }
	      }
	      this._events = {};
	      return this;
	    }
	    // specific event
	    cbs = this._events[event];
	    if (!cbs) {
	      return this;
	    }
	    if (arguments.length === 1) {
	      modifyListenerCount(this, event, -cbs.length);
	      this._events[event] = null;
	      return this;
	    }
	    // specific handler
	    var cb;
	    var i = cbs.length;
	    while (i--) {
	      cb = cbs[i];
	      if (cb === fn || cb.fn === fn) {
	        modifyListenerCount(this, event, -1);
	        cbs.splice(i, 1);
	        break;
	      }
	    }
	    return this;
	  };

	  /**
	   * Trigger an event on self.
	   *
	   * @param {String|Object} event
	   * @return {Boolean} shouldPropagate
	   */

	  Vue.prototype.$emit = function (event) {
	    var isSource = typeof event === 'string';
	    event = isSource ? event : event.name;
	    var cbs = this._events[event];
	    var shouldPropagate = isSource || !cbs;
	    if (cbs) {
	      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
	      // this is a somewhat hacky solution to the question raised
	      // in #2102: for an inline component listener like <comp @test="doThis">,
	      // the propagation handling is somewhat broken. Therefore we
	      // need to treat these inline callbacks differently.
	      var hasParentCbs = isSource && cbs.some(function (cb) {
	        return cb._fromParent;
	      });
	      if (hasParentCbs) {
	        shouldPropagate = false;
	      }
	      var args = toArray(arguments, 1);
	      for (var i = 0, l = cbs.length; i < l; i++) {
	        var cb = cbs[i];
	        var res = cb.apply(this, args);
	        if (res === true && (!hasParentCbs || cb._fromParent)) {
	          shouldPropagate = true;
	        }
	      }
	    }
	    return shouldPropagate;
	  };

	  /**
	   * Recursively broadcast an event to all children instances.
	   *
	   * @param {String|Object} event
	   * @param {...*} additional arguments
	   */

	  Vue.prototype.$broadcast = function (event) {
	    var isSource = typeof event === 'string';
	    event = isSource ? event : event.name;
	    // if no child has registered for this event,
	    // then there's no need to broadcast.
	    if (!this._eventsCount[event]) return;
	    var children = this.$children;
	    var args = toArray(arguments);
	    if (isSource) {
	      // use object event to indicate non-source emit
	      // on children
	      args[0] = { name: event, source: this };
	    }
	    for (var i = 0, l = children.length; i < l; i++) {
	      var child = children[i];
	      var shouldPropagate = child.$emit.apply(child, args);
	      if (shouldPropagate) {
	        child.$broadcast.apply(child, args);
	      }
	    }
	    return this;
	  };

	  /**
	   * Recursively propagate an event up the parent chain.
	   *
	   * @param {String} event
	   * @param {...*} additional arguments
	   */

	  Vue.prototype.$dispatch = function (event) {
	    var shouldPropagate = this.$emit.apply(this, arguments);
	    if (!shouldPropagate) return;
	    var parent = this.$parent;
	    var args = toArray(arguments);
	    // use object event to indicate non-source emit
	    // on parents
	    args[0] = { name: event, source: this };
	    while (parent) {
	      shouldPropagate = parent.$emit.apply(parent, args);
	      parent = shouldPropagate ? parent.$parent : null;
	    }
	    return this;
	  };

	  /**
	   * Modify the listener counts on all parents.
	   * This bookkeeping allows $broadcast to return early when
	   * no child has listened to a certain event.
	   *
	   * @param {Vue} vm
	   * @param {String} event
	   * @param {Number} count
	   */

	  var hookRE = /^hook:/;
	  function modifyListenerCount(vm, event, count) {
	    var parent = vm.$parent;
	    // hooks do not get broadcasted so no need
	    // to do bookkeeping for them
	    if (!parent || !count || hookRE.test(event)) return;
	    while (parent) {
	      parent._eventsCount[event] = (parent._eventsCount[event] || 0) + count;
	      parent = parent.$parent;
	    }
	  }
	}

	function lifecycleAPI (Vue) {
	  /**
	   * Set instance target element and kick off the compilation
	   * process. The passed in `el` can be a selector string, an
	   * existing Element, or a DocumentFragment (for block
	   * instances).
	   *
	   * @param {Element|DocumentFragment|string} el
	   * @public
	   */

	  Vue.prototype.$mount = function (el) {
	    if (this._isCompiled) {
	      process.env.NODE_ENV !== 'production' && warn('$mount() should be called only once.', this);
	      return;
	    }
	    el = query(el);
	    if (!el) {
	      el = document.createElement('div');
	    }
	    this._compile(el);
	    this._initDOMHooks();
	    if (inDoc(this.$el)) {
	      this._callHook('attached');
	      ready.call(this);
	    } else {
	      this.$once('hook:attached', ready);
	    }
	    return this;
	  };

	  /**
	   * Mark an instance as ready.
	   */

	  function ready() {
	    this._isAttached = true;
	    this._isReady = true;
	    this._callHook('ready');
	  }

	  /**
	   * Teardown the instance, simply delegate to the internal
	   * _destroy.
	   *
	   * @param {Boolean} remove
	   * @param {Boolean} deferCleanup
	   */

	  Vue.prototype.$destroy = function (remove, deferCleanup) {
	    this._destroy(remove, deferCleanup);
	  };

	  /**
	   * Partially compile a piece of DOM and return a
	   * decompile function.
	   *
	   * @param {Element|DocumentFragment} el
	   * @param {Vue} [host]
	   * @param {Object} [scope]
	   * @param {Fragment} [frag]
	   * @return {Function}
	   */

	  Vue.prototype.$compile = function (el, host, scope, frag) {
	    return compile(el, this.$options, true)(this, el, host, scope, frag);
	  };
	}

	/**
	 * The exposed Vue constructor.
	 *
	 * API conventions:
	 * - public API methods/properties are prefixed with `$`
	 * - internal methods/properties are prefixed with `_`
	 * - non-prefixed properties are assumed to be proxied user
	 *   data.
	 *
	 * @constructor
	 * @param {Object} [options]
	 * @public
	 */

	function Vue(options) {
	  this._init(options);
	}

	// install internals
	initMixin(Vue);
	stateMixin(Vue);
	eventsMixin(Vue);
	lifecycleMixin(Vue);
	miscMixin(Vue);

	// install instance APIs
	dataAPI(Vue);
	domAPI(Vue);
	eventsAPI(Vue);
	lifecycleAPI(Vue);

	var slot = {

	  priority: SLOT,
	  params: ['name'],

	  bind: function bind() {
	    // this was resolved during component transclusion
	    var name = this.params.name || 'default';
	    var content = this.vm._slotContents && this.vm._slotContents[name];
	    if (!content || !content.hasChildNodes()) {
	      this.fallback();
	    } else {
	      this.compile(content.cloneNode(true), this.vm._context, this.vm);
	    }
	  },

	  compile: function compile(content, context, host) {
	    if (content && context) {
	      if (this.el.hasChildNodes() && content.childNodes.length === 1 && content.childNodes[0].nodeType === 1 && content.childNodes[0].hasAttribute('v-if')) {
	        // if the inserted slot has v-if
	        // inject fallback content as the v-else
	        var elseBlock = document.createElement('template');
	        elseBlock.setAttribute('v-else', '');
	        elseBlock.innerHTML = this.el.innerHTML;
	        // the else block should be compiled in child scope
	        elseBlock._context = this.vm;
	        content.appendChild(elseBlock);
	      }
	      var scope = host ? host._scope : this._scope;
	      this.unlink = context.$compile(content, host, scope, this._frag);
	    }
	    if (content) {
	      replace(this.el, content);
	    } else {
	      remove(this.el);
	    }
	  },

	  fallback: function fallback() {
	    this.compile(extractContent(this.el, true), this.vm);
	  },

	  unbind: function unbind() {
	    if (this.unlink) {
	      this.unlink();
	    }
	  }
	};

	var partial = {

	  priority: PARTIAL,

	  params: ['name'],

	  // watch changes to name for dynamic partials
	  paramWatchers: {
	    name: function name(value) {
	      vIf.remove.call(this);
	      if (value) {
	        this.insert(value);
	      }
	    }
	  },

	  bind: function bind() {
	    this.anchor = createAnchor('v-partial');
	    replace(this.el, this.anchor);
	    this.insert(this.params.name);
	  },

	  insert: function insert(id) {
	    var partial = resolveAsset(this.vm.$options, 'partials', id, true);
	    if (partial) {
	      this.factory = new FragmentFactory(this.vm, partial);
	      vIf.insert.call(this);
	    }
	  },

	  unbind: function unbind() {
	    if (this.frag) {
	      this.frag.destroy();
	    }
	  }
	};

	var elementDirectives = {
	  slot: slot,
	  partial: partial
	};

	var convertArray = vFor._postProcess;

	/**
	 * Limit filter for arrays
	 *
	 * @param {Number} n
	 * @param {Number} offset (Decimal expected)
	 */

	function limitBy(arr, n, offset) {
	  offset = offset ? parseInt(offset, 10) : 0;
	  n = toNumber(n);
	  return typeof n === 'number' ? arr.slice(offset, offset + n) : arr;
	}

	/**
	 * Filter filter for arrays
	 *
	 * @param {String} search
	 * @param {String} [delimiter]
	 * @param {String} ...dataKeys
	 */

	function filterBy(arr, search, delimiter) {
	  arr = convertArray(arr);
	  if (search == null) {
	    return arr;
	  }
	  if (typeof search === 'function') {
	    return arr.filter(search);
	  }
	  // cast to lowercase string
	  search = ('' + search).toLowerCase();
	  // allow optional `in` delimiter
	  // because why not
	  var n = delimiter === 'in' ? 3 : 2;
	  // extract and flatten keys
	  var keys = Array.prototype.concat.apply([], toArray(arguments, n));
	  var res = [];
	  var item, key, val, j;
	  for (var i = 0, l = arr.length; i < l; i++) {
	    item = arr[i];
	    val = item && item.$value || item;
	    j = keys.length;
	    if (j) {
	      while (j--) {
	        key = keys[j];
	        if (key === '$key' && contains(item.$key, search) || contains(getPath(val, key), search)) {
	          res.push(item);
	          break;
	        }
	      }
	    } else if (contains(item, search)) {
	      res.push(item);
	    }
	  }
	  return res;
	}

	/**
	 * Filter filter for arrays
	 *
	 * @param {String|Array<String>|Function} ...sortKeys
	 * @param {Number} [order]
	 */

	function orderBy(arr) {
	  var comparator = null;
	  var sortKeys = undefined;
	  arr = convertArray(arr);

	  // determine order (last argument)
	  var args = toArray(arguments, 1);
	  var order = args[args.length - 1];
	  if (typeof order === 'number') {
	    order = order < 0 ? -1 : 1;
	    args = args.length > 1 ? args.slice(0, -1) : args;
	  } else {
	    order = 1;
	  }

	  // determine sortKeys & comparator
	  var firstArg = args[0];
	  if (!firstArg) {
	    return arr;
	  } else if (typeof firstArg === 'function') {
	    // custom comparator
	    comparator = function (a, b) {
	      return firstArg(a, b) * order;
	    };
	  } else {
	    // string keys. flatten first
	    sortKeys = Array.prototype.concat.apply([], args);
	    comparator = function (a, b, i) {
	      i = i || 0;
	      return i >= sortKeys.length - 1 ? baseCompare(a, b, i) : baseCompare(a, b, i) || comparator(a, b, i + 1);
	    };
	  }

	  function baseCompare(a, b, sortKeyIndex) {
	    var sortKey = sortKeys[sortKeyIndex];
	    if (sortKey) {
	      if (sortKey !== '$key') {
	        if (isObject(a) && '$value' in a) a = a.$value;
	        if (isObject(b) && '$value' in b) b = b.$value;
	      }
	      a = isObject(a) ? getPath(a, sortKey) : a;
	      b = isObject(b) ? getPath(b, sortKey) : b;
	    }
	    return a === b ? 0 : a > b ? order : -order;
	  }

	  // sort on a copy to avoid mutating original array
	  return arr.slice().sort(comparator);
	}

	/**
	 * String contain helper
	 *
	 * @param {*} val
	 * @param {String} search
	 */

	function contains(val, search) {
	  var i;
	  if (isPlainObject(val)) {
	    var keys = Object.keys(val);
	    i = keys.length;
	    while (i--) {
	      if (contains(val[keys[i]], search)) {
	        return true;
	      }
	    }
	  } else if (isArray(val)) {
	    i = val.length;
	    while (i--) {
	      if (contains(val[i], search)) {
	        return true;
	      }
	    }
	  } else if (val != null) {
	    return val.toString().toLowerCase().indexOf(search) > -1;
	  }
	}

	var digitsRE = /(\d{3})(?=\d)/g;

	// asset collections must be a plain object.
	var filters = {

	  orderBy: orderBy,
	  filterBy: filterBy,
	  limitBy: limitBy,

	  /**
	   * Stringify value.
	   *
	   * @param {Number} indent
	   */

	  json: {
	    read: function read(value, indent) {
	      return typeof value === 'string' ? value : JSON.stringify(value, null, Number(indent) || 2);
	    },
	    write: function write(value) {
	      try {
	        return JSON.parse(value);
	      } catch (e) {
	        return value;
	      }
	    }
	  },

	  /**
	   * 'abc' => 'Abc'
	   */

	  capitalize: function capitalize(value) {
	    if (!value && value !== 0) return '';
	    value = value.toString();
	    return value.charAt(0).toUpperCase() + value.slice(1);
	  },

	  /**
	   * 'abc' => 'ABC'
	   */

	  uppercase: function uppercase(value) {
	    return value || value === 0 ? value.toString().toUpperCase() : '';
	  },

	  /**
	   * 'AbC' => 'abc'
	   */

	  lowercase: function lowercase(value) {
	    return value || value === 0 ? value.toString().toLowerCase() : '';
	  },

	  /**
	   * 12345 => $12,345.00
	   *
	   * @param {String} sign
	   */

	  currency: function currency(value, _currency) {
	    value = parseFloat(value);
	    if (!isFinite(value) || !value && value !== 0) return '';
	    _currency = _currency != null ? _currency : '$';
	    var stringified = Math.abs(value).toFixed(2);
	    var _int = stringified.slice(0, -3);
	    var i = _int.length % 3;
	    var head = i > 0 ? _int.slice(0, i) + (_int.length > 3 ? ',' : '') : '';
	    var _float = stringified.slice(-3);
	    var sign = value < 0 ? '-' : '';
	    return sign + _currency + head + _int.slice(i).replace(digitsRE, '$1,') + _float;
	  },

	  /**
	   * 'item' => 'items'
	   *
	   * @params
	   *  an array of strings corresponding to
	   *  the single, double, triple ... forms of the word to
	   *  be pluralized. When the number to be pluralized
	   *  exceeds the length of the args, it will use the last
	   *  entry in the array.
	   *
	   *  e.g. ['single', 'double', 'triple', 'multiple']
	   */

	  pluralize: function pluralize(value) {
	    var args = toArray(arguments, 1);
	    return args.length > 1 ? args[value % 10 - 1] || args[args.length - 1] : args[0] + (value === 1 ? '' : 's');
	  },

	  /**
	   * Debounce a handler function.
	   *
	   * @param {Function} handler
	   * @param {Number} delay = 300
	   * @return {Function}
	   */

	  debounce: function debounce(handler, delay) {
	    if (!handler) return;
	    if (!delay) {
	      delay = 300;
	    }
	    return _debounce(handler, delay);
	  }
	};

	function installGlobalAPI (Vue) {
	  /**
	   * Vue and every constructor that extends Vue has an
	   * associated options object, which can be accessed during
	   * compilation steps as `this.constructor.options`.
	   *
	   * These can be seen as the default options of every
	   * Vue instance.
	   */

	  Vue.options = {
	    directives: directives,
	    elementDirectives: elementDirectives,
	    filters: filters,
	    transitions: {},
	    components: {},
	    partials: {},
	    replace: true
	  };

	  /**
	   * Expose useful internals
	   */

	  Vue.util = util;
	  Vue.config = config;
	  Vue.set = set;
	  Vue['delete'] = del;
	  Vue.nextTick = nextTick;

	  /**
	   * The following are exposed for advanced usage / plugins
	   */

	  Vue.compiler = compiler;
	  Vue.FragmentFactory = FragmentFactory;
	  Vue.internalDirectives = internalDirectives;
	  Vue.parsers = {
	    path: path,
	    text: text,
	    template: template,
	    directive: directive,
	    expression: expression
	  };

	  /**
	   * Each instance constructor, including Vue, has a unique
	   * cid. This enables us to create wrapped "child
	   * constructors" for prototypal inheritance and cache them.
	   */

	  Vue.cid = 0;
	  var cid = 1;

	  /**
	   * Class inheritance
	   *
	   * @param {Object} extendOptions
	   */

	  Vue.extend = function (extendOptions) {
	    extendOptions = extendOptions || {};
	    var Super = this;
	    var isFirstExtend = Super.cid === 0;
	    if (isFirstExtend && extendOptions._Ctor) {
	      return extendOptions._Ctor;
	    }
	    var name = extendOptions.name || Super.options.name;
	    if (process.env.NODE_ENV !== 'production') {
	      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
	        warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characaters and the hyphen.');
	        name = null;
	      }
	    }
	    var Sub = createClass(name || 'VueComponent');
	    Sub.prototype = Object.create(Super.prototype);
	    Sub.prototype.constructor = Sub;
	    Sub.cid = cid++;
	    Sub.options = mergeOptions(Super.options, extendOptions);
	    Sub['super'] = Super;
	    // allow further extension
	    Sub.extend = Super.extend;
	    // create asset registers, so extended classes
	    // can have their private assets too.
	    config._assetTypes.forEach(function (type) {
	      Sub[type] = Super[type];
	    });
	    // enable recursive self-lookup
	    if (name) {
	      Sub.options.components[name] = Sub;
	    }
	    // cache constructor
	    if (isFirstExtend) {
	      extendOptions._Ctor = Sub;
	    }
	    return Sub;
	  };

	  /**
	   * A function that returns a sub-class constructor with the
	   * given name. This gives us much nicer output when
	   * logging instances in the console.
	   *
	   * @param {String} name
	   * @return {Function}
	   */

	  function createClass(name) {
	    /* eslint-disable no-new-func */
	    return new Function('return function ' + classify(name) + ' (options) { this._init(options) }')();
	    /* eslint-enable no-new-func */
	  }

	  /**
	   * Plugin system
	   *
	   * @param {Object} plugin
	   */

	  Vue.use = function (plugin) {
	    /* istanbul ignore if */
	    if (plugin.installed) {
	      return;
	    }
	    // additional parameters
	    var args = toArray(arguments, 1);
	    args.unshift(this);
	    if (typeof plugin.install === 'function') {
	      plugin.install.apply(plugin, args);
	    } else {
	      plugin.apply(null, args);
	    }
	    plugin.installed = true;
	    return this;
	  };

	  /**
	   * Apply a global mixin by merging it into the default
	   * options.
	   */

	  Vue.mixin = function (mixin) {
	    Vue.options = mergeOptions(Vue.options, mixin);
	  };

	  /**
	   * Create asset registration methods with the following
	   * signature:
	   *
	   * @param {String} id
	   * @param {*} definition
	   */

	  config._assetTypes.forEach(function (type) {
	    Vue[type] = function (id, definition) {
	      if (!definition) {
	        return this.options[type + 's'][id];
	      } else {
	        /* istanbul ignore if */
	        if (process.env.NODE_ENV !== 'production') {
	          if (type === 'component' && (commonTagRE.test(id) || reservedTagRE.test(id))) {
	            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
	          }
	        }
	        if (type === 'component' && isPlainObject(definition)) {
	          definition.name = id;
	          definition = Vue.extend(definition);
	        }
	        this.options[type + 's'][id] = definition;
	        return definition;
	      }
	    };
	  });

	  // expose internal transition API
	  extend(Vue.transition, transition);
	}

	installGlobalAPI(Vue);

	Vue.version = '1.0.21';

	// devtools global hook
	/* istanbul ignore next */
	setTimeout(function () {
	  if (config.devtools) {
	    if (devtools) {
	      devtools.emit('init', Vue);
	    } else if (process.env.NODE_ENV !== 'production' && inBrowser && /Chrome\/\d+/.test(window.navigator.userAgent)) {
	      console.log('Download the Vue Devtools for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
	    }
	  }
	}, 0);

	module.exports = Vue;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(2)))

/***/ },
/* 2 */
/***/ function(module, exports) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var katex = __webpack_require__(4)
	var mk = __webpack_require__(27)
	var md = __webpack_require__(28)()


	// md.use(mk)

	/*
	  change to Katex for math rendering
	 */
	md.use(__webpack_require__(105), {
	  inlineOpen: '$',
	  inlineClose: '$',
	  blockOpen: '$$',
	  blockClose: '$$',
	  inlineRenderer: function (str) {
	    console.log('----', str)
	    var strHtml = str
	    var tpl = '<span class="math inline latex-error" data-latex="$data$">$latex$</span>'

	    try {
	      strHtml = katex.renderToString(str)
	      tpl = tpl.replace('error', '')
	    } catch (e) {
	      // console.log('[----]', e, str)
	    }

	    return tpl.replace('$latex$', strHtml).replace('$data$', str)
	  },
	  blockRenderer: function (str) {
	    var strHtml = str
	    var tpl = '<span class="math block latex-error" data-latex="$data$">$latex$</span>'
	    try {
	      strHtml = katex.renderToString(str)
	      tpl = tpl.replace('error', '')
	    } catch (e) {
	      // console.log('[----]', e, str)
	    }

	    return tpl.replace('$latex$', strHtml).replace('$data$', str);
	  }
	});




	md.renderer.rules.image = function(tokens, idx, options, env, self){
	  
	  var token = tokens[idx]

	  var src = ''

	  if(token.attrs && token.attrs[0] && token.attrs[0][1]){
	    src = token.attrs[0] && token.attrs[0][1]
	  }
	  var exp = src.match(/#(.*)/)
	  var styl = 'float: $;'
	  if(exp && exp[1]){
	    exp = exp[1]
	  }

	  if(exp === 'right' || exp === 'left'){
	    styl = styl.replace('$', exp)
	    token.attrs.push(['style', styl])
	  }

	  // "alt" attr MUST be set, even if empty. Because it's mandatory and
	  // should be placed on proper position for tests.
	  //
	  // Replace content with actual value

	  token.attrs[token.attrIndex('alt')][1] =
	    self.renderInlineAsText(token.children, options, env);

	  return self.renderToken(tokens, idx, options);
	}


	module.exports = md 

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * This is the main entry point for KaTeX. Here, we expose functions for
	 * rendering expressions either to DOM nodes or to markup strings.
	 *
	 * We also expose the ParseError class to check if errors thrown from KaTeX are
	 * errors in the expression, or errors in javascript handling.
	 */

	var ParseError = __webpack_require__(5);
	var Settings = __webpack_require__(6);

	var buildTree = __webpack_require__(7);
	var parseTree = __webpack_require__(20);
	var utils = __webpack_require__(12);

	/**
	 * Parse and build an expression, and place that expression in the DOM node
	 * given.
	 */
	var render = function(expression, baseNode, options) {
	    utils.clearNode(baseNode);

	    var settings = new Settings(options);

	    var tree = parseTree(expression, settings);
	    var node = buildTree(tree, expression, settings).toNode();

	    baseNode.appendChild(node);
	};

	// KaTeX's styles don't work properly in quirks mode. Print out an error, and
	// disable rendering.
	if (typeof document !== "undefined") {
	    if (document.compatMode !== "CSS1Compat") {
	        typeof console !== "undefined" && console.warn(
	            "Warning: KaTeX doesn't work in quirks mode. Make sure your " +
	                "website has a suitable doctype.");

	        render = function() {
	            throw new ParseError("KaTeX doesn't work in quirks mode.");
	        };
	    }
	}

	/**
	 * Parse and build an expression, and return the markup for that.
	 */
	var renderToString = function(expression, options) {
	    var settings = new Settings(options);

	    var tree = parseTree(expression, settings);
	    return buildTree(tree, expression, settings).toMarkup();
	};

	/**
	 * Parse an expression and return the parse tree.
	 */
	var generateParseTree = function(expression, options) {
	    var settings = new Settings(options);
	    return parseTree(expression, settings);
	};

	module.exports = {
	    render: render,
	    renderToString: renderToString,
	    /**
	     * NOTE: This method is not currently recommended for public use.
	     * The internal tree representation is unstable and is very likely
	     * to change. Use at your own risk.
	     */
	    __parse: generateParseTree,
	    ParseError: ParseError
	};


/***/ },
/* 5 */
/***/ function(module, exports) {

	/**
	 * This is the ParseError class, which is the main error thrown by KaTeX
	 * functions when something has gone wrong. This is used to distinguish internal
	 * errors from errors in the expression that the user provided.
	 */
	function ParseError(message, lexer, position) {
	    var error = "KaTeX parse error: " + message;

	    if (lexer !== undefined && position !== undefined) {
	        // If we have the input and a position, make the error a bit fancier

	        // Prepend some information
	        error += " at position " + position + ": ";

	        // Get the input
	        var input = lexer._input;
	        // Insert a combining underscore at the correct position
	        input = input.slice(0, position) + "\u0332" +
	            input.slice(position);

	        // Extract some context from the input and add it to the error
	        var begin = Math.max(0, position - 15);
	        var end = position + 15;
	        error += input.slice(begin, end);
	    }

	    // Some hackery to make ParseError a prototype of Error
	    // See http://stackoverflow.com/a/8460753
	    var self = new Error(error);
	    self.name = "ParseError";
	    self.__proto__ = ParseError.prototype;

	    self.position = position;
	    return self;
	}

	// More hackery
	ParseError.prototype.__proto__ = Error.prototype;

	module.exports = ParseError;


/***/ },
/* 6 */
/***/ function(module, exports) {

	/**
	 * This is a module for storing settings passed into KaTeX. It correctly handles
	 * default settings.
	 */

	/**
	 * Helper function for getting a default value if the value is undefined
	 */
	function get(option, defaultValue) {
	    return option === undefined ? defaultValue : option;
	}

	/**
	 * The main Settings object
	 *
	 * The current options stored are:
	 *  - displayMode: Whether the expression should be typeset by default in
	 *                 textstyle or displaystyle (default false)
	 */
	function Settings(options) {
	    // allow null options
	    options = options || {};
	    this.displayMode = get(options.displayMode, false);
	    this.throwOnError = get(options.throwOnError, true);
	    this.errorColor = get(options.errorColor, "#cc0000");
	}

	module.exports = Settings;


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var buildHTML = __webpack_require__(8);
	var buildMathML = __webpack_require__(17);
	var buildCommon = __webpack_require__(10);
	var Options = __webpack_require__(19);
	var Settings = __webpack_require__(6);
	var Style = __webpack_require__(9);

	var makeSpan = buildCommon.makeSpan;

	var buildTree = function(tree, expression, settings) {
	    settings = settings || new Settings({});

	    var startStyle = Style.TEXT;
	    if (settings.displayMode) {
	        startStyle = Style.DISPLAY;
	    }

	    // Setup the default options
	    var options = new Options({
	        style: startStyle,
	        size: "size5"
	    });

	    // `buildHTML` sometimes messes with the parse tree (like turning bins ->
	    // ords), so we build the MathML version first.
	    var mathMLNode = buildMathML(tree, expression, options);
	    var htmlNode = buildHTML(tree, options);

	    var katexNode = makeSpan(["katex"], [
	        mathMLNode, htmlNode
	    ]);

	    if (settings.displayMode) {
	        return makeSpan(["katex-display"], [katexNode]);
	    } else {
	        return katexNode;
	    }
	};

	module.exports = buildTree;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * This file does the main work of building a domTree structure from a parse
	 * tree. The entry point is the `buildHTML` function, which takes a parse tree.
	 * Then, the buildExpression, buildGroup, and various groupTypes functions are
	 * called, to produce a final HTML tree.
	 */

	var ParseError = __webpack_require__(5);
	var Style = __webpack_require__(9);

	var buildCommon = __webpack_require__(10);
	var delimiter = __webpack_require__(16);
	var domTree = __webpack_require__(11);
	var fontMetrics = __webpack_require__(13);
	var utils = __webpack_require__(12);

	var makeSpan = buildCommon.makeSpan;

	/**
	 * Take a list of nodes, build them in order, and return a list of the built
	 * nodes. This function handles the `prev` node correctly, and passes the
	 * previous element from the list as the prev of the next element.
	 */
	var buildExpression = function(expression, options, prev) {
	    var groups = [];
	    for (var i = 0; i < expression.length; i++) {
	        var group = expression[i];
	        groups.push(buildGroup(group, options, prev));
	        prev = group;
	    }
	    return groups;
	};

	// List of types used by getTypeOfGroup,
	// see https://github.com/Khan/KaTeX/wiki/Examining-TeX#group-types
	var groupToType = {
	    mathord: "mord",
	    textord: "mord",
	    bin: "mbin",
	    rel: "mrel",
	    text: "mord",
	    open: "mopen",
	    close: "mclose",
	    inner: "minner",
	    genfrac: "mord",
	    array: "mord",
	    spacing: "mord",
	    punct: "mpunct",
	    ordgroup: "mord",
	    op: "mop",
	    katex: "mord",
	    overline: "mord",
	    rule: "mord",
	    leftright: "minner",
	    sqrt: "mord",
	    accent: "mord"
	};

	/**
	 * Gets the final math type of an expression, given its group type. This type is
	 * used to determine spacing between elements, and affects bin elements by
	 * causing them to change depending on what types are around them. This type
	 * must be attached to the outermost node of an element as a CSS class so that
	 * spacing with its surrounding elements works correctly.
	 *
	 * Some elements can be mapped one-to-one from group type to math type, and
	 * those are listed in the `groupToType` table.
	 *
	 * Others (usually elements that wrap around other elements) often have
	 * recursive definitions, and thus call `getTypeOfGroup` on their inner
	 * elements.
	 */
	var getTypeOfGroup = function(group) {
	    if (group == null) {
	        // Like when typesetting $^3$
	        return groupToType.mathord;
	    } else if (group.type === "supsub") {
	        return getTypeOfGroup(group.value.base);
	    } else if (group.type === "llap" || group.type === "rlap") {
	        return getTypeOfGroup(group.value);
	    } else if (group.type === "color") {
	        return getTypeOfGroup(group.value.value);
	    } else if (group.type === "sizing") {
	        return getTypeOfGroup(group.value.value);
	    } else if (group.type === "styling") {
	        return getTypeOfGroup(group.value.value);
	    } else if (group.type === "delimsizing") {
	        return groupToType[group.value.delimType];
	    } else {
	        return groupToType[group.type];
	    }
	};

	/**
	 * Sometimes, groups perform special rules when they have superscripts or
	 * subscripts attached to them. This function lets the `supsub` group know that
	 * its inner element should handle the superscripts and subscripts instead of
	 * handling them itself.
	 */
	var shouldHandleSupSub = function(group, options) {
	    if (!group) {
	        return false;
	    } else if (group.type === "op") {
	        // Operators handle supsubs differently when they have limits
	        // (e.g. `\displaystyle\sum_2^3`)
	        return group.value.limits &&
	            (options.style.size === Style.DISPLAY.size || group.value.alwaysHandleSupSub);
	    } else if (group.type === "accent") {
	        return isCharacterBox(group.value.base);
	    } else {
	        return null;
	    }
	};

	/**
	 * Sometimes we want to pull out the innermost element of a group. In most
	 * cases, this will just be the group itself, but when ordgroups and colors have
	 * a single element, we want to pull that out.
	 */
	var getBaseElem = function(group) {
	    if (!group) {
	        return false;
	    } else if (group.type === "ordgroup") {
	        if (group.value.length === 1) {
	            return getBaseElem(group.value[0]);
	        } else {
	            return group;
	        }
	    } else if (group.type === "color") {
	        if (group.value.value.length === 1) {
	            return getBaseElem(group.value.value[0]);
	        } else {
	            return group;
	        }
	    } else {
	        return group;
	    }
	};

	/**
	 * TeXbook algorithms often reference "character boxes", which are simply groups
	 * with a single character in them. To decide if something is a character box,
	 * we find its innermost group, and see if it is a single character.
	 */
	var isCharacterBox = function(group) {
	    var baseElem = getBaseElem(group);

	    // These are all they types of groups which hold single characters
	    return baseElem.type === "mathord" ||
	        baseElem.type === "textord" ||
	        baseElem.type === "bin" ||
	        baseElem.type === "rel" ||
	        baseElem.type === "inner" ||
	        baseElem.type === "open" ||
	        baseElem.type === "close" ||
	        baseElem.type === "punct";
	};

	var makeNullDelimiter = function(options) {
	    return makeSpan([
	        "sizing", "reset-" + options.size, "size5",
	        options.style.reset(), Style.TEXT.cls(),
	        "nulldelimiter"
	    ]);
	};

	/**
	 * This is a map of group types to the function used to handle that type.
	 * Simpler types come at the beginning, while complicated types come afterwards.
	 */
	var groupTypes = {
	    mathord: function(group, options, prev) {
	        return buildCommon.makeOrd(group, options, "mathord");
	    },

	    textord: function(group, options, prev) {
	        return buildCommon.makeOrd(group, options, "textord");
	    },

	    bin: function(group, options, prev) {
	        var className = "mbin";
	        // Pull out the most recent element. Do some special handling to find
	        // things at the end of a \color group. Note that we don't use the same
	        // logic for ordgroups (which count as ords).
	        var prevAtom = prev;
	        while (prevAtom && prevAtom.type === "color") {
	            var atoms = prevAtom.value.value;
	            prevAtom = atoms[atoms.length - 1];
	        }
	        // See TeXbook pg. 442-446, Rules 5 and 6, and the text before Rule 19.
	        // Here, we determine whether the bin should turn into an ord. We
	        // currently only apply Rule 5.
	        if (!prev || utils.contains(["mbin", "mopen", "mrel", "mop", "mpunct"],
	                getTypeOfGroup(prevAtom))) {
	            group.type = "textord";
	            className = "mord";
	        }

	        return buildCommon.mathsym(
	            group.value, group.mode, options.getColor(), [className]);
	    },

	    rel: function(group, options, prev) {
	        return buildCommon.mathsym(
	            group.value, group.mode, options.getColor(), ["mrel"]);
	    },

	    open: function(group, options, prev) {
	        return buildCommon.mathsym(
	            group.value, group.mode, options.getColor(), ["mopen"]);
	    },

	    close: function(group, options, prev) {
	        return buildCommon.mathsym(
	            group.value, group.mode, options.getColor(), ["mclose"]);
	    },

	    inner: function(group, options, prev) {
	        return buildCommon.mathsym(
	            group.value, group.mode, options.getColor(), ["minner"]);
	    },

	    punct: function(group, options, prev) {
	        return buildCommon.mathsym(
	            group.value, group.mode, options.getColor(), ["mpunct"]);
	    },

	    ordgroup: function(group, options, prev) {
	        return makeSpan(
	            ["mord", options.style.cls()],
	            buildExpression(group.value, options.reset())
	        );
	    },

	    text: function(group, options, prev) {
	        return makeSpan(["text", "mord", options.style.cls()],
	            buildExpression(group.value.body, options.reset()));
	    },

	    color: function(group, options, prev) {
	        var elements = buildExpression(
	            group.value.value,
	            options.withColor(group.value.color),
	            prev
	        );

	        // \color isn't supposed to affect the type of the elements it contains.
	        // To accomplish this, we wrap the results in a fragment, so the inner
	        // elements will be able to directly interact with their neighbors. For
	        // example, `\color{red}{2 +} 3` has the same spacing as `2 + 3`
	        return new buildCommon.makeFragment(elements);
	    },

	    supsub: function(group, options, prev) {
	        // Superscript and subscripts are handled in the TeXbook on page
	        // 445-446, rules 18(a-f).

	        // Here is where we defer to the inner group if it should handle
	        // superscripts and subscripts itself.
	        if (shouldHandleSupSub(group.value.base, options)) {
	            return groupTypes[group.value.base.type](group, options, prev);
	        }

	        var base = buildGroup(group.value.base, options.reset());
	        var supmid, submid, sup, sub;

	        if (group.value.sup) {
	            sup = buildGroup(group.value.sup,
	                    options.withStyle(options.style.sup()));
	            supmid = makeSpan(
	                    [options.style.reset(), options.style.sup().cls()], [sup]);
	        }

	        if (group.value.sub) {
	            sub = buildGroup(group.value.sub,
	                    options.withStyle(options.style.sub()));
	            submid = makeSpan(
	                    [options.style.reset(), options.style.sub().cls()], [sub]);
	        }

	        // Rule 18a
	        var supShift, subShift;
	        if (isCharacterBox(group.value.base)) {
	            supShift = 0;
	            subShift = 0;
	        } else {
	            supShift = base.height - fontMetrics.metrics.supDrop;
	            subShift = base.depth + fontMetrics.metrics.subDrop;
	        }

	        // Rule 18c
	        var minSupShift;
	        if (options.style === Style.DISPLAY) {
	            minSupShift = fontMetrics.metrics.sup1;
	        } else if (options.style.cramped) {
	            minSupShift = fontMetrics.metrics.sup3;
	        } else {
	            minSupShift = fontMetrics.metrics.sup2;
	        }

	        // scriptspace is a font-size-independent size, so scale it
	        // appropriately
	        var multiplier = Style.TEXT.sizeMultiplier *
	                options.style.sizeMultiplier;
	        var scriptspace =
	            (0.5 / fontMetrics.metrics.ptPerEm) / multiplier + "em";

	        var supsub;
	        if (!group.value.sup) {
	            // Rule 18b
	            subShift = Math.max(
	                subShift, fontMetrics.metrics.sub1,
	                sub.height - 0.8 * fontMetrics.metrics.xHeight);

	            supsub = buildCommon.makeVList([
	                {type: "elem", elem: submid}
	            ], "shift", subShift, options);

	            supsub.children[0].style.marginRight = scriptspace;

	            // Subscripts shouldn't be shifted by the base's italic correction.
	            // Account for that by shifting the subscript back the appropriate
	            // amount. Note we only do this when the base is a single symbol.
	            if (base instanceof domTree.symbolNode) {
	                supsub.children[0].style.marginLeft = -base.italic + "em";
	            }
	        } else if (!group.value.sub) {
	            // Rule 18c, d
	            supShift = Math.max(supShift, minSupShift,
	                sup.depth + 0.25 * fontMetrics.metrics.xHeight);

	            supsub = buildCommon.makeVList([
	                {type: "elem", elem: supmid}
	            ], "shift", -supShift, options);

	            supsub.children[0].style.marginRight = scriptspace;
	        } else {
	            supShift = Math.max(
	                supShift, minSupShift,
	                sup.depth + 0.25 * fontMetrics.metrics.xHeight);
	            subShift = Math.max(subShift, fontMetrics.metrics.sub2);

	            var ruleWidth = fontMetrics.metrics.defaultRuleThickness;

	            // Rule 18e
	            if ((supShift - sup.depth) - (sub.height - subShift) <
	                    4 * ruleWidth) {
	                subShift = 4 * ruleWidth - (supShift - sup.depth) + sub.height;
	                var psi = 0.8 * fontMetrics.metrics.xHeight -
	                    (supShift - sup.depth);
	                if (psi > 0) {
	                    supShift += psi;
	                    subShift -= psi;
	                }
	            }

	            supsub = buildCommon.makeVList([
	                {type: "elem", elem: submid, shift: subShift},
	                {type: "elem", elem: supmid, shift: -supShift}
	            ], "individualShift", null, options);

	            // See comment above about subscripts not being shifted
	            if (base instanceof domTree.symbolNode) {
	                supsub.children[0].style.marginLeft = -base.italic + "em";
	            }

	            supsub.children[0].style.marginRight = scriptspace;
	            supsub.children[1].style.marginRight = scriptspace;
	        }

	        return makeSpan([getTypeOfGroup(group.value.base)],
	            [base, supsub]);
	    },

	    genfrac: function(group, options, prev) {
	        // Fractions are handled in the TeXbook on pages 444-445, rules 15(a-e).
	        // Figure out what style this fraction should be in based on the
	        // function used
	        var fstyle = options.style;
	        if (group.value.size === "display") {
	            fstyle = Style.DISPLAY;
	        } else if (group.value.size === "text") {
	            fstyle = Style.TEXT;
	        }

	        var nstyle = fstyle.fracNum();
	        var dstyle = fstyle.fracDen();

	        var numer = buildGroup(group.value.numer, options.withStyle(nstyle));
	        var numerreset = makeSpan([fstyle.reset(), nstyle.cls()], [numer]);

	        var denom = buildGroup(group.value.denom, options.withStyle(dstyle));
	        var denomreset = makeSpan([fstyle.reset(), dstyle.cls()], [denom]);

	        var ruleWidth;
	        if (group.value.hasBarLine) {
	            ruleWidth = fontMetrics.metrics.defaultRuleThickness /
	                options.style.sizeMultiplier;
	        } else {
	            ruleWidth = 0;
	        }

	        // Rule 15b
	        var numShift;
	        var clearance;
	        var denomShift;
	        if (fstyle.size === Style.DISPLAY.size) {
	            numShift = fontMetrics.metrics.num1;
	            if (ruleWidth > 0) {
	                clearance = 3 * ruleWidth;
	            } else {
	                clearance = 7 * fontMetrics.metrics.defaultRuleThickness;
	            }
	            denomShift = fontMetrics.metrics.denom1;
	        } else {
	            if (ruleWidth > 0) {
	                numShift = fontMetrics.metrics.num2;
	                clearance = ruleWidth;
	            } else {
	                numShift = fontMetrics.metrics.num3;
	                clearance = 3 * fontMetrics.metrics.defaultRuleThickness;
	            }
	            denomShift = fontMetrics.metrics.denom2;
	        }

	        var frac;
	        if (ruleWidth === 0) {
	            // Rule 15c
	            var candiateClearance =
	                (numShift - numer.depth) - (denom.height - denomShift);
	            if (candiateClearance < clearance) {
	                numShift += 0.5 * (clearance - candiateClearance);
	                denomShift += 0.5 * (clearance - candiateClearance);
	            }

	            frac = buildCommon.makeVList([
	                {type: "elem", elem: denomreset, shift: denomShift},
	                {type: "elem", elem: numerreset, shift: -numShift}
	            ], "individualShift", null, options);
	        } else {
	            // Rule 15d
	            var axisHeight = fontMetrics.metrics.axisHeight;

	            if ((numShift - numer.depth) - (axisHeight + 0.5 * ruleWidth) <
	                    clearance) {
	                numShift +=
	                    clearance - ((numShift - numer.depth) -
	                                 (axisHeight + 0.5 * ruleWidth));
	            }

	            if ((axisHeight - 0.5 * ruleWidth) - (denom.height - denomShift) <
	                    clearance) {
	                denomShift +=
	                    clearance - ((axisHeight - 0.5 * ruleWidth) -
	                                 (denom.height - denomShift));
	            }

	            var mid = makeSpan(
	                [options.style.reset(), Style.TEXT.cls(), "frac-line"]);
	            // Manually set the height of the line because its height is
	            // created in CSS
	            mid.height = ruleWidth;

	            var midShift = -(axisHeight - 0.5 * ruleWidth);

	            frac = buildCommon.makeVList([
	                {type: "elem", elem: denomreset, shift: denomShift},
	                {type: "elem", elem: mid,        shift: midShift},
	                {type: "elem", elem: numerreset, shift: -numShift}
	            ], "individualShift", null, options);
	        }

	        // Since we manually change the style sometimes (with \dfrac or \tfrac),
	        // account for the possible size change here.
	        frac.height *= fstyle.sizeMultiplier / options.style.sizeMultiplier;
	        frac.depth *= fstyle.sizeMultiplier / options.style.sizeMultiplier;

	        // Rule 15e
	        var delimSize;
	        if (fstyle.size === Style.DISPLAY.size) {
	            delimSize = fontMetrics.metrics.delim1;
	        } else {
	            delimSize = fontMetrics.metrics.getDelim2(fstyle);
	        }

	        var leftDelim, rightDelim;
	        if (group.value.leftDelim == null) {
	            leftDelim = makeNullDelimiter(options);
	        } else {
	            leftDelim = delimiter.customSizedDelim(
	                group.value.leftDelim, delimSize, true,
	                options.withStyle(fstyle), group.mode);
	        }
	        if (group.value.rightDelim == null) {
	            rightDelim = makeNullDelimiter(options);
	        } else {
	            rightDelim = delimiter.customSizedDelim(
	                group.value.rightDelim, delimSize, true,
	                options.withStyle(fstyle), group.mode);
	        }

	        return makeSpan(
	            ["mord", options.style.reset(), fstyle.cls()],
	            [leftDelim, makeSpan(["mfrac"], [frac]), rightDelim],
	            options.getColor());
	    },

	    array: function(group, options, prev) {
	        var r, c;
	        var nr = group.value.body.length;
	        var nc = 0;
	        var body = new Array(nr);

	        // Horizontal spacing
	        var pt = 1 / fontMetrics.metrics.ptPerEm;
	        var arraycolsep = 5 * pt; // \arraycolsep in article.cls

	        // Vertical spacing
	        var baselineskip = 12 * pt; // see size10.clo
	        // Default \arraystretch from lttab.dtx
	        // TODO(gagern): may get redefined once we have user-defined macros
	        var arraystretch = utils.deflt(group.value.arraystretch, 1);
	        var arrayskip = arraystretch * baselineskip;
	        var arstrutHeight = 0.7 * arrayskip; // \strutbox in ltfsstrc.dtx and
	        var arstrutDepth = 0.3 * arrayskip;  // \@arstrutbox in lttab.dtx

	        var totalHeight = 0;
	        for (r = 0; r < group.value.body.length; ++r) {
	            var inrow = group.value.body[r];
	            var height = arstrutHeight; // \@array adds an \@arstrut
	            var depth = arstrutDepth;   // to each tow (via the template)

	            if (nc < inrow.length) {
	                nc = inrow.length;
	            }

	            var outrow = new Array(inrow.length);
	            for (c = 0; c < inrow.length; ++c) {
	                var elt = buildGroup(inrow[c], options);
	                if (depth < elt.depth) {
	                    depth = elt.depth;
	                }
	                if (height < elt.height) {
	                    height = elt.height;
	                }
	                outrow[c] = elt;
	            }

	            var gap = 0;
	            if (group.value.rowGaps[r]) {
	                gap = group.value.rowGaps[r].value;
	                switch (gap.unit) {
	                case "em":
	                    gap = gap.number;
	                    break;
	                case "ex":
	                    gap = gap.number * fontMetrics.metrics.emPerEx;
	                    break;
	                default:
	                    console.error("Can't handle unit " + gap.unit);
	                    gap = 0;
	                }
	                if (gap > 0) { // \@argarraycr
	                    gap += arstrutDepth;
	                    if (depth < gap) {
	                        depth = gap; // \@xargarraycr
	                    }
	                    gap = 0;
	                }
	            }

	            outrow.height = height;
	            outrow.depth = depth;
	            totalHeight += height;
	            outrow.pos = totalHeight;
	            totalHeight += depth + gap; // \@yargarraycr
	            body[r] = outrow;
	        }

	        var offset = totalHeight / 2 + fontMetrics.metrics.axisHeight;
	        var colDescriptions = group.value.cols || [];
	        var cols = [];
	        var colSep;
	        var colDescrNum;
	        for (c = 0, colDescrNum = 0;
	             // Continue while either there are more columns or more column
	             // descriptions, so trailing separators don't get lost.
	             c < nc || colDescrNum < colDescriptions.length;
	             ++c, ++colDescrNum) {

	            var colDescr = colDescriptions[colDescrNum] || {};

	            var firstSeparator = true;
	            while (colDescr.type === "separator") {
	                // If there is more than one separator in a row, add a space
	                // between them.
	                if (!firstSeparator) {
	                    colSep = makeSpan(["arraycolsep"], []);
	                    colSep.style.width =
	                        fontMetrics.metrics.doubleRuleSep + "em";
	                    cols.push(colSep);
	                }

	                if (colDescr.separator === "|") {
	                    var separator = makeSpan(
	                        ["vertical-separator"],
	                        []);
	                    separator.style.height = totalHeight + "em";
	                    separator.style.verticalAlign =
	                        -(totalHeight - offset) + "em";

	                    cols.push(separator);
	                } else {
	                    throw new ParseError(
	                        "Invalid separator type: " + colDescr.separator);
	                }

	                colDescrNum++;
	                colDescr = colDescriptions[colDescrNum] || {};
	                firstSeparator = false;
	            }

	            if (c >= nc) {
	                continue;
	            }

	            var sepwidth;
	            if (c > 0 || group.value.hskipBeforeAndAfter) {
	                sepwidth = utils.deflt(colDescr.pregap, arraycolsep);
	                if (sepwidth !== 0) {
	                    colSep = makeSpan(["arraycolsep"], []);
	                    colSep.style.width = sepwidth + "em";
	                    cols.push(colSep);
	                }
	            }

	            var col = [];
	            for (r = 0; r < nr; ++r) {
	                var row = body[r];
	                var elem = row[c];
	                if (!elem) {
	                    continue;
	                }
	                var shift = row.pos - offset;
	                elem.depth = row.depth;
	                elem.height = row.height;
	                col.push({type: "elem", elem: elem, shift: shift});
	            }

	            col = buildCommon.makeVList(col, "individualShift", null, options);
	            col = makeSpan(
	                ["col-align-" + (colDescr.align || "c")],
	                [col]);
	            cols.push(col);

	            if (c < nc - 1 || group.value.hskipBeforeAndAfter) {
	                sepwidth = utils.deflt(colDescr.postgap, arraycolsep);
	                if (sepwidth !== 0) {
	                    colSep = makeSpan(["arraycolsep"], []);
	                    colSep.style.width = sepwidth + "em";
	                    cols.push(colSep);
	                }
	            }
	        }
	        body = makeSpan(["mtable"], cols);
	        return makeSpan(["mord"], [body], options.getColor());
	    },

	    spacing: function(group, options, prev) {
	        if (group.value === "\\ " || group.value === "\\space" ||
	            group.value === " " || group.value === "~") {
	            // Spaces are generated by adding an actual space. Each of these
	            // things has an entry in the symbols table, so these will be turned
	            // into appropriate outputs.
	            return makeSpan(
	                ["mord", "mspace"],
	                [buildCommon.mathsym(group.value, group.mode)]
	            );
	        } else {
	            // Other kinds of spaces are of arbitrary width. We use CSS to
	            // generate these.
	            return makeSpan(
	                ["mord", "mspace",
	                 buildCommon.spacingFunctions[group.value].className]);
	        }
	    },

	    llap: function(group, options, prev) {
	        var inner = makeSpan(
	            ["inner"], [buildGroup(group.value.body, options.reset())]);
	        var fix = makeSpan(["fix"], []);
	        return makeSpan(
	            ["llap", options.style.cls()], [inner, fix]);
	    },

	    rlap: function(group, options, prev) {
	        var inner = makeSpan(
	            ["inner"], [buildGroup(group.value.body, options.reset())]);
	        var fix = makeSpan(["fix"], []);
	        return makeSpan(
	            ["rlap", options.style.cls()], [inner, fix]);
	    },

	    op: function(group, options, prev) {
	        // Operators are handled in the TeXbook pg. 443-444, rule 13(a).
	        var supGroup;
	        var subGroup;
	        var hasLimits = false;
	        if (group.type === "supsub" ) {
	            // If we have limits, supsub will pass us its group to handle. Pull
	            // out the superscript and subscript and set the group to the op in
	            // its base.
	            supGroup = group.value.sup;
	            subGroup = group.value.sub;
	            group = group.value.base;
	            hasLimits = true;
	        }

	        // Most operators have a large successor symbol, but these don't.
	        var noSuccessor = [
	            "\\smallint"
	        ];

	        var large = false;
	        if (options.style.size === Style.DISPLAY.size &&
	            group.value.symbol &&
	            !utils.contains(noSuccessor, group.value.body)) {

	            // Most symbol operators get larger in displaystyle (rule 13)
	            large = true;
	        }

	        var base;
	        var baseShift = 0;
	        var slant = 0;
	        if (group.value.symbol) {
	            // If this is a symbol, create the symbol.
	            var style = large ? "Size2-Regular" : "Size1-Regular";
	            base = buildCommon.makeSymbol(
	                group.value.body, style, "math", options.getColor(),
	                ["op-symbol", large ? "large-op" : "small-op", "mop"]);

	            // Shift the symbol so its center lies on the axis (rule 13). It
	            // appears that our fonts have the centers of the symbols already
	            // almost on the axis, so these numbers are very small. Note we
	            // don't actually apply this here, but instead it is used either in
	            // the vlist creation or separately when there are no limits.
	            baseShift = (base.height - base.depth) / 2 -
	                fontMetrics.metrics.axisHeight *
	                options.style.sizeMultiplier;

	            // The slant of the symbol is just its italic correction.
	            slant = base.italic;
	        } else {
	            // Otherwise, this is a text operator. Build the text from the
	            // operator's name.
	            // TODO(emily): Add a space in the middle of some of these
	            // operators, like \limsup
	            var output = [];
	            for (var i = 1; i < group.value.body.length; i++) {
	                output.push(buildCommon.mathsym(group.value.body[i], group.mode));
	            }
	            base = makeSpan(["mop"], output, options.getColor());
	        }

	        if (hasLimits) {
	            // IE 8 clips \int if it is in a display: inline-block. We wrap it
	            // in a new span so it is an inline, and works.
	            base = makeSpan([], [base]);

	            var supmid, supKern, submid, subKern;
	            // We manually have to handle the superscripts and subscripts. This,
	            // aside from the kern calculations, is copied from supsub.
	            if (supGroup) {
	                var sup = buildGroup(
	                    supGroup, options.withStyle(options.style.sup()));
	                supmid = makeSpan(
	                    [options.style.reset(), options.style.sup().cls()], [sup]);

	                supKern = Math.max(
	                    fontMetrics.metrics.bigOpSpacing1,
	                    fontMetrics.metrics.bigOpSpacing3 - sup.depth);
	            }

	            if (subGroup) {
	                var sub = buildGroup(
	                    subGroup, options.withStyle(options.style.sub()));
	                submid = makeSpan(
	                    [options.style.reset(), options.style.sub().cls()],
	                    [sub]);

	                subKern = Math.max(
	                    fontMetrics.metrics.bigOpSpacing2,
	                    fontMetrics.metrics.bigOpSpacing4 - sub.height);
	            }

	            // Build the final group as a vlist of the possible subscript, base,
	            // and possible superscript.
	            var finalGroup, top, bottom;
	            if (!supGroup) {
	                top = base.height - baseShift;

	                finalGroup = buildCommon.makeVList([
	                    {type: "kern", size: fontMetrics.metrics.bigOpSpacing5},
	                    {type: "elem", elem: submid},
	                    {type: "kern", size: subKern},
	                    {type: "elem", elem: base}
	                ], "top", top, options);

	                // Here, we shift the limits by the slant of the symbol. Note
	                // that we are supposed to shift the limits by 1/2 of the slant,
	                // but since we are centering the limits adding a full slant of
	                // margin will shift by 1/2 that.
	                finalGroup.children[0].style.marginLeft = -slant + "em";
	            } else if (!subGroup) {
	                bottom = base.depth + baseShift;

	                finalGroup = buildCommon.makeVList([
	                    {type: "elem", elem: base},
	                    {type: "kern", size: supKern},
	                    {type: "elem", elem: supmid},
	                    {type: "kern", size: fontMetrics.metrics.bigOpSpacing5}
	                ], "bottom", bottom, options);

	                // See comment above about slants
	                finalGroup.children[1].style.marginLeft = slant + "em";
	            } else if (!supGroup && !subGroup) {
	                // This case probably shouldn't occur (this would mean the
	                // supsub was sending us a group with no superscript or
	                // subscript) but be safe.
	                return base;
	            } else {
	                bottom = fontMetrics.metrics.bigOpSpacing5 +
	                    submid.height + submid.depth +
	                    subKern +
	                    base.depth + baseShift;

	                finalGroup = buildCommon.makeVList([
	                    {type: "kern", size: fontMetrics.metrics.bigOpSpacing5},
	                    {type: "elem", elem: submid},
	                    {type: "kern", size: subKern},
	                    {type: "elem", elem: base},
	                    {type: "kern", size: supKern},
	                    {type: "elem", elem: supmid},
	                    {type: "kern", size: fontMetrics.metrics.bigOpSpacing5}
	                ], "bottom", bottom, options);

	                // See comment above about slants
	                finalGroup.children[0].style.marginLeft = -slant + "em";
	                finalGroup.children[2].style.marginLeft = slant + "em";
	            }

	            return makeSpan(["mop", "op-limits"], [finalGroup]);
	        } else {
	            if (group.value.symbol) {
	                base.style.top = baseShift + "em";
	            }

	            return base;
	        }
	    },

	    katex: function(group, options, prev) {
	        // The KaTeX logo. The offsets for the K and a were chosen to look
	        // good, but the offsets for the T, E, and X were taken from the
	        // definition of \TeX in TeX (see TeXbook pg. 356)
	        var k = makeSpan(
	            ["k"], [buildCommon.mathsym("K", group.mode)]);
	        var a = makeSpan(
	            ["a"], [buildCommon.mathsym("A", group.mode)]);

	        a.height = (a.height + 0.2) * 0.75;
	        a.depth = (a.height - 0.2) * 0.75;

	        var t = makeSpan(
	            ["t"], [buildCommon.mathsym("T", group.mode)]);
	        var e = makeSpan(
	            ["e"], [buildCommon.mathsym("E", group.mode)]);

	        e.height = (e.height - 0.2155);
	        e.depth = (e.depth + 0.2155);

	        var x = makeSpan(
	            ["x"], [buildCommon.mathsym("X", group.mode)]);

	        return makeSpan(
	            ["katex-logo", "mord"], [k, a, t, e, x], options.getColor());
	    },

	    overline: function(group, options, prev) {
	        // Overlines are handled in the TeXbook pg 443, Rule 9.

	        // Build the inner group in the cramped style.
	        var innerGroup = buildGroup(group.value.body,
	                options.withStyle(options.style.cramp()));

	        var ruleWidth = fontMetrics.metrics.defaultRuleThickness /
	            options.style.sizeMultiplier;

	        // Create the line above the body
	        var line = makeSpan(
	            [options.style.reset(), Style.TEXT.cls(), "overline-line"]);
	        line.height = ruleWidth;
	        line.maxFontSize = 1.0;

	        // Generate the vlist, with the appropriate kerns
	        var vlist = buildCommon.makeVList([
	            {type: "elem", elem: innerGroup},
	            {type: "kern", size: 3 * ruleWidth},
	            {type: "elem", elem: line},
	            {type: "kern", size: ruleWidth}
	        ], "firstBaseline", null, options);

	        return makeSpan(["overline", "mord"], [vlist], options.getColor());
	    },

	    sqrt: function(group, options, prev) {
	        // Square roots are handled in the TeXbook pg. 443, Rule 11.

	        // First, we do the same steps as in overline to build the inner group
	        // and line
	        var inner = buildGroup(group.value.body,
	                options.withStyle(options.style.cramp()));

	        var ruleWidth = fontMetrics.metrics.defaultRuleThickness /
	            options.style.sizeMultiplier;

	        var line = makeSpan(
	            [options.style.reset(), Style.TEXT.cls(), "sqrt-line"], [],
	            options.getColor());
	        line.height = ruleWidth;
	        line.maxFontSize = 1.0;

	        var phi = ruleWidth;
	        if (options.style.id < Style.TEXT.id) {
	            phi = fontMetrics.metrics.xHeight;
	        }

	        // Calculate the clearance between the body and line
	        var lineClearance = ruleWidth + phi / 4;

	        var innerHeight =
	            (inner.height + inner.depth) * options.style.sizeMultiplier;
	        var minDelimiterHeight = innerHeight + lineClearance + ruleWidth;

	        // Create a \surd delimiter of the required minimum size
	        var delim = makeSpan(["sqrt-sign"], [
	            delimiter.customSizedDelim("\\surd", minDelimiterHeight,
	                                       false, options, group.mode)],
	                             options.getColor());

	        var delimDepth = (delim.height + delim.depth) - ruleWidth;

	        // Adjust the clearance based on the delimiter size
	        if (delimDepth > inner.height + inner.depth + lineClearance) {
	            lineClearance =
	                (lineClearance + delimDepth - inner.height - inner.depth) / 2;
	        }

	        // Shift the delimiter so that its top lines up with the top of the line
	        var delimShift = -(inner.height + lineClearance + ruleWidth) + delim.height;
	        delim.style.top = delimShift + "em";
	        delim.height -= delimShift;
	        delim.depth += delimShift;

	        // We add a special case here, because even when `inner` is empty, we
	        // still get a line. So, we use a simple heuristic to decide if we
	        // should omit the body entirely. (note this doesn't work for something
	        // like `\sqrt{\rlap{x}}`, but if someone is doing that they deserve for
	        // it not to work.
	        var body;
	        if (inner.height === 0 && inner.depth === 0) {
	            body = makeSpan();
	        } else {
	            body = buildCommon.makeVList([
	                {type: "elem", elem: inner},
	                {type: "kern", size: lineClearance},
	                {type: "elem", elem: line},
	                {type: "kern", size: ruleWidth}
	            ], "firstBaseline", null, options);
	        }

	        if (!group.value.index) {
	            return makeSpan(["sqrt", "mord"], [delim, body]);
	        } else {
	            // Handle the optional root index

	            // The index is always in scriptscript style
	            var root = buildGroup(
	                group.value.index,
	                options.withStyle(Style.SCRIPTSCRIPT));
	            var rootWrap = makeSpan(
	                [options.style.reset(), Style.SCRIPTSCRIPT.cls()],
	                [root]);

	            // Figure out the height and depth of the inner part
	            var innerRootHeight = Math.max(delim.height, body.height);
	            var innerRootDepth = Math.max(delim.depth, body.depth);

	            // The amount the index is shifted by. This is taken from the TeX
	            // source, in the definition of `\r@@t`.
	            var toShift = 0.6 * (innerRootHeight - innerRootDepth);

	            // Build a VList with the superscript shifted up correctly
	            var rootVList = buildCommon.makeVList(
	                [{type: "elem", elem: rootWrap}],
	                "shift", -toShift, options);
	            // Add a class surrounding it so we can add on the appropriate
	            // kerning
	            var rootVListWrap = makeSpan(["root"], [rootVList]);

	            return makeSpan(["sqrt", "mord"], [rootVListWrap, delim, body]);
	        }
	    },

	    sizing: function(group, options, prev) {
	        // Handle sizing operators like \Huge. Real TeX doesn't actually allow
	        // these functions inside of math expressions, so we do some special
	        // handling.
	        var inner = buildExpression(group.value.value,
	                options.withSize(group.value.size), prev);

	        var span = makeSpan(["mord"],
	            [makeSpan(["sizing", "reset-" + options.size, group.value.size,
	                       options.style.cls()],
	                      inner)]);

	        // Calculate the correct maxFontSize manually
	        var fontSize = buildCommon.sizingMultiplier[group.value.size];
	        span.maxFontSize = fontSize * options.style.sizeMultiplier;

	        return span;
	    },

	    styling: function(group, options, prev) {
	        // Style changes are handled in the TeXbook on pg. 442, Rule 3.

	        // Figure out what style we're changing to.
	        var style = {
	            "display": Style.DISPLAY,
	            "text": Style.TEXT,
	            "script": Style.SCRIPT,
	            "scriptscript": Style.SCRIPTSCRIPT
	        };

	        var newStyle = style[group.value.style];

	        // Build the inner expression in the new style.
	        var inner = buildExpression(
	            group.value.value, options.withStyle(newStyle), prev);

	        return makeSpan([options.style.reset(), newStyle.cls()], inner);
	    },

	    font: function(group, options, prev) {
	        var font = group.value.font;
	        return buildGroup(group.value.body, options.withFont(font), prev);
	    },

	    delimsizing: function(group, options, prev) {
	        var delim = group.value.value;

	        if (delim === ".") {
	            // Empty delimiters still count as elements, even though they don't
	            // show anything.
	            return makeSpan([groupToType[group.value.delimType]]);
	        }

	        // Use delimiter.sizedDelim to generate the delimiter.
	        return makeSpan(
	            [groupToType[group.value.delimType]],
	            [delimiter.sizedDelim(
	                delim, group.value.size, options, group.mode)]);
	    },

	    leftright: function(group, options, prev) {
	        // Build the inner expression
	        var inner = buildExpression(group.value.body, options.reset());

	        var innerHeight = 0;
	        var innerDepth = 0;

	        // Calculate its height and depth
	        for (var i = 0; i < inner.length; i++) {
	            innerHeight = Math.max(inner[i].height, innerHeight);
	            innerDepth = Math.max(inner[i].depth, innerDepth);
	        }

	        // The size of delimiters is the same, regardless of what style we are
	        // in. Thus, to correctly calculate the size of delimiter we need around
	        // a group, we scale down the inner size based on the size.
	        innerHeight *= options.style.sizeMultiplier;
	        innerDepth *= options.style.sizeMultiplier;

	        var leftDelim;
	        if (group.value.left === ".") {
	            // Empty delimiters in \left and \right make null delimiter spaces.
	            leftDelim = makeNullDelimiter(options);
	        } else {
	            // Otherwise, use leftRightDelim to generate the correct sized
	            // delimiter.
	            leftDelim = delimiter.leftRightDelim(
	                group.value.left, innerHeight, innerDepth, options,
	                group.mode);
	        }
	        // Add it to the beginning of the expression
	        inner.unshift(leftDelim);

	        var rightDelim;
	        // Same for the right delimiter
	        if (group.value.right === ".") {
	            rightDelim = makeNullDelimiter(options);
	        } else {
	            rightDelim = delimiter.leftRightDelim(
	                group.value.right, innerHeight, innerDepth, options,
	                group.mode);
	        }
	        // Add it to the end of the expression.
	        inner.push(rightDelim);

	        return makeSpan(
	            ["minner", options.style.cls()], inner, options.getColor());
	    },

	    rule: function(group, options, prev) {
	        // Make an empty span for the rule
	        var rule = makeSpan(["mord", "rule"], [], options.getColor());

	        // Calculate the shift, width, and height of the rule, and account for units
	        var shift = 0;
	        if (group.value.shift) {
	            shift = group.value.shift.number;
	            if (group.value.shift.unit === "ex") {
	                shift *= fontMetrics.metrics.xHeight;
	            }
	        }

	        var width = group.value.width.number;
	        if (group.value.width.unit === "ex") {
	            width *= fontMetrics.metrics.xHeight;
	        }

	        var height = group.value.height.number;
	        if (group.value.height.unit === "ex") {
	            height *= fontMetrics.metrics.xHeight;
	        }

	        // The sizes of rules are absolute, so make it larger if we are in a
	        // smaller style.
	        shift /= options.style.sizeMultiplier;
	        width /= options.style.sizeMultiplier;
	        height /= options.style.sizeMultiplier;

	        // Style the rule to the right size
	        rule.style.borderRightWidth = width + "em";
	        rule.style.borderTopWidth = height + "em";
	        rule.style.bottom = shift + "em";

	        // Record the height and width
	        rule.width = width;
	        rule.height = height + shift;
	        rule.depth = -shift;

	        return rule;
	    },

	    accent: function(group, options, prev) {
	        // Accents are handled in the TeXbook pg. 443, rule 12.
	        var base = group.value.base;

	        var supsubGroup;
	        if (group.type === "supsub") {
	            // If our base is a character box, and we have superscripts and
	            // subscripts, the supsub will defer to us. In particular, we want
	            // to attach the superscripts and subscripts to the inner body (so
	            // that the position of the superscripts and subscripts won't be
	            // affected by the height of the accent). We accomplish this by
	            // sticking the base of the accent into the base of the supsub, and
	            // rendering that, while keeping track of where the accent is.

	            // The supsub group is the group that was passed in
	            var supsub = group;
	            // The real accent group is the base of the supsub group
	            group = supsub.value.base;
	            // The character box is the base of the accent group
	            base = group.value.base;
	            // Stick the character box into the base of the supsub group
	            supsub.value.base = base;

	            // Rerender the supsub group with its new base, and store that
	            // result.
	            supsubGroup = buildGroup(
	                supsub, options.reset(), prev);
	        }

	        // Build the base group
	        var body = buildGroup(
	            base, options.withStyle(options.style.cramp()));

	        // Calculate the skew of the accent. This is based on the line "If the
	        // nucleus is not a single character, let s = 0; otherwise set s to the
	        // kern amount for the nucleus followed by the \skewchar of its font."
	        // Note that our skew metrics are just the kern between each character
	        // and the skewchar.
	        var skew;
	        if (isCharacterBox(base)) {
	            // If the base is a character box, then we want the skew of the
	            // innermost character. To do that, we find the innermost character:
	            var baseChar = getBaseElem(base);
	            // Then, we render its group to get the symbol inside it
	            var baseGroup = buildGroup(
	                baseChar, options.withStyle(options.style.cramp()));
	            // Finally, we pull the skew off of the symbol.
	            skew = baseGroup.skew;
	            // Note that we now throw away baseGroup, because the layers we
	            // removed with getBaseElem might contain things like \color which
	            // we can't get rid of.
	            // TODO(emily): Find a better way to get the skew
	        } else {
	            skew = 0;
	        }

	        // calculate the amount of space between the body and the accent
	        var clearance = Math.min(body.height, fontMetrics.metrics.xHeight);

	        // Build the accent
	        var accent = buildCommon.makeSymbol(
	            group.value.accent, "Main-Regular", "math", options.getColor());
	        // Remove the italic correction of the accent, because it only serves to
	        // shift the accent over to a place we don't want.
	        accent.italic = 0;

	        // The \vec character that the fonts use is a combining character, and
	        // thus shows up much too far to the left. To account for this, we add a
	        // specific class which shifts the accent over to where we want it.
	        // TODO(emily): Fix this in a better way, like by changing the font
	        var vecClass = group.value.accent === "\\vec" ? "accent-vec" : null;

	        var accentBody = makeSpan(["accent-body", vecClass], [
	            makeSpan([], [accent])]);

	        accentBody = buildCommon.makeVList([
	            {type: "elem", elem: body},
	            {type: "kern", size: -clearance},
	            {type: "elem", elem: accentBody}
	        ], "firstBaseline", null, options);

	        // Shift the accent over by the skew. Note we shift by twice the skew
	        // because we are centering the accent, so by adding 2*skew to the left,
	        // we shift it to the right by 1*skew.
	        accentBody.children[1].style.marginLeft = 2 * skew + "em";

	        var accentWrap = makeSpan(["mord", "accent"], [accentBody]);

	        if (supsubGroup) {
	            // Here, we replace the "base" child of the supsub with our newly
	            // generated accent.
	            supsubGroup.children[0] = accentWrap;

	            // Since we don't rerun the height calculation after replacing the
	            // accent, we manually recalculate height.
	            supsubGroup.height = Math.max(accentWrap.height, supsubGroup.height);

	            // Accents should always be ords, even when their innards are not.
	            supsubGroup.classes[0] = "mord";

	            return supsubGroup;
	        } else {
	            return accentWrap;
	        }
	    },

	    phantom: function(group, options, prev) {
	        var elements = buildExpression(
	            group.value.value,
	            options.withPhantom(),
	            prev
	        );

	        // \phantom isn't supposed to affect the elements it contains.
	        // See "color" for more details.
	        return new buildCommon.makeFragment(elements);
	    }
	};

	/**
	 * buildGroup is the function that takes a group and calls the correct groupType
	 * function for it. It also handles the interaction of size and style changes
	 * between parents and children.
	 */
	var buildGroup = function(group, options, prev) {
	    if (!group) {
	        return makeSpan();
	    }

	    if (groupTypes[group.type]) {
	        // Call the groupTypes function
	        var groupNode = groupTypes[group.type](group, options, prev);
	        var multiplier;

	        // If the style changed between the parent and the current group,
	        // account for the size difference
	        if (options.style !== options.parentStyle) {
	            multiplier = options.style.sizeMultiplier /
	                    options.parentStyle.sizeMultiplier;

	            groupNode.height *= multiplier;
	            groupNode.depth *= multiplier;
	        }

	        // If the size changed between the parent and the current group, account
	        // for that size difference.
	        if (options.size !== options.parentSize) {
	            multiplier = buildCommon.sizingMultiplier[options.size] /
	                    buildCommon.sizingMultiplier[options.parentSize];

	            groupNode.height *= multiplier;
	            groupNode.depth *= multiplier;
	        }

	        return groupNode;
	    } else {
	        throw new ParseError(
	            "Got group of unknown type: '" + group.type + "'");
	    }
	};

	/**
	 * Take an entire parse tree, and build it into an appropriate set of HTML
	 * nodes.
	 */
	var buildHTML = function(tree, options) {
	    // buildExpression is destructive, so we need to make a clone
	    // of the incoming tree so that it isn't accidentally changed
	    tree = JSON.parse(JSON.stringify(tree));

	    // Build the expression contained in the tree
	    var expression = buildExpression(tree, options);
	    var body = makeSpan(["base", options.style.cls()], expression);

	    // Add struts, which ensure that the top of the HTML element falls at the
	    // height of the expression, and the bottom of the HTML element falls at the
	    // depth of the expression.
	    var topStrut = makeSpan(["strut"]);
	    var bottomStrut = makeSpan(["strut", "bottom"]);

	    topStrut.style.height = body.height + "em";
	    bottomStrut.style.height = (body.height + body.depth) + "em";
	    // We'd like to use `vertical-align: top` but in IE 9 this lowers the
	    // baseline of the box to the bottom of this strut (instead staying in the
	    // normal place) so we use an absolute value for vertical-align instead
	    bottomStrut.style.verticalAlign = -body.depth + "em";

	    // Wrap the struts and body together
	    var htmlNode = makeSpan(["katex-html"], [topStrut, bottomStrut, body]);

	    htmlNode.setAttribute("aria-hidden", "true");

	    return htmlNode;
	};

	module.exports = buildHTML;


/***/ },
/* 9 */
/***/ function(module, exports) {

	/**
	 * This file contains information and classes for the various kinds of styles
	 * used in TeX. It provides a generic `Style` class, which holds information
	 * about a specific style. It then provides instances of all the different kinds
	 * of styles possible, and provides functions to move between them and get
	 * information about them.
	 */

	/**
	 * The main style class. Contains a unique id for the style, a size (which is
	 * the same for cramped and uncramped version of a style), a cramped flag, and a
	 * size multiplier, which gives the size difference between a style and
	 * textstyle.
	 */
	function Style(id, size, multiplier, cramped) {
	    this.id = id;
	    this.size = size;
	    this.cramped = cramped;
	    this.sizeMultiplier = multiplier;
	}

	/**
	 * Get the style of a superscript given a base in the current style.
	 */
	Style.prototype.sup = function() {
	    return styles[sup[this.id]];
	};

	/**
	 * Get the style of a subscript given a base in the current style.
	 */
	Style.prototype.sub = function() {
	    return styles[sub[this.id]];
	};

	/**
	 * Get the style of a fraction numerator given the fraction in the current
	 * style.
	 */
	Style.prototype.fracNum = function() {
	    return styles[fracNum[this.id]];
	};

	/**
	 * Get the style of a fraction denominator given the fraction in the current
	 * style.
	 */
	Style.prototype.fracDen = function() {
	    return styles[fracDen[this.id]];
	};

	/**
	 * Get the cramped version of a style (in particular, cramping a cramped style
	 * doesn't change the style).
	 */
	Style.prototype.cramp = function() {
	    return styles[cramp[this.id]];
	};

	/**
	 * HTML class name, like "displaystyle cramped"
	 */
	Style.prototype.cls = function() {
	    return sizeNames[this.size] + (this.cramped ? " cramped" : " uncramped");
	};

	/**
	 * HTML Reset class name, like "reset-textstyle"
	 */
	Style.prototype.reset = function() {
	    return resetNames[this.size];
	};

	// IDs of the different styles
	var D = 0;
	var Dc = 1;
	var T = 2;
	var Tc = 3;
	var S = 4;
	var Sc = 5;
	var SS = 6;
	var SSc = 7;

	// String names for the different sizes
	var sizeNames = [
	    "displaystyle textstyle",
	    "textstyle",
	    "scriptstyle",
	    "scriptscriptstyle"
	];

	// Reset names for the different sizes
	var resetNames = [
	    "reset-textstyle",
	    "reset-textstyle",
	    "reset-scriptstyle",
	    "reset-scriptscriptstyle"
	];

	// Instances of the different styles
	var styles = [
	    new Style(D, 0, 1.0, false),
	    new Style(Dc, 0, 1.0, true),
	    new Style(T, 1, 1.0, false),
	    new Style(Tc, 1, 1.0, true),
	    new Style(S, 2, 0.7, false),
	    new Style(Sc, 2, 0.7, true),
	    new Style(SS, 3, 0.5, false),
	    new Style(SSc, 3, 0.5, true)
	];

	// Lookup tables for switching from one style to another
	var sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
	var sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
	var fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];
	var fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
	var cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];

	// We only export some of the styles. Also, we don't export the `Style` class so
	// no more styles can be generated.
	module.exports = {
	    DISPLAY: styles[D],
	    TEXT: styles[T],
	    SCRIPT: styles[S],
	    SCRIPTSCRIPT: styles[SS]
	};


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * This module contains general functions that can be used for building
	 * different kinds of domTree nodes in a consistent manner.
	 */

	var domTree = __webpack_require__(11);
	var fontMetrics = __webpack_require__(13);
	var symbols = __webpack_require__(15);
	var utils = __webpack_require__(12);

	var greekCapitals = [
	    "\\Gamma",
	    "\\Delta",
	    "\\Theta",
	    "\\Lambda",
	    "\\Xi",
	    "\\Pi",
	    "\\Sigma",
	    "\\Upsilon",
	    "\\Phi",
	    "\\Psi",
	    "\\Omega"
	];

	var dotlessLetters = [
	    "\u0131",   // dotless i, \imath
	    "\u0237"    // dotless j, \jmath
	];

	/**
	 * Makes a symbolNode after translation via the list of symbols in symbols.js.
	 * Correctly pulls out metrics for the character, and optionally takes a list of
	 * classes to be attached to the node.
	 */
	var makeSymbol = function(value, style, mode, color, classes) {
	    // Replace the value with its replaced value from symbol.js
	    if (symbols[mode][value] && symbols[mode][value].replace) {
	        value = symbols[mode][value].replace;
	    }

	    var metrics = fontMetrics.getCharacterMetrics(value, style);

	    var symbolNode;
	    if (metrics) {
	        symbolNode = new domTree.symbolNode(
	            value, metrics.height, metrics.depth, metrics.italic, metrics.skew,
	            classes);
	    } else {
	        // TODO(emily): Figure out a good way to only print this in development
	        typeof console !== "undefined" && console.warn(
	            "No character metrics for '" + value + "' in style '" +
	                style + "'");
	        symbolNode = new domTree.symbolNode(value, 0, 0, 0, 0, classes);
	    }

	    if (color) {
	        symbolNode.style.color = color;
	    }

	    return symbolNode;
	};

	/**
	 * Makes a symbol in Main-Regular or AMS-Regular.
	 * Used for rel, bin, open, close, inner, and punct.
	 */
	var mathsym = function(value, mode, color, classes) {
	    // Decide what font to render the symbol in by its entry in the symbols
	    // table.
	    // Have a special case for when the value = \ because the \ is used as a
	    // textord in unsupported command errors but cannot be parsed as a regular
	    // text ordinal and is therefore not present as a symbol in the symbols
	    // table for text
	    if (value === "\\" || symbols[mode][value].font === "main") {
	        return makeSymbol(value, "Main-Regular", mode, color, classes);
	    } else {
	        return makeSymbol(
	            value, "AMS-Regular", mode, color, classes.concat(["amsrm"]));
	    }
	};

	/**
	 * Makes a symbol in the default font for mathords and textords.
	 */
	var mathDefault = function(value, mode, color, classes, type) {
	    if (type === "mathord") {
	        return mathit(value, mode, color, classes);
	    } else if (type === "textord") {
	        return makeSymbol(
	            value, "Main-Regular", mode, color, classes.concat(["mathrm"]));
	    } else {
	        throw new Error("unexpected type: " + type + " in mathDefault");
	    }
	};

	/**
	 * Makes a symbol in the italic math font.
	 */
	var mathit = function(value, mode, color, classes) {
	    if (/[0-9]/.test(value.charAt(0)) ||
	            // glyphs for \imath and \jmath do not exist in Math-Italic so we
	            // need to use Main-Italic instead
	            utils.contains(dotlessLetters, value) ||
	            utils.contains(greekCapitals, value)) {
	        return makeSymbol(
	            value, "Main-Italic", mode, color, classes.concat(["mainit"]));
	    } else {
	        return makeSymbol(
	            value, "Math-Italic", mode, color, classes.concat(["mathit"]));
	    }
	};

	/**
	 * Makes either a mathord or textord in the correct font and color.
	 */
	var makeOrd = function(group, options, type) {
	    var mode = group.mode;
	    var value = group.value;
	    if (symbols[mode][value] && symbols[mode][value].replace) {
	        value = symbols[mode][value].replace;
	    }

	    var classes = ["mord"];
	    var color = options.getColor();

	    var font = options.font;
	    if (font) {
	        if (font === "mathit" || utils.contains(dotlessLetters, value)) {
	            return mathit(value, mode, color, classes);
	        } else {
	            var fontName = fontMap[font].fontName;
	            if (fontMetrics.getCharacterMetrics(value, fontName)) {
	                return makeSymbol(value, fontName, mode, color, classes.concat([font]));
	            } else {
	                return mathDefault(value, mode, color, classes, type);
	            }
	        }
	    } else {
	        return mathDefault(value, mode, color, classes, type);
	    }
	};

	/**
	 * Calculate the height, depth, and maxFontSize of an element based on its
	 * children.
	 */
	var sizeElementFromChildren = function(elem) {
	    var height = 0;
	    var depth = 0;
	    var maxFontSize = 0;

	    if (elem.children) {
	        for (var i = 0; i < elem.children.length; i++) {
	            if (elem.children[i].height > height) {
	                height = elem.children[i].height;
	            }
	            if (elem.children[i].depth > depth) {
	                depth = elem.children[i].depth;
	            }
	            if (elem.children[i].maxFontSize > maxFontSize) {
	                maxFontSize = elem.children[i].maxFontSize;
	            }
	        }
	    }

	    elem.height = height;
	    elem.depth = depth;
	    elem.maxFontSize = maxFontSize;
	};

	/**
	 * Makes a span with the given list of classes, list of children, and color.
	 */
	var makeSpan = function(classes, children, color) {
	    var span = new domTree.span(classes, children);

	    sizeElementFromChildren(span);

	    if (color) {
	        span.style.color = color;
	    }

	    return span;
	};

	/**
	 * Makes a document fragment with the given list of children.
	 */
	var makeFragment = function(children) {
	    var fragment = new domTree.documentFragment(children);

	    sizeElementFromChildren(fragment);

	    return fragment;
	};

	/**
	 * Makes an element placed in each of the vlist elements to ensure that each
	 * element has the same max font size. To do this, we create a zero-width space
	 * with the correct font size.
	 */
	var makeFontSizer = function(options, fontSize) {
	    var fontSizeInner = makeSpan([], [new domTree.symbolNode("\u200b")]);
	    fontSizeInner.style.fontSize = (fontSize / options.style.sizeMultiplier) + "em";

	    var fontSizer = makeSpan(
	        ["fontsize-ensurer", "reset-" + options.size, "size5"],
	        [fontSizeInner]);

	    return fontSizer;
	};

	/**
	 * Makes a vertical list by stacking elements and kerns on top of each other.
	 * Allows for many different ways of specifying the positioning method.
	 *
	 * Arguments:
	 *  - children: A list of child or kern nodes to be stacked on top of each other
	 *              (i.e. the first element will be at the bottom, and the last at
	 *              the top). Element nodes are specified as
	 *                {type: "elem", elem: node}
	 *              while kern nodes are specified as
	 *                {type: "kern", size: size}
	 *  - positionType: The method by which the vlist should be positioned. Valid
	 *                  values are:
	 *                   - "individualShift": The children list only contains elem
	 *                                        nodes, and each node contains an extra
	 *                                        "shift" value of how much it should be
	 *                                        shifted (note that shifting is always
	 *                                        moving downwards). positionData is
	 *                                        ignored.
	 *                   - "top": The positionData specifies the topmost point of
	 *                            the vlist (note this is expected to be a height,
	 *                            so positive values move up)
	 *                   - "bottom": The positionData specifies the bottommost point
	 *                               of the vlist (note this is expected to be a
	 *                               depth, so positive values move down
	 *                   - "shift": The vlist will be positioned such that its
	 *                              baseline is positionData away from the baseline
	 *                              of the first child. Positive values move
	 *                              downwards.
	 *                   - "firstBaseline": The vlist will be positioned such that
	 *                                      its baseline is aligned with the
	 *                                      baseline of the first child.
	 *                                      positionData is ignored. (this is
	 *                                      equivalent to "shift" with
	 *                                      positionData=0)
	 *  - positionData: Data used in different ways depending on positionType
	 *  - options: An Options object
	 *
	 */
	var makeVList = function(children, positionType, positionData, options) {
	    var depth;
	    var currPos;
	    var i;
	    if (positionType === "individualShift") {
	        var oldChildren = children;
	        children = [oldChildren[0]];

	        // Add in kerns to the list of children to get each element to be
	        // shifted to the correct specified shift
	        depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
	        currPos = depth;
	        for (i = 1; i < oldChildren.length; i++) {
	            var diff = -oldChildren[i].shift - currPos -
	                oldChildren[i].elem.depth;
	            var size = diff -
	                (oldChildren[i - 1].elem.height +
	                 oldChildren[i - 1].elem.depth);

	            currPos = currPos + diff;

	            children.push({type: "kern", size: size});
	            children.push(oldChildren[i]);
	        }
	    } else if (positionType === "top") {
	        // We always start at the bottom, so calculate the bottom by adding up
	        // all the sizes
	        var bottom = positionData;
	        for (i = 0; i < children.length; i++) {
	            if (children[i].type === "kern") {
	                bottom -= children[i].size;
	            } else {
	                bottom -= children[i].elem.height + children[i].elem.depth;
	            }
	        }
	        depth = bottom;
	    } else if (positionType === "bottom") {
	        depth = -positionData;
	    } else if (positionType === "shift") {
	        depth = -children[0].elem.depth - positionData;
	    } else if (positionType === "firstBaseline") {
	        depth = -children[0].elem.depth;
	    } else {
	        depth = 0;
	    }

	    // Make the fontSizer
	    var maxFontSize = 0;
	    for (i = 0; i < children.length; i++) {
	        if (children[i].type === "elem") {
	            maxFontSize = Math.max(maxFontSize, children[i].elem.maxFontSize);
	        }
	    }
	    var fontSizer = makeFontSizer(options, maxFontSize);

	    // Create a new list of actual children at the correct offsets
	    var realChildren = [];
	    currPos = depth;
	    for (i = 0; i < children.length; i++) {
	        if (children[i].type === "kern") {
	            currPos += children[i].size;
	        } else {
	            var child = children[i].elem;

	            var shift = -child.depth - currPos;
	            currPos += child.height + child.depth;

	            var childWrap = makeSpan([], [fontSizer, child]);
	            childWrap.height -= shift;
	            childWrap.depth += shift;
	            childWrap.style.top = shift + "em";

	            realChildren.push(childWrap);
	        }
	    }

	    // Add in an element at the end with no offset to fix the calculation of
	    // baselines in some browsers (namely IE, sometimes safari)
	    var baselineFix = makeSpan(
	        ["baseline-fix"], [fontSizer, new domTree.symbolNode("\u200b")]);
	    realChildren.push(baselineFix);

	    var vlist = makeSpan(["vlist"], realChildren);
	    // Fix the final height and depth, in case there were kerns at the ends
	    // since the makeSpan calculation won't take that in to account.
	    vlist.height = Math.max(currPos, vlist.height);
	    vlist.depth = Math.max(-depth, vlist.depth);
	    return vlist;
	};

	// A table of size -> font size for the different sizing functions
	var sizingMultiplier = {
	    size1: 0.5,
	    size2: 0.7,
	    size3: 0.8,
	    size4: 0.9,
	    size5: 1.0,
	    size6: 1.2,
	    size7: 1.44,
	    size8: 1.73,
	    size9: 2.07,
	    size10: 2.49
	};

	// A map of spacing functions to their attributes, like size and corresponding
	// CSS class
	var spacingFunctions = {
	    "\\qquad": {
	        size: "2em",
	        className: "qquad"
	    },
	    "\\quad": {
	        size: "1em",
	        className: "quad"
	    },
	    "\\enspace": {
	        size: "0.5em",
	        className: "enspace"
	    },
	    "\\;": {
	        size: "0.277778em",
	        className: "thickspace"
	    },
	    "\\:": {
	        size: "0.22222em",
	        className: "mediumspace"
	    },
	    "\\,": {
	        size: "0.16667em",
	        className: "thinspace"
	    },
	    "\\!": {
	        size: "-0.16667em",
	        className: "negativethinspace"
	    }
	};

	/**
	 * Maps TeX font commands to objects containing:
	 * - variant: string used for "mathvariant" attribute in buildMathML.js
	 * - fontName: the "style" parameter to fontMetrics.getCharacterMetrics
	 */
	// A map between tex font commands an MathML mathvariant attribute values
	var fontMap = {
	    // styles
	    "mathbf": {
	        variant: "bold",
	        fontName: "Main-Bold"
	    },
	    "mathrm": {
	        variant: "normal",
	        fontName: "Main-Regular"
	    },

	    // "mathit" is missing because it requires the use of two fonts: Main-Italic
	    // and Math-Italic.  This is handled by a special case in makeOrd which ends
	    // up calling mathit.

	    // families
	    "mathbb": {
	        variant: "double-struck",
	        fontName: "AMS-Regular"
	    },
	    "mathcal": {
	        variant: "script",
	        fontName: "Caligraphic-Regular"
	    },
	    "mathfrak": {
	        variant: "fraktur",
	        fontName: "Fraktur-Regular"
	    },
	    "mathscr": {
	        variant: "script",
	        fontName: "Script-Regular"
	    },
	    "mathsf": {
	        variant: "sans-serif",
	        fontName: "SansSerif-Regular"
	    },
	    "mathtt": {
	        variant: "monospace",
	        fontName: "Typewriter-Regular"
	    }
	};

	module.exports = {
	    fontMap: fontMap,
	    makeSymbol: makeSymbol,
	    mathsym: mathsym,
	    makeSpan: makeSpan,
	    makeFragment: makeFragment,
	    makeVList: makeVList,
	    makeOrd: makeOrd,
	    sizingMultiplier: sizingMultiplier,
	    spacingFunctions: spacingFunctions
	};


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * These objects store the data about the DOM nodes we create, as well as some
	 * extra data. They can then be transformed into real DOM nodes with the
	 * `toNode` function or HTML markup using `toMarkup`. They are useful for both
	 * storing extra properties on the nodes, as well as providing a way to easily
	 * work with the DOM.
	 *
	 * Similar functions for working with MathML nodes exist in mathMLTree.js.
	 */

	var utils = __webpack_require__(12);

	/**
	 * Create an HTML className based on a list of classes. In addition to joining
	 * with spaces, we also remove null or empty classes.
	 */
	var createClass = function(classes) {
	    classes = classes.slice();
	    for (var i = classes.length - 1; i >= 0; i--) {
	        if (!classes[i]) {
	            classes.splice(i, 1);
	        }
	    }

	    return classes.join(" ");
	};

	/**
	 * This node represents a span node, with a className, a list of children, and
	 * an inline style. It also contains information about its height, depth, and
	 * maxFontSize.
	 */
	function span(classes, children, height, depth, maxFontSize, style) {
	    this.classes = classes || [];
	    this.children = children || [];
	    this.height = height || 0;
	    this.depth = depth || 0;
	    this.maxFontSize = maxFontSize || 0;
	    this.style = style || {};
	    this.attributes = {};
	}

	/**
	 * Sets an arbitrary attribute on the span. Warning: use this wisely. Not all
	 * browsers support attributes the same, and having too many custom attributes
	 * is probably bad.
	 */
	span.prototype.setAttribute = function(attribute, value) {
	    this.attributes[attribute] = value;
	};

	/**
	 * Convert the span into an HTML node
	 */
	span.prototype.toNode = function() {
	    var span = document.createElement("span");

	    // Apply the class
	    span.className = createClass(this.classes);

	    // Apply inline styles
	    for (var style in this.style) {
	        if (Object.prototype.hasOwnProperty.call(this.style, style)) {
	            span.style[style] = this.style[style];
	        }
	    }

	    // Apply attributes
	    for (var attr in this.attributes) {
	        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
	            span.setAttribute(attr, this.attributes[attr]);
	        }
	    }

	    // Append the children, also as HTML nodes
	    for (var i = 0; i < this.children.length; i++) {
	        span.appendChild(this.children[i].toNode());
	    }

	    return span;
	};

	/**
	 * Convert the span into an HTML markup string
	 */
	span.prototype.toMarkup = function() {
	    var markup = "<span";

	    // Add the class
	    if (this.classes.length) {
	        markup += " class=\"";
	        markup += utils.escape(createClass(this.classes));
	        markup += "\"";
	    }

	    var styles = "";

	    // Add the styles, after hyphenation
	    for (var style in this.style) {
	        if (this.style.hasOwnProperty(style)) {
	            styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
	        }
	    }

	    if (styles) {
	        markup += " style=\"" + utils.escape(styles) + "\"";
	    }

	    // Add the attributes
	    for (var attr in this.attributes) {
	        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
	            markup += " " + attr + "=\"";
	            markup += utils.escape(this.attributes[attr]);
	            markup += "\"";
	        }
	    }

	    markup += ">";

	    // Add the markup of the children, also as markup
	    for (var i = 0; i < this.children.length; i++) {
	        markup += this.children[i].toMarkup();
	    }

	    markup += "</span>";

	    return markup;
	};

	/**
	 * This node represents a document fragment, which contains elements, but when
	 * placed into the DOM doesn't have any representation itself. Thus, it only
	 * contains children and doesn't have any HTML properties. It also keeps track
	 * of a height, depth, and maxFontSize.
	 */
	function documentFragment(children, height, depth, maxFontSize) {
	    this.children = children || [];
	    this.height = height || 0;
	    this.depth = depth || 0;
	    this.maxFontSize = maxFontSize || 0;
	}

	/**
	 * Convert the fragment into a node
	 */
	documentFragment.prototype.toNode = function() {
	    // Create a fragment
	    var frag = document.createDocumentFragment();

	    // Append the children
	    for (var i = 0; i < this.children.length; i++) {
	        frag.appendChild(this.children[i].toNode());
	    }

	    return frag;
	};

	/**
	 * Convert the fragment into HTML markup
	 */
	documentFragment.prototype.toMarkup = function() {
	    var markup = "";

	    // Simply concatenate the markup for the children together
	    for (var i = 0; i < this.children.length; i++) {
	        markup += this.children[i].toMarkup();
	    }

	    return markup;
	};

	/**
	 * A symbol node contains information about a single symbol. It either renders
	 * to a single text node, or a span with a single text node in it, depending on
	 * whether it has CSS classes, styles, or needs italic correction.
	 */
	function symbolNode(value, height, depth, italic, skew, classes, style) {
	    this.value = value || "";
	    this.height = height || 0;
	    this.depth = depth || 0;
	    this.italic = italic || 0;
	    this.skew = skew || 0;
	    this.classes = classes || [];
	    this.style = style || {};
	    this.maxFontSize = 0;
	}

	/**
	 * Creates a text node or span from a symbol node. Note that a span is only
	 * created if it is needed.
	 */
	symbolNode.prototype.toNode = function() {
	    var node = document.createTextNode(this.value);
	    var span = null;

	    if (this.italic > 0) {
	        span = document.createElement("span");
	        span.style.marginRight = this.italic + "em";
	    }

	    if (this.classes.length > 0) {
	        span = span || document.createElement("span");
	        span.className = createClass(this.classes);
	    }

	    for (var style in this.style) {
	        if (this.style.hasOwnProperty(style)) {
	            span = span || document.createElement("span");
	            span.style[style] = this.style[style];
	        }
	    }

	    if (span) {
	        span.appendChild(node);
	        return span;
	    } else {
	        return node;
	    }
	};

	/**
	 * Creates markup for a symbol node.
	 */
	symbolNode.prototype.toMarkup = function() {
	    // TODO(alpert): More duplication than I'd like from
	    // span.prototype.toMarkup and symbolNode.prototype.toNode...
	    var needsSpan = false;

	    var markup = "<span";

	    if (this.classes.length) {
	        needsSpan = true;
	        markup += " class=\"";
	        markup += utils.escape(createClass(this.classes));
	        markup += "\"";
	    }

	    var styles = "";

	    if (this.italic > 0) {
	        styles += "margin-right:" + this.italic + "em;";
	    }
	    for (var style in this.style) {
	        if (this.style.hasOwnProperty(style)) {
	            styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
	        }
	    }

	    if (styles) {
	        needsSpan = true;
	        markup += " style=\"" + utils.escape(styles) + "\"";
	    }

	    var escaped = utils.escape(this.value);
	    if (needsSpan) {
	        markup += ">";
	        markup += escaped;
	        markup += "</span>";
	        return markup;
	    } else {
	        return escaped;
	    }
	};

	module.exports = {
	    span: span,
	    documentFragment: documentFragment,
	    symbolNode: symbolNode
	};


/***/ },
/* 12 */
/***/ function(module, exports) {

	/**
	 * This file contains a list of utility functions which are useful in other
	 * files.
	 */

	/**
	 * Provide an `indexOf` function which works in IE8, but defers to native if
	 * possible.
	 */
	var nativeIndexOf = Array.prototype.indexOf;
	var indexOf = function(list, elem) {
	    if (list == null) {
	        return -1;
	    }
	    if (nativeIndexOf && list.indexOf === nativeIndexOf) {
	        return list.indexOf(elem);
	    }
	    var i = 0, l = list.length;
	    for (; i < l; i++) {
	        if (list[i] === elem) {
	            return i;
	        }
	    }
	    return -1;
	};

	/**
	 * Return whether an element is contained in a list
	 */
	var contains = function(list, elem) {
	    return indexOf(list, elem) !== -1;
	};

	/**
	 * Provide a default value if a setting is undefined
	 */
	var deflt = function(setting, defaultIfUndefined) {
	    return setting === undefined ? defaultIfUndefined : setting;
	};

	// hyphenate and escape adapted from Facebook's React under Apache 2 license

	var uppercase = /([A-Z])/g;
	var hyphenate = function(str) {
	    return str.replace(uppercase, "-$1").toLowerCase();
	};

	var ESCAPE_LOOKUP = {
	  "&": "&amp;",
	  ">": "&gt;",
	  "<": "&lt;",
	  "\"": "&quot;",
	  "'": "&#x27;"
	};

	var ESCAPE_REGEX = /[&><"']/g;

	function escaper(match) {
	  return ESCAPE_LOOKUP[match];
	}

	/**
	 * Escapes text to prevent scripting attacks.
	 *
	 * @param {*} text Text value to escape.
	 * @return {string} An escaped string.
	 */
	function escape(text) {
	  return ("" + text).replace(ESCAPE_REGEX, escaper);
	}

	/**
	 * A function to set the text content of a DOM element in all supported
	 * browsers. Note that we don't define this if there is no document.
	 */
	var setTextContent;
	if (typeof document !== "undefined") {
	    var testNode = document.createElement("span");
	    if ("textContent" in testNode) {
	        setTextContent = function(node, text) {
	            node.textContent = text;
	        };
	    } else {
	        setTextContent = function(node, text) {
	            node.innerText = text;
	        };
	    }
	}

	/**
	 * A function to clear a node.
	 */
	function clearNode(node) {
	    setTextContent(node, "");
	}

	module.exports = {
	    contains: contains,
	    deflt: deflt,
	    escape: escape,
	    hyphenate: hyphenate,
	    indexOf: indexOf,
	    setTextContent: setTextContent,
	    clearNode: clearNode
	};


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/* jshint unused:false */

	var Style = __webpack_require__(9);

	/**
	 * This file contains metrics regarding fonts and individual symbols. The sigma
	 * and xi variables, as well as the metricMap map contain data extracted from
	 * TeX, TeX font metrics, and the TTF files. These data are then exposed via the
	 * `metrics` variable and the getCharacterMetrics function.
	 */

	// These font metrics are extracted from TeX by using
	// \font\a=cmmi10
	// \showthe\fontdimenX\a
	// where X is the corresponding variable number. These correspond to the font
	// parameters of the symbol fonts. In TeX, there are actually three sets of
	// dimensions, one for each of textstyle, scriptstyle, and scriptscriptstyle,
	// but we only use the textstyle ones, and scale certain dimensions accordingly.
	// See the TeXbook, page 441.
	var sigma1 = 0.025;
	var sigma2 = 0;
	var sigma3 = 0;
	var sigma4 = 0;
	var sigma5 = 0.431;
	var sigma6 = 1;
	var sigma7 = 0;
	var sigma8 = 0.677;
	var sigma9 = 0.394;
	var sigma10 = 0.444;
	var sigma11 = 0.686;
	var sigma12 = 0.345;
	var sigma13 = 0.413;
	var sigma14 = 0.363;
	var sigma15 = 0.289;
	var sigma16 = 0.150;
	var sigma17 = 0.247;
	var sigma18 = 0.386;
	var sigma19 = 0.050;
	var sigma20 = 2.390;
	var sigma21 = 1.01;
	var sigma21Script = 0.81;
	var sigma21ScriptScript = 0.71;
	var sigma22 = 0.250;

	// These font metrics are extracted from TeX by using
	// \font\a=cmex10
	// \showthe\fontdimenX\a
	// where X is the corresponding variable number. These correspond to the font
	// parameters of the extension fonts (family 3). See the TeXbook, page 441.
	var xi1 = 0;
	var xi2 = 0;
	var xi3 = 0;
	var xi4 = 0;
	var xi5 = 0.431;
	var xi6 = 1;
	var xi7 = 0;
	var xi8 = 0.04;
	var xi9 = 0.111;
	var xi10 = 0.166;
	var xi11 = 0.2;
	var xi12 = 0.6;
	var xi13 = 0.1;

	// This value determines how large a pt is, for metrics which are defined in
	// terms of pts.
	// This value is also used in katex.less; if you change it make sure the values
	// match.
	var ptPerEm = 10.0;

	// The space between adjacent `|` columns in an array definition. From
	// `\showthe\doublerulesep` in LaTeX.
	var doubleRuleSep = 2.0 / ptPerEm;

	/**
	 * This is just a mapping from common names to real metrics
	 */
	var metrics = {
	    xHeight: sigma5,
	    quad: sigma6,
	    num1: sigma8,
	    num2: sigma9,
	    num3: sigma10,
	    denom1: sigma11,
	    denom2: sigma12,
	    sup1: sigma13,
	    sup2: sigma14,
	    sup3: sigma15,
	    sub1: sigma16,
	    sub2: sigma17,
	    supDrop: sigma18,
	    subDrop: sigma19,
	    axisHeight: sigma22,
	    defaultRuleThickness: xi8,
	    bigOpSpacing1: xi9,
	    bigOpSpacing2: xi10,
	    bigOpSpacing3: xi11,
	    bigOpSpacing4: xi12,
	    bigOpSpacing5: xi13,
	    ptPerEm: ptPerEm,
	    emPerEx: sigma5 / sigma6,
	    doubleRuleSep: doubleRuleSep,

	    // TODO(alpert): Missing parallel structure here. We should probably add
	    // style-specific metrics for all of these.
	    delim1: sigma20,
	    getDelim2: function(style) {
	        if (style.size === Style.TEXT.size) {
	            return sigma21;
	        } else if (style.size === Style.SCRIPT.size) {
	            return sigma21Script;
	        } else if (style.size === Style.SCRIPTSCRIPT.size) {
	            return sigma21ScriptScript;
	        }
	        throw new Error("Unexpected style size: " + style.size);
	    }
	};

	// This map contains a mapping from font name and character code to character
	// metrics, including height, depth, italic correction, and skew (kern from the
	// character to the corresponding \skewchar)
	// This map is generated via `make metrics`. It should not be changed manually.
	var metricMap = __webpack_require__(14);

	/**
	 * This function is a convience function for looking up information in the
	 * metricMap table. It takes a character as a string, and a style
	 */
	var getCharacterMetrics = function(character, style) {
	    return metricMap[style][character.charCodeAt(0)];
	};

	module.exports = {
	    metrics: metrics,
	    getCharacterMetrics: getCharacterMetrics
	};


/***/ },
/* 14 */
/***/ function(module, exports) {

	module.exports = {
	"AMS-Regular": {
	  "65": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "66": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "67": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "68": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "69": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "70": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "71": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "72": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "73": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "74": {"depth": 0.16667, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "75": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "76": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "77": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "78": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "79": {"depth": 0.16667, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "80": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "81": {"depth": 0.16667, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "82": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "83": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "84": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "85": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "86": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "87": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "88": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "89": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "90": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "107": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "165": {"depth": 0.0, "height": 0.675, "italic": 0.025, "skew": 0.0},
	  "174": {"depth": 0.15559, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "240": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "295": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "710": {"depth": 0.0, "height": 0.825, "italic": 0.0, "skew": 0.0},
	  "732": {"depth": 0.0, "height": 0.9, "italic": 0.0, "skew": 0.0},
	  "770": {"depth": 0.0, "height": 0.825, "italic": 0.0, "skew": 0.0},
	  "771": {"depth": 0.0, "height": 0.9, "italic": 0.0, "skew": 0.0},
	  "989": {"depth": 0.08167, "height": 0.58167, "italic": 0.0, "skew": 0.0},
	  "1008": {"depth": 0.0, "height": 0.43056, "italic": 0.04028, "skew": 0.0},
	  "8245": {"depth": 0.0, "height": 0.54986, "italic": 0.0, "skew": 0.0},
	  "8463": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "8487": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "8498": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "8502": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "8503": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "8504": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "8513": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "8592": {"depth": -0.03598, "height": 0.46402, "italic": 0.0, "skew": 0.0},
	  "8594": {"depth": -0.03598, "height": 0.46402, "italic": 0.0, "skew": 0.0},
	  "8602": {"depth": -0.13313, "height": 0.36687, "italic": 0.0, "skew": 0.0},
	  "8603": {"depth": -0.13313, "height": 0.36687, "italic": 0.0, "skew": 0.0},
	  "8606": {"depth": 0.01354, "height": 0.52239, "italic": 0.0, "skew": 0.0},
	  "8608": {"depth": 0.01354, "height": 0.52239, "italic": 0.0, "skew": 0.0},
	  "8610": {"depth": 0.01354, "height": 0.52239, "italic": 0.0, "skew": 0.0},
	  "8611": {"depth": 0.01354, "height": 0.52239, "italic": 0.0, "skew": 0.0},
	  "8619": {"depth": 0.0, "height": 0.54986, "italic": 0.0, "skew": 0.0},
	  "8620": {"depth": 0.0, "height": 0.54986, "italic": 0.0, "skew": 0.0},
	  "8621": {"depth": -0.13313, "height": 0.37788, "italic": 0.0, "skew": 0.0},
	  "8622": {"depth": -0.13313, "height": 0.36687, "italic": 0.0, "skew": 0.0},
	  "8624": {"depth": 0.0, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "8625": {"depth": 0.0, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "8630": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "8631": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "8634": {"depth": 0.08198, "height": 0.58198, "italic": 0.0, "skew": 0.0},
	  "8635": {"depth": 0.08198, "height": 0.58198, "italic": 0.0, "skew": 0.0},
	  "8638": {"depth": 0.19444, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "8639": {"depth": 0.19444, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "8642": {"depth": 0.19444, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "8643": {"depth": 0.19444, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "8644": {"depth": 0.1808, "height": 0.675, "italic": 0.0, "skew": 0.0},
	  "8646": {"depth": 0.1808, "height": 0.675, "italic": 0.0, "skew": 0.0},
	  "8647": {"depth": 0.1808, "height": 0.675, "italic": 0.0, "skew": 0.0},
	  "8648": {"depth": 0.19444, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "8649": {"depth": 0.1808, "height": 0.675, "italic": 0.0, "skew": 0.0},
	  "8650": {"depth": 0.19444, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "8651": {"depth": 0.01354, "height": 0.52239, "italic": 0.0, "skew": 0.0},
	  "8652": {"depth": 0.01354, "height": 0.52239, "italic": 0.0, "skew": 0.0},
	  "8653": {"depth": -0.13313, "height": 0.36687, "italic": 0.0, "skew": 0.0},
	  "8654": {"depth": -0.13313, "height": 0.36687, "italic": 0.0, "skew": 0.0},
	  "8655": {"depth": -0.13313, "height": 0.36687, "italic": 0.0, "skew": 0.0},
	  "8666": {"depth": 0.13667, "height": 0.63667, "italic": 0.0, "skew": 0.0},
	  "8667": {"depth": 0.13667, "height": 0.63667, "italic": 0.0, "skew": 0.0},
	  "8669": {"depth": -0.13313, "height": 0.37788, "italic": 0.0, "skew": 0.0},
	  "8672": {"depth": -0.064, "height": 0.437, "italic": 0, "skew": 0},
	  "8674": {"depth": -0.064, "height": 0.437, "italic": 0, "skew": 0},
	  "8705": {"depth": 0.0, "height": 0.825, "italic": 0.0, "skew": 0.0},
	  "8708": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "8709": {"depth": 0.08167, "height": 0.58167, "italic": 0.0, "skew": 0.0},
	  "8717": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "8722": {"depth": -0.03598, "height": 0.46402, "italic": 0.0, "skew": 0.0},
	  "8724": {"depth": 0.08198, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "8726": {"depth": 0.08167, "height": 0.58167, "italic": 0.0, "skew": 0.0},
	  "8733": {"depth": 0.0, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "8736": {"depth": 0.0, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "8737": {"depth": 0.0, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "8738": {"depth": 0.03517, "height": 0.52239, "italic": 0.0, "skew": 0.0},
	  "8739": {"depth": 0.08167, "height": 0.58167, "italic": 0.0, "skew": 0.0},
	  "8740": {"depth": 0.25142, "height": 0.74111, "italic": 0.0, "skew": 0.0},
	  "8741": {"depth": 0.08167, "height": 0.58167, "italic": 0.0, "skew": 0.0},
	  "8742": {"depth": 0.25142, "height": 0.74111, "italic": 0.0, "skew": 0.0},
	  "8756": {"depth": 0.0, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "8757": {"depth": 0.0, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "8764": {"depth": -0.13313, "height": 0.36687, "italic": 0.0, "skew": 0.0},
	  "8765": {"depth": -0.13313, "height": 0.37788, "italic": 0.0, "skew": 0.0},
	  "8769": {"depth": -0.13313, "height": 0.36687, "italic": 0.0, "skew": 0.0},
	  "8770": {"depth": -0.03625, "height": 0.46375, "italic": 0.0, "skew": 0.0},
	  "8774": {"depth": 0.30274, "height": 0.79383, "italic": 0.0, "skew": 0.0},
	  "8776": {"depth": -0.01688, "height": 0.48312, "italic": 0.0, "skew": 0.0},
	  "8778": {"depth": 0.08167, "height": 0.58167, "italic": 0.0, "skew": 0.0},
	  "8782": {"depth": 0.06062, "height": 0.54986, "italic": 0.0, "skew": 0.0},
	  "8783": {"depth": 0.06062, "height": 0.54986, "italic": 0.0, "skew": 0.0},
	  "8785": {"depth": 0.08198, "height": 0.58198, "italic": 0.0, "skew": 0.0},
	  "8786": {"depth": 0.08198, "height": 0.58198, "italic": 0.0, "skew": 0.0},
	  "8787": {"depth": 0.08198, "height": 0.58198, "italic": 0.0, "skew": 0.0},
	  "8790": {"depth": 0.0, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "8791": {"depth": 0.22958, "height": 0.72958, "italic": 0.0, "skew": 0.0},
	  "8796": {"depth": 0.08198, "height": 0.91667, "italic": 0.0, "skew": 0.0},
	  "8806": {"depth": 0.25583, "height": 0.75583, "italic": 0.0, "skew": 0.0},
	  "8807": {"depth": 0.25583, "height": 0.75583, "italic": 0.0, "skew": 0.0},
	  "8808": {"depth": 0.25142, "height": 0.75726, "italic": 0.0, "skew": 0.0},
	  "8809": {"depth": 0.25142, "height": 0.75726, "italic": 0.0, "skew": 0.0},
	  "8812": {"depth": 0.25583, "height": 0.75583, "italic": 0.0, "skew": 0.0},
	  "8814": {"depth": 0.20576, "height": 0.70576, "italic": 0.0, "skew": 0.0},
	  "8815": {"depth": 0.20576, "height": 0.70576, "italic": 0.0, "skew": 0.0},
	  "8816": {"depth": 0.30274, "height": 0.79383, "italic": 0.0, "skew": 0.0},
	  "8817": {"depth": 0.30274, "height": 0.79383, "italic": 0.0, "skew": 0.0},
	  "8818": {"depth": 0.22958, "height": 0.72958, "italic": 0.0, "skew": 0.0},
	  "8819": {"depth": 0.22958, "height": 0.72958, "italic": 0.0, "skew": 0.0},
	  "8822": {"depth": 0.1808, "height": 0.675, "italic": 0.0, "skew": 0.0},
	  "8823": {"depth": 0.1808, "height": 0.675, "italic": 0.0, "skew": 0.0},
	  "8828": {"depth": 0.13667, "height": 0.63667, "italic": 0.0, "skew": 0.0},
	  "8829": {"depth": 0.13667, "height": 0.63667, "italic": 0.0, "skew": 0.0},
	  "8830": {"depth": 0.22958, "height": 0.72958, "italic": 0.0, "skew": 0.0},
	  "8831": {"depth": 0.22958, "height": 0.72958, "italic": 0.0, "skew": 0.0},
	  "8832": {"depth": 0.20576, "height": 0.70576, "italic": 0.0, "skew": 0.0},
	  "8833": {"depth": 0.20576, "height": 0.70576, "italic": 0.0, "skew": 0.0},
	  "8840": {"depth": 0.30274, "height": 0.79383, "italic": 0.0, "skew": 0.0},
	  "8841": {"depth": 0.30274, "height": 0.79383, "italic": 0.0, "skew": 0.0},
	  "8842": {"depth": 0.13597, "height": 0.63597, "italic": 0.0, "skew": 0.0},
	  "8843": {"depth": 0.13597, "height": 0.63597, "italic": 0.0, "skew": 0.0},
	  "8847": {"depth": 0.03517, "height": 0.54986, "italic": 0.0, "skew": 0.0},
	  "8848": {"depth": 0.03517, "height": 0.54986, "italic": 0.0, "skew": 0.0},
	  "8858": {"depth": 0.08198, "height": 0.58198, "italic": 0.0, "skew": 0.0},
	  "8859": {"depth": 0.08198, "height": 0.58198, "italic": 0.0, "skew": 0.0},
	  "8861": {"depth": 0.08198, "height": 0.58198, "italic": 0.0, "skew": 0.0},
	  "8862": {"depth": 0.0, "height": 0.675, "italic": 0.0, "skew": 0.0},
	  "8863": {"depth": 0.0, "height": 0.675, "italic": 0.0, "skew": 0.0},
	  "8864": {"depth": 0.0, "height": 0.675, "italic": 0.0, "skew": 0.0},
	  "8865": {"depth": 0.0, "height": 0.675, "italic": 0.0, "skew": 0.0},
	  "8872": {"depth": 0.0, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "8873": {"depth": 0.0, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "8874": {"depth": 0.0, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "8876": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "8877": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "8878": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "8879": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "8882": {"depth": 0.03517, "height": 0.54986, "italic": 0.0, "skew": 0.0},
	  "8883": {"depth": 0.03517, "height": 0.54986, "italic": 0.0, "skew": 0.0},
	  "8884": {"depth": 0.13667, "height": 0.63667, "italic": 0.0, "skew": 0.0},
	  "8885": {"depth": 0.13667, "height": 0.63667, "italic": 0.0, "skew": 0.0},
	  "8888": {"depth": 0.0, "height": 0.54986, "italic": 0.0, "skew": 0.0},
	  "8890": {"depth": 0.19444, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "8891": {"depth": 0.19444, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "8892": {"depth": 0.19444, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "8901": {"depth": 0.0, "height": 0.54986, "italic": 0.0, "skew": 0.0},
	  "8903": {"depth": 0.08167, "height": 0.58167, "italic": 0.0, "skew": 0.0},
	  "8905": {"depth": 0.08167, "height": 0.58167, "italic": 0.0, "skew": 0.0},
	  "8906": {"depth": 0.08167, "height": 0.58167, "italic": 0.0, "skew": 0.0},
	  "8907": {"depth": 0.0, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "8908": {"depth": 0.0, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "8909": {"depth": -0.03598, "height": 0.46402, "italic": 0.0, "skew": 0.0},
	  "8910": {"depth": 0.0, "height": 0.54986, "italic": 0.0, "skew": 0.0},
	  "8911": {"depth": 0.0, "height": 0.54986, "italic": 0.0, "skew": 0.0},
	  "8912": {"depth": 0.03517, "height": 0.54986, "italic": 0.0, "skew": 0.0},
	  "8913": {"depth": 0.03517, "height": 0.54986, "italic": 0.0, "skew": 0.0},
	  "8914": {"depth": 0.0, "height": 0.54986, "italic": 0.0, "skew": 0.0},
	  "8915": {"depth": 0.0, "height": 0.54986, "italic": 0.0, "skew": 0.0},
	  "8916": {"depth": 0.0, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "8918": {"depth": 0.0391, "height": 0.5391, "italic": 0.0, "skew": 0.0},
	  "8919": {"depth": 0.0391, "height": 0.5391, "italic": 0.0, "skew": 0.0},
	  "8920": {"depth": 0.03517, "height": 0.54986, "italic": 0.0, "skew": 0.0},
	  "8921": {"depth": 0.03517, "height": 0.54986, "italic": 0.0, "skew": 0.0},
	  "8922": {"depth": 0.38569, "height": 0.88569, "italic": 0.0, "skew": 0.0},
	  "8923": {"depth": 0.38569, "height": 0.88569, "italic": 0.0, "skew": 0.0},
	  "8926": {"depth": 0.13667, "height": 0.63667, "italic": 0.0, "skew": 0.0},
	  "8927": {"depth": 0.13667, "height": 0.63667, "italic": 0.0, "skew": 0.0},
	  "8928": {"depth": 0.30274, "height": 0.79383, "italic": 0.0, "skew": 0.0},
	  "8929": {"depth": 0.30274, "height": 0.79383, "italic": 0.0, "skew": 0.0},
	  "8934": {"depth": 0.23222, "height": 0.74111, "italic": 0.0, "skew": 0.0},
	  "8935": {"depth": 0.23222, "height": 0.74111, "italic": 0.0, "skew": 0.0},
	  "8936": {"depth": 0.23222, "height": 0.74111, "italic": 0.0, "skew": 0.0},
	  "8937": {"depth": 0.23222, "height": 0.74111, "italic": 0.0, "skew": 0.0},
	  "8938": {"depth": 0.20576, "height": 0.70576, "italic": 0.0, "skew": 0.0},
	  "8939": {"depth": 0.20576, "height": 0.70576, "italic": 0.0, "skew": 0.0},
	  "8940": {"depth": 0.30274, "height": 0.79383, "italic": 0.0, "skew": 0.0},
	  "8941": {"depth": 0.30274, "height": 0.79383, "italic": 0.0, "skew": 0.0},
	  "8994": {"depth": 0.19444, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "8995": {"depth": 0.19444, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "9416": {"depth": 0.15559, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "9484": {"depth": 0.0, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "9488": {"depth": 0.0, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "9492": {"depth": 0.0, "height": 0.37788, "italic": 0.0, "skew": 0.0},
	  "9496": {"depth": 0.0, "height": 0.37788, "italic": 0.0, "skew": 0.0},
	  "9585": {"depth": 0.19444, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "9586": {"depth": 0.19444, "height": 0.74111, "italic": 0.0, "skew": 0.0},
	  "9632": {"depth": 0.0, "height": 0.675, "italic": 0.0, "skew": 0.0},
	  "9633": {"depth": 0.0, "height": 0.675, "italic": 0.0, "skew": 0.0},
	  "9650": {"depth": 0.0, "height": 0.54986, "italic": 0.0, "skew": 0.0},
	  "9651": {"depth": 0.0, "height": 0.54986, "italic": 0.0, "skew": 0.0},
	  "9654": {"depth": 0.03517, "height": 0.54986, "italic": 0.0, "skew": 0.0},
	  "9660": {"depth": 0.0, "height": 0.54986, "italic": 0.0, "skew": 0.0},
	  "9661": {"depth": 0.0, "height": 0.54986, "italic": 0.0, "skew": 0.0},
	  "9664": {"depth": 0.03517, "height": 0.54986, "italic": 0.0, "skew": 0.0},
	  "9674": {"depth": 0.11111, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "9733": {"depth": 0.19444, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "10003": {"depth": 0.0, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "10016": {"depth": 0.0, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "10731": {"depth": 0.11111, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "10846": {"depth": 0.19444, "height": 0.75583, "italic": 0.0, "skew": 0.0},
	  "10877": {"depth": 0.13667, "height": 0.63667, "italic": 0.0, "skew": 0.0},
	  "10878": {"depth": 0.13667, "height": 0.63667, "italic": 0.0, "skew": 0.0},
	  "10885": {"depth": 0.25583, "height": 0.75583, "italic": 0.0, "skew": 0.0},
	  "10886": {"depth": 0.25583, "height": 0.75583, "italic": 0.0, "skew": 0.0},
	  "10887": {"depth": 0.13597, "height": 0.63597, "italic": 0.0, "skew": 0.0},
	  "10888": {"depth": 0.13597, "height": 0.63597, "italic": 0.0, "skew": 0.0},
	  "10889": {"depth": 0.26167, "height": 0.75726, "italic": 0.0, "skew": 0.0},
	  "10890": {"depth": 0.26167, "height": 0.75726, "italic": 0.0, "skew": 0.0},
	  "10891": {"depth": 0.48256, "height": 0.98256, "italic": 0.0, "skew": 0.0},
	  "10892": {"depth": 0.48256, "height": 0.98256, "italic": 0.0, "skew": 0.0},
	  "10901": {"depth": 0.13667, "height": 0.63667, "italic": 0.0, "skew": 0.0},
	  "10902": {"depth": 0.13667, "height": 0.63667, "italic": 0.0, "skew": 0.0},
	  "10933": {"depth": 0.25142, "height": 0.75726, "italic": 0.0, "skew": 0.0},
	  "10934": {"depth": 0.25142, "height": 0.75726, "italic": 0.0, "skew": 0.0},
	  "10935": {"depth": 0.26167, "height": 0.75726, "italic": 0.0, "skew": 0.0},
	  "10936": {"depth": 0.26167, "height": 0.75726, "italic": 0.0, "skew": 0.0},
	  "10937": {"depth": 0.26167, "height": 0.75726, "italic": 0.0, "skew": 0.0},
	  "10938": {"depth": 0.26167, "height": 0.75726, "italic": 0.0, "skew": 0.0},
	  "10949": {"depth": 0.25583, "height": 0.75583, "italic": 0.0, "skew": 0.0},
	  "10950": {"depth": 0.25583, "height": 0.75583, "italic": 0.0, "skew": 0.0},
	  "10955": {"depth": 0.28481, "height": 0.79383, "italic": 0.0, "skew": 0.0},
	  "10956": {"depth": 0.28481, "height": 0.79383, "italic": 0.0, "skew": 0.0},
	  "57350": {"depth": 0.08167, "height": 0.58167, "italic": 0.0, "skew": 0.0},
	  "57351": {"depth": 0.08167, "height": 0.58167, "italic": 0.0, "skew": 0.0},
	  "57352": {"depth": 0.08167, "height": 0.58167, "italic": 0.0, "skew": 0.0},
	  "57353": {"depth": 0.0, "height": 0.43056, "italic": 0.04028, "skew": 0.0},
	  "57356": {"depth": 0.25142, "height": 0.75726, "italic": 0.0, "skew": 0.0},
	  "57357": {"depth": 0.25142, "height": 0.75726, "italic": 0.0, "skew": 0.0},
	  "57358": {"depth": 0.41951, "height": 0.91951, "italic": 0.0, "skew": 0.0},
	  "57359": {"depth": 0.30274, "height": 0.79383, "italic": 0.0, "skew": 0.0},
	  "57360": {"depth": 0.30274, "height": 0.79383, "italic": 0.0, "skew": 0.0},
	  "57361": {"depth": 0.41951, "height": 0.91951, "italic": 0.0, "skew": 0.0},
	  "57366": {"depth": 0.25142, "height": 0.75726, "italic": 0.0, "skew": 0.0},
	  "57367": {"depth": 0.25142, "height": 0.75726, "italic": 0.0, "skew": 0.0},
	  "57368": {"depth": 0.25142, "height": 0.75726, "italic": 0.0, "skew": 0.0},
	  "57369": {"depth": 0.25142, "height": 0.75726, "italic": 0.0, "skew": 0.0},
	  "57370": {"depth": 0.13597, "height": 0.63597, "italic": 0.0, "skew": 0.0},
	  "57371": {"depth": 0.13597, "height": 0.63597, "italic": 0.0, "skew": 0.0}
	},
	"Caligraphic-Regular": {
	  "48": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "49": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "50": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "51": {"depth": 0.19444, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "52": {"depth": 0.19444, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "53": {"depth": 0.19444, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "54": {"depth": 0.0, "height": 0.64444, "italic": 0.0, "skew": 0.0},
	  "55": {"depth": 0.19444, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "56": {"depth": 0.0, "height": 0.64444, "italic": 0.0, "skew": 0.0},
	  "57": {"depth": 0.19444, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "65": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.19445},
	  "66": {"depth": 0.0, "height": 0.68333, "italic": 0.03041, "skew": 0.13889},
	  "67": {"depth": 0.0, "height": 0.68333, "italic": 0.05834, "skew": 0.13889},
	  "68": {"depth": 0.0, "height": 0.68333, "italic": 0.02778, "skew": 0.08334},
	  "69": {"depth": 0.0, "height": 0.68333, "italic": 0.08944, "skew": 0.11111},
	  "70": {"depth": 0.0, "height": 0.68333, "italic": 0.09931, "skew": 0.11111},
	  "71": {"depth": 0.09722, "height": 0.68333, "italic": 0.0593, "skew": 0.11111},
	  "72": {"depth": 0.0, "height": 0.68333, "italic": 0.00965, "skew": 0.11111},
	  "73": {"depth": 0.0, "height": 0.68333, "italic": 0.07382, "skew": 0.0},
	  "74": {"depth": 0.09722, "height": 0.68333, "italic": 0.18472, "skew": 0.16667},
	  "75": {"depth": 0.0, "height": 0.68333, "italic": 0.01445, "skew": 0.05556},
	  "76": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.13889},
	  "77": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.13889},
	  "78": {"depth": 0.0, "height": 0.68333, "italic": 0.14736, "skew": 0.08334},
	  "79": {"depth": 0.0, "height": 0.68333, "italic": 0.02778, "skew": 0.11111},
	  "80": {"depth": 0.0, "height": 0.68333, "italic": 0.08222, "skew": 0.08334},
	  "81": {"depth": 0.09722, "height": 0.68333, "italic": 0.0, "skew": 0.11111},
	  "82": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.08334},
	  "83": {"depth": 0.0, "height": 0.68333, "italic": 0.075, "skew": 0.13889},
	  "84": {"depth": 0.0, "height": 0.68333, "italic": 0.25417, "skew": 0.0},
	  "85": {"depth": 0.0, "height": 0.68333, "italic": 0.09931, "skew": 0.08334},
	  "86": {"depth": 0.0, "height": 0.68333, "italic": 0.08222, "skew": 0.0},
	  "87": {"depth": 0.0, "height": 0.68333, "italic": 0.08222, "skew": 0.08334},
	  "88": {"depth": 0.0, "height": 0.68333, "italic": 0.14643, "skew": 0.13889},
	  "89": {"depth": 0.09722, "height": 0.68333, "italic": 0.08222, "skew": 0.08334},
	  "90": {"depth": 0.0, "height": 0.68333, "italic": 0.07944, "skew": 0.13889}
	},
	"Fraktur-Regular": {
	  "33": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "34": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "38": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "39": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "40": {"depth": 0.24982, "height": 0.74947, "italic": 0.0, "skew": 0.0},
	  "41": {"depth": 0.24982, "height": 0.74947, "italic": 0.0, "skew": 0.0},
	  "42": {"depth": 0.0, "height": 0.62119, "italic": 0.0, "skew": 0.0},
	  "43": {"depth": 0.08319, "height": 0.58283, "italic": 0.0, "skew": 0.0},
	  "44": {"depth": 0.0, "height": 0.10803, "italic": 0.0, "skew": 0.0},
	  "45": {"depth": 0.08319, "height": 0.58283, "italic": 0.0, "skew": 0.0},
	  "46": {"depth": 0.0, "height": 0.10803, "italic": 0.0, "skew": 0.0},
	  "47": {"depth": 0.24982, "height": 0.74947, "italic": 0.0, "skew": 0.0},
	  "48": {"depth": 0.0, "height": 0.47534, "italic": 0.0, "skew": 0.0},
	  "49": {"depth": 0.0, "height": 0.47534, "italic": 0.0, "skew": 0.0},
	  "50": {"depth": 0.0, "height": 0.47534, "italic": 0.0, "skew": 0.0},
	  "51": {"depth": 0.18906, "height": 0.47534, "italic": 0.0, "skew": 0.0},
	  "52": {"depth": 0.18906, "height": 0.47534, "italic": 0.0, "skew": 0.0},
	  "53": {"depth": 0.18906, "height": 0.47534, "italic": 0.0, "skew": 0.0},
	  "54": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "55": {"depth": 0.18906, "height": 0.47534, "italic": 0.0, "skew": 0.0},
	  "56": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "57": {"depth": 0.18906, "height": 0.47534, "italic": 0.0, "skew": 0.0},
	  "58": {"depth": 0.0, "height": 0.47534, "italic": 0.0, "skew": 0.0},
	  "59": {"depth": 0.12604, "height": 0.47534, "italic": 0.0, "skew": 0.0},
	  "61": {"depth": -0.13099, "height": 0.36866, "italic": 0.0, "skew": 0.0},
	  "63": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "65": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "66": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "67": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "68": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "69": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "70": {"depth": 0.12604, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "71": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "72": {"depth": 0.06302, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "73": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "74": {"depth": 0.12604, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "75": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "76": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "77": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "78": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "79": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "80": {"depth": 0.18906, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "81": {"depth": 0.03781, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "82": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "83": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "84": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "85": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "86": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "87": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "88": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "89": {"depth": 0.18906, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "90": {"depth": 0.12604, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "91": {"depth": 0.24982, "height": 0.74947, "italic": 0.0, "skew": 0.0},
	  "93": {"depth": 0.24982, "height": 0.74947, "italic": 0.0, "skew": 0.0},
	  "94": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "97": {"depth": 0.0, "height": 0.47534, "italic": 0.0, "skew": 0.0},
	  "98": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "99": {"depth": 0.0, "height": 0.47534, "italic": 0.0, "skew": 0.0},
	  "100": {"depth": 0.0, "height": 0.62119, "italic": 0.0, "skew": 0.0},
	  "101": {"depth": 0.0, "height": 0.47534, "italic": 0.0, "skew": 0.0},
	  "102": {"depth": 0.18906, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "103": {"depth": 0.18906, "height": 0.47534, "italic": 0.0, "skew": 0.0},
	  "104": {"depth": 0.18906, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "105": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "106": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "107": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "108": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "109": {"depth": 0.0, "height": 0.47534, "italic": 0.0, "skew": 0.0},
	  "110": {"depth": 0.0, "height": 0.47534, "italic": 0.0, "skew": 0.0},
	  "111": {"depth": 0.0, "height": 0.47534, "italic": 0.0, "skew": 0.0},
	  "112": {"depth": 0.18906, "height": 0.52396, "italic": 0.0, "skew": 0.0},
	  "113": {"depth": 0.18906, "height": 0.47534, "italic": 0.0, "skew": 0.0},
	  "114": {"depth": 0.0, "height": 0.47534, "italic": 0.0, "skew": 0.0},
	  "115": {"depth": 0.0, "height": 0.47534, "italic": 0.0, "skew": 0.0},
	  "116": {"depth": 0.0, "height": 0.62119, "italic": 0.0, "skew": 0.0},
	  "117": {"depth": 0.0, "height": 0.47534, "italic": 0.0, "skew": 0.0},
	  "118": {"depth": 0.0, "height": 0.52396, "italic": 0.0, "skew": 0.0},
	  "119": {"depth": 0.0, "height": 0.52396, "italic": 0.0, "skew": 0.0},
	  "120": {"depth": 0.18906, "height": 0.47534, "italic": 0.0, "skew": 0.0},
	  "121": {"depth": 0.18906, "height": 0.47534, "italic": 0.0, "skew": 0.0},
	  "122": {"depth": 0.18906, "height": 0.47534, "italic": 0.0, "skew": 0.0},
	  "8216": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "8217": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "58112": {"depth": 0.0, "height": 0.62119, "italic": 0.0, "skew": 0.0},
	  "58113": {"depth": 0.0, "height": 0.62119, "italic": 0.0, "skew": 0.0},
	  "58114": {"depth": 0.18906, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "58115": {"depth": 0.18906, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "58116": {"depth": 0.18906, "height": 0.47534, "italic": 0.0, "skew": 0.0},
	  "58117": {"depth": 0.0, "height": 0.69141, "italic": 0.0, "skew": 0.0},
	  "58118": {"depth": 0.0, "height": 0.62119, "italic": 0.0, "skew": 0.0},
	  "58119": {"depth": 0.0, "height": 0.47534, "italic": 0.0, "skew": 0.0}
	},
	"Main-Bold": {
	  "33": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "34": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "35": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "36": {"depth": 0.05556, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "37": {"depth": 0.05556, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "38": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "39": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "40": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "41": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "42": {"depth": 0.0, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "43": {"depth": 0.13333, "height": 0.63333, "italic": 0.0, "skew": 0.0},
	  "44": {"depth": 0.19444, "height": 0.15556, "italic": 0.0, "skew": 0.0},
	  "45": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "46": {"depth": 0.0, "height": 0.15556, "italic": 0.0, "skew": 0.0},
	  "47": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "48": {"depth": 0.0, "height": 0.64444, "italic": 0.0, "skew": 0.0},
	  "49": {"depth": 0.0, "height": 0.64444, "italic": 0.0, "skew": 0.0},
	  "50": {"depth": 0.0, "height": 0.64444, "italic": 0.0, "skew": 0.0},
	  "51": {"depth": 0.0, "height": 0.64444, "italic": 0.0, "skew": 0.0},
	  "52": {"depth": 0.0, "height": 0.64444, "italic": 0.0, "skew": 0.0},
	  "53": {"depth": 0.0, "height": 0.64444, "italic": 0.0, "skew": 0.0},
	  "54": {"depth": 0.0, "height": 0.64444, "italic": 0.0, "skew": 0.0},
	  "55": {"depth": 0.0, "height": 0.64444, "italic": 0.0, "skew": 0.0},
	  "56": {"depth": 0.0, "height": 0.64444, "italic": 0.0, "skew": 0.0},
	  "57": {"depth": 0.0, "height": 0.64444, "italic": 0.0, "skew": 0.0},
	  "58": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "59": {"depth": 0.19444, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "60": {"depth": 0.08556, "height": 0.58556, "italic": 0.0, "skew": 0.0},
	  "61": {"depth": -0.10889, "height": 0.39111, "italic": 0.0, "skew": 0.0},
	  "62": {"depth": 0.08556, "height": 0.58556, "italic": 0.0, "skew": 0.0},
	  "63": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "64": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "65": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "66": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "67": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "68": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "69": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "70": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "71": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "72": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "73": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "74": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "75": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "76": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "77": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "78": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "79": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "80": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "81": {"depth": 0.19444, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "82": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "83": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "84": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "85": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "86": {"depth": 0.0, "height": 0.68611, "italic": 0.01597, "skew": 0.0},
	  "87": {"depth": 0.0, "height": 0.68611, "italic": 0.01597, "skew": 0.0},
	  "88": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "89": {"depth": 0.0, "height": 0.68611, "italic": 0.02875, "skew": 0.0},
	  "90": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "91": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "92": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "93": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "94": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "95": {"depth": 0.31, "height": 0.13444, "italic": 0.03194, "skew": 0.0},
	  "96": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "97": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "98": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "99": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "100": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "101": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "102": {"depth": 0.0, "height": 0.69444, "italic": 0.10903, "skew": 0.0},
	  "103": {"depth": 0.19444, "height": 0.44444, "italic": 0.01597, "skew": 0.0},
	  "104": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "105": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "106": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "107": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "108": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "109": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "110": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "111": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "112": {"depth": 0.19444, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "113": {"depth": 0.19444, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "114": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "115": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "116": {"depth": 0.0, "height": 0.63492, "italic": 0.0, "skew": 0.0},
	  "117": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "118": {"depth": 0.0, "height": 0.44444, "italic": 0.01597, "skew": 0.0},
	  "119": {"depth": 0.0, "height": 0.44444, "italic": 0.01597, "skew": 0.0},
	  "120": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "121": {"depth": 0.19444, "height": 0.44444, "italic": 0.01597, "skew": 0.0},
	  "122": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "123": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "124": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "125": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "126": {"depth": 0.35, "height": 0.34444, "italic": 0.0, "skew": 0.0},
	  "168": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "172": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "175": {"depth": 0.0, "height": 0.59611, "italic": 0.0, "skew": 0.0},
	  "176": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "177": {"depth": 0.13333, "height": 0.63333, "italic": 0.0, "skew": 0.0},
	  "180": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "215": {"depth": 0.13333, "height": 0.63333, "italic": 0.0, "skew": 0.0},
	  "247": {"depth": 0.13333, "height": 0.63333, "italic": 0.0, "skew": 0.0},
	  "305": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "567": {"depth": 0.19444, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "710": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "711": {"depth": 0.0, "height": 0.63194, "italic": 0.0, "skew": 0.0},
	  "713": {"depth": 0.0, "height": 0.59611, "italic": 0.0, "skew": 0.0},
	  "714": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "715": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "728": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "729": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "730": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "732": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "768": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "769": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "770": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "771": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "772": {"depth": 0.0, "height": 0.59611, "italic": 0.0, "skew": 0.0},
	  "774": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "775": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "776": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "778": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "779": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "780": {"depth": 0.0, "height": 0.63194, "italic": 0.0, "skew": 0.0},
	  "824": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "915": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "916": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "920": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "923": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "926": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "928": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "931": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "933": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "934": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "936": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "937": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "8211": {"depth": 0.0, "height": 0.44444, "italic": 0.03194, "skew": 0.0},
	  "8212": {"depth": 0.0, "height": 0.44444, "italic": 0.03194, "skew": 0.0},
	  "8216": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8217": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8220": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8221": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8224": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8225": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8242": {"depth": 0.0, "height": 0.55556, "italic": 0.0, "skew": 0.0},
	  "8407": {"depth": 0.0, "height": 0.72444, "italic": 0.15486, "skew": 0.0},
	  "8463": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8465": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8467": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8472": {"depth": 0.19444, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "8476": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8501": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8592": {"depth": -0.10889, "height": 0.39111, "italic": 0.0, "skew": 0.0},
	  "8593": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8594": {"depth": -0.10889, "height": 0.39111, "italic": 0.0, "skew": 0.0},
	  "8595": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8596": {"depth": -0.10889, "height": 0.39111, "italic": 0.0, "skew": 0.0},
	  "8597": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8598": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8599": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8600": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8601": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8636": {"depth": -0.10889, "height": 0.39111, "italic": 0.0, "skew": 0.0},
	  "8637": {"depth": -0.10889, "height": 0.39111, "italic": 0.0, "skew": 0.0},
	  "8640": {"depth": -0.10889, "height": 0.39111, "italic": 0.0, "skew": 0.0},
	  "8641": {"depth": -0.10889, "height": 0.39111, "italic": 0.0, "skew": 0.0},
	  "8656": {"depth": -0.10889, "height": 0.39111, "italic": 0.0, "skew": 0.0},
	  "8657": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8658": {"depth": -0.10889, "height": 0.39111, "italic": 0.0, "skew": 0.0},
	  "8659": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8660": {"depth": -0.10889, "height": 0.39111, "italic": 0.0, "skew": 0.0},
	  "8661": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8704": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8706": {"depth": 0.0, "height": 0.69444, "italic": 0.06389, "skew": 0.0},
	  "8707": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8709": {"depth": 0.05556, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8711": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "8712": {"depth": 0.08556, "height": 0.58556, "italic": 0.0, "skew": 0.0},
	  "8715": {"depth": 0.08556, "height": 0.58556, "italic": 0.0, "skew": 0.0},
	  "8722": {"depth": 0.13333, "height": 0.63333, "italic": 0.0, "skew": 0.0},
	  "8723": {"depth": 0.13333, "height": 0.63333, "italic": 0.0, "skew": 0.0},
	  "8725": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8726": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8727": {"depth": -0.02778, "height": 0.47222, "italic": 0.0, "skew": 0.0},
	  "8728": {"depth": -0.02639, "height": 0.47361, "italic": 0.0, "skew": 0.0},
	  "8729": {"depth": -0.02639, "height": 0.47361, "italic": 0.0, "skew": 0.0},
	  "8730": {"depth": 0.18, "height": 0.82, "italic": 0.0, "skew": 0.0},
	  "8733": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "8734": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "8736": {"depth": 0.0, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "8739": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8741": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8743": {"depth": 0.0, "height": 0.55556, "italic": 0.0, "skew": 0.0},
	  "8744": {"depth": 0.0, "height": 0.55556, "italic": 0.0, "skew": 0.0},
	  "8745": {"depth": 0.0, "height": 0.55556, "italic": 0.0, "skew": 0.0},
	  "8746": {"depth": 0.0, "height": 0.55556, "italic": 0.0, "skew": 0.0},
	  "8747": {"depth": 0.19444, "height": 0.69444, "italic": 0.12778, "skew": 0.0},
	  "8764": {"depth": -0.10889, "height": 0.39111, "italic": 0.0, "skew": 0.0},
	  "8768": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8771": {"depth": 0.00222, "height": 0.50222, "italic": 0.0, "skew": 0.0},
	  "8776": {"depth": 0.02444, "height": 0.52444, "italic": 0.0, "skew": 0.0},
	  "8781": {"depth": 0.00222, "height": 0.50222, "italic": 0.0, "skew": 0.0},
	  "8801": {"depth": 0.00222, "height": 0.50222, "italic": 0.0, "skew": 0.0},
	  "8804": {"depth": 0.19667, "height": 0.69667, "italic": 0.0, "skew": 0.0},
	  "8805": {"depth": 0.19667, "height": 0.69667, "italic": 0.0, "skew": 0.0},
	  "8810": {"depth": 0.08556, "height": 0.58556, "italic": 0.0, "skew": 0.0},
	  "8811": {"depth": 0.08556, "height": 0.58556, "italic": 0.0, "skew": 0.0},
	  "8826": {"depth": 0.08556, "height": 0.58556, "italic": 0.0, "skew": 0.0},
	  "8827": {"depth": 0.08556, "height": 0.58556, "italic": 0.0, "skew": 0.0},
	  "8834": {"depth": 0.08556, "height": 0.58556, "italic": 0.0, "skew": 0.0},
	  "8835": {"depth": 0.08556, "height": 0.58556, "italic": 0.0, "skew": 0.0},
	  "8838": {"depth": 0.19667, "height": 0.69667, "italic": 0.0, "skew": 0.0},
	  "8839": {"depth": 0.19667, "height": 0.69667, "italic": 0.0, "skew": 0.0},
	  "8846": {"depth": 0.0, "height": 0.55556, "italic": 0.0, "skew": 0.0},
	  "8849": {"depth": 0.19667, "height": 0.69667, "italic": 0.0, "skew": 0.0},
	  "8850": {"depth": 0.19667, "height": 0.69667, "italic": 0.0, "skew": 0.0},
	  "8851": {"depth": 0.0, "height": 0.55556, "italic": 0.0, "skew": 0.0},
	  "8852": {"depth": 0.0, "height": 0.55556, "italic": 0.0, "skew": 0.0},
	  "8853": {"depth": 0.13333, "height": 0.63333, "italic": 0.0, "skew": 0.0},
	  "8854": {"depth": 0.13333, "height": 0.63333, "italic": 0.0, "skew": 0.0},
	  "8855": {"depth": 0.13333, "height": 0.63333, "italic": 0.0, "skew": 0.0},
	  "8856": {"depth": 0.13333, "height": 0.63333, "italic": 0.0, "skew": 0.0},
	  "8857": {"depth": 0.13333, "height": 0.63333, "italic": 0.0, "skew": 0.0},
	  "8866": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8867": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8868": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8869": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8900": {"depth": -0.02639, "height": 0.47361, "italic": 0.0, "skew": 0.0},
	  "8901": {"depth": -0.02639, "height": 0.47361, "italic": 0.0, "skew": 0.0},
	  "8902": {"depth": -0.02778, "height": 0.47222, "italic": 0.0, "skew": 0.0},
	  "8968": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8969": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8970": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8971": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8994": {"depth": -0.13889, "height": 0.36111, "italic": 0.0, "skew": 0.0},
	  "8995": {"depth": -0.13889, "height": 0.36111, "italic": 0.0, "skew": 0.0},
	  "9651": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "9657": {"depth": -0.02778, "height": 0.47222, "italic": 0.0, "skew": 0.0},
	  "9661": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "9667": {"depth": -0.02778, "height": 0.47222, "italic": 0.0, "skew": 0.0},
	  "9711": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "9824": {"depth": 0.12963, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "9825": {"depth": 0.12963, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "9826": {"depth": 0.12963, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "9827": {"depth": 0.12963, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "9837": {"depth": 0.0, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "9838": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "9839": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "10216": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "10217": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "10815": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "10927": {"depth": 0.19667, "height": 0.69667, "italic": 0.0, "skew": 0.0},
	  "10928": {"depth": 0.19667, "height": 0.69667, "italic": 0.0, "skew": 0.0}
	},
	"Main-Italic": {
	  "33": {"depth": 0.0, "height": 0.69444, "italic": 0.12417, "skew": 0.0},
	  "34": {"depth": 0.0, "height": 0.69444, "italic": 0.06961, "skew": 0.0},
	  "35": {"depth": 0.19444, "height": 0.69444, "italic": 0.06616, "skew": 0.0},
	  "37": {"depth": 0.05556, "height": 0.75, "italic": 0.13639, "skew": 0.0},
	  "38": {"depth": 0.0, "height": 0.69444, "italic": 0.09694, "skew": 0.0},
	  "39": {"depth": 0.0, "height": 0.69444, "italic": 0.12417, "skew": 0.0},
	  "40": {"depth": 0.25, "height": 0.75, "italic": 0.16194, "skew": 0.0},
	  "41": {"depth": 0.25, "height": 0.75, "italic": 0.03694, "skew": 0.0},
	  "42": {"depth": 0.0, "height": 0.75, "italic": 0.14917, "skew": 0.0},
	  "43": {"depth": 0.05667, "height": 0.56167, "italic": 0.03694, "skew": 0.0},
	  "44": {"depth": 0.19444, "height": 0.10556, "italic": 0.0, "skew": 0.0},
	  "45": {"depth": 0.0, "height": 0.43056, "italic": 0.02826, "skew": 0.0},
	  "46": {"depth": 0.0, "height": 0.10556, "italic": 0.0, "skew": 0.0},
	  "47": {"depth": 0.25, "height": 0.75, "italic": 0.16194, "skew": 0.0},
	  "48": {"depth": 0.0, "height": 0.64444, "italic": 0.13556, "skew": 0.0},
	  "49": {"depth": 0.0, "height": 0.64444, "italic": 0.13556, "skew": 0.0},
	  "50": {"depth": 0.0, "height": 0.64444, "italic": 0.13556, "skew": 0.0},
	  "51": {"depth": 0.0, "height": 0.64444, "italic": 0.13556, "skew": 0.0},
	  "52": {"depth": 0.19444, "height": 0.64444, "italic": 0.13556, "skew": 0.0},
	  "53": {"depth": 0.0, "height": 0.64444, "italic": 0.13556, "skew": 0.0},
	  "54": {"depth": 0.0, "height": 0.64444, "italic": 0.13556, "skew": 0.0},
	  "55": {"depth": 0.19444, "height": 0.64444, "italic": 0.13556, "skew": 0.0},
	  "56": {"depth": 0.0, "height": 0.64444, "italic": 0.13556, "skew": 0.0},
	  "57": {"depth": 0.0, "height": 0.64444, "italic": 0.13556, "skew": 0.0},
	  "58": {"depth": 0.0, "height": 0.43056, "italic": 0.0582, "skew": 0.0},
	  "59": {"depth": 0.19444, "height": 0.43056, "italic": 0.0582, "skew": 0.0},
	  "61": {"depth": -0.13313, "height": 0.36687, "italic": 0.06616, "skew": 0.0},
	  "63": {"depth": 0.0, "height": 0.69444, "italic": 0.1225, "skew": 0.0},
	  "64": {"depth": 0.0, "height": 0.69444, "italic": 0.09597, "skew": 0.0},
	  "65": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "66": {"depth": 0.0, "height": 0.68333, "italic": 0.10257, "skew": 0.0},
	  "67": {"depth": 0.0, "height": 0.68333, "italic": 0.14528, "skew": 0.0},
	  "68": {"depth": 0.0, "height": 0.68333, "italic": 0.09403, "skew": 0.0},
	  "69": {"depth": 0.0, "height": 0.68333, "italic": 0.12028, "skew": 0.0},
	  "70": {"depth": 0.0, "height": 0.68333, "italic": 0.13305, "skew": 0.0},
	  "71": {"depth": 0.0, "height": 0.68333, "italic": 0.08722, "skew": 0.0},
	  "72": {"depth": 0.0, "height": 0.68333, "italic": 0.16389, "skew": 0.0},
	  "73": {"depth": 0.0, "height": 0.68333, "italic": 0.15806, "skew": 0.0},
	  "74": {"depth": 0.0, "height": 0.68333, "italic": 0.14028, "skew": 0.0},
	  "75": {"depth": 0.0, "height": 0.68333, "italic": 0.14528, "skew": 0.0},
	  "76": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "77": {"depth": 0.0, "height": 0.68333, "italic": 0.16389, "skew": 0.0},
	  "78": {"depth": 0.0, "height": 0.68333, "italic": 0.16389, "skew": 0.0},
	  "79": {"depth": 0.0, "height": 0.68333, "italic": 0.09403, "skew": 0.0},
	  "80": {"depth": 0.0, "height": 0.68333, "italic": 0.10257, "skew": 0.0},
	  "81": {"depth": 0.19444, "height": 0.68333, "italic": 0.09403, "skew": 0.0},
	  "82": {"depth": 0.0, "height": 0.68333, "italic": 0.03868, "skew": 0.0},
	  "83": {"depth": 0.0, "height": 0.68333, "italic": 0.11972, "skew": 0.0},
	  "84": {"depth": 0.0, "height": 0.68333, "italic": 0.13305, "skew": 0.0},
	  "85": {"depth": 0.0, "height": 0.68333, "italic": 0.16389, "skew": 0.0},
	  "86": {"depth": 0.0, "height": 0.68333, "italic": 0.18361, "skew": 0.0},
	  "87": {"depth": 0.0, "height": 0.68333, "italic": 0.18361, "skew": 0.0},
	  "88": {"depth": 0.0, "height": 0.68333, "italic": 0.15806, "skew": 0.0},
	  "89": {"depth": 0.0, "height": 0.68333, "italic": 0.19383, "skew": 0.0},
	  "90": {"depth": 0.0, "height": 0.68333, "italic": 0.14528, "skew": 0.0},
	  "91": {"depth": 0.25, "height": 0.75, "italic": 0.1875, "skew": 0.0},
	  "93": {"depth": 0.25, "height": 0.75, "italic": 0.10528, "skew": 0.0},
	  "94": {"depth": 0.0, "height": 0.69444, "italic": 0.06646, "skew": 0.0},
	  "95": {"depth": 0.31, "height": 0.12056, "italic": 0.09208, "skew": 0.0},
	  "97": {"depth": 0.0, "height": 0.43056, "italic": 0.07671, "skew": 0.0},
	  "98": {"depth": 0.0, "height": 0.69444, "italic": 0.06312, "skew": 0.0},
	  "99": {"depth": 0.0, "height": 0.43056, "italic": 0.05653, "skew": 0.0},
	  "100": {"depth": 0.0, "height": 0.69444, "italic": 0.10333, "skew": 0.0},
	  "101": {"depth": 0.0, "height": 0.43056, "italic": 0.07514, "skew": 0.0},
	  "102": {"depth": 0.19444, "height": 0.69444, "italic": 0.21194, "skew": 0.0},
	  "103": {"depth": 0.19444, "height": 0.43056, "italic": 0.08847, "skew": 0.0},
	  "104": {"depth": 0.0, "height": 0.69444, "italic": 0.07671, "skew": 0.0},
	  "105": {"depth": 0.0, "height": 0.65536, "italic": 0.1019, "skew": 0.0},
	  "106": {"depth": 0.19444, "height": 0.65536, "italic": 0.14467, "skew": 0.0},
	  "107": {"depth": 0.0, "height": 0.69444, "italic": 0.10764, "skew": 0.0},
	  "108": {"depth": 0.0, "height": 0.69444, "italic": 0.10333, "skew": 0.0},
	  "109": {"depth": 0.0, "height": 0.43056, "italic": 0.07671, "skew": 0.0},
	  "110": {"depth": 0.0, "height": 0.43056, "italic": 0.07671, "skew": 0.0},
	  "111": {"depth": 0.0, "height": 0.43056, "italic": 0.06312, "skew": 0.0},
	  "112": {"depth": 0.19444, "height": 0.43056, "italic": 0.06312, "skew": 0.0},
	  "113": {"depth": 0.19444, "height": 0.43056, "italic": 0.08847, "skew": 0.0},
	  "114": {"depth": 0.0, "height": 0.43056, "italic": 0.10764, "skew": 0.0},
	  "115": {"depth": 0.0, "height": 0.43056, "italic": 0.08208, "skew": 0.0},
	  "116": {"depth": 0.0, "height": 0.61508, "italic": 0.09486, "skew": 0.0},
	  "117": {"depth": 0.0, "height": 0.43056, "italic": 0.07671, "skew": 0.0},
	  "118": {"depth": 0.0, "height": 0.43056, "italic": 0.10764, "skew": 0.0},
	  "119": {"depth": 0.0, "height": 0.43056, "italic": 0.10764, "skew": 0.0},
	  "120": {"depth": 0.0, "height": 0.43056, "italic": 0.12042, "skew": 0.0},
	  "121": {"depth": 0.19444, "height": 0.43056, "italic": 0.08847, "skew": 0.0},
	  "122": {"depth": 0.0, "height": 0.43056, "italic": 0.12292, "skew": 0.0},
	  "126": {"depth": 0.35, "height": 0.31786, "italic": 0.11585, "skew": 0.0},
	  "163": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "305": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.02778},
	  "567": {"depth": 0.19444, "height": 0.43056, "italic": 0.0, "skew": 0.08334},
	  "768": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "769": {"depth": 0.0, "height": 0.69444, "italic": 0.09694, "skew": 0.0},
	  "770": {"depth": 0.0, "height": 0.69444, "italic": 0.06646, "skew": 0.0},
	  "771": {"depth": 0.0, "height": 0.66786, "italic": 0.11585, "skew": 0.0},
	  "772": {"depth": 0.0, "height": 0.56167, "italic": 0.10333, "skew": 0.0},
	  "774": {"depth": 0.0, "height": 0.69444, "italic": 0.10806, "skew": 0.0},
	  "775": {"depth": 0.0, "height": 0.66786, "italic": 0.11752, "skew": 0.0},
	  "776": {"depth": 0.0, "height": 0.66786, "italic": 0.10474, "skew": 0.0},
	  "778": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "779": {"depth": 0.0, "height": 0.69444, "italic": 0.1225, "skew": 0.0},
	  "780": {"depth": 0.0, "height": 0.62847, "italic": 0.08295, "skew": 0.0},
	  "915": {"depth": 0.0, "height": 0.68333, "italic": 0.13305, "skew": 0.0},
	  "916": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "920": {"depth": 0.0, "height": 0.68333, "italic": 0.09403, "skew": 0.0},
	  "923": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "926": {"depth": 0.0, "height": 0.68333, "italic": 0.15294, "skew": 0.0},
	  "928": {"depth": 0.0, "height": 0.68333, "italic": 0.16389, "skew": 0.0},
	  "931": {"depth": 0.0, "height": 0.68333, "italic": 0.12028, "skew": 0.0},
	  "933": {"depth": 0.0, "height": 0.68333, "italic": 0.11111, "skew": 0.0},
	  "934": {"depth": 0.0, "height": 0.68333, "italic": 0.05986, "skew": 0.0},
	  "936": {"depth": 0.0, "height": 0.68333, "italic": 0.11111, "skew": 0.0},
	  "937": {"depth": 0.0, "height": 0.68333, "italic": 0.10257, "skew": 0.0},
	  "8211": {"depth": 0.0, "height": 0.43056, "italic": 0.09208, "skew": 0.0},
	  "8212": {"depth": 0.0, "height": 0.43056, "italic": 0.09208, "skew": 0.0},
	  "8216": {"depth": 0.0, "height": 0.69444, "italic": 0.12417, "skew": 0.0},
	  "8217": {"depth": 0.0, "height": 0.69444, "italic": 0.12417, "skew": 0.0},
	  "8220": {"depth": 0.0, "height": 0.69444, "italic": 0.1685, "skew": 0.0},
	  "8221": {"depth": 0.0, "height": 0.69444, "italic": 0.06961, "skew": 0.0},
	  "8463": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0}
	},
	"Main-Regular": {
	  "32": {"depth": 0.0, "height": 0.0, "italic": 0, "skew": 0},
	  "33": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "34": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "35": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "36": {"depth": 0.05556, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "37": {"depth": 0.05556, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "38": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "39": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "40": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "41": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "42": {"depth": 0.0, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "43": {"depth": 0.08333, "height": 0.58333, "italic": 0.0, "skew": 0.0},
	  "44": {"depth": 0.19444, "height": 0.10556, "italic": 0.0, "skew": 0.0},
	  "45": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "46": {"depth": 0.0, "height": 0.10556, "italic": 0.0, "skew": 0.0},
	  "47": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "48": {"depth": 0.0, "height": 0.64444, "italic": 0.0, "skew": 0.0},
	  "49": {"depth": 0.0, "height": 0.64444, "italic": 0.0, "skew": 0.0},
	  "50": {"depth": 0.0, "height": 0.64444, "italic": 0.0, "skew": 0.0},
	  "51": {"depth": 0.0, "height": 0.64444, "italic": 0.0, "skew": 0.0},
	  "52": {"depth": 0.0, "height": 0.64444, "italic": 0.0, "skew": 0.0},
	  "53": {"depth": 0.0, "height": 0.64444, "italic": 0.0, "skew": 0.0},
	  "54": {"depth": 0.0, "height": 0.64444, "italic": 0.0, "skew": 0.0},
	  "55": {"depth": 0.0, "height": 0.64444, "italic": 0.0, "skew": 0.0},
	  "56": {"depth": 0.0, "height": 0.64444, "italic": 0.0, "skew": 0.0},
	  "57": {"depth": 0.0, "height": 0.64444, "italic": 0.0, "skew": 0.0},
	  "58": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "59": {"depth": 0.19444, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "60": {"depth": 0.0391, "height": 0.5391, "italic": 0.0, "skew": 0.0},
	  "61": {"depth": -0.13313, "height": 0.36687, "italic": 0.0, "skew": 0.0},
	  "62": {"depth": 0.0391, "height": 0.5391, "italic": 0.0, "skew": 0.0},
	  "63": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "64": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "65": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "66": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "67": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "68": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "69": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "70": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "71": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "72": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "73": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "74": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "75": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "76": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "77": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "78": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "79": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "80": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "81": {"depth": 0.19444, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "82": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "83": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "84": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "85": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "86": {"depth": 0.0, "height": 0.68333, "italic": 0.01389, "skew": 0.0},
	  "87": {"depth": 0.0, "height": 0.68333, "italic": 0.01389, "skew": 0.0},
	  "88": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "89": {"depth": 0.0, "height": 0.68333, "italic": 0.025, "skew": 0.0},
	  "90": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "91": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "92": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "93": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "94": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "95": {"depth": 0.31, "height": 0.12056, "italic": 0.02778, "skew": 0.0},
	  "96": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "97": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "98": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "99": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "100": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "101": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "102": {"depth": 0.0, "height": 0.69444, "italic": 0.07778, "skew": 0.0},
	  "103": {"depth": 0.19444, "height": 0.43056, "italic": 0.01389, "skew": 0.0},
	  "104": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "105": {"depth": 0.0, "height": 0.66786, "italic": 0.0, "skew": 0.0},
	  "106": {"depth": 0.19444, "height": 0.66786, "italic": 0.0, "skew": 0.0},
	  "107": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "108": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "109": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "110": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "111": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "112": {"depth": 0.19444, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "113": {"depth": 0.19444, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "114": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "115": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "116": {"depth": 0.0, "height": 0.61508, "italic": 0.0, "skew": 0.0},
	  "117": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "118": {"depth": 0.0, "height": 0.43056, "italic": 0.01389, "skew": 0.0},
	  "119": {"depth": 0.0, "height": 0.43056, "italic": 0.01389, "skew": 0.0},
	  "120": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "121": {"depth": 0.19444, "height": 0.43056, "italic": 0.01389, "skew": 0.0},
	  "122": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "123": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "124": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "125": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "126": {"depth": 0.35, "height": 0.31786, "italic": 0.0, "skew": 0.0},
	  "160": {"depth": 0.0, "height": 0.0, "italic": 0, "skew": 0},
	  "168": {"depth": 0.0, "height": 0.66786, "italic": 0.0, "skew": 0.0},
	  "172": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "175": {"depth": 0.0, "height": 0.56778, "italic": 0.0, "skew": 0.0},
	  "176": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "177": {"depth": 0.08333, "height": 0.58333, "italic": 0.0, "skew": 0.0},
	  "180": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "215": {"depth": 0.08333, "height": 0.58333, "italic": 0.0, "skew": 0.0},
	  "247": {"depth": 0.08333, "height": 0.58333, "italic": 0.0, "skew": 0.0},
	  "305": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "567": {"depth": 0.19444, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "710": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "711": {"depth": 0.0, "height": 0.62847, "italic": 0.0, "skew": 0.0},
	  "713": {"depth": 0.0, "height": 0.56778, "italic": 0.0, "skew": 0.0},
	  "714": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "715": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "728": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "729": {"depth": 0.0, "height": 0.66786, "italic": 0.0, "skew": 0.0},
	  "730": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "732": {"depth": 0.0, "height": 0.66786, "italic": 0.0, "skew": 0.0},
	  "768": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "769": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "770": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "771": {"depth": 0.0, "height": 0.66786, "italic": 0.0, "skew": 0.0},
	  "772": {"depth": 0.0, "height": 0.56778, "italic": 0.0, "skew": 0.0},
	  "774": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "775": {"depth": 0.0, "height": 0.66786, "italic": 0.0, "skew": 0.0},
	  "776": {"depth": 0.0, "height": 0.66786, "italic": 0.0, "skew": 0.0},
	  "778": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "779": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "780": {"depth": 0.0, "height": 0.62847, "italic": 0.0, "skew": 0.0},
	  "824": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "915": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "916": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "920": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "923": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "926": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "928": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "931": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "933": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "934": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "936": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "937": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "8211": {"depth": 0.0, "height": 0.43056, "italic": 0.02778, "skew": 0.0},
	  "8212": {"depth": 0.0, "height": 0.43056, "italic": 0.02778, "skew": 0.0},
	  "8216": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8217": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8220": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8221": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8224": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8225": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8230": {"depth": 0.0, "height": 0.12, "italic": 0, "skew": 0},
	  "8242": {"depth": 0.0, "height": 0.55556, "italic": 0.0, "skew": 0.0},
	  "8407": {"depth": 0.0, "height": 0.71444, "italic": 0.15382, "skew": 0.0},
	  "8463": {"depth": 0.0, "height": 0.68889, "italic": 0.0, "skew": 0.0},
	  "8465": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8467": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.11111},
	  "8472": {"depth": 0.19444, "height": 0.43056, "italic": 0.0, "skew": 0.11111},
	  "8476": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8501": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8592": {"depth": -0.13313, "height": 0.36687, "italic": 0.0, "skew": 0.0},
	  "8593": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8594": {"depth": -0.13313, "height": 0.36687, "italic": 0.0, "skew": 0.0},
	  "8595": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8596": {"depth": -0.13313, "height": 0.36687, "italic": 0.0, "skew": 0.0},
	  "8597": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8598": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8599": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8600": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8601": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8614": {"depth": 0.011, "height": 0.511, "italic": 0, "skew": 0},
	  "8617": {"depth": 0.011, "height": 0.511, "italic": 0, "skew": 0},
	  "8618": {"depth": 0.011, "height": 0.511, "italic": 0, "skew": 0},
	  "8636": {"depth": -0.13313, "height": 0.36687, "italic": 0.0, "skew": 0.0},
	  "8637": {"depth": -0.13313, "height": 0.36687, "italic": 0.0, "skew": 0.0},
	  "8640": {"depth": -0.13313, "height": 0.36687, "italic": 0.0, "skew": 0.0},
	  "8641": {"depth": -0.13313, "height": 0.36687, "italic": 0.0, "skew": 0.0},
	  "8652": {"depth": 0.011, "height": 0.671, "italic": 0, "skew": 0},
	  "8656": {"depth": -0.13313, "height": 0.36687, "italic": 0.0, "skew": 0.0},
	  "8657": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8658": {"depth": -0.13313, "height": 0.36687, "italic": 0.0, "skew": 0.0},
	  "8659": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8660": {"depth": -0.13313, "height": 0.36687, "italic": 0.0, "skew": 0.0},
	  "8661": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8704": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8706": {"depth": 0.0, "height": 0.69444, "italic": 0.05556, "skew": 0.08334},
	  "8707": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8709": {"depth": 0.05556, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8711": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "8712": {"depth": 0.0391, "height": 0.5391, "italic": 0.0, "skew": 0.0},
	  "8715": {"depth": 0.0391, "height": 0.5391, "italic": 0.0, "skew": 0.0},
	  "8722": {"depth": 0.08333, "height": 0.58333, "italic": 0.0, "skew": 0.0},
	  "8723": {"depth": 0.08333, "height": 0.58333, "italic": 0.0, "skew": 0.0},
	  "8725": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8726": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8727": {"depth": -0.03472, "height": 0.46528, "italic": 0.0, "skew": 0.0},
	  "8728": {"depth": -0.05555, "height": 0.44445, "italic": 0.0, "skew": 0.0},
	  "8729": {"depth": -0.05555, "height": 0.44445, "italic": 0.0, "skew": 0.0},
	  "8730": {"depth": 0.2, "height": 0.8, "italic": 0.0, "skew": 0.0},
	  "8733": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "8734": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "8736": {"depth": 0.0, "height": 0.69224, "italic": 0.0, "skew": 0.0},
	  "8739": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8741": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8743": {"depth": 0.0, "height": 0.55556, "italic": 0.0, "skew": 0.0},
	  "8744": {"depth": 0.0, "height": 0.55556, "italic": 0.0, "skew": 0.0},
	  "8745": {"depth": 0.0, "height": 0.55556, "italic": 0.0, "skew": 0.0},
	  "8746": {"depth": 0.0, "height": 0.55556, "italic": 0.0, "skew": 0.0},
	  "8747": {"depth": 0.19444, "height": 0.69444, "italic": 0.11111, "skew": 0.0},
	  "8764": {"depth": -0.13313, "height": 0.36687, "italic": 0.0, "skew": 0.0},
	  "8768": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8771": {"depth": -0.03625, "height": 0.46375, "italic": 0.0, "skew": 0.0},
	  "8773": {"depth": -0.022, "height": 0.589, "italic": 0, "skew": 0},
	  "8776": {"depth": -0.01688, "height": 0.48312, "italic": 0.0, "skew": 0.0},
	  "8781": {"depth": -0.03625, "height": 0.46375, "italic": 0.0, "skew": 0.0},
	  "8784": {"depth": -0.133, "height": 0.67, "italic": 0, "skew": 0},
	  "8800": {"depth": 0.215, "height": 0.716, "italic": 0, "skew": 0},
	  "8801": {"depth": -0.03625, "height": 0.46375, "italic": 0.0, "skew": 0.0},
	  "8804": {"depth": 0.13597, "height": 0.63597, "italic": 0.0, "skew": 0.0},
	  "8805": {"depth": 0.13597, "height": 0.63597, "italic": 0.0, "skew": 0.0},
	  "8810": {"depth": 0.0391, "height": 0.5391, "italic": 0.0, "skew": 0.0},
	  "8811": {"depth": 0.0391, "height": 0.5391, "italic": 0.0, "skew": 0.0},
	  "8826": {"depth": 0.0391, "height": 0.5391, "italic": 0.0, "skew": 0.0},
	  "8827": {"depth": 0.0391, "height": 0.5391, "italic": 0.0, "skew": 0.0},
	  "8834": {"depth": 0.0391, "height": 0.5391, "italic": 0.0, "skew": 0.0},
	  "8835": {"depth": 0.0391, "height": 0.5391, "italic": 0.0, "skew": 0.0},
	  "8838": {"depth": 0.13597, "height": 0.63597, "italic": 0.0, "skew": 0.0},
	  "8839": {"depth": 0.13597, "height": 0.63597, "italic": 0.0, "skew": 0.0},
	  "8846": {"depth": 0.0, "height": 0.55556, "italic": 0.0, "skew": 0.0},
	  "8849": {"depth": 0.13597, "height": 0.63597, "italic": 0.0, "skew": 0.0},
	  "8850": {"depth": 0.13597, "height": 0.63597, "italic": 0.0, "skew": 0.0},
	  "8851": {"depth": 0.0, "height": 0.55556, "italic": 0.0, "skew": 0.0},
	  "8852": {"depth": 0.0, "height": 0.55556, "italic": 0.0, "skew": 0.0},
	  "8853": {"depth": 0.08333, "height": 0.58333, "italic": 0.0, "skew": 0.0},
	  "8854": {"depth": 0.08333, "height": 0.58333, "italic": 0.0, "skew": 0.0},
	  "8855": {"depth": 0.08333, "height": 0.58333, "italic": 0.0, "skew": 0.0},
	  "8856": {"depth": 0.08333, "height": 0.58333, "italic": 0.0, "skew": 0.0},
	  "8857": {"depth": 0.08333, "height": 0.58333, "italic": 0.0, "skew": 0.0},
	  "8866": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8867": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8868": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8869": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8872": {"depth": 0.249, "height": 0.75, "italic": 0, "skew": 0},
	  "8900": {"depth": -0.05555, "height": 0.44445, "italic": 0.0, "skew": 0.0},
	  "8901": {"depth": -0.05555, "height": 0.44445, "italic": 0.0, "skew": 0.0},
	  "8902": {"depth": -0.03472, "height": 0.46528, "italic": 0.0, "skew": 0.0},
	  "8904": {"depth": 0.005, "height": 0.505, "italic": 0, "skew": 0},
	  "8942": {"depth": 0.03, "height": 0.9, "italic": 0, "skew": 0},
	  "8943": {"depth": -0.19, "height": 0.31, "italic": 0, "skew": 0},
	  "8945": {"depth": -0.1, "height": 0.82, "italic": 0, "skew": 0},
	  "8968": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8969": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8970": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8971": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8994": {"depth": -0.14236, "height": 0.35764, "italic": 0.0, "skew": 0.0},
	  "8995": {"depth": -0.14236, "height": 0.35764, "italic": 0.0, "skew": 0.0},
	  "9136": {"depth": 0.244, "height": 0.744, "italic": 0, "skew": 0},
	  "9137": {"depth": 0.244, "height": 0.744, "italic": 0, "skew": 0},
	  "9651": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "9657": {"depth": -0.03472, "height": 0.46528, "italic": 0.0, "skew": 0.0},
	  "9661": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "9667": {"depth": -0.03472, "height": 0.46528, "italic": 0.0, "skew": 0.0},
	  "9711": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "9824": {"depth": 0.12963, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "9825": {"depth": 0.12963, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "9826": {"depth": 0.12963, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "9827": {"depth": 0.12963, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "9837": {"depth": 0.0, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "9838": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "9839": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "10216": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "10217": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "10222": {"depth": 0.244, "height": 0.744, "italic": 0, "skew": 0},
	  "10223": {"depth": 0.244, "height": 0.744, "italic": 0, "skew": 0},
	  "10229": {"depth": 0.011, "height": 0.511, "italic": 0, "skew": 0},
	  "10230": {"depth": 0.011, "height": 0.511, "italic": 0, "skew": 0},
	  "10231": {"depth": 0.011, "height": 0.511, "italic": 0, "skew": 0},
	  "10232": {"depth": 0.024, "height": 0.525, "italic": 0, "skew": 0},
	  "10233": {"depth": 0.024, "height": 0.525, "italic": 0, "skew": 0},
	  "10234": {"depth": 0.024, "height": 0.525, "italic": 0, "skew": 0},
	  "10236": {"depth": 0.011, "height": 0.511, "italic": 0, "skew": 0},
	  "10815": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.0},
	  "10927": {"depth": 0.13597, "height": 0.63597, "italic": 0.0, "skew": 0.0},
	  "10928": {"depth": 0.13597, "height": 0.63597, "italic": 0.0, "skew": 0.0}
	},
	"Math-BoldItalic": {
	  "47": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "65": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "66": {"depth": 0.0, "height": 0.68611, "italic": 0.04835, "skew": 0.0},
	  "67": {"depth": 0.0, "height": 0.68611, "italic": 0.06979, "skew": 0.0},
	  "68": {"depth": 0.0, "height": 0.68611, "italic": 0.03194, "skew": 0.0},
	  "69": {"depth": 0.0, "height": 0.68611, "italic": 0.05451, "skew": 0.0},
	  "70": {"depth": 0.0, "height": 0.68611, "italic": 0.15972, "skew": 0.0},
	  "71": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "72": {"depth": 0.0, "height": 0.68611, "italic": 0.08229, "skew": 0.0},
	  "73": {"depth": 0.0, "height": 0.68611, "italic": 0.07778, "skew": 0.0},
	  "74": {"depth": 0.0, "height": 0.68611, "italic": 0.10069, "skew": 0.0},
	  "75": {"depth": 0.0, "height": 0.68611, "italic": 0.06979, "skew": 0.0},
	  "76": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "77": {"depth": 0.0, "height": 0.68611, "italic": 0.11424, "skew": 0.0},
	  "78": {"depth": 0.0, "height": 0.68611, "italic": 0.11424, "skew": 0.0},
	  "79": {"depth": 0.0, "height": 0.68611, "italic": 0.03194, "skew": 0.0},
	  "80": {"depth": 0.0, "height": 0.68611, "italic": 0.15972, "skew": 0.0},
	  "81": {"depth": 0.19444, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "82": {"depth": 0.0, "height": 0.68611, "italic": 0.00421, "skew": 0.0},
	  "83": {"depth": 0.0, "height": 0.68611, "italic": 0.05382, "skew": 0.0},
	  "84": {"depth": 0.0, "height": 0.68611, "italic": 0.15972, "skew": 0.0},
	  "85": {"depth": 0.0, "height": 0.68611, "italic": 0.11424, "skew": 0.0},
	  "86": {"depth": 0.0, "height": 0.68611, "italic": 0.25555, "skew": 0.0},
	  "87": {"depth": 0.0, "height": 0.68611, "italic": 0.15972, "skew": 0.0},
	  "88": {"depth": 0.0, "height": 0.68611, "italic": 0.07778, "skew": 0.0},
	  "89": {"depth": 0.0, "height": 0.68611, "italic": 0.25555, "skew": 0.0},
	  "90": {"depth": 0.0, "height": 0.68611, "italic": 0.06979, "skew": 0.0},
	  "97": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "98": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "99": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "100": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "101": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "102": {"depth": 0.19444, "height": 0.69444, "italic": 0.11042, "skew": 0.0},
	  "103": {"depth": 0.19444, "height": 0.44444, "italic": 0.03704, "skew": 0.0},
	  "104": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "105": {"depth": 0.0, "height": 0.69326, "italic": 0.0, "skew": 0.0},
	  "106": {"depth": 0.19444, "height": 0.69326, "italic": 0.0622, "skew": 0.0},
	  "107": {"depth": 0.0, "height": 0.69444, "italic": 0.01852, "skew": 0.0},
	  "108": {"depth": 0.0, "height": 0.69444, "italic": 0.0088, "skew": 0.0},
	  "109": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "110": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "111": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "112": {"depth": 0.19444, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "113": {"depth": 0.19444, "height": 0.44444, "italic": 0.03704, "skew": 0.0},
	  "114": {"depth": 0.0, "height": 0.44444, "italic": 0.03194, "skew": 0.0},
	  "115": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "116": {"depth": 0.0, "height": 0.63492, "italic": 0.0, "skew": 0.0},
	  "117": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "118": {"depth": 0.0, "height": 0.44444, "italic": 0.03704, "skew": 0.0},
	  "119": {"depth": 0.0, "height": 0.44444, "italic": 0.02778, "skew": 0.0},
	  "120": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "121": {"depth": 0.19444, "height": 0.44444, "italic": 0.03704, "skew": 0.0},
	  "122": {"depth": 0.0, "height": 0.44444, "italic": 0.04213, "skew": 0.0},
	  "915": {"depth": 0.0, "height": 0.68611, "italic": 0.15972, "skew": 0.0},
	  "916": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "920": {"depth": 0.0, "height": 0.68611, "italic": 0.03194, "skew": 0.0},
	  "923": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "926": {"depth": 0.0, "height": 0.68611, "italic": 0.07458, "skew": 0.0},
	  "928": {"depth": 0.0, "height": 0.68611, "italic": 0.08229, "skew": 0.0},
	  "931": {"depth": 0.0, "height": 0.68611, "italic": 0.05451, "skew": 0.0},
	  "933": {"depth": 0.0, "height": 0.68611, "italic": 0.15972, "skew": 0.0},
	  "934": {"depth": 0.0, "height": 0.68611, "italic": 0.0, "skew": 0.0},
	  "936": {"depth": 0.0, "height": 0.68611, "italic": 0.11653, "skew": 0.0},
	  "937": {"depth": 0.0, "height": 0.68611, "italic": 0.04835, "skew": 0.0},
	  "945": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "946": {"depth": 0.19444, "height": 0.69444, "italic": 0.03403, "skew": 0.0},
	  "947": {"depth": 0.19444, "height": 0.44444, "italic": 0.06389, "skew": 0.0},
	  "948": {"depth": 0.0, "height": 0.69444, "italic": 0.03819, "skew": 0.0},
	  "949": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "950": {"depth": 0.19444, "height": 0.69444, "italic": 0.06215, "skew": 0.0},
	  "951": {"depth": 0.19444, "height": 0.44444, "italic": 0.03704, "skew": 0.0},
	  "952": {"depth": 0.0, "height": 0.69444, "italic": 0.03194, "skew": 0.0},
	  "953": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "954": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "955": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "956": {"depth": 0.19444, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "957": {"depth": 0.0, "height": 0.44444, "italic": 0.06898, "skew": 0.0},
	  "958": {"depth": 0.19444, "height": 0.69444, "italic": 0.03021, "skew": 0.0},
	  "959": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "960": {"depth": 0.0, "height": 0.44444, "italic": 0.03704, "skew": 0.0},
	  "961": {"depth": 0.19444, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "962": {"depth": 0.09722, "height": 0.44444, "italic": 0.07917, "skew": 0.0},
	  "963": {"depth": 0.0, "height": 0.44444, "italic": 0.03704, "skew": 0.0},
	  "964": {"depth": 0.0, "height": 0.44444, "italic": 0.13472, "skew": 0.0},
	  "965": {"depth": 0.0, "height": 0.44444, "italic": 0.03704, "skew": 0.0},
	  "966": {"depth": 0.19444, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "967": {"depth": 0.19444, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "968": {"depth": 0.19444, "height": 0.69444, "italic": 0.03704, "skew": 0.0},
	  "969": {"depth": 0.0, "height": 0.44444, "italic": 0.03704, "skew": 0.0},
	  "977": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "981": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "982": {"depth": 0.0, "height": 0.44444, "italic": 0.03194, "skew": 0.0},
	  "1009": {"depth": 0.19444, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "1013": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0}
	},
	"Math-Italic": {
	  "47": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "65": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.13889},
	  "66": {"depth": 0.0, "height": 0.68333, "italic": 0.05017, "skew": 0.08334},
	  "67": {"depth": 0.0, "height": 0.68333, "italic": 0.07153, "skew": 0.08334},
	  "68": {"depth": 0.0, "height": 0.68333, "italic": 0.02778, "skew": 0.05556},
	  "69": {"depth": 0.0, "height": 0.68333, "italic": 0.05764, "skew": 0.08334},
	  "70": {"depth": 0.0, "height": 0.68333, "italic": 0.13889, "skew": 0.08334},
	  "71": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.08334},
	  "72": {"depth": 0.0, "height": 0.68333, "italic": 0.08125, "skew": 0.05556},
	  "73": {"depth": 0.0, "height": 0.68333, "italic": 0.07847, "skew": 0.11111},
	  "74": {"depth": 0.0, "height": 0.68333, "italic": 0.09618, "skew": 0.16667},
	  "75": {"depth": 0.0, "height": 0.68333, "italic": 0.07153, "skew": 0.05556},
	  "76": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.02778},
	  "77": {"depth": 0.0, "height": 0.68333, "italic": 0.10903, "skew": 0.08334},
	  "78": {"depth": 0.0, "height": 0.68333, "italic": 0.10903, "skew": 0.08334},
	  "79": {"depth": 0.0, "height": 0.68333, "italic": 0.02778, "skew": 0.08334},
	  "80": {"depth": 0.0, "height": 0.68333, "italic": 0.13889, "skew": 0.08334},
	  "81": {"depth": 0.19444, "height": 0.68333, "italic": 0.0, "skew": 0.08334},
	  "82": {"depth": 0.0, "height": 0.68333, "italic": 0.00773, "skew": 0.08334},
	  "83": {"depth": 0.0, "height": 0.68333, "italic": 0.05764, "skew": 0.08334},
	  "84": {"depth": 0.0, "height": 0.68333, "italic": 0.13889, "skew": 0.08334},
	  "85": {"depth": 0.0, "height": 0.68333, "italic": 0.10903, "skew": 0.02778},
	  "86": {"depth": 0.0, "height": 0.68333, "italic": 0.22222, "skew": 0.0},
	  "87": {"depth": 0.0, "height": 0.68333, "italic": 0.13889, "skew": 0.0},
	  "88": {"depth": 0.0, "height": 0.68333, "italic": 0.07847, "skew": 0.08334},
	  "89": {"depth": 0.0, "height": 0.68333, "italic": 0.22222, "skew": 0.0},
	  "90": {"depth": 0.0, "height": 0.68333, "italic": 0.07153, "skew": 0.08334},
	  "97": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "98": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "99": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.05556},
	  "100": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.16667},
	  "101": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.05556},
	  "102": {"depth": 0.19444, "height": 0.69444, "italic": 0.10764, "skew": 0.16667},
	  "103": {"depth": 0.19444, "height": 0.43056, "italic": 0.03588, "skew": 0.02778},
	  "104": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "105": {"depth": 0.0, "height": 0.65952, "italic": 0.0, "skew": 0.0},
	  "106": {"depth": 0.19444, "height": 0.65952, "italic": 0.05724, "skew": 0.0},
	  "107": {"depth": 0.0, "height": 0.69444, "italic": 0.03148, "skew": 0.0},
	  "108": {"depth": 0.0, "height": 0.69444, "italic": 0.01968, "skew": 0.08334},
	  "109": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "110": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "111": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.05556},
	  "112": {"depth": 0.19444, "height": 0.43056, "italic": 0.0, "skew": 0.08334},
	  "113": {"depth": 0.19444, "height": 0.43056, "italic": 0.03588, "skew": 0.08334},
	  "114": {"depth": 0.0, "height": 0.43056, "italic": 0.02778, "skew": 0.05556},
	  "115": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.05556},
	  "116": {"depth": 0.0, "height": 0.61508, "italic": 0.0, "skew": 0.08334},
	  "117": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.02778},
	  "118": {"depth": 0.0, "height": 0.43056, "italic": 0.03588, "skew": 0.02778},
	  "119": {"depth": 0.0, "height": 0.43056, "italic": 0.02691, "skew": 0.08334},
	  "120": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.02778},
	  "121": {"depth": 0.19444, "height": 0.43056, "italic": 0.03588, "skew": 0.05556},
	  "122": {"depth": 0.0, "height": 0.43056, "italic": 0.04398, "skew": 0.05556},
	  "915": {"depth": 0.0, "height": 0.68333, "italic": 0.13889, "skew": 0.08334},
	  "916": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.16667},
	  "920": {"depth": 0.0, "height": 0.68333, "italic": 0.02778, "skew": 0.08334},
	  "923": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.16667},
	  "926": {"depth": 0.0, "height": 0.68333, "italic": 0.07569, "skew": 0.08334},
	  "928": {"depth": 0.0, "height": 0.68333, "italic": 0.08125, "skew": 0.05556},
	  "931": {"depth": 0.0, "height": 0.68333, "italic": 0.05764, "skew": 0.08334},
	  "933": {"depth": 0.0, "height": 0.68333, "italic": 0.13889, "skew": 0.05556},
	  "934": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.08334},
	  "936": {"depth": 0.0, "height": 0.68333, "italic": 0.11, "skew": 0.05556},
	  "937": {"depth": 0.0, "height": 0.68333, "italic": 0.05017, "skew": 0.08334},
	  "945": {"depth": 0.0, "height": 0.43056, "italic": 0.0037, "skew": 0.02778},
	  "946": {"depth": 0.19444, "height": 0.69444, "italic": 0.05278, "skew": 0.08334},
	  "947": {"depth": 0.19444, "height": 0.43056, "italic": 0.05556, "skew": 0.0},
	  "948": {"depth": 0.0, "height": 0.69444, "italic": 0.03785, "skew": 0.05556},
	  "949": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.08334},
	  "950": {"depth": 0.19444, "height": 0.69444, "italic": 0.07378, "skew": 0.08334},
	  "951": {"depth": 0.19444, "height": 0.43056, "italic": 0.03588, "skew": 0.05556},
	  "952": {"depth": 0.0, "height": 0.69444, "italic": 0.02778, "skew": 0.08334},
	  "953": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.05556},
	  "954": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "955": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "956": {"depth": 0.19444, "height": 0.43056, "italic": 0.0, "skew": 0.02778},
	  "957": {"depth": 0.0, "height": 0.43056, "italic": 0.06366, "skew": 0.02778},
	  "958": {"depth": 0.19444, "height": 0.69444, "italic": 0.04601, "skew": 0.11111},
	  "959": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.05556},
	  "960": {"depth": 0.0, "height": 0.43056, "italic": 0.03588, "skew": 0.0},
	  "961": {"depth": 0.19444, "height": 0.43056, "italic": 0.0, "skew": 0.08334},
	  "962": {"depth": 0.09722, "height": 0.43056, "italic": 0.07986, "skew": 0.08334},
	  "963": {"depth": 0.0, "height": 0.43056, "italic": 0.03588, "skew": 0.0},
	  "964": {"depth": 0.0, "height": 0.43056, "italic": 0.1132, "skew": 0.02778},
	  "965": {"depth": 0.0, "height": 0.43056, "italic": 0.03588, "skew": 0.02778},
	  "966": {"depth": 0.19444, "height": 0.43056, "italic": 0.0, "skew": 0.08334},
	  "967": {"depth": 0.19444, "height": 0.43056, "italic": 0.0, "skew": 0.05556},
	  "968": {"depth": 0.19444, "height": 0.69444, "italic": 0.03588, "skew": 0.11111},
	  "969": {"depth": 0.0, "height": 0.43056, "italic": 0.03588, "skew": 0.0},
	  "977": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.08334},
	  "981": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.08334},
	  "982": {"depth": 0.0, "height": 0.43056, "italic": 0.02778, "skew": 0.0},
	  "1009": {"depth": 0.19444, "height": 0.43056, "italic": 0.0, "skew": 0.08334},
	  "1013": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.05556}
	},
	"Math-Regular": {
	  "65": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.13889},
	  "66": {"depth": 0.0, "height": 0.68333, "italic": 0.05017, "skew": 0.08334},
	  "67": {"depth": 0.0, "height": 0.68333, "italic": 0.07153, "skew": 0.08334},
	  "68": {"depth": 0.0, "height": 0.68333, "italic": 0.02778, "skew": 0.05556},
	  "69": {"depth": 0.0, "height": 0.68333, "italic": 0.05764, "skew": 0.08334},
	  "70": {"depth": 0.0, "height": 0.68333, "italic": 0.13889, "skew": 0.08334},
	  "71": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.08334},
	  "72": {"depth": 0.0, "height": 0.68333, "italic": 0.08125, "skew": 0.05556},
	  "73": {"depth": 0.0, "height": 0.68333, "italic": 0.07847, "skew": 0.11111},
	  "74": {"depth": 0.0, "height": 0.68333, "italic": 0.09618, "skew": 0.16667},
	  "75": {"depth": 0.0, "height": 0.68333, "italic": 0.07153, "skew": 0.05556},
	  "76": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.02778},
	  "77": {"depth": 0.0, "height": 0.68333, "italic": 0.10903, "skew": 0.08334},
	  "78": {"depth": 0.0, "height": 0.68333, "italic": 0.10903, "skew": 0.08334},
	  "79": {"depth": 0.0, "height": 0.68333, "italic": 0.02778, "skew": 0.08334},
	  "80": {"depth": 0.0, "height": 0.68333, "italic": 0.13889, "skew": 0.08334},
	  "81": {"depth": 0.19444, "height": 0.68333, "italic": 0.0, "skew": 0.08334},
	  "82": {"depth": 0.0, "height": 0.68333, "italic": 0.00773, "skew": 0.08334},
	  "83": {"depth": 0.0, "height": 0.68333, "italic": 0.05764, "skew": 0.08334},
	  "84": {"depth": 0.0, "height": 0.68333, "italic": 0.13889, "skew": 0.08334},
	  "85": {"depth": 0.0, "height": 0.68333, "italic": 0.10903, "skew": 0.02778},
	  "86": {"depth": 0.0, "height": 0.68333, "italic": 0.22222, "skew": 0.0},
	  "87": {"depth": 0.0, "height": 0.68333, "italic": 0.13889, "skew": 0.0},
	  "88": {"depth": 0.0, "height": 0.68333, "italic": 0.07847, "skew": 0.08334},
	  "89": {"depth": 0.0, "height": 0.68333, "italic": 0.22222, "skew": 0.0},
	  "90": {"depth": 0.0, "height": 0.68333, "italic": 0.07153, "skew": 0.08334},
	  "97": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "98": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "99": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.05556},
	  "100": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.16667},
	  "101": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.05556},
	  "102": {"depth": 0.19444, "height": 0.69444, "italic": 0.10764, "skew": 0.16667},
	  "103": {"depth": 0.19444, "height": 0.43056, "italic": 0.03588, "skew": 0.02778},
	  "104": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "105": {"depth": 0.0, "height": 0.65952, "italic": 0.0, "skew": 0.0},
	  "106": {"depth": 0.19444, "height": 0.65952, "italic": 0.05724, "skew": 0.0},
	  "107": {"depth": 0.0, "height": 0.69444, "italic": 0.03148, "skew": 0.0},
	  "108": {"depth": 0.0, "height": 0.69444, "italic": 0.01968, "skew": 0.08334},
	  "109": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "110": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "111": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.05556},
	  "112": {"depth": 0.19444, "height": 0.43056, "italic": 0.0, "skew": 0.08334},
	  "113": {"depth": 0.19444, "height": 0.43056, "italic": 0.03588, "skew": 0.08334},
	  "114": {"depth": 0.0, "height": 0.43056, "italic": 0.02778, "skew": 0.05556},
	  "115": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.05556},
	  "116": {"depth": 0.0, "height": 0.61508, "italic": 0.0, "skew": 0.08334},
	  "117": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.02778},
	  "118": {"depth": 0.0, "height": 0.43056, "italic": 0.03588, "skew": 0.02778},
	  "119": {"depth": 0.0, "height": 0.43056, "italic": 0.02691, "skew": 0.08334},
	  "120": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.02778},
	  "121": {"depth": 0.19444, "height": 0.43056, "italic": 0.03588, "skew": 0.05556},
	  "122": {"depth": 0.0, "height": 0.43056, "italic": 0.04398, "skew": 0.05556},
	  "915": {"depth": 0.0, "height": 0.68333, "italic": 0.13889, "skew": 0.08334},
	  "916": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.16667},
	  "920": {"depth": 0.0, "height": 0.68333, "italic": 0.02778, "skew": 0.08334},
	  "923": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.16667},
	  "926": {"depth": 0.0, "height": 0.68333, "italic": 0.07569, "skew": 0.08334},
	  "928": {"depth": 0.0, "height": 0.68333, "italic": 0.08125, "skew": 0.05556},
	  "931": {"depth": 0.0, "height": 0.68333, "italic": 0.05764, "skew": 0.08334},
	  "933": {"depth": 0.0, "height": 0.68333, "italic": 0.13889, "skew": 0.05556},
	  "934": {"depth": 0.0, "height": 0.68333, "italic": 0.0, "skew": 0.08334},
	  "936": {"depth": 0.0, "height": 0.68333, "italic": 0.11, "skew": 0.05556},
	  "937": {"depth": 0.0, "height": 0.68333, "italic": 0.05017, "skew": 0.08334},
	  "945": {"depth": 0.0, "height": 0.43056, "italic": 0.0037, "skew": 0.02778},
	  "946": {"depth": 0.19444, "height": 0.69444, "italic": 0.05278, "skew": 0.08334},
	  "947": {"depth": 0.19444, "height": 0.43056, "italic": 0.05556, "skew": 0.0},
	  "948": {"depth": 0.0, "height": 0.69444, "italic": 0.03785, "skew": 0.05556},
	  "949": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.08334},
	  "950": {"depth": 0.19444, "height": 0.69444, "italic": 0.07378, "skew": 0.08334},
	  "951": {"depth": 0.19444, "height": 0.43056, "italic": 0.03588, "skew": 0.05556},
	  "952": {"depth": 0.0, "height": 0.69444, "italic": 0.02778, "skew": 0.08334},
	  "953": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.05556},
	  "954": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "955": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "956": {"depth": 0.19444, "height": 0.43056, "italic": 0.0, "skew": 0.02778},
	  "957": {"depth": 0.0, "height": 0.43056, "italic": 0.06366, "skew": 0.02778},
	  "958": {"depth": 0.19444, "height": 0.69444, "italic": 0.04601, "skew": 0.11111},
	  "959": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.05556},
	  "960": {"depth": 0.0, "height": 0.43056, "italic": 0.03588, "skew": 0.0},
	  "961": {"depth": 0.19444, "height": 0.43056, "italic": 0.0, "skew": 0.08334},
	  "962": {"depth": 0.09722, "height": 0.43056, "italic": 0.07986, "skew": 0.08334},
	  "963": {"depth": 0.0, "height": 0.43056, "italic": 0.03588, "skew": 0.0},
	  "964": {"depth": 0.0, "height": 0.43056, "italic": 0.1132, "skew": 0.02778},
	  "965": {"depth": 0.0, "height": 0.43056, "italic": 0.03588, "skew": 0.02778},
	  "966": {"depth": 0.19444, "height": 0.43056, "italic": 0.0, "skew": 0.08334},
	  "967": {"depth": 0.19444, "height": 0.43056, "italic": 0.0, "skew": 0.05556},
	  "968": {"depth": 0.19444, "height": 0.69444, "italic": 0.03588, "skew": 0.11111},
	  "969": {"depth": 0.0, "height": 0.43056, "italic": 0.03588, "skew": 0.0},
	  "977": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.08334},
	  "981": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.08334},
	  "982": {"depth": 0.0, "height": 0.43056, "italic": 0.02778, "skew": 0.0},
	  "1009": {"depth": 0.19444, "height": 0.43056, "italic": 0.0, "skew": 0.08334},
	  "1013": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.05556}
	},
	"SansSerif-Regular": {
	  "33": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "34": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "35": {"depth": 0.19444, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "36": {"depth": 0.05556, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "37": {"depth": 0.05556, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "38": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "39": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "40": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "41": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "42": {"depth": 0.0, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "43": {"depth": 0.08333, "height": 0.58333, "italic": 0.0, "skew": 0.0},
	  "44": {"depth": 0.125, "height": 0.08333, "italic": 0.0, "skew": 0.0},
	  "45": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "46": {"depth": 0.0, "height": 0.08333, "italic": 0.0, "skew": 0.0},
	  "47": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "48": {"depth": 0.0, "height": 0.65556, "italic": 0.0, "skew": 0.0},
	  "49": {"depth": 0.0, "height": 0.65556, "italic": 0.0, "skew": 0.0},
	  "50": {"depth": 0.0, "height": 0.65556, "italic": 0.0, "skew": 0.0},
	  "51": {"depth": 0.0, "height": 0.65556, "italic": 0.0, "skew": 0.0},
	  "52": {"depth": 0.0, "height": 0.65556, "italic": 0.0, "skew": 0.0},
	  "53": {"depth": 0.0, "height": 0.65556, "italic": 0.0, "skew": 0.0},
	  "54": {"depth": 0.0, "height": 0.65556, "italic": 0.0, "skew": 0.0},
	  "55": {"depth": 0.0, "height": 0.65556, "italic": 0.0, "skew": 0.0},
	  "56": {"depth": 0.0, "height": 0.65556, "italic": 0.0, "skew": 0.0},
	  "57": {"depth": 0.0, "height": 0.65556, "italic": 0.0, "skew": 0.0},
	  "58": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "59": {"depth": 0.125, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "61": {"depth": -0.13, "height": 0.37, "italic": 0.0, "skew": 0.0},
	  "63": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "64": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "65": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "66": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "67": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "68": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "69": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "70": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "71": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "72": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "73": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "74": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "75": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "76": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "77": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "78": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "79": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "80": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "81": {"depth": 0.125, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "82": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "83": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "84": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "85": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "86": {"depth": 0.0, "height": 0.69444, "italic": 0.01389, "skew": 0.0},
	  "87": {"depth": 0.0, "height": 0.69444, "italic": 0.01389, "skew": 0.0},
	  "88": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "89": {"depth": 0.0, "height": 0.69444, "italic": 0.025, "skew": 0.0},
	  "90": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "91": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "93": {"depth": 0.25, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "94": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "95": {"depth": 0.35, "height": 0.09444, "italic": 0.02778, "skew": 0.0},
	  "97": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "98": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "99": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "100": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "101": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "102": {"depth": 0.0, "height": 0.69444, "italic": 0.06944, "skew": 0.0},
	  "103": {"depth": 0.19444, "height": 0.44444, "italic": 0.01389, "skew": 0.0},
	  "104": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "105": {"depth": 0.0, "height": 0.67937, "italic": 0.0, "skew": 0.0},
	  "106": {"depth": 0.19444, "height": 0.67937, "italic": 0.0, "skew": 0.0},
	  "107": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "108": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "109": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "110": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "111": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "112": {"depth": 0.19444, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "113": {"depth": 0.19444, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "114": {"depth": 0.0, "height": 0.44444, "italic": 0.01389, "skew": 0.0},
	  "115": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "116": {"depth": 0.0, "height": 0.57143, "italic": 0.0, "skew": 0.0},
	  "117": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "118": {"depth": 0.0, "height": 0.44444, "italic": 0.01389, "skew": 0.0},
	  "119": {"depth": 0.0, "height": 0.44444, "italic": 0.01389, "skew": 0.0},
	  "120": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "121": {"depth": 0.19444, "height": 0.44444, "italic": 0.01389, "skew": 0.0},
	  "122": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "126": {"depth": 0.35, "height": 0.32659, "italic": 0.0, "skew": 0.0},
	  "305": {"depth": 0.0, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "567": {"depth": 0.19444, "height": 0.44444, "italic": 0.0, "skew": 0.0},
	  "768": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "769": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "770": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "771": {"depth": 0.0, "height": 0.67659, "italic": 0.0, "skew": 0.0},
	  "772": {"depth": 0.0, "height": 0.60889, "italic": 0.0, "skew": 0.0},
	  "774": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "775": {"depth": 0.0, "height": 0.67937, "italic": 0.0, "skew": 0.0},
	  "776": {"depth": 0.0, "height": 0.67937, "italic": 0.0, "skew": 0.0},
	  "778": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "779": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "780": {"depth": 0.0, "height": 0.63194, "italic": 0.0, "skew": 0.0},
	  "915": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "916": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "920": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "923": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "926": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "928": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "931": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "933": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "934": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "936": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "937": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8211": {"depth": 0.0, "height": 0.44444, "italic": 0.02778, "skew": 0.0},
	  "8212": {"depth": 0.0, "height": 0.44444, "italic": 0.02778, "skew": 0.0},
	  "8216": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8217": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8220": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "8221": {"depth": 0.0, "height": 0.69444, "italic": 0.0, "skew": 0.0}
	},
	"Script-Regular": {
	  "65": {"depth": 0.0, "height": 0.7, "italic": 0.22925, "skew": 0.0},
	  "66": {"depth": 0.0, "height": 0.7, "italic": 0.04087, "skew": 0.0},
	  "67": {"depth": 0.0, "height": 0.7, "italic": 0.1689, "skew": 0.0},
	  "68": {"depth": 0.0, "height": 0.7, "italic": 0.09371, "skew": 0.0},
	  "69": {"depth": 0.0, "height": 0.7, "italic": 0.18583, "skew": 0.0},
	  "70": {"depth": 0.0, "height": 0.7, "italic": 0.13634, "skew": 0.0},
	  "71": {"depth": 0.0, "height": 0.7, "italic": 0.17322, "skew": 0.0},
	  "72": {"depth": 0.0, "height": 0.7, "italic": 0.29694, "skew": 0.0},
	  "73": {"depth": 0.0, "height": 0.7, "italic": 0.19189, "skew": 0.0},
	  "74": {"depth": 0.27778, "height": 0.7, "italic": 0.19189, "skew": 0.0},
	  "75": {"depth": 0.0, "height": 0.7, "italic": 0.31259, "skew": 0.0},
	  "76": {"depth": 0.0, "height": 0.7, "italic": 0.19189, "skew": 0.0},
	  "77": {"depth": 0.0, "height": 0.7, "italic": 0.15981, "skew": 0.0},
	  "78": {"depth": 0.0, "height": 0.7, "italic": 0.3525, "skew": 0.0},
	  "79": {"depth": 0.0, "height": 0.7, "italic": 0.08078, "skew": 0.0},
	  "80": {"depth": 0.0, "height": 0.7, "italic": 0.08078, "skew": 0.0},
	  "81": {"depth": 0.0, "height": 0.7, "italic": 0.03305, "skew": 0.0},
	  "82": {"depth": 0.0, "height": 0.7, "italic": 0.06259, "skew": 0.0},
	  "83": {"depth": 0.0, "height": 0.7, "italic": 0.19189, "skew": 0.0},
	  "84": {"depth": 0.0, "height": 0.7, "italic": 0.29087, "skew": 0.0},
	  "85": {"depth": 0.0, "height": 0.7, "italic": 0.25815, "skew": 0.0},
	  "86": {"depth": 0.0, "height": 0.7, "italic": 0.27523, "skew": 0.0},
	  "87": {"depth": 0.0, "height": 0.7, "italic": 0.27523, "skew": 0.0},
	  "88": {"depth": 0.0, "height": 0.7, "italic": 0.26006, "skew": 0.0},
	  "89": {"depth": 0.0, "height": 0.7, "italic": 0.2939, "skew": 0.0},
	  "90": {"depth": 0.0, "height": 0.7, "italic": 0.24037, "skew": 0.0}
	},
	"Size1-Regular": {
	  "40": {"depth": 0.35001, "height": 0.85, "italic": 0.0, "skew": 0.0},
	  "41": {"depth": 0.35001, "height": 0.85, "italic": 0.0, "skew": 0.0},
	  "47": {"depth": 0.35001, "height": 0.85, "italic": 0.0, "skew": 0.0},
	  "91": {"depth": 0.35001, "height": 0.85, "italic": 0.0, "skew": 0.0},
	  "92": {"depth": 0.35001, "height": 0.85, "italic": 0.0, "skew": 0.0},
	  "93": {"depth": 0.35001, "height": 0.85, "italic": 0.0, "skew": 0.0},
	  "123": {"depth": 0.35001, "height": 0.85, "italic": 0.0, "skew": 0.0},
	  "125": {"depth": 0.35001, "height": 0.85, "italic": 0.0, "skew": 0.0},
	  "710": {"depth": 0.0, "height": 0.72222, "italic": 0.0, "skew": 0.0},
	  "732": {"depth": 0.0, "height": 0.72222, "italic": 0.0, "skew": 0.0},
	  "770": {"depth": 0.0, "height": 0.72222, "italic": 0.0, "skew": 0.0},
	  "771": {"depth": 0.0, "height": 0.72222, "italic": 0.0, "skew": 0.0},
	  "8214": {"depth": -0.00099, "height": 0.601, "italic": 0.0, "skew": 0.0},
	  "8593": {"depth": 1e-05, "height": 0.6, "italic": 0.0, "skew": 0.0},
	  "8595": {"depth": 1e-05, "height": 0.6, "italic": 0.0, "skew": 0.0},
	  "8657": {"depth": 1e-05, "height": 0.6, "italic": 0.0, "skew": 0.0},
	  "8659": {"depth": 1e-05, "height": 0.6, "italic": 0.0, "skew": 0.0},
	  "8719": {"depth": 0.25001, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8720": {"depth": 0.25001, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8721": {"depth": 0.25001, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8730": {"depth": 0.35001, "height": 0.85, "italic": 0.0, "skew": 0.0},
	  "8739": {"depth": -0.00599, "height": 0.606, "italic": 0.0, "skew": 0.0},
	  "8741": {"depth": -0.00599, "height": 0.606, "italic": 0.0, "skew": 0.0},
	  "8747": {"depth": 0.30612, "height": 0.805, "italic": 0.19445, "skew": 0.0},
	  "8748": {"depth": 0.306, "height": 0.805, "italic": 0.19445, "skew": 0.0},
	  "8749": {"depth": 0.306, "height": 0.805, "italic": 0.19445, "skew": 0.0},
	  "8750": {"depth": 0.30612, "height": 0.805, "italic": 0.19445, "skew": 0.0},
	  "8896": {"depth": 0.25001, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8897": {"depth": 0.25001, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8898": {"depth": 0.25001, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8899": {"depth": 0.25001, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8968": {"depth": 0.35001, "height": 0.85, "italic": 0.0, "skew": 0.0},
	  "8969": {"depth": 0.35001, "height": 0.85, "italic": 0.0, "skew": 0.0},
	  "8970": {"depth": 0.35001, "height": 0.85, "italic": 0.0, "skew": 0.0},
	  "8971": {"depth": 0.35001, "height": 0.85, "italic": 0.0, "skew": 0.0},
	  "9168": {"depth": -0.00099, "height": 0.601, "italic": 0.0, "skew": 0.0},
	  "10216": {"depth": 0.35001, "height": 0.85, "italic": 0.0, "skew": 0.0},
	  "10217": {"depth": 0.35001, "height": 0.85, "italic": 0.0, "skew": 0.0},
	  "10752": {"depth": 0.25001, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "10753": {"depth": 0.25001, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "10754": {"depth": 0.25001, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "10756": {"depth": 0.25001, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "10758": {"depth": 0.25001, "height": 0.75, "italic": 0.0, "skew": 0.0}
	},
	"Size2-Regular": {
	  "40": {"depth": 0.65002, "height": 1.15, "italic": 0.0, "skew": 0.0},
	  "41": {"depth": 0.65002, "height": 1.15, "italic": 0.0, "skew": 0.0},
	  "47": {"depth": 0.65002, "height": 1.15, "italic": 0.0, "skew": 0.0},
	  "91": {"depth": 0.65002, "height": 1.15, "italic": 0.0, "skew": 0.0},
	  "92": {"depth": 0.65002, "height": 1.15, "italic": 0.0, "skew": 0.0},
	  "93": {"depth": 0.65002, "height": 1.15, "italic": 0.0, "skew": 0.0},
	  "123": {"depth": 0.65002, "height": 1.15, "italic": 0.0, "skew": 0.0},
	  "125": {"depth": 0.65002, "height": 1.15, "italic": 0.0, "skew": 0.0},
	  "710": {"depth": 0.0, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "732": {"depth": 0.0, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "770": {"depth": 0.0, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "771": {"depth": 0.0, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8719": {"depth": 0.55001, "height": 1.05, "italic": 0.0, "skew": 0.0},
	  "8720": {"depth": 0.55001, "height": 1.05, "italic": 0.0, "skew": 0.0},
	  "8721": {"depth": 0.55001, "height": 1.05, "italic": 0.0, "skew": 0.0},
	  "8730": {"depth": 0.65002, "height": 1.15, "italic": 0.0, "skew": 0.0},
	  "8747": {"depth": 0.86225, "height": 1.36, "italic": 0.44445, "skew": 0.0},
	  "8748": {"depth": 0.862, "height": 1.36, "italic": 0.44445, "skew": 0.0},
	  "8749": {"depth": 0.862, "height": 1.36, "italic": 0.44445, "skew": 0.0},
	  "8750": {"depth": 0.86225, "height": 1.36, "italic": 0.44445, "skew": 0.0},
	  "8896": {"depth": 0.55001, "height": 1.05, "italic": 0.0, "skew": 0.0},
	  "8897": {"depth": 0.55001, "height": 1.05, "italic": 0.0, "skew": 0.0},
	  "8898": {"depth": 0.55001, "height": 1.05, "italic": 0.0, "skew": 0.0},
	  "8899": {"depth": 0.55001, "height": 1.05, "italic": 0.0, "skew": 0.0},
	  "8968": {"depth": 0.65002, "height": 1.15, "italic": 0.0, "skew": 0.0},
	  "8969": {"depth": 0.65002, "height": 1.15, "italic": 0.0, "skew": 0.0},
	  "8970": {"depth": 0.65002, "height": 1.15, "italic": 0.0, "skew": 0.0},
	  "8971": {"depth": 0.65002, "height": 1.15, "italic": 0.0, "skew": 0.0},
	  "10216": {"depth": 0.65002, "height": 1.15, "italic": 0.0, "skew": 0.0},
	  "10217": {"depth": 0.65002, "height": 1.15, "italic": 0.0, "skew": 0.0},
	  "10752": {"depth": 0.55001, "height": 1.05, "italic": 0.0, "skew": 0.0},
	  "10753": {"depth": 0.55001, "height": 1.05, "italic": 0.0, "skew": 0.0},
	  "10754": {"depth": 0.55001, "height": 1.05, "italic": 0.0, "skew": 0.0},
	  "10756": {"depth": 0.55001, "height": 1.05, "italic": 0.0, "skew": 0.0},
	  "10758": {"depth": 0.55001, "height": 1.05, "italic": 0.0, "skew": 0.0}
	},
	"Size3-Regular": {
	  "40": {"depth": 0.95003, "height": 1.45, "italic": 0.0, "skew": 0.0},
	  "41": {"depth": 0.95003, "height": 1.45, "italic": 0.0, "skew": 0.0},
	  "47": {"depth": 0.95003, "height": 1.45, "italic": 0.0, "skew": 0.0},
	  "91": {"depth": 0.95003, "height": 1.45, "italic": 0.0, "skew": 0.0},
	  "92": {"depth": 0.95003, "height": 1.45, "italic": 0.0, "skew": 0.0},
	  "93": {"depth": 0.95003, "height": 1.45, "italic": 0.0, "skew": 0.0},
	  "123": {"depth": 0.95003, "height": 1.45, "italic": 0.0, "skew": 0.0},
	  "125": {"depth": 0.95003, "height": 1.45, "italic": 0.0, "skew": 0.0},
	  "710": {"depth": 0.0, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "732": {"depth": 0.0, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "770": {"depth": 0.0, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "771": {"depth": 0.0, "height": 0.75, "italic": 0.0, "skew": 0.0},
	  "8730": {"depth": 0.95003, "height": 1.45, "italic": 0.0, "skew": 0.0},
	  "8968": {"depth": 0.95003, "height": 1.45, "italic": 0.0, "skew": 0.0},
	  "8969": {"depth": 0.95003, "height": 1.45, "italic": 0.0, "skew": 0.0},
	  "8970": {"depth": 0.95003, "height": 1.45, "italic": 0.0, "skew": 0.0},
	  "8971": {"depth": 0.95003, "height": 1.45, "italic": 0.0, "skew": 0.0},
	  "10216": {"depth": 0.95003, "height": 1.45, "italic": 0.0, "skew": 0.0},
	  "10217": {"depth": 0.95003, "height": 1.45, "italic": 0.0, "skew": 0.0}
	},
	"Size4-Regular": {
	  "40": {"depth": 1.25003, "height": 1.75, "italic": 0.0, "skew": 0.0},
	  "41": {"depth": 1.25003, "height": 1.75, "italic": 0.0, "skew": 0.0},
	  "47": {"depth": 1.25003, "height": 1.75, "italic": 0.0, "skew": 0.0},
	  "91": {"depth": 1.25003, "height": 1.75, "italic": 0.0, "skew": 0.0},
	  "92": {"depth": 1.25003, "height": 1.75, "italic": 0.0, "skew": 0.0},
	  "93": {"depth": 1.25003, "height": 1.75, "italic": 0.0, "skew": 0.0},
	  "123": {"depth": 1.25003, "height": 1.75, "italic": 0.0, "skew": 0.0},
	  "125": {"depth": 1.25003, "height": 1.75, "italic": 0.0, "skew": 0.0},
	  "710": {"depth": 0.0, "height": 0.825, "italic": 0.0, "skew": 0.0},
	  "732": {"depth": 0.0, "height": 0.825, "italic": 0.0, "skew": 0.0},
	  "770": {"depth": 0.0, "height": 0.825, "italic": 0.0, "skew": 0.0},
	  "771": {"depth": 0.0, "height": 0.825, "italic": 0.0, "skew": 0.0},
	  "8730": {"depth": 1.25003, "height": 1.75, "italic": 0.0, "skew": 0.0},
	  "8968": {"depth": 1.25003, "height": 1.75, "italic": 0.0, "skew": 0.0},
	  "8969": {"depth": 1.25003, "height": 1.75, "italic": 0.0, "skew": 0.0},
	  "8970": {"depth": 1.25003, "height": 1.75, "italic": 0.0, "skew": 0.0},
	  "8971": {"depth": 1.25003, "height": 1.75, "italic": 0.0, "skew": 0.0},
	  "9115": {"depth": 0.64502, "height": 1.155, "italic": 0.0, "skew": 0.0},
	  "9116": {"depth": 1e-05, "height": 0.6, "italic": 0.0, "skew": 0.0},
	  "9117": {"depth": 0.64502, "height": 1.155, "italic": 0.0, "skew": 0.0},
	  "9118": {"depth": 0.64502, "height": 1.155, "italic": 0.0, "skew": 0.0},
	  "9119": {"depth": 1e-05, "height": 0.6, "italic": 0.0, "skew": 0.0},
	  "9120": {"depth": 0.64502, "height": 1.155, "italic": 0.0, "skew": 0.0},
	  "9121": {"depth": 0.64502, "height": 1.155, "italic": 0.0, "skew": 0.0},
	  "9122": {"depth": -0.00099, "height": 0.601, "italic": 0.0, "skew": 0.0},
	  "9123": {"depth": 0.64502, "height": 1.155, "italic": 0.0, "skew": 0.0},
	  "9124": {"depth": 0.64502, "height": 1.155, "italic": 0.0, "skew": 0.0},
	  "9125": {"depth": -0.00099, "height": 0.601, "italic": 0.0, "skew": 0.0},
	  "9126": {"depth": 0.64502, "height": 1.155, "italic": 0.0, "skew": 0.0},
	  "9127": {"depth": 1e-05, "height": 0.9, "italic": 0.0, "skew": 0.0},
	  "9128": {"depth": 0.65002, "height": 1.15, "italic": 0.0, "skew": 0.0},
	  "9129": {"depth": 0.90001, "height": 0.0, "italic": 0.0, "skew": 0.0},
	  "9130": {"depth": 0.0, "height": 0.3, "italic": 0.0, "skew": 0.0},
	  "9131": {"depth": 1e-05, "height": 0.9, "italic": 0.0, "skew": 0.0},
	  "9132": {"depth": 0.65002, "height": 1.15, "italic": 0.0, "skew": 0.0},
	  "9133": {"depth": 0.90001, "height": 0.0, "italic": 0.0, "skew": 0.0},
	  "9143": {"depth": 0.88502, "height": 0.915, "italic": 0.0, "skew": 0.0},
	  "10216": {"depth": 1.25003, "height": 1.75, "italic": 0.0, "skew": 0.0},
	  "10217": {"depth": 1.25003, "height": 1.75, "italic": 0.0, "skew": 0.0},
	  "57344": {"depth": -0.00499, "height": 0.605, "italic": 0.0, "skew": 0.0},
	  "57345": {"depth": -0.00499, "height": 0.605, "italic": 0.0, "skew": 0.0},
	  "57680": {"depth": 0.0, "height": 0.12, "italic": 0.0, "skew": 0.0},
	  "57681": {"depth": 0.0, "height": 0.12, "italic": 0.0, "skew": 0.0},
	  "57682": {"depth": 0.0, "height": 0.12, "italic": 0.0, "skew": 0.0},
	  "57683": {"depth": 0.0, "height": 0.12, "italic": 0.0, "skew": 0.0}
	},
	"Typewriter-Regular": {
	  "33": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "34": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "35": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "36": {"depth": 0.08333, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "37": {"depth": 0.08333, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "38": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "39": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "40": {"depth": 0.08333, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "41": {"depth": 0.08333, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "42": {"depth": 0.0, "height": 0.52083, "italic": 0.0, "skew": 0.0},
	  "43": {"depth": -0.08056, "height": 0.53055, "italic": 0.0, "skew": 0.0},
	  "44": {"depth": 0.13889, "height": 0.125, "italic": 0.0, "skew": 0.0},
	  "45": {"depth": -0.08056, "height": 0.53055, "italic": 0.0, "skew": 0.0},
	  "46": {"depth": 0.0, "height": 0.125, "italic": 0.0, "skew": 0.0},
	  "47": {"depth": 0.08333, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "48": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "49": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "50": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "51": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "52": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "53": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "54": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "55": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "56": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "57": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "58": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "59": {"depth": 0.13889, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "60": {"depth": -0.05556, "height": 0.55556, "italic": 0.0, "skew": 0.0},
	  "61": {"depth": -0.19549, "height": 0.41562, "italic": 0.0, "skew": 0.0},
	  "62": {"depth": -0.05556, "height": 0.55556, "italic": 0.0, "skew": 0.0},
	  "63": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "64": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "65": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "66": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "67": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "68": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "69": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "70": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "71": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "72": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "73": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "74": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "75": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "76": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "77": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "78": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "79": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "80": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "81": {"depth": 0.13889, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "82": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "83": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "84": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "85": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "86": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "87": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "88": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "89": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "90": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "91": {"depth": 0.08333, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "92": {"depth": 0.08333, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "93": {"depth": 0.08333, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "94": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "95": {"depth": 0.09514, "height": 0.0, "italic": 0.0, "skew": 0.0},
	  "96": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "97": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "98": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "99": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "100": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "101": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "102": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "103": {"depth": 0.22222, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "104": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "105": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "106": {"depth": 0.22222, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "107": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "108": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "109": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "110": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "111": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "112": {"depth": 0.22222, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "113": {"depth": 0.22222, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "114": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "115": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "116": {"depth": 0.0, "height": 0.55358, "italic": 0.0, "skew": 0.0},
	  "117": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "118": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "119": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "120": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "121": {"depth": 0.22222, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "122": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "123": {"depth": 0.08333, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "124": {"depth": 0.08333, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "125": {"depth": 0.08333, "height": 0.69444, "italic": 0.0, "skew": 0.0},
	  "126": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "127": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "305": {"depth": 0.0, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "567": {"depth": 0.22222, "height": 0.43056, "italic": 0.0, "skew": 0.0},
	  "768": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "769": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "770": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "771": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "772": {"depth": 0.0, "height": 0.56555, "italic": 0.0, "skew": 0.0},
	  "774": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "776": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "778": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "780": {"depth": 0.0, "height": 0.56597, "italic": 0.0, "skew": 0.0},
	  "915": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "916": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "920": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "923": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "926": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "928": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "931": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "933": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "934": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "936": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "937": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "2018": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "2019": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0},
	  "8242": {"depth": 0.0, "height": 0.61111, "italic": 0.0, "skew": 0.0}
	}};


/***/ },
/* 15 */
/***/ function(module, exports) {

	/**
	 * This file holds a list of all no-argument functions and single-character
	 * symbols (like 'a' or ';').
	 *
	 * For each of the symbols, there are three properties they can have:
	 * - font (required): the font to be used for this symbol. Either "main" (the
	     normal font), or "ams" (the ams fonts).
	 * - group (required): the ParseNode group type the symbol should have (i.e.
	     "textord", "mathord", etc).
	     See https://github.com/Khan/KaTeX/wiki/Examining-TeX#group-types
	 * - replace (optional): the character that this symbol or function should be
	 *   replaced with (i.e. "\phi" has a replace value of "\u03d5", the phi
	 *   character in the main font).
	 *
	 * The outermost map in the table indicates what mode the symbols should be
	 * accepted in (e.g. "math" or "text").
	 */

	var symbols = {
	    "math": {
	        // Relation Symbols
	        "\\equiv": {
	            font: "main",
	            group: "rel",
	            replace: "\u2261"
	        },
	        "\\prec": {
	            font: "main",
	            group: "rel",
	            replace: "\u227a"
	        },
	        "\\succ": {
	            font: "main",
	            group: "rel",
	            replace: "\u227b"
	        },
	        "\\sim": {
	            font: "main",
	            group: "rel",
	            replace: "\u223c"
	        },
	        "\\perp": {
	            font: "main",
	            group: "rel",
	            replace: "\u22a5"
	        },
	        "\\preceq": {
	            font: "main",
	            group: "rel",
	            replace: "\u2aaf"
	        },
	        "\\succeq": {
	            font: "main",
	            group: "rel",
	            replace: "\u2ab0"
	        },
	        "\\simeq": {
	            font: "main",
	            group: "rel",
	            replace: "\u2243"
	        },
	        "\\mid": {
	            font: "main",
	            group: "rel",
	            replace: "\u2223"
	        },
	        "\\ll": {
	            font: "main",
	            group: "rel",
	            replace: "\u226a"
	        },
	        "\\gg": {
	            font: "main",
	            group: "rel",
	            replace: "\u226b"
	        },
	        "\\asymp": {
	            font: "main",
	            group: "rel",
	            replace: "\u224d"
	        },
	        "\\parallel": {
	            font: "main",
	            group: "rel",
	            replace: "\u2225"
	        },
	        "\\bowtie": {
	            font: "main",
	            group: "rel",
	            replace: "\u22c8"
	        },
	        "\\smile": {
	            font: "main",
	            group: "rel",
	            replace: "\u2323"
	        },
	        "\\sqsubseteq": {
	            font: "main",
	            group: "rel",
	            replace: "\u2291"
	        },
	        "\\sqsupseteq": {
	            font: "main",
	            group: "rel",
	            replace: "\u2292"
	        },
	        "\\doteq": {
	            font: "main",
	            group: "rel",
	            replace: "\u2250"
	        },
	        "\\frown": {
	            font: "main",
	            group: "rel",
	            replace: "\u2322"
	        },
	        "\\ni": {
	            font: "main",
	            group: "rel",
	            replace: "\u220b"
	        },
	        "\\propto": {
	            font: "main",
	            group: "rel",
	            replace: "\u221d"
	        },
	        "\\vdash": {
	            font: "main",
	            group: "rel",
	            replace: "\u22a2"
	        },
	        "\\dashv": {
	            font: "main",
	            group: "rel",
	            replace: "\u22a3"
	        },
	        "\\owns": {
	            font: "main",
	            group: "rel",
	            replace: "\u220b"
	        },

	        // Punctuation
	        "\\ldotp": {
	            font: "main",
	            group: "punct",
	            replace: "\u002e"
	        },
	        "\\cdotp": {
	            font: "main",
	            group: "punct",
	            replace: "\u22c5"
	        },

	        // Misc Symbols
	        "\\#": {
	          font: "main",
	          group: "textord",
	          replace: "\u0023"
	        },
	        "\\&": {
	          font: "main",
	          group: "textord",
	          replace: "\u0026"
	        },
	        "\\aleph": {
	            font: "main",
	            group: "textord",
	            replace: "\u2135"
	        },
	        "\\forall": {
	            font: "main",
	            group: "textord",
	            replace: "\u2200"
	        },
	        "\\hbar": {
	            font: "main",
	            group: "textord",
	            replace: "\u210f"
	        },
	        "\\exists": {
	            font: "main",
	            group: "textord",
	            replace: "\u2203"
	        },
	        "\\nabla": {
	            font: "main",
	            group: "textord",
	            replace: "\u2207"
	        },
	        "\\flat": {
	            font: "main",
	            group: "textord",
	            replace: "\u266d"
	        },
	        "\\ell": {
	            font: "main",
	            group: "textord",
	            replace: "\u2113"
	        },
	        "\\natural": {
	            font: "main",
	            group: "textord",
	            replace: "\u266e"
	        },
	        "\\clubsuit": {
	            font: "main",
	            group: "textord",
	            replace: "\u2663"
	        },
	        "\\wp": {
	            font: "main",
	            group: "textord",
	            replace: "\u2118"
	        },
	        "\\sharp": {
	            font: "main",
	            group: "textord",
	            replace: "\u266f"
	        },
	        "\\diamondsuit": {
	            font: "main",
	            group: "textord",
	            replace: "\u2662"
	        },
	        "\\Re": {
	            font: "main",
	            group: "textord",
	            replace: "\u211c"
	        },
	        "\\heartsuit": {
	            font: "main",
	            group: "textord",
	            replace: "\u2661"
	        },
	        "\\Im": {
	            font: "main",
	            group: "textord",
	            replace: "\u2111"
	        },
	        "\\spadesuit": {
	            font: "main",
	            group: "textord",
	            replace: "\u2660"
	        },

	        // Math and Text
	        "\\dag": {
	            font: "main",
	            group: "textord",
	            replace: "\u2020"
	        },
	        "\\ddag": {
	            font: "main",
	            group: "textord",
	            replace: "\u2021"
	        },

	        // Large Delimiters
	        "\\rmoustache": {
	            font: "main",
	            group: "close",
	            replace: "\u23b1"
	        },
	        "\\lmoustache": {
	            font: "main",
	            group: "open",
	            replace: "\u23b0"
	        },
	        "\\rgroup": {
	            font: "main",
	            group: "close",
	            replace: "\u27ef"
	        },
	        "\\lgroup": {
	            font: "main",
	            group: "open",
	            replace: "\u27ee"
	        },

	        // Binary Operators
	        "\\mp": {
	            font: "main",
	            group: "bin",
	            replace: "\u2213"
	        },
	        "\\ominus": {
	            font: "main",
	            group: "bin",
	            replace: "\u2296"
	        },
	        "\\uplus": {
	            font: "main",
	            group: "bin",
	            replace: "\u228e"
	        },
	        "\\sqcap": {
	            font: "main",
	            group: "bin",
	            replace: "\u2293"
	        },
	        "\\ast": {
	            font: "main",
	            group: "bin",
	            replace: "\u2217"
	        },
	        "\\sqcup": {
	            font: "main",
	            group: "bin",
	            replace: "\u2294"
	        },
	        "\\bigcirc": {
	            font: "main",
	            group: "bin",
	            replace: "\u25ef"
	        },
	        "\\bullet": {
	            font: "main",
	            group: "bin",
	            replace: "\u2219"
	        },
	        "\\ddagger": {
	            font: "main",
	            group: "bin",
	            replace: "\u2021"
	        },
	        "\\wr": {
	            font: "main",
	            group: "bin",
	            replace: "\u2240"
	        },
	        "\\amalg": {
	            font: "main",
	            group: "bin",
	            replace: "\u2a3f"
	        },

	        // Arrow Symbols
	        "\\longleftarrow": {
	            font: "main",
	            group: "rel",
	            replace: "\u27f5"
	        },
	        "\\Leftarrow": {
	            font: "main",
	            group: "rel",
	            replace: "\u21d0"
	        },
	        "\\Longleftarrow": {
	            font: "main",
	            group: "rel",
	            replace: "\u27f8"
	        },
	        "\\longrightarrow": {
	            font: "main",
	            group: "rel",
	            replace: "\u27f6"
	        },
	        "\\Rightarrow": {
	            font: "main",
	            group: "rel",
	            replace: "\u21d2"
	        },
	        "\\Longrightarrow": {
	            font: "main",
	            group: "rel",
	            replace: "\u27f9"
	        },
	        "\\leftrightarrow": {
	            font: "main",
	            group: "rel",
	            replace: "\u2194"
	        },
	        "\\longleftrightarrow": {
	            font: "main",
	            group: "rel",
	            replace: "\u27f7"
	        },
	        "\\Leftrightarrow": {
	            font: "main",
	            group: "rel",
	            replace: "\u21d4"
	        },
	        "\\Longleftrightarrow": {
	            font: "main",
	            group: "rel",
	            replace: "\u27fa"
	        },
	        "\\mapsto": {
	            font: "main",
	            group: "rel",
	            replace: "\u21a6"
	        },
	        "\\longmapsto": {
	            font: "main",
	            group: "rel",
	            replace: "\u27fc"
	        },
	        "\\nearrow": {
	            font: "main",
	            group: "rel",
	            replace: "\u2197"
	        },
	        "\\hookleftarrow": {
	            font: "main",
	            group: "rel",
	            replace: "\u21a9"
	        },
	        "\\hookrightarrow": {
	            font: "main",
	            group: "rel",
	            replace: "\u21aa"
	        },
	        "\\searrow": {
	            font: "main",
	            group: "rel",
	            replace: "\u2198"
	        },
	        "\\leftharpoonup": {
	            font: "main",
	            group: "rel",
	            replace: "\u21bc"
	        },
	        "\\rightharpoonup": {
	            font: "main",
	            group: "rel",
	            replace: "\u21c0"
	        },
	        "\\swarrow": {
	            font: "main",
	            group: "rel",
	            replace: "\u2199"
	        },
	        "\\leftharpoondown": {
	            font: "main",
	            group: "rel",
	            replace: "\u21bd"
	        },
	        "\\rightharpoondown": {
	            font: "main",
	            group: "rel",
	            replace: "\u21c1"
	        },
	        "\\nwarrow": {
	            font: "main",
	            group: "rel",
	            replace: "\u2196"
	        },
	        "\\rightleftharpoons": {
	            font: "main",
	            group: "rel",
	            replace: "\u21cc"
	        },

	        // AMS Negated Binary Relations
	        "\\nless": {
	            font: "ams",
	            group: "rel",
	            replace: "\u226e"
	        },
	        "\\nleqslant": {
	            font: "ams",
	            group: "rel",
	            replace: "\ue010"
	        },
	        "\\nleqq": {
	            font: "ams",
	            group: "rel",
	            replace: "\ue011"
	        },
	        "\\lneq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2a87"
	        },
	        "\\lneqq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2268"
	        },
	        "\\lvertneqq": {
	            font: "ams",
	            group: "rel",
	            replace: "\ue00c"
	        },
	        "\\lnsim": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22e6"
	        },
	        "\\lnapprox": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2a89"
	        },
	        "\\nprec": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2280"
	        },
	        "\\npreceq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22e0"
	        },
	        "\\precnsim": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22e8"
	        },
	        "\\precnapprox": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2ab9"
	        },
	        "\\nsim": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2241"
	        },
	        "\\nshortmid": {
	            font: "ams",
	            group: "rel",
	            replace: "\ue006"
	        },
	        "\\nmid": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2224"
	        },
	        "\\nvdash": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22ac"
	        },
	        "\\nvDash": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22ad"
	        },
	        "\\ntriangleleft": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22ea"
	        },
	        "\\ntrianglelefteq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22ec"
	        },
	        "\\subsetneq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u228a"
	        },
	        "\\varsubsetneq": {
	            font: "ams",
	            group: "rel",
	            replace: "\ue01a"
	        },
	        "\\subsetneqq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2acb"
	        },
	        "\\varsubsetneqq": {
	            font: "ams",
	            group: "rel",
	            replace: "\ue017"
	        },
	        "\\ngtr": {
	            font: "ams",
	            group: "rel",
	            replace: "\u226f"
	        },
	        "\\ngeqslant": {
	            font: "ams",
	            group: "rel",
	            replace: "\ue00f"
	        },
	        "\\ngeqq": {
	            font: "ams",
	            group: "rel",
	            replace: "\ue00e"
	        },
	        "\\gneq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2a88"
	        },
	        "\\gneqq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2269"
	        },
	        "\\gvertneqq": {
	            font: "ams",
	            group: "rel",
	            replace: "\ue00d"
	        },
	        "\\gnsim": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22e7"
	        },
	        "\\gnapprox": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2a8a"
	        },
	        "\\nsucc": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2281"
	        },
	        "\\nsucceq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22e1"
	        },
	        "\\succnsim": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22e9"
	        },
	        "\\succnapprox": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2aba"
	        },
	        "\\ncong": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2246"
	        },
	        "\\nshortparallel": {
	            font: "ams",
	            group: "rel",
	            replace: "\ue007"
	        },
	        "\\nparallel": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2226"
	        },
	        "\\nVDash": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22af"
	        },
	        "\\ntriangleright": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22eb"
	        },
	        "\\ntrianglerighteq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22ed"
	        },
	        "\\nsupseteqq": {
	            font: "ams",
	            group: "rel",
	            replace: "\ue018"
	        },
	        "\\supsetneq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u228b"
	        },
	        "\\varsupsetneq": {
	            font: "ams",
	            group: "rel",
	            replace: "\ue01b"
	        },
	        "\\supsetneqq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2acc"
	        },
	        "\\varsupsetneqq": {
	            font: "ams",
	            group: "rel",
	            replace: "\ue019"
	        },
	        "\\nVdash": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22ae"
	        },
	        "\\precneqq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2ab5"
	        },
	        "\\succneqq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2ab6"
	        },
	        "\\nsubseteqq": {
	            font: "ams",
	            group: "rel",
	            replace: "\ue016"
	        },
	        "\\unlhd": {
	            font: "ams",
	            group: "bin",
	            replace: "\u22b4"
	        },
	        "\\unrhd": {
	            font: "ams",
	            group: "bin",
	            replace: "\u22b5"
	        },

	        // AMS Negated Arrows
	         "\\nleftarrow": {
	            font: "ams",
	            group: "rel",
	            replace: "\u219a"
	        },
	        "\\nrightarrow": {
	            font: "ams",
	            group: "rel",
	            replace: "\u219b"
	        },
	        "\\nLeftarrow": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21cd"
	        },
	        "\\nRightarrow": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21cf"
	        },
	        "\\nleftrightarrow": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21ae"
	        },
	        "\\nLeftrightarrow": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21ce"
	        },

	        // AMS Misc
	        "\\vartriangle": {
	            font: "ams",
	            group: "rel",
	            replace: "\u25b3"
	        },
	        "\\hslash": {
	            font: "ams",
	            group: "textord",
	            replace: "\u210f"
	        },
	        "\\triangledown": {
	            font: "ams",
	            group: "textord",
	            replace: "\u25bd"
	        },
	        "\\lozenge": {
	            font: "ams",
	            group: "textord",
	            replace: "\u25ca"
	        },
	        "\\circledS": {
	            font: "ams",
	            group: "textord",
	            replace: "\u24c8"
	        },
	        "\\circledR": {
	            font: "ams",
	            group: "textord",
	            replace: "\u00ae"
	        },
	        "\\measuredangle": {
	            font: "ams",
	            group: "textord",
	            replace: "\u2221"
	        },
	        "\\nexists": {
	            font: "ams",
	            group: "textord",
	            replace: "\u2204"
	        },
	        "\\mho": {
	            font: "ams",
	            group: "textord",
	            replace: "\u2127"
	        },
	        "\\Finv": {
	            font: "ams",
	            group: "textord",
	            replace: "\u2132"
	        },
	        "\\Game": {
	            font: "ams",
	            group: "textord",
	            replace: "\u2141"
	        },
	        "\\Bbbk": {
	            font: "ams",
	            group: "textord",
	            replace: "\u006b"
	        },
	        "\\backprime": {
	            font: "ams",
	            group: "textord",
	            replace: "\u2035"
	        },
	        "\\blacktriangle": {
	            font: "ams",
	            group: "textord",
	            replace: "\u25b2"
	        },
	        "\\blacktriangledown": {
	            font: "ams",
	            group: "textord",
	            replace: "\u25bc"
	        },
	        "\\blacksquare": {
	            font: "ams",
	            group: "textord",
	            replace: "\u25a0"
	        },
	        "\\blacklozenge": {
	            font: "ams",
	            group: "textord",
	            replace: "\u29eb"
	        },
	        "\\bigstar": {
	            font: "ams",
	            group: "textord",
	            replace: "\u2605"
	        },
	        "\\sphericalangle": {
	            font: "ams",
	            group: "textord",
	            replace: "\u2222"
	        },
	        "\\complement": {
	            font: "ams",
	            group: "textord",
	            replace: "\u2201"
	        },
	        "\\eth": {
	            font: "ams",
	            group: "textord",
	            replace: "\u00f0"
	        },
	        "\\diagup": {
	            font: "ams",
	            group: "textord",
	            replace: "\u2571"
	        },
	        "\\diagdown": {
	            font: "ams",
	            group: "textord",
	            replace: "\u2572"
	        },
	        "\\square": {
	            font: "ams",
	            group: "textord",
	            replace: "\u25a1"
	        },
	        "\\Box": {
	            font: "ams",
	            group: "textord",
	            replace: "\u25a1"
	        },
	        "\\Diamond": {
	            font: "ams",
	            group: "textord",
	            replace: "\u25ca"
	        },
	        "\\yen": {
	            font: "ams",
	            group: "textord",
	            replace: "\u00a5"
	        },
	        "\\checkmark": {
	            font: "ams",
	            group: "textord",
	            replace: "\u2713"
	        },

	        // AMS Hebrew
	        "\\beth": {
	            font: "ams",
	            group: "textord",
	            replace: "\u2136"
	        },
	        "\\daleth": {
	            font: "ams",
	            group: "textord",
	            replace: "\u2138"
	        },
	        "\\gimel": {
	            font: "ams",
	            group: "textord",
	            replace: "\u2137"
	        },

	        // AMS Greek
	        "\\digamma": {
	            font: "ams",
	            group: "textord",
	            replace: "\u03dd"
	        },
	        "\\varkappa": {
	            font: "ams",
	            group: "textord",
	            replace: "\u03f0"
	        },

	        // AMS Delimiters
	        "\\ulcorner": {
	            font: "ams",
	            group: "open",
	            replace: "\u250c"
	        },
	        "\\urcorner": {
	            font: "ams",
	            group: "close",
	            replace: "\u2510"
	        },
	        "\\llcorner": {
	            font: "ams",
	            group: "open",
	            replace: "\u2514"
	        },
	        "\\lrcorner": {
	            font: "ams",
	            group: "close",
	            replace: "\u2518"
	        },

	        // AMS Binary Relations
	        "\\leqq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2266"
	        },
	        "\\leqslant": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2a7d"
	        },
	        "\\eqslantless": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2a95"
	        },
	        "\\lesssim": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2272"
	        },
	        "\\lessapprox": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2a85"
	        },
	        "\\approxeq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u224a"
	        },
	        "\\lessdot": {
	            font: "ams",
	            group: "bin",
	            replace: "\u22d6"
	        },
	        "\\lll": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22d8"
	        },
	        "\\lessgtr": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2276"
	        },
	        "\\lesseqgtr": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22da"
	        },
	        "\\lesseqqgtr": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2a8b"
	        },
	        "\\doteqdot": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2251"
	        },
	        "\\risingdotseq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2253"
	        },
	        "\\fallingdotseq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2252"
	        },
	        "\\backsim": {
	            font: "ams",
	            group: "rel",
	            replace: "\u223d"
	        },
	        "\\backsimeq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22cd"
	        },
	        "\\subseteqq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2ac5"
	        },
	        "\\Subset": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22d0"
	        },
	        "\\sqsubset": {
	            font: "ams",
	            group: "rel",
	            replace: "\u228f"
	        },
	        "\\preccurlyeq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u227c"
	        },
	        "\\curlyeqprec": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22de"
	        },
	        "\\precsim": {
	            font: "ams",
	            group: "rel",
	            replace: "\u227e"
	        },
	        "\\precapprox": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2ab7"
	        },
	        "\\vartriangleleft": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22b2"
	        },
	        "\\trianglelefteq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22b4"
	        },
	        "\\vDash": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22a8"
	        },
	        "\\Vvdash": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22aa"
	        },
	        "\\smallsmile": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2323"
	        },
	        "\\smallfrown": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2322"
	        },
	        "\\bumpeq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u224f"
	        },
	        "\\Bumpeq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u224e"
	        },
	        "\\geqq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2267"
	        },
	        "\\geqslant": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2a7e"
	        },
	        "\\eqslantgtr": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2a96"
	        },
	        "\\gtrsim": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2273"
	        },
	        "\\gtrapprox": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2a86"
	        },
	        "\\gtrdot": {
	            font: "ams",
	            group: "bin",
	            replace: "\u22d7"
	        },
	        "\\ggg": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22d9"
	        },
	        "\\gtrless": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2277"
	        },
	        "\\gtreqless": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22db"
	        },
	        "\\gtreqqless": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2a8c"
	        },
	        "\\eqcirc": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2256"
	        },
	        "\\circeq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2257"
	        },
	        "\\triangleq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u225c"
	        },
	        "\\thicksim": {
	            font: "ams",
	            group: "rel",
	            replace: "\u223c"
	        },
	        "\\thickapprox": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2248"
	        },
	        "\\supseteqq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2ac6"
	        },
	        "\\Supset": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22d1"
	        },
	        "\\sqsupset": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2290"
	        },
	        "\\succcurlyeq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u227d"
	        },
	        "\\curlyeqsucc": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22df"
	        },
	        "\\succsim": {
	            font: "ams",
	            group: "rel",
	            replace: "\u227f"
	        },
	        "\\succapprox": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2ab8"
	        },
	        "\\vartriangleright": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22b3"
	        },
	        "\\trianglerighteq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22b5"
	        },
	        "\\Vdash": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22a9"
	        },
	        "\\shortmid": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2223"
	        },
	        "\\shortparallel": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2225"
	        },
	        "\\between": {
	            font: "ams",
	            group: "rel",
	            replace: "\u226c"
	        },
	        "\\pitchfork": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22d4"
	        },
	        "\\varpropto": {
	            font: "ams",
	            group: "rel",
	            replace: "\u221d"
	        },
	        "\\blacktriangleleft": {
	            font: "ams",
	            group: "rel",
	            replace: "\u25c0"
	        },
	        "\\therefore": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2234"
	        },
	        "\\backepsilon": {
	            font: "ams",
	            group: "rel",
	            replace: "\u220d"
	        },
	        "\\blacktriangleright": {
	            font: "ams",
	            group: "rel",
	            replace: "\u25b6"
	        },
	        "\\because": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2235"
	        },
	        "\\llless": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22d8"
	        },
	        "\\gggtr": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22d9"
	        },
	        "\\lhd": {
	            font: "ams",
	            group: "bin",
	            replace: "\u22b2"
	        },
	        "\\rhd": {
	            font: "ams",
	            group: "bin",
	            replace: "\u22b3"
	        },
	        "\\eqsim": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2242"
	        },
	        "\\Join": {
	            font: "main",
	            group: "rel",
	            replace: "\u22c8"
	        },
	        "\\Doteq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2251"
	        },

	        // AMS Binary Operators
	        "\\dotplus": {
	            font: "ams",
	            group: "bin",
	            replace: "\u2214"
	        },
	        "\\smallsetminus": {
	            font: "ams",
	            group: "bin",
	            replace: "\u2216"
	        },
	        "\\Cap": {
	            font: "ams",
	            group: "bin",
	            replace: "\u22d2"
	        },
	        "\\Cup": {
	            font: "ams",
	            group: "bin",
	            replace: "\u22d3"
	        },
	        "\\doublebarwedge": {
	            font: "ams",
	            group: "bin",
	            replace: "\u2a5e"
	        },
	        "\\boxminus": {
	            font: "ams",
	            group: "bin",
	            replace: "\u229f"
	        },
	        "\\boxplus": {
	            font: "ams",
	            group: "bin",
	            replace: "\u229e"
	        },
	        "\\divideontimes": {
	            font: "ams",
	            group: "bin",
	            replace: "\u22c7"
	        },
	        "\\ltimes": {
	            font: "ams",
	            group: "bin",
	            replace: "\u22c9"
	        },
	        "\\rtimes": {
	            font: "ams",
	            group: "bin",
	            replace: "\u22ca"
	        },
	        "\\leftthreetimes": {
	            font: "ams",
	            group: "bin",
	            replace: "\u22cb"
	        },
	        "\\rightthreetimes": {
	            font: "ams",
	            group: "bin",
	            replace: "\u22cc"
	        },
	        "\\curlywedge": {
	            font: "ams",
	            group: "bin",
	            replace: "\u22cf"
	        },
	        "\\curlyvee": {
	            font: "ams",
	            group: "bin",
	            replace: "\u22ce"
	        },
	        "\\circleddash": {
	            font: "ams",
	            group: "bin",
	            replace: "\u229d"
	        },
	        "\\circledast": {
	            font: "ams",
	            group: "bin",
	            replace: "\u229b"
	        },
	        "\\centerdot": {
	            font: "ams",
	            group: "bin",
	            replace: "\u22c5"
	        },
	        "\\intercal": {
	            font: "ams",
	            group: "bin",
	            replace: "\u22ba"
	        },
	        "\\doublecap": {
	            font: "ams",
	            group: "bin",
	            replace: "\u22d2"
	        },
	        "\\doublecup": {
	            font: "ams",
	            group: "bin",
	            replace: "\u22d3"
	        },
	        "\\boxtimes": {
	            font: "ams",
	            group: "bin",
	            replace: "\u22a0"
	        },

	        // AMS Arrows
	        "\\dashrightarrow": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21e2"
	        },
	        "\\dashleftarrow": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21e0"
	        },
	        "\\leftleftarrows": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21c7"
	        },
	        "\\leftrightarrows": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21c6"
	        },
	        "\\Lleftarrow": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21da"
	        },
	        "\\twoheadleftarrow": {
	            font: "ams",
	            group: "rel",
	            replace: "\u219e"
	        },
	        "\\leftarrowtail": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21a2"
	        },
	        "\\looparrowleft": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21ab"
	        },
	        "\\leftrightharpoons": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21cb"
	        },
	        "\\curvearrowleft": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21b6"
	        },
	        "\\circlearrowleft": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21ba"
	        },
	        "\\Lsh": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21b0"
	        },
	        "\\upuparrows": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21c8"
	        },
	        "\\upharpoonleft": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21bf"
	        },
	        "\\downharpoonleft": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21c3"
	        },
	        "\\multimap": {
	            font: "ams",
	            group: "rel",
	            replace: "\u22b8"
	        },
	        "\\leftrightsquigarrow": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21ad"
	        },
	        "\\rightrightarrows": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21c9"
	        },
	        "\\rightleftarrows": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21c4"
	        },
	        "\\twoheadrightarrow": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21a0"
	        },
	        "\\rightarrowtail": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21a3"
	        },
	        "\\looparrowright": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21ac"
	        },
	        "\\curvearrowright": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21b7"
	        },
	        "\\circlearrowright": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21bb"
	        },
	        "\\Rsh": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21b1"
	        },
	        "\\downdownarrows": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21ca"
	        },
	        "\\upharpoonright": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21be"
	        },
	        "\\downharpoonright": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21c2"
	        },
	        "\\rightsquigarrow": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21dd"
	        },
	        "\\leadsto": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21dd"
	        },
	        "\\Rrightarrow": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21db"
	        },
	        "\\restriction": {
	            font: "ams",
	            group: "rel",
	            replace: "\u21be"
	        },

	        "`": {
	            font: "main",
	            group: "textord",
	            replace: "\u2018"
	        },
	        "\\$": {
	            font: "main",
	            group: "textord",
	            replace: "$"
	        },
	        "\\%": {
	            font: "main",
	            group: "textord",
	            replace: "%"
	        },
	        "\\_": {
	            font: "main",
	            group: "textord",
	            replace: "_"
	        },
	        "\\angle": {
	            font: "main",
	            group: "textord",
	            replace: "\u2220"
	        },
	        "\\infty": {
	            font: "main",
	            group: "textord",
	            replace: "\u221e"
	        },
	        "\\prime": {
	            font: "main",
	            group: "textord",
	            replace: "\u2032"
	        },
	        "\\triangle": {
	            font: "main",
	            group: "textord",
	            replace: "\u25b3"
	        },
	        "\\Gamma": {
	            font: "main",
	            group: "textord",
	            replace: "\u0393"
	        },
	        "\\Delta": {
	            font: "main",
	            group: "textord",
	            replace: "\u0394"
	        },
	        "\\Theta": {
	            font: "main",
	            group: "textord",
	            replace: "\u0398"
	        },
	        "\\Lambda": {
	            font: "main",
	            group: "textord",
	            replace: "\u039b"
	        },
	        "\\Xi": {
	            font: "main",
	            group: "textord",
	            replace: "\u039e"
	        },
	        "\\Pi": {
	            font: "main",
	            group: "textord",
	            replace: "\u03a0"
	        },
	        "\\Sigma": {
	            font: "main",
	            group: "textord",
	            replace: "\u03a3"
	        },
	        "\\Upsilon": {
	            font: "main",
	            group: "textord",
	            replace: "\u03a5"
	        },
	        "\\Phi": {
	            font: "main",
	            group: "textord",
	            replace: "\u03a6"
	        },
	        "\\Psi": {
	            font: "main",
	            group: "textord",
	            replace: "\u03a8"
	        },
	        "\\Omega": {
	            font: "main",
	            group: "textord",
	            replace: "\u03a9"
	        },
	        "\\neg": {
	            font: "main",
	            group: "textord",
	            replace: "\u00ac"
	        },
	        "\\lnot": {
	            font: "main",
	            group: "textord",
	            replace: "\u00ac"
	        },
	        "\\top": {
	            font: "main",
	            group: "textord",
	            replace: "\u22a4"
	        },
	        "\\bot": {
	            font: "main",
	            group: "textord",
	            replace: "\u22a5"
	        },
	        "\\emptyset": {
	            font: "main",
	            group: "textord",
	            replace: "\u2205"
	        },
	        "\\varnothing": {
	            font: "ams",
	            group: "textord",
	            replace: "\u2205"
	        },
	        "\\alpha": {
	            font: "main",
	            group: "mathord",
	            replace: "\u03b1"
	        },
	        "\\beta": {
	            font: "main",
	            group: "mathord",
	            replace: "\u03b2"
	        },
	        "\\gamma": {
	            font: "main",
	            group: "mathord",
	            replace: "\u03b3"
	        },
	        "\\delta": {
	            font: "main",
	            group: "mathord",
	            replace: "\u03b4"
	        },
	        "\\epsilon": {
	            font: "main",
	            group: "mathord",
	            replace: "\u03f5"
	        },
	        "\\zeta": {
	            font: "main",
	            group: "mathord",
	            replace: "\u03b6"
	        },
	        "\\eta": {
	            font: "main",
	            group: "mathord",
	            replace: "\u03b7"
	        },
	        "\\theta": {
	            font: "main",
	            group: "mathord",
	            replace: "\u03b8"
	        },
	        "\\iota": {
	            font: "main",
	            group: "mathord",
	            replace: "\u03b9"
	        },
	        "\\kappa": {
	            font: "main",
	            group: "mathord",
	            replace: "\u03ba"
	        },
	        "\\lambda": {
	            font: "main",
	            group: "mathord",
	            replace: "\u03bb"
	        },
	        "\\mu": {
	            font: "main",
	            group: "mathord",
	            replace: "\u03bc"
	        },
	        "\\nu": {
	            font: "main",
	            group: "mathord",
	            replace: "\u03bd"
	        },
	        "\\xi": {
	            font: "main",
	            group: "mathord",
	            replace: "\u03be"
	        },
	        "\\omicron": {
	            font: "main",
	            group: "mathord",
	            replace: "o"
	        },
	        "\\pi": {
	            font: "main",
	            group: "mathord",
	            replace: "\u03c0"
	        },
	        "\\rho": {
	            font: "main",
	            group: "mathord",
	            replace: "\u03c1"
	        },
	        "\\sigma": {
	            font: "main",
	            group: "mathord",
	            replace: "\u03c3"
	        },
	        "\\tau": {
	            font: "main",
	            group: "mathord",
	            replace: "\u03c4"
	        },
	        "\\upsilon": {
	            font: "main",
	            group: "mathord",
	            replace: "\u03c5"
	        },
	        "\\phi": {
	            font: "main",
	            group: "mathord",
	            replace: "\u03d5"
	        },
	        "\\chi": {
	            font: "main",
	            group: "mathord",
	            replace: "\u03c7"
	        },
	        "\\psi": {
	            font: "main",
	            group: "mathord",
	            replace: "\u03c8"
	        },
	        "\\omega": {
	            font: "main",
	            group: "mathord",
	            replace: "\u03c9"
	        },
	        "\\varepsilon": {
	            font: "main",
	            group: "mathord",
	            replace: "\u03b5"
	        },
	        "\\vartheta": {
	            font: "main",
	            group: "mathord",
	            replace: "\u03d1"
	        },
	        "\\varpi": {
	            font: "main",
	            group: "mathord",
	            replace: "\u03d6"
	        },
	        "\\varrho": {
	            font: "main",
	            group: "mathord",
	            replace: "\u03f1"
	        },
	        "\\varsigma": {
	            font: "main",
	            group: "mathord",
	            replace: "\u03c2"
	        },
	        "\\varphi": {
	            font: "main",
	            group: "mathord",
	            replace: "\u03c6"
	        },
	        "*": {
	            font: "main",
	            group: "bin",
	            replace: "\u2217"
	        },
	        "+": {
	            font: "main",
	            group: "bin"
	        },
	        "-": {
	            font: "main",
	            group: "bin",
	            replace: "\u2212"
	        },
	        "\\cdot": {
	            font: "main",
	            group: "bin",
	            replace: "\u22c5"
	        },
	        "\\circ": {
	            font: "main",
	            group: "bin",
	            replace: "\u2218"
	        },
	        "\\div": {
	            font: "main",
	            group: "bin",
	            replace: "\u00f7"
	        },
	        "\\pm": {
	            font: "main",
	            group: "bin",
	            replace: "\u00b1"
	        },
	        "\\times": {
	            font: "main",
	            group: "bin",
	            replace: "\u00d7"
	        },
	        "\\cap": {
	            font: "main",
	            group: "bin",
	            replace: "\u2229"
	        },
	        "\\cup": {
	            font: "main",
	            group: "bin",
	            replace: "\u222a"
	        },
	        "\\setminus": {
	            font: "main",
	            group: "bin",
	            replace: "\u2216"
	        },
	        "\\land": {
	            font: "main",
	            group: "bin",
	            replace: "\u2227"
	        },
	        "\\lor": {
	            font: "main",
	            group: "bin",
	            replace: "\u2228"
	        },
	        "\\wedge": {
	            font: "main",
	            group: "bin",
	            replace: "\u2227"
	        },
	        "\\vee": {
	            font: "main",
	            group: "bin",
	            replace: "\u2228"
	        },
	        "\\surd": {
	            font: "main",
	            group: "textord",
	            replace: "\u221a"
	        },
	        "(": {
	            font: "main",
	            group: "open"
	        },
	        "[": {
	            font: "main",
	            group: "open"
	        },
	        "\\langle": {
	            font: "main",
	            group: "open",
	            replace: "\u27e8"
	        },
	        "\\lvert": {
	            font: "main",
	            group: "open",
	            replace: "\u2223"
	        },
	        "\\lVert": {
	            font: "main",
	            group: "open",
	            replace: "\u2225"
	        },
	        ")": {
	            font: "main",
	            group: "close"
	        },
	        "]": {
	            font: "main",
	            group: "close"
	        },
	        "?": {
	            font: "main",
	            group: "close"
	        },
	        "!": {
	            font: "main",
	            group: "close"
	        },
	        "\\rangle": {
	            font: "main",
	            group: "close",
	            replace: "\u27e9"
	        },
	        "\\rvert": {
	            font: "main",
	            group: "close",
	            replace: "\u2223"
	        },
	        "\\rVert": {
	            font: "main",
	            group: "close",
	            replace: "\u2225"
	        },
	        "=": {
	            font: "main",
	            group: "rel"
	        },
	        "<": {
	            font: "main",
	            group: "rel"
	        },
	        ">": {
	            font: "main",
	            group: "rel"
	        },
	        ":": {
	            font: "main",
	            group: "rel"
	        },
	        "\\approx": {
	            font: "main",
	            group: "rel",
	            replace: "\u2248"
	        },
	        "\\cong": {
	            font: "main",
	            group: "rel",
	            replace: "\u2245"
	        },
	        "\\ge": {
	            font: "main",
	            group: "rel",
	            replace: "\u2265"
	        },
	        "\\geq": {
	            font: "main",
	            group: "rel",
	            replace: "\u2265"
	        },
	        "\\gets": {
	            font: "main",
	            group: "rel",
	            replace: "\u2190"
	        },
	        "\\in": {
	            font: "main",
	            group: "rel",
	            replace: "\u2208"
	        },
	        "\\notin": {
	            font: "main",
	            group: "rel",
	            replace: "\u2209"
	        },
	        "\\subset": {
	            font: "main",
	            group: "rel",
	            replace: "\u2282"
	        },
	        "\\supset": {
	            font: "main",
	            group: "rel",
	            replace: "\u2283"
	        },
	        "\\subseteq": {
	            font: "main",
	            group: "rel",
	            replace: "\u2286"
	        },
	        "\\supseteq": {
	            font: "main",
	            group: "rel",
	            replace: "\u2287"
	        },
	        "\\nsubseteq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2288"
	        },
	        "\\nsupseteq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2289"
	        },
	        "\\models": {
	            font: "main",
	            group: "rel",
	            replace: "\u22a8"
	        },
	        "\\leftarrow": {
	            font: "main",
	            group: "rel",
	            replace: "\u2190"
	        },
	        "\\le": {
	            font: "main",
	            group: "rel",
	            replace: "\u2264"
	        },
	        "\\leq": {
	            font: "main",
	            group: "rel",
	            replace: "\u2264"
	        },
	        "\\ne": {
	            font: "main",
	            group: "rel",
	            replace: "\u2260"
	        },
	        "\\neq": {
	            font: "main",
	            group: "rel",
	            replace: "\u2260"
	        },
	        "\\rightarrow": {
	            font: "main",
	            group: "rel",
	            replace: "\u2192"
	        },
	        "\\to": {
	            font: "main",
	            group: "rel",
	            replace: "\u2192"
	        },
	        "\\ngeq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2271"
	        },
	        "\\nleq": {
	            font: "ams",
	            group: "rel",
	            replace: "\u2270"
	        },
	        "\\!": {
	            font: "main",
	            group: "spacing"
	        },
	        "\\ ": {
	            font: "main",
	            group: "spacing",
	            replace: "\u00a0"
	        },
	        "~": {
	            font: "main",
	            group: "spacing",
	            replace: "\u00a0"
	        },
	        "\\,": {
	            font: "main",
	            group: "spacing"
	        },
	        "\\:": {
	            font: "main",
	            group: "spacing"
	        },
	        "\\;": {
	            font: "main",
	            group: "spacing"
	        },
	        "\\enspace": {
	            font: "main",
	            group: "spacing"
	        },
	        "\\qquad": {
	            font: "main",
	            group: "spacing"
	        },
	        "\\quad": {
	            font: "main",
	            group: "spacing"
	        },
	        "\\space": {
	            font: "main",
	            group: "spacing",
	            replace: "\u00a0"
	        },
	        ",": {
	            font: "main",
	            group: "punct"
	        },
	        ";": {
	            font: "main",
	            group: "punct"
	        },
	        "\\colon": {
	            font: "main",
	            group: "punct",
	            replace: ":"
	        },
	        "\\barwedge": {
	            font: "ams",
	            group: "bin",
	            replace: "\u22bc"
	        },
	        "\\veebar": {
	            font: "ams",
	            group: "bin",
	            replace: "\u22bb"
	        },
	        "\\odot": {
	            font: "main",
	            group: "bin",
	            replace: "\u2299"
	        },
	        "\\oplus": {
	            font: "main",
	            group: "bin",
	            replace: "\u2295"
	        },
	        "\\otimes": {
	            font: "main",
	            group: "bin",
	            replace: "\u2297"
	        },
	        "\\partial":{
	            font: "main",
	            group: "textord",
	            replace: "\u2202"
	        },
	        "\\oslash": {
	            font: "main",
	            group: "bin",
	            replace: "\u2298"
	        },
	        "\\circledcirc": {
	            font: "ams",
	            group: "bin",
	            replace: "\u229a"
	        },
	        "\\boxdot": {
	            font: "ams",
	            group: "bin",
	            replace: "\u22a1"
	        },
	        "\\bigtriangleup": {
	            font: "main",
	            group: "bin",
	            replace: "\u25b3"
	        },
	        "\\bigtriangledown": {
	            font: "main",
	            group: "bin",
	            replace: "\u25bd"
	        },
	        "\\dagger": {
	            font: "main",
	            group: "bin",
	            replace: "\u2020"
	        },
	        "\\diamond": {
	            font: "main",
	            group: "bin",
	            replace: "\u22c4"
	        },
	        "\\star": {
	            font: "main",
	            group: "bin",
	            replace: "\u22c6"
	        },
	        "\\triangleleft": {
	            font: "main",
	            group: "bin",
	            replace: "\u25c3"
	        },
	        "\\triangleright": {
	            font: "main",
	            group: "bin",
	            replace: "\u25b9"
	        },
	        "\\{": {
	            font: "main",
	            group: "open",
	            replace: "{"
	        },
	        "\\}": {
	            font: "main",
	            group: "close",
	            replace: "}"
	        },
	        "\\lbrace": {
	            font: "main",
	            group: "open",
	            replace: "{"
	        },
	        "\\rbrace": {
	            font: "main",
	            group: "close",
	            replace: "}"
	        },
	        "\\lbrack": {
	            font: "main",
	            group: "open",
	            replace: "["
	        },
	        "\\rbrack": {
	            font: "main",
	            group: "close",
	            replace: "]"
	        },
	        "\\lfloor": {
	            font: "main",
	            group: "open",
	            replace: "\u230a"
	        },
	        "\\rfloor": {
	            font: "main",
	            group: "close",
	            replace: "\u230b"
	        },
	        "\\lceil": {
	            font: "main",
	            group: "open",
	            replace: "\u2308"
	        },
	        "\\rceil": {
	            font: "main",
	            group: "close",
	            replace: "\u2309"
	        },
	        "\\backslash": {
	            font: "main",
	            group: "textord",
	            replace: "\\"
	        },
	        "|": {
	            font: "main",
	            group: "textord",
	            replace: "\u2223"
	        },
	        "\\vert": {
	            font: "main",
	            group: "textord",
	            replace: "\u2223"
	        },
	        "\\|": {
	            font: "main",
	            group: "textord",
	            replace: "\u2225"
	        },
	        "\\Vert": {
	            font: "main",
	            group: "textord",
	            replace: "\u2225"
	        },
	        "\\uparrow": {
	            font: "main",
	            group: "rel",
	            replace: "\u2191"
	        },
	        "\\Uparrow": {
	            font: "main",
	            group: "rel",
	            replace: "\u21d1"
	        },
	        "\\downarrow": {
	            font: "main",
	            group: "rel",
	            replace: "\u2193"
	        },
	        "\\Downarrow": {
	            font: "main",
	            group: "rel",
	            replace: "\u21d3"
	        },
	        "\\updownarrow": {
	            font: "main",
	            group: "rel",
	            replace: "\u2195"
	        },
	        "\\Updownarrow": {
	            font: "main",
	            group: "rel",
	            replace: "\u21d5"
	        },
	        "\\coprod": {
	            font: "math",
	            group: "op",
	            replace: "\u2210"
	        },
	        "\\bigvee": {
	            font: "math",
	            group: "op",
	            replace: "\u22c1"
	        },
	        "\\bigwedge": {
	            font: "math",
	            group: "op",
	            replace: "\u22c0"
	        },
	        "\\biguplus": {
	            font: "math",
	            group: "op",
	            replace: "\u2a04"
	        },
	        "\\bigcap": {
	            font: "math",
	            group: "op",
	            replace: "\u22c2"
	        },
	        "\\bigcup": {
	            font: "math",
	            group: "op",
	            replace: "\u22c3"
	        },
	        "\\int": {
	            font: "math",
	            group: "op",
	            replace: "\u222b"
	        },
	        "\\intop": {
	            font: "math",
	            group: "op",
	            replace: "\u222b"
	        },
	        "\\iint": {
	            font: "math",
	            group: "op",
	            replace: "\u222c"
	        },
	        "\\iiint": {
	            font: "math",
	            group: "op",
	            replace: "\u222d"
	        },
	        "\\prod": {
	            font: "math",
	            group: "op",
	            replace: "\u220f"
	        },
	        "\\sum": {
	            font: "math",
	            group: "op",
	            replace: "\u2211"
	        },
	        "\\bigotimes": {
	            font: "math",
	            group: "op",
	            replace: "\u2a02"
	        },
	        "\\bigoplus": {
	            font: "math",
	            group: "op",
	            replace: "\u2a01"
	        },
	        "\\bigodot": {
	            font: "math",
	            group: "op",
	            replace: "\u2a00"
	        },
	        "\\oint": {
	            font: "math",
	            group: "op",
	            replace: "\u222e"
	        },
	        "\\bigsqcup": {
	            font: "math",
	            group: "op",
	            replace: "\u2a06"
	        },
	        "\\smallint": {
	            font: "math",
	            group: "op",
	            replace: "\u222b"
	        },
	        "\\ldots": {
	            font: "main",
	            group: "inner",
	            replace: "\u2026"
	        },
	        "\\cdots": {
	            font: "main",
	            group: "inner",
	            replace: "\u22ef"
	        },
	        "\\ddots": {
	            font: "main",
	            group: "inner",
	            replace: "\u22f1"
	        },
	        "\\vdots": {
	            font: "main",
	            group: "textord",
	            replace: "\u22ee"
	        },
	        "\\acute": {
	            font: "main",
	            group: "accent",
	            replace: "\u00b4"
	        },
	        "\\grave": {
	            font: "main",
	            group: "accent",
	            replace: "\u0060"
	        },
	        "\\ddot": {
	            font: "main",
	            group: "accent",
	            replace: "\u00a8"
	        },
	        "\\tilde": {
	            font: "main",
	            group: "accent",
	            replace: "\u007e"
	        },
	        "\\bar": {
	            font: "main",
	            group: "accent",
	            replace: "\u00af"
	        },
	        "\\breve": {
	            font: "main",
	            group: "accent",
	            replace: "\u02d8"
	        },
	        "\\check": {
	            font: "main",
	            group: "accent",
	            replace: "\u02c7"
	        },
	        "\\hat": {
	            font: "main",
	            group: "accent",
	            replace: "\u005e"
	        },
	        "\\vec": {
	            font: "main",
	            group: "accent",
	            replace: "\u20d7"
	        },
	        "\\dot": {
	            font: "main",
	            group: "accent",
	            replace: "\u02d9"
	        },

	        "\\imath": {
	            font: "main",
	            group: "mathord",
	            replace: "\u0131"
	        },
	        "\\jmath": {
	            font: "main",
	            group: "mathord",
	            replace: "\u0237"
	        }
	    },
	    "text": {
	        "\\ ": {
	            font: "main",
	            group: "spacing",
	            replace: "\u00a0"
	        },
	        " ": {
	            font: "main",
	            group: "spacing",
	            replace: "\u00a0"
	        },
	        "~": {
	            font: "main",
	            group: "spacing",
	            replace: "\u00a0"
	        }
	    }
	};

	// There are lots of symbols which are the same, so we add them in afterwards.

	// All of these are textords in math mode
	var mathTextSymbols = "0123456789/@.\"";
	for (var i = 0; i < mathTextSymbols.length; i++) {
	    var ch = mathTextSymbols.charAt(i);
	    symbols.math[ch] = {
	        font: "main",
	        group: "textord"
	    };
	}

	// All of these are textords in text mode
	var textSymbols = "0123456789`!@*()-=+[]'\";:?/.,";
	for (var i = 0; i < textSymbols.length; i++) {
	    var ch = textSymbols.charAt(i);
	    symbols.text[ch] = {
	        font: "main",
	        group: "textord"
	    };
	}

	// All of these are textords in text mode, and mathords in math mode
	var letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
	for (var i = 0; i < letters.length; i++) {
	    var ch = letters.charAt(i);
	    symbols.math[ch] = {
	        font: "main",
	        group: "mathord"
	    };
	    symbols.text[ch] = {
	        font: "main",
	        group: "textord"
	    };
	}

	module.exports = symbols;


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * This file deals with creating delimiters of various sizes. The TeXbook
	 * discusses these routines on page 441-442, in the "Another subroutine sets box
	 * x to a specified variable delimiter" paragraph.
	 *
	 * There are three main routines here. `makeSmallDelim` makes a delimiter in the
	 * normal font, but in either text, script, or scriptscript style.
	 * `makeLargeDelim` makes a delimiter in textstyle, but in one of the Size1,
	 * Size2, Size3, or Size4 fonts. `makeStackedDelim` makes a delimiter out of
	 * smaller pieces that are stacked on top of one another.
	 *
	 * The functions take a parameter `center`, which determines if the delimiter
	 * should be centered around the axis.
	 *
	 * Then, there are three exposed functions. `sizedDelim` makes a delimiter in
	 * one of the given sizes. This is used for things like `\bigl`.
	 * `customSizedDelim` makes a delimiter with a given total height+depth. It is
	 * called in places like `\sqrt`. `leftRightDelim` makes an appropriate
	 * delimiter which surrounds an expression of a given height an depth. It is
	 * used in `\left` and `\right`.
	 */

	var ParseError = __webpack_require__(5);
	var Style = __webpack_require__(9);

	var buildCommon = __webpack_require__(10);
	var fontMetrics = __webpack_require__(13);
	var symbols = __webpack_require__(15);
	var utils = __webpack_require__(12);

	var makeSpan = buildCommon.makeSpan;

	/**
	 * Get the metrics for a given symbol and font, after transformation (i.e.
	 * after following replacement from symbols.js)
	 */
	var getMetrics = function(symbol, font) {
	    if (symbols.math[symbol] && symbols.math[symbol].replace) {
	        return fontMetrics.getCharacterMetrics(
	            symbols.math[symbol].replace, font);
	    } else {
	        return fontMetrics.getCharacterMetrics(
	            symbol, font);
	    }
	};

	/**
	 * Builds a symbol in the given font size (note size is an integer)
	 */
	var mathrmSize = function(value, size, mode) {
	    return buildCommon.makeSymbol(value, "Size" + size + "-Regular", mode);
	};

	/**
	 * Puts a delimiter span in a given style, and adds appropriate height, depth,
	 * and maxFontSizes.
	 */
	var styleWrap = function(delim, toStyle, options) {
	    var span = makeSpan(
	        ["style-wrap", options.style.reset(), toStyle.cls()], [delim]);

	    var multiplier = toStyle.sizeMultiplier / options.style.sizeMultiplier;

	    span.height *= multiplier;
	    span.depth *= multiplier;
	    span.maxFontSize = toStyle.sizeMultiplier;

	    return span;
	};

	/**
	 * Makes a small delimiter. This is a delimiter that comes in the Main-Regular
	 * font, but is restyled to either be in textstyle, scriptstyle, or
	 * scriptscriptstyle.
	 */
	var makeSmallDelim = function(delim, style, center, options, mode) {
	    var text = buildCommon.makeSymbol(delim, "Main-Regular", mode);

	    var span = styleWrap(text, style, options);

	    if (center) {
	        var shift =
	            (1 - options.style.sizeMultiplier / style.sizeMultiplier) *
	            fontMetrics.metrics.axisHeight;

	        span.style.top = shift + "em";
	        span.height -= shift;
	        span.depth += shift;
	    }

	    return span;
	};

	/**
	 * Makes a large delimiter. This is a delimiter that comes in the Size1, Size2,
	 * Size3, or Size4 fonts. It is always rendered in textstyle.
	 */
	var makeLargeDelim = function(delim, size, center, options, mode) {
	    var inner = mathrmSize(delim, size, mode);

	    var span = styleWrap(
	        makeSpan(["delimsizing", "size" + size],
	                 [inner], options.getColor()),
	        Style.TEXT, options);

	    if (center) {
	        var shift = (1 - options.style.sizeMultiplier) *
	            fontMetrics.metrics.axisHeight;

	        span.style.top = shift + "em";
	        span.height -= shift;
	        span.depth += shift;
	    }

	    return span;
	};

	/**
	 * Make an inner span with the given offset and in the given font. This is used
	 * in `makeStackedDelim` to make the stacking pieces for the delimiter.
	 */
	var makeInner = function(symbol, font, mode) {
	    var sizeClass;
	    // Apply the correct CSS class to choose the right font.
	    if (font === "Size1-Regular") {
	        sizeClass = "delim-size1";
	    } else if (font === "Size4-Regular") {
	        sizeClass = "delim-size4";
	    }

	    var inner = makeSpan(
	        ["delimsizinginner", sizeClass],
	        [makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);

	    // Since this will be passed into `makeVList` in the end, wrap the element
	    // in the appropriate tag that VList uses.
	    return {type: "elem", elem: inner};
	};

	/**
	 * Make a stacked delimiter out of a given delimiter, with the total height at
	 * least `heightTotal`. This routine is mentioned on page 442 of the TeXbook.
	 */
	var makeStackedDelim = function(delim, heightTotal, center, options, mode) {
	    // There are four parts, the top, an optional middle, a repeated part, and a
	    // bottom.
	    var top, middle, repeat, bottom;
	    top = repeat = bottom = delim;
	    middle = null;
	    // Also keep track of what font the delimiters are in
	    var font = "Size1-Regular";

	    // We set the parts and font based on the symbol. Note that we use
	    // '\u23d0' instead of '|' and '\u2016' instead of '\\|' for the
	    // repeats of the arrows
	    if (delim === "\\uparrow") {
	        repeat = bottom = "\u23d0";
	    } else if (delim === "\\Uparrow") {
	        repeat = bottom = "\u2016";
	    } else if (delim === "\\downarrow") {
	        top = repeat = "\u23d0";
	    } else if (delim === "\\Downarrow") {
	        top = repeat = "\u2016";
	    } else if (delim === "\\updownarrow") {
	        top = "\\uparrow";
	        repeat = "\u23d0";
	        bottom = "\\downarrow";
	    } else if (delim === "\\Updownarrow") {
	        top = "\\Uparrow";
	        repeat = "\u2016";
	        bottom = "\\Downarrow";
	    } else if (delim === "[" || delim === "\\lbrack") {
	        top = "\u23a1";
	        repeat = "\u23a2";
	        bottom = "\u23a3";
	        font = "Size4-Regular";
	    } else if (delim === "]" || delim === "\\rbrack") {
	        top = "\u23a4";
	        repeat = "\u23a5";
	        bottom = "\u23a6";
	        font = "Size4-Regular";
	    } else if (delim === "\\lfloor") {
	        repeat = top = "\u23a2";
	        bottom = "\u23a3";
	        font = "Size4-Regular";
	    } else if (delim === "\\lceil") {
	        top = "\u23a1";
	        repeat = bottom = "\u23a2";
	        font = "Size4-Regular";
	    } else if (delim === "\\rfloor") {
	        repeat = top = "\u23a5";
	        bottom = "\u23a6";
	        font = "Size4-Regular";
	    } else if (delim === "\\rceil") {
	        top = "\u23a4";
	        repeat = bottom = "\u23a5";
	        font = "Size4-Regular";
	    } else if (delim === "(") {
	        top = "\u239b";
	        repeat = "\u239c";
	        bottom = "\u239d";
	        font = "Size4-Regular";
	    } else if (delim === ")") {
	        top = "\u239e";
	        repeat = "\u239f";
	        bottom = "\u23a0";
	        font = "Size4-Regular";
	    } else if (delim === "\\{" || delim === "\\lbrace") {
	        top = "\u23a7";
	        middle = "\u23a8";
	        bottom = "\u23a9";
	        repeat = "\u23aa";
	        font = "Size4-Regular";
	    } else if (delim === "\\}" || delim === "\\rbrace") {
	        top = "\u23ab";
	        middle = "\u23ac";
	        bottom = "\u23ad";
	        repeat = "\u23aa";
	        font = "Size4-Regular";
	    } else if (delim === "\\lgroup") {
	        top = "\u23a7";
	        bottom = "\u23a9";
	        repeat = "\u23aa";
	        font = "Size4-Regular";
	    } else if (delim === "\\rgroup") {
	        top = "\u23ab";
	        bottom = "\u23ad";
	        repeat = "\u23aa";
	        font = "Size4-Regular";
	    } else if (delim === "\\lmoustache") {
	        top = "\u23a7";
	        bottom = "\u23ad";
	        repeat = "\u23aa";
	        font = "Size4-Regular";
	    } else if (delim === "\\rmoustache") {
	        top = "\u23ab";
	        bottom = "\u23a9";
	        repeat = "\u23aa";
	        font = "Size4-Regular";
	    } else if (delim === "\\surd") {
	        top = "\ue001";
	        bottom = "\u23b7";
	        repeat = "\ue000";
	        font = "Size4-Regular";
	    }

	    // Get the metrics of the four sections
	    var topMetrics = getMetrics(top, font);
	    var topHeightTotal = topMetrics.height + topMetrics.depth;
	    var repeatMetrics = getMetrics(repeat, font);
	    var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
	    var bottomMetrics = getMetrics(bottom, font);
	    var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
	    var middleHeightTotal = 0;
	    var middleFactor = 1;
	    if (middle !== null) {
	        var middleMetrics = getMetrics(middle, font);
	        middleHeightTotal = middleMetrics.height + middleMetrics.depth;
	        middleFactor = 2; // repeat symmetrically above and below middle
	    }

	    // Calcuate the minimal height that the delimiter can have.
	    // It is at least the size of the top, bottom, and optional middle combined.
	    var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;

	    // Compute the number of copies of the repeat symbol we will need
	    var repeatCount = Math.ceil(
	        (heightTotal - minHeight) / (middleFactor * repeatHeightTotal));

	    // Compute the total height of the delimiter including all the symbols
	    var realHeightTotal =
	        minHeight + repeatCount * middleFactor * repeatHeightTotal;

	    // The center of the delimiter is placed at the center of the axis. Note
	    // that in this context, "center" means that the delimiter should be
	    // centered around the axis in the current style, while normally it is
	    // centered around the axis in textstyle.
	    var axisHeight = fontMetrics.metrics.axisHeight;
	    if (center) {
	        axisHeight *= options.style.sizeMultiplier;
	    }
	    // Calculate the depth
	    var depth = realHeightTotal / 2 - axisHeight;

	    // Now, we start building the pieces that will go into the vlist

	    // Keep a list of the inner pieces
	    var inners = [];

	    // Add the bottom symbol
	    inners.push(makeInner(bottom, font, mode));

	    var i;
	    if (middle === null) {
	        // Add that many symbols
	        for (i = 0; i < repeatCount; i++) {
	            inners.push(makeInner(repeat, font, mode));
	        }
	    } else {
	        // When there is a middle bit, we need the middle part and two repeated
	        // sections
	        for (i = 0; i < repeatCount; i++) {
	            inners.push(makeInner(repeat, font, mode));
	        }
	        inners.push(makeInner(middle, font, mode));
	        for (i = 0; i < repeatCount; i++) {
	            inners.push(makeInner(repeat, font, mode));
	        }
	    }

	    // Add the top symbol
	    inners.push(makeInner(top, font, mode));

	    // Finally, build the vlist
	    var inner = buildCommon.makeVList(inners, "bottom", depth, options);

	    return styleWrap(
	        makeSpan(["delimsizing", "mult"], [inner], options.getColor()),
	        Style.TEXT, options);
	};

	// There are three kinds of delimiters, delimiters that stack when they become
	// too large
	var stackLargeDelimiters = [
	    "(", ")", "[", "\\lbrack", "]", "\\rbrack",
	    "\\{", "\\lbrace", "\\}", "\\rbrace",
	    "\\lfloor", "\\rfloor", "\\lceil", "\\rceil",
	    "\\surd"
	];

	// delimiters that always stack
	var stackAlwaysDelimiters = [
	    "\\uparrow", "\\downarrow", "\\updownarrow",
	    "\\Uparrow", "\\Downarrow", "\\Updownarrow",
	    "|", "\\|", "\\vert", "\\Vert",
	    "\\lvert", "\\rvert", "\\lVert", "\\rVert",
	    "\\lgroup", "\\rgroup", "\\lmoustache", "\\rmoustache"
	];

	// and delimiters that never stack
	var stackNeverDelimiters = [
	    "<", ">", "\\langle", "\\rangle", "/", "\\backslash"
	];

	// Metrics of the different sizes. Found by looking at TeX's output of
	// $\bigl| // \Bigl| \biggl| \Biggl| \showlists$
	// Used to create stacked delimiters of appropriate sizes in makeSizedDelim.
	var sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3.0];

	/**
	 * Used to create a delimiter of a specific size, where `size` is 1, 2, 3, or 4.
	 */
	var makeSizedDelim = function(delim, size, options, mode) {
	    // < and > turn into \langle and \rangle in delimiters
	    if (delim === "<") {
	        delim = "\\langle";
	    } else if (delim === ">") {
	        delim = "\\rangle";
	    }

	    // Sized delimiters are never centered.
	    if (utils.contains(stackLargeDelimiters, delim) ||
	        utils.contains(stackNeverDelimiters, delim)) {
	        return makeLargeDelim(delim, size, false, options, mode);
	    } else if (utils.contains(stackAlwaysDelimiters, delim)) {
	        return makeStackedDelim(
	            delim, sizeToMaxHeight[size], false, options, mode);
	    } else {
	        throw new ParseError("Illegal delimiter: '" + delim + "'");
	    }
	};

	/**
	 * There are three different sequences of delimiter sizes that the delimiters
	 * follow depending on the kind of delimiter. This is used when creating custom
	 * sized delimiters to decide whether to create a small, large, or stacked
	 * delimiter.
	 *
	 * In real TeX, these sequences aren't explicitly defined, but are instead
	 * defined inside the font metrics. Since there are only three sequences that
	 * are possible for the delimiters that TeX defines, it is easier to just encode
	 * them explicitly here.
	 */

	// Delimiters that never stack try small delimiters and large delimiters only
	var stackNeverDelimiterSequence = [
	    {type: "small", style: Style.SCRIPTSCRIPT},
	    {type: "small", style: Style.SCRIPT},
	    {type: "small", style: Style.TEXT},
	    {type: "large", size: 1},
	    {type: "large", size: 2},
	    {type: "large", size: 3},
	    {type: "large", size: 4}
	];

	// Delimiters that always stack try the small delimiters first, then stack
	var stackAlwaysDelimiterSequence = [
	    {type: "small", style: Style.SCRIPTSCRIPT},
	    {type: "small", style: Style.SCRIPT},
	    {type: "small", style: Style.TEXT},
	    {type: "stack"}
	];

	// Delimiters that stack when large try the small and then large delimiters, and
	// stack afterwards
	var stackLargeDelimiterSequence = [
	    {type: "small", style: Style.SCRIPTSCRIPT},
	    {type: "small", style: Style.SCRIPT},
	    {type: "small", style: Style.TEXT},
	    {type: "large", size: 1},
	    {type: "large", size: 2},
	    {type: "large", size: 3},
	    {type: "large", size: 4},
	    {type: "stack"}
	];

	/**
	 * Get the font used in a delimiter based on what kind of delimiter it is.
	 */
	var delimTypeToFont = function(type) {
	    if (type.type === "small") {
	        return "Main-Regular";
	    } else if (type.type === "large") {
	        return "Size" + type.size + "-Regular";
	    } else if (type.type === "stack") {
	        return "Size4-Regular";
	    }
	};

	/**
	 * Traverse a sequence of types of delimiters to decide what kind of delimiter
	 * should be used to create a delimiter of the given height+depth.
	 */
	var traverseSequence = function(delim, height, sequence, options) {
	    // Here, we choose the index we should start at in the sequences. In smaller
	    // sizes (which correspond to larger numbers in style.size) we start earlier
	    // in the sequence. Thus, scriptscript starts at index 3-3=0, script starts
	    // at index 3-2=1, text starts at 3-1=2, and display starts at min(2,3-0)=2
	    var start = Math.min(2, 3 - options.style.size);
	    for (var i = start; i < sequence.length; i++) {
	        if (sequence[i].type === "stack") {
	            // This is always the last delimiter, so we just break the loop now.
	            break;
	        }

	        var metrics = getMetrics(delim, delimTypeToFont(sequence[i]));
	        var heightDepth = metrics.height + metrics.depth;

	        // Small delimiters are scaled down versions of the same font, so we
	        // account for the style change size.

	        if (sequence[i].type === "small") {
	            heightDepth *= sequence[i].style.sizeMultiplier;
	        }

	        // Check if the delimiter at this size works for the given height.
	        if (heightDepth > height) {
	            return sequence[i];
	        }
	    }

	    // If we reached the end of the sequence, return the last sequence element.
	    return sequence[sequence.length - 1];
	};

	/**
	 * Make a delimiter of a given height+depth, with optional centering. Here, we
	 * traverse the sequences, and create a delimiter that the sequence tells us to.
	 */
	var makeCustomSizedDelim = function(delim, height, center, options, mode) {
	    if (delim === "<") {
	        delim = "\\langle";
	    } else if (delim === ">") {
	        delim = "\\rangle";
	    }

	    // Decide what sequence to use
	    var sequence;
	    if (utils.contains(stackNeverDelimiters, delim)) {
	        sequence = stackNeverDelimiterSequence;
	    } else if (utils.contains(stackLargeDelimiters, delim)) {
	        sequence = stackLargeDelimiterSequence;
	    } else {
	        sequence = stackAlwaysDelimiterSequence;
	    }

	    // Look through the sequence
	    var delimType = traverseSequence(delim, height, sequence, options);

	    // Depending on the sequence element we decided on, call the appropriate
	    // function.
	    if (delimType.type === "small") {
	        return makeSmallDelim(delim, delimType.style, center, options, mode);
	    } else if (delimType.type === "large") {
	        return makeLargeDelim(delim, delimType.size, center, options, mode);
	    } else if (delimType.type === "stack") {
	        return makeStackedDelim(delim, height, center, options, mode);
	    }
	};

	/**
	 * Make a delimiter for use with `\left` and `\right`, given a height and depth
	 * of an expression that the delimiters surround.
	 */
	var makeLeftRightDelim = function(delim, height, depth, options, mode) {
	    // We always center \left/\right delimiters, so the axis is always shifted
	    var axisHeight =
	        fontMetrics.metrics.axisHeight * options.style.sizeMultiplier;

	    // Taken from TeX source, tex.web, function make_left_right
	    var delimiterFactor = 901;
	    var delimiterExtend = 5.0 / fontMetrics.metrics.ptPerEm;

	    var maxDistFromAxis = Math.max(
	        height - axisHeight, depth + axisHeight);

	    var totalHeight = Math.max(
	        // In real TeX, calculations are done using integral values which are
	        // 65536 per pt, or 655360 per em. So, the division here truncates in
	        // TeX but doesn't here, producing different results. If we wanted to
	        // exactly match TeX's calculation, we could do
	        //   Math.floor(655360 * maxDistFromAxis / 500) *
	        //    delimiterFactor / 655360
	        // (To see the difference, compare
	        //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
	        // in TeX and KaTeX)
	        maxDistFromAxis / 500 * delimiterFactor,
	        2 * maxDistFromAxis - delimiterExtend);

	    // Finally, we defer to `makeCustomSizedDelim` with our calculated total
	    // height
	    return makeCustomSizedDelim(delim, totalHeight, true, options, mode);
	};

	module.exports = {
	    sizedDelim: makeSizedDelim,
	    customSizedDelim: makeCustomSizedDelim,
	    leftRightDelim: makeLeftRightDelim
	};


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * This file converts a parse tree into a cooresponding MathML tree. The main
	 * entry point is the `buildMathML` function, which takes a parse tree from the
	 * parser.
	 */

	var buildCommon = __webpack_require__(10);
	var fontMetrics = __webpack_require__(13);
	var mathMLTree = __webpack_require__(18);
	var ParseError = __webpack_require__(5);
	var symbols = __webpack_require__(15);
	var utils = __webpack_require__(12);

	var makeSpan = buildCommon.makeSpan;
	var fontMap = buildCommon.fontMap;

	/**
	 * Takes a symbol and converts it into a MathML text node after performing
	 * optional replacement from symbols.js.
	 */
	var makeText = function(text, mode) {
	    if (symbols[mode][text] && symbols[mode][text].replace) {
	        text = symbols[mode][text].replace;
	    }

	    return new mathMLTree.TextNode(text);
	};

	/**
	 * Returns the math variant as a string or null if none is required.
	 */
	var getVariant = function(group, options) {
	    var font = options.font;
	    if (!font) {
	        return null;
	    }

	    var mode = group.mode;
	    if (font === "mathit") {
	        return "italic";
	    }

	    var value = group.value;
	    if (utils.contains(["\\imath", "\\jmath"], value)) {
	        return null;
	    }

	    if (symbols[mode][value] && symbols[mode][value].replace) {
	        value = symbols[mode][value].replace;
	    }

	    var fontName = fontMap[font].fontName;
	    if (fontMetrics.getCharacterMetrics(value, fontName)) {
	        return fontMap[options.font].variant;
	    }

	    return null;
	};

	/**
	 * Functions for handling the different types of groups found in the parse
	 * tree. Each function should take a parse group and return a MathML node.
	 */
	var groupTypes = {
	    mathord: function(group, options) {
	        var node = new mathMLTree.MathNode(
	            "mi",
	            [makeText(group.value, group.mode)]);

	        var variant = getVariant(group, options);
	        if (variant) {
	            node.setAttribute("mathvariant", variant);
	        }
	        return node;
	    },

	    textord: function(group, options) {
	        var text = makeText(group.value, group.mode);

	        var variant = getVariant(group, options) || "normal";

	        var node;
	        if (/[0-9]/.test(group.value)) {
	            // TODO(kevinb) merge adjacent <mn> nodes
	            // do it as a post processing step
	            node = new mathMLTree.MathNode("mn", [text]);
	            if (options.font) {
	                node.setAttribute("mathvariant", variant);
	            }
	        } else {
	            node = new mathMLTree.MathNode("mi", [text]);
	            node.setAttribute("mathvariant", variant);
	        }

	        return node;
	    },

	    bin: function(group) {
	        var node = new mathMLTree.MathNode(
	            "mo", [makeText(group.value, group.mode)]);

	        return node;
	    },

	    rel: function(group) {
	        var node = new mathMLTree.MathNode(
	            "mo", [makeText(group.value, group.mode)]);

	        return node;
	    },

	    open: function(group) {
	        var node = new mathMLTree.MathNode(
	            "mo", [makeText(group.value, group.mode)]);

	        return node;
	    },

	    close: function(group) {
	        var node = new mathMLTree.MathNode(
	            "mo", [makeText(group.value, group.mode)]);

	        return node;
	    },

	    inner: function(group) {
	        var node = new mathMLTree.MathNode(
	            "mo", [makeText(group.value, group.mode)]);

	        return node;
	    },

	    punct: function(group) {
	        var node = new mathMLTree.MathNode(
	            "mo", [makeText(group.value, group.mode)]);

	        node.setAttribute("separator", "true");

	        return node;
	    },

	    ordgroup: function(group, options) {
	        var inner = buildExpression(group.value, options);

	        var node = new mathMLTree.MathNode("mrow", inner);

	        return node;
	    },

	    text: function(group, options) {
	        var inner = buildExpression(group.value.body, options);

	        var node = new mathMLTree.MathNode("mtext", inner);

	        return node;
	    },

	    color: function(group, options) {
	        var inner = buildExpression(group.value.value, options);

	        var node = new mathMLTree.MathNode("mstyle", inner);

	        node.setAttribute("mathcolor", group.value.color);

	        return node;
	    },

	    supsub: function(group, options) {
	        var children = [buildGroup(group.value.base, options)];

	        if (group.value.sub) {
	            children.push(buildGroup(group.value.sub, options));
	        }

	        if (group.value.sup) {
	            children.push(buildGroup(group.value.sup, options));
	        }

	        var nodeType;
	        if (!group.value.sub) {
	            nodeType = "msup";
	        } else if (!group.value.sup) {
	            nodeType = "msub";
	        } else {
	            nodeType = "msubsup";
	        }

	        var node = new mathMLTree.MathNode(nodeType, children);

	        return node;
	    },

	    genfrac: function(group, options) {
	        var node = new mathMLTree.MathNode(
	            "mfrac",
	            [buildGroup(group.value.numer, options),
	             buildGroup(group.value.denom, options)]);

	        if (!group.value.hasBarLine) {
	            node.setAttribute("linethickness", "0px");
	        }

	        if (group.value.leftDelim != null || group.value.rightDelim != null) {
	            var withDelims = [];

	            if (group.value.leftDelim != null) {
	                var leftOp = new mathMLTree.MathNode(
	                    "mo", [new mathMLTree.TextNode(group.value.leftDelim)]);

	                leftOp.setAttribute("fence", "true");

	                withDelims.push(leftOp);
	            }

	            withDelims.push(node);

	            if (group.value.rightDelim != null) {
	                var rightOp = new mathMLTree.MathNode(
	                    "mo", [new mathMLTree.TextNode(group.value.rightDelim)]);

	                rightOp.setAttribute("fence", "true");

	                withDelims.push(rightOp);
	            }

	            var outerNode = new mathMLTree.MathNode("mrow", withDelims);

	            return outerNode;
	        }

	        return node;
	    },

	    array: function(group, options) {
	        return new mathMLTree.MathNode(
	            "mtable", group.value.body.map(function(row) {
	                return new mathMLTree.MathNode(
	                    "mtr", row.map(function(cell) {
	                        return new mathMLTree.MathNode(
	                            "mtd", [buildGroup(cell, options)]);
	                    }));
	            }));
	    },

	    sqrt: function(group, options) {
	        var node;
	        if (group.value.index) {
	            node = new mathMLTree.MathNode(
	                "mroot", [
	                    buildGroup(group.value.body, options),
	                    buildGroup(group.value.index, options)
	                ]);
	        } else {
	            node = new mathMLTree.MathNode(
	                "msqrt", [buildGroup(group.value.body, options)]);
	        }

	        return node;
	    },

	    leftright: function(group, options) {
	        var inner = buildExpression(group.value.body, options);

	        if (group.value.left !== ".") {
	            var leftNode = new mathMLTree.MathNode(
	                "mo", [makeText(group.value.left, group.mode)]);

	            leftNode.setAttribute("fence", "true");

	            inner.unshift(leftNode);
	        }

	        if (group.value.right !== ".") {
	            var rightNode = new mathMLTree.MathNode(
	                "mo", [makeText(group.value.right, group.mode)]);

	            rightNode.setAttribute("fence", "true");

	            inner.push(rightNode);
	        }

	        var outerNode = new mathMLTree.MathNode("mrow", inner);

	        return outerNode;
	    },

	    accent: function(group, options) {
	        var accentNode = new mathMLTree.MathNode(
	            "mo", [makeText(group.value.accent, group.mode)]);

	        var node = new mathMLTree.MathNode(
	            "mover",
	            [buildGroup(group.value.base, options),
	             accentNode]);

	        node.setAttribute("accent", "true");

	        return node;
	    },

	    spacing: function(group) {
	        var node;

	        if (group.value === "\\ " || group.value === "\\space" ||
	            group.value === " " || group.value === "~") {
	            node = new mathMLTree.MathNode(
	                "mtext", [new mathMLTree.TextNode("\u00a0")]);
	        } else {
	            node = new mathMLTree.MathNode("mspace");

	            node.setAttribute(
	                "width", buildCommon.spacingFunctions[group.value].size);
	        }

	        return node;
	    },

	    op: function(group) {
	        var node;

	        // TODO(emily): handle big operators using the `largeop` attribute

	        if (group.value.symbol) {
	            // This is a symbol. Just add the symbol.
	            node = new mathMLTree.MathNode(
	                "mo", [makeText(group.value.body, group.mode)]);
	        } else {
	            // This is a text operator. Add all of the characters from the
	            // operator's name.
	            // TODO(emily): Add a space in the middle of some of these
	            // operators, like \limsup.
	            node = new mathMLTree.MathNode(
	                "mi", [new mathMLTree.TextNode(group.value.body.slice(1))]);
	        }

	        return node;
	    },

	    katex: function(group) {
	        var node = new mathMLTree.MathNode(
	            "mtext", [new mathMLTree.TextNode("KaTeX")]);

	        return node;
	    },

	    font: function(group, options) {
	        var font = group.value.font;
	        return buildGroup(group.value.body, options.withFont(font));
	    },

	    delimsizing: function(group) {
	        var children = [];

	        if (group.value.value !== ".") {
	            children.push(makeText(group.value.value, group.mode));
	        }

	        var node = new mathMLTree.MathNode("mo", children);

	        if (group.value.delimType === "open" ||
	            group.value.delimType === "close") {
	            // Only some of the delimsizing functions act as fences, and they
	            // return "open" or "close" delimTypes.
	            node.setAttribute("fence", "true");
	        } else {
	            // Explicitly disable fencing if it's not a fence, to override the
	            // defaults.
	            node.setAttribute("fence", "false");
	        }

	        return node;
	    },

	    styling: function(group, options) {
	        var inner = buildExpression(group.value.value, options);

	        var node = new mathMLTree.MathNode("mstyle", inner);

	        var styleAttributes = {
	            "display": ["0", "true"],
	            "text": ["0", "false"],
	            "script": ["1", "false"],
	            "scriptscript": ["2", "false"]
	        };

	        var attr = styleAttributes[group.value.style];

	        node.setAttribute("scriptlevel", attr[0]);
	        node.setAttribute("displaystyle", attr[1]);

	        return node;
	    },

	    sizing: function(group, options) {
	        var inner = buildExpression(group.value.value, options);

	        var node = new mathMLTree.MathNode("mstyle", inner);

	        // TODO(emily): This doesn't produce the correct size for nested size
	        // changes, because we don't keep state of what style we're currently
	        // in, so we can't reset the size to normal before changing it.  Now
	        // that we're passing an options parameter we should be able to fix
	        // this.
	        node.setAttribute(
	            "mathsize", buildCommon.sizingMultiplier[group.value.size] + "em");

	        return node;
	    },

	    overline: function(group, options) {
	        var operator = new mathMLTree.MathNode(
	            "mo", [new mathMLTree.TextNode("\u203e")]);
	        operator.setAttribute("stretchy", "true");

	        var node = new mathMLTree.MathNode(
	            "mover",
	            [buildGroup(group.value.body, options),
	             operator]);
	        node.setAttribute("accent", "true");

	        return node;
	    },

	    rule: function(group) {
	        // TODO(emily): Figure out if there's an actual way to draw black boxes
	        // in MathML.
	        var node = new mathMLTree.MathNode("mrow");

	        return node;
	    },

	    llap: function(group, options) {
	        var node = new mathMLTree.MathNode(
	            "mpadded", [buildGroup(group.value.body, options)]);

	        node.setAttribute("lspace", "-1width");
	        node.setAttribute("width", "0px");

	        return node;
	    },

	    rlap: function(group, options) {
	        var node = new mathMLTree.MathNode(
	            "mpadded", [buildGroup(group.value.body, options)]);

	        node.setAttribute("width", "0px");

	        return node;
	    },

	    phantom: function(group, options, prev) {
	        var inner = buildExpression(group.value.value, options);
	        return new mathMLTree.MathNode("mphantom", inner);
	    }
	};

	/**
	 * Takes a list of nodes, builds them, and returns a list of the generated
	 * MathML nodes. A little simpler than the HTML version because we don't do any
	 * previous-node handling.
	 */
	var buildExpression = function(expression, options) {
	    var groups = [];
	    for (var i = 0; i < expression.length; i++) {
	        var group = expression[i];
	        groups.push(buildGroup(group, options));
	    }
	    return groups;
	};

	/**
	 * Takes a group from the parser and calls the appropriate groupTypes function
	 * on it to produce a MathML node.
	 */
	var buildGroup = function(group, options) {
	    if (!group) {
	        return new mathMLTree.MathNode("mrow");
	    }

	    if (groupTypes[group.type]) {
	        // Call the groupTypes function
	        return groupTypes[group.type](group, options);
	    } else {
	        throw new ParseError(
	            "Got group of unknown type: '" + group.type + "'");
	    }
	};

	/**
	 * Takes a full parse tree and settings and builds a MathML representation of
	 * it. In particular, we put the elements from building the parse tree into a
	 * <semantics> tag so we can also include that TeX source as an annotation.
	 *
	 * Note that we actually return a domTree element with a `<math>` inside it so
	 * we can do appropriate styling.
	 */
	var buildMathML = function(tree, texExpression, options) {
	    var expression = buildExpression(tree, options);

	    // Wrap up the expression in an mrow so it is presented in the semantics
	    // tag correctly.
	    var wrapper = new mathMLTree.MathNode("mrow", expression);

	    // Build a TeX annotation of the source
	    var annotation = new mathMLTree.MathNode(
	        "annotation", [new mathMLTree.TextNode(texExpression)]);

	    annotation.setAttribute("encoding", "application/x-tex");

	    var semantics = new mathMLTree.MathNode(
	        "semantics", [wrapper, annotation]);

	    var math = new mathMLTree.MathNode("math", [semantics]);

	    // You can't style <math> nodes, so we wrap the node in a span.
	    return makeSpan(["katex-mathml"], [math]);
	};

	module.exports = buildMathML;


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * These objects store data about MathML nodes. This is the MathML equivalent
	 * of the types in domTree.js. Since MathML handles its own rendering, and
	 * since we're mainly using MathML to improve accessibility, we don't manage
	 * any of the styling state that the plain DOM nodes do.
	 *
	 * The `toNode` and `toMarkup` functions work simlarly to how they do in
	 * domTree.js, creating namespaced DOM nodes and HTML text markup respectively.
	 */

	var utils = __webpack_require__(12);

	/**
	 * This node represents a general purpose MathML node of any type. The
	 * constructor requires the type of node to create (for example, `"mo"` or
	 * `"mspace"`, corresponding to `<mo>` and `<mspace>` tags).
	 */
	function MathNode(type, children) {
	    this.type = type;
	    this.attributes = {};
	    this.children = children || [];
	}

	/**
	 * Sets an attribute on a MathML node. MathML depends on attributes to convey a
	 * semantic content, so this is used heavily.
	 */
	MathNode.prototype.setAttribute = function(name, value) {
	    this.attributes[name] = value;
	};

	/**
	 * Converts the math node into a MathML-namespaced DOM element.
	 */
	MathNode.prototype.toNode = function() {
	    var node = document.createElementNS(
	        "http://www.w3.org/1998/Math/MathML", this.type);

	    for (var attr in this.attributes) {
	        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
	            node.setAttribute(attr, this.attributes[attr]);
	        }
	    }

	    for (var i = 0; i < this.children.length; i++) {
	        node.appendChild(this.children[i].toNode());
	    }

	    return node;
	};

	/**
	 * Converts the math node into an HTML markup string.
	 */
	MathNode.prototype.toMarkup = function() {
	    var markup = "<" + this.type;

	    // Add the attributes
	    for (var attr in this.attributes) {
	        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
	            markup += " " + attr + "=\"";
	            markup += utils.escape(this.attributes[attr]);
	            markup += "\"";
	        }
	    }

	    markup += ">";

	    for (var i = 0; i < this.children.length; i++) {
	        markup += this.children[i].toMarkup();
	    }

	    markup += "</" + this.type + ">";

	    return markup;
	};

	/**
	 * This node represents a piece of text.
	 */
	function TextNode(text) {
	    this.text = text;
	}

	/**
	 * Converts the text node into a DOM text node.
	 */
	TextNode.prototype.toNode = function() {
	    return document.createTextNode(this.text);
	};

	/**
	 * Converts the text node into HTML markup (which is just the text itself).
	 */
	TextNode.prototype.toMarkup = function() {
	    return utils.escape(this.text);
	};

	module.exports = {
	    MathNode: MathNode,
	    TextNode: TextNode
	};


/***/ },
/* 19 */
/***/ function(module, exports) {

	/**
	 * This file contains information about the options that the Parser carries
	 * around with it while parsing. Data is held in an `Options` object, and when
	 * recursing, a new `Options` object can be created with the `.with*` and
	 * `.reset` functions.
	 */

	/**
	 * This is the main options class. It contains the style, size, color, and font
	 * of the current parse level. It also contains the style and size of the parent
	 * parse level, so size changes can be handled efficiently.
	 *
	 * Each of the `.with*` and `.reset` functions passes its current style and size
	 * as the parentStyle and parentSize of the new options class, so parent
	 * handling is taken care of automatically.
	 */
	function Options(data) {
	    this.style = data.style;
	    this.color = data.color;
	    this.size = data.size;
	    this.phantom = data.phantom;
	    this.font = data.font;

	    if (data.parentStyle === undefined) {
	        this.parentStyle = data.style;
	    } else {
	        this.parentStyle = data.parentStyle;
	    }

	    if (data.parentSize === undefined) {
	        this.parentSize = data.size;
	    } else {
	        this.parentSize = data.parentSize;
	    }
	}

	/**
	 * Returns a new options object with the same properties as "this".  Properties
	 * from "extension" will be copied to the new options object.
	 */
	Options.prototype.extend = function(extension) {
	    var data = {
	        style: this.style,
	        size: this.size,
	        color: this.color,
	        parentStyle: this.style,
	        parentSize: this.size,
	        phantom: this.phantom,
	        font: this.font
	    };

	    for (var key in extension) {
	        if (extension.hasOwnProperty(key)) {
	            data[key] = extension[key];
	        }
	    }

	    return new Options(data);
	};

	/**
	 * Create a new options object with the given style.
	 */
	Options.prototype.withStyle = function(style) {
	    return this.extend({
	        style: style
	    });
	};

	/**
	 * Create a new options object with the given size.
	 */
	Options.prototype.withSize = function(size) {
	    return this.extend({
	        size: size
	    });
	};

	/**
	 * Create a new options object with the given color.
	 */
	Options.prototype.withColor = function(color) {
	    return this.extend({
	        color: color
	    });
	};

	/**
	 * Create a new options object with "phantom" set to true.
	 */
	Options.prototype.withPhantom = function() {
	    return this.extend({
	        phantom: true
	    });
	};

	/**
	 * Create a new options objects with the give font.
	 */
	Options.prototype.withFont = function(font) {
	    return this.extend({
	        font: font
	    });
	};

	/**
	 * Create a new options object with the same style, size, and color. This is
	 * used so that parent style and size changes are handled correctly.
	 */
	Options.prototype.reset = function() {
	    return this.extend({});
	};

	/**
	 * A map of color names to CSS colors.
	 * TODO(emily): Remove this when we have real macros
	 */
	var colorMap = {
	    "katex-blue": "#6495ed",
	    "katex-orange": "#ffa500",
	    "katex-pink": "#ff00af",
	    "katex-red": "#df0030",
	    "katex-green": "#28ae7b",
	    "katex-gray": "gray",
	    "katex-purple": "#9d38bd",
	    "katex-blueA": "#c7e9f1",
	    "katex-blueB": "#9cdceb",
	    "katex-blueC": "#58c4dd",
	    "katex-blueD": "#29abca",
	    "katex-blueE": "#1c758a",
	    "katex-tealA": "#acead7",
	    "katex-tealB": "#76ddc0",
	    "katex-tealC": "#5cd0b3",
	    "katex-tealD": "#55c1a7",
	    "katex-tealE": "#49a88f",
	    "katex-greenA": "#c9e2ae",
	    "katex-greenB": "#a6cf8c",
	    "katex-greenC": "#83c167",
	    "katex-greenD": "#77b05d",
	    "katex-greenE": "#699c52",
	    "katex-goldA": "#f7c797",
	    "katex-goldB": "#f9b775",
	    "katex-goldC": "#f0ac5f",
	    "katex-goldD": "#e1a158",
	    "katex-goldE": "#c78d46",
	    "katex-redA": "#f7a1a3",
	    "katex-redB": "#ff8080",
	    "katex-redC": "#fc6255",
	    "katex-redD": "#e65a4c",
	    "katex-redE": "#cf5044",
	    "katex-maroonA": "#ecabc1",
	    "katex-maroonB": "#ec92ab",
	    "katex-maroonC": "#c55f73",
	    "katex-maroonD": "#a24d61",
	    "katex-maroonE": "#94424f",
	    "katex-purpleA": "#caa3e8",
	    "katex-purpleB": "#b189c6",
	    "katex-purpleC": "#9a72ac",
	    "katex-purpleD": "#715582",
	    "katex-purpleE": "#644172",
	    "katex-mintA": "#f5f9e8",
	    "katex-mintB": "#edf2df",
	    "katex-mintC": "#e0e5cc",
	    "katex-grayA": "#fdfdfd",
	    "katex-grayB": "#f7f7f7",
	    "katex-grayC": "#eeeeee",
	    "katex-grayD": "#dddddd",
	    "katex-grayE": "#cccccc",
	    "katex-grayF": "#aaaaaa",
	    "katex-grayG": "#999999",
	    "katex-grayH": "#555555",
	    "katex-grayI": "#333333",
	    "katex-kaBlue": "#314453",
	    "katex-kaGreen": "#639b24"
	};

	/**
	 * Gets the CSS color of the current options object, accounting for the
	 * `colorMap`.
	 */
	Options.prototype.getColor = function() {
	    if (this.phantom) {
	        return "transparent";
	    } else {
	        return colorMap[this.color] || this.color;
	    }
	};

	module.exports = Options;


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Provides a single function for parsing an expression using a Parser
	 * TODO(emily): Remove this
	 */

	var Parser = __webpack_require__(21);

	/**
	 * Parses an expression using a Parser, then returns the parsed result.
	 */
	var parseTree = function(toParse, settings) {
	    var parser = new Parser(toParse, settings);

	    return parser.parse();
	};

	module.exports = parseTree;


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var functions = __webpack_require__(22);
	var environments = __webpack_require__(23);
	var Lexer = __webpack_require__(25);
	var symbols = __webpack_require__(15);
	var utils = __webpack_require__(12);

	var parseData = __webpack_require__(24);
	var ParseError = __webpack_require__(5);

	/**
	 * This file contains the parser used to parse out a TeX expression from the
	 * input. Since TeX isn't context-free, standard parsers don't work particularly
	 * well.
	 *
	 * The strategy of this parser is as such:
	 *
	 * The main functions (the `.parse...` ones) take a position in the current
	 * parse string to parse tokens from. The lexer (found in Lexer.js, stored at
	 * this.lexer) also supports pulling out tokens at arbitrary places. When
	 * individual tokens are needed at a position, the lexer is called to pull out a
	 * token, which is then used.
	 *
	 * The main functions also take a mode that the parser is currently in
	 * (currently "math" or "text"), which denotes whether the current environment
	 * is a math-y one or a text-y one (e.g. inside \text). Currently, this serves
	 * to limit the functions which can be used in text mode.
	 *
	 * The main functions then return an object which contains the useful data that
	 * was parsed at its given point, and a new position at the end of the parsed
	 * data. The main functions can call each other and continue the parsing by
	 * using the returned position as a new starting point.
	 *
	 * There are also extra `.handle...` functions, which pull out some reused
	 * functionality into self-contained functions.
	 *
	 * The earlier functions return `ParseResult`s, which contain a ParseNode and a
	 * new position.
	 *
	 * The later functions (which are called deeper in the parse) sometimes return
	 * ParseFuncOrArgument, which contain a ParseResult as well as some data about
	 * whether the parsed object is a function which is missing some arguments, or a
	 * standalone object which can be used as an argument to another function.
	 */

	/**
	 * Main Parser class
	 */
	function Parser(input, settings) {
	    // Make a new lexer
	    this.lexer = new Lexer(input);
	    // Store the settings for use in parsing
	    this.settings = settings;
	}

	var ParseNode = parseData.ParseNode;
	var ParseResult = parseData.ParseResult;

	/**
	 * An initial function (without its arguments), or an argument to a function.
	 * The `result` argument should be a ParseResult.
	 */
	function ParseFuncOrArgument(result, isFunction) {
	    this.result = result;
	    // Is this a function (i.e. is it something defined in functions.js)?
	    this.isFunction = isFunction;
	}

	/**
	 * Checks a result to make sure it has the right type, and throws an
	 * appropriate error otherwise.
	 */
	Parser.prototype.expect = function(result, text) {
	    if (result.text !== text) {
	        throw new ParseError(
	            "Expected '" + text + "', got '" + result.text + "'",
	            this.lexer, result.position
	        );
	    }
	};

	/**
	 * Main parsing function, which parses an entire input.
	 *
	 * @return {?Array.<ParseNode>}
	 */
	Parser.prototype.parse = function(input) {
	    // Try to parse the input
	    var parse = this.parseInput(0, "math");
	    return parse.result;
	};

	/**
	 * Parses an entire input tree.
	 */
	Parser.prototype.parseInput = function(pos, mode) {
	    // Parse an expression
	    var expression = this.parseExpression(pos, mode, false);
	    // If we succeeded, make sure there's an EOF at the end
	    this.expect(expression.peek, "EOF");
	    return expression;
	};

	var endOfExpression = ["}", "\\end", "\\right", "&", "\\\\", "\\cr"];

	/**
	 * Parses an "expression", which is a list of atoms.
	 *
	 * @param {boolean} breakOnInfix Should the parsing stop when we hit infix
	 *                  nodes? This happens when functions have higher precendence
	 *                  than infix nodes in implicit parses.
	 *
	 * @param {?string} breakOnToken The token that the expression should end with,
	 *                  or `null` if something else should end the expression.
	 *
	 * @return {ParseResult}
	 */
	Parser.prototype.parseExpression = function(pos, mode, breakOnInfix, breakOnToken) {
	    var body = [];
	    var lex = null;
	    // Keep adding atoms to the body until we can't parse any more atoms (either
	    // we reached the end, a }, or a \right)
	    while (true) {
	        lex = this.lexer.lex(pos, mode);
	        if (endOfExpression.indexOf(lex.text) !== -1) {
	            break;
	        }
	        if (breakOnToken && lex.text === breakOnToken) {
	            break;
	        }
	        var atom = this.parseAtom(pos, mode);
	        if (!atom) {
	            if (!this.settings.throwOnError && lex.text[0] === "\\") {
	                var errorNode = this.handleUnsupportedCmd(lex.text, mode);
	                body.push(errorNode);

	                pos = lex.position;
	                continue;
	            }

	            break;
	        }
	        if (breakOnInfix && atom.result.type === "infix") {
	            break;
	        }
	        body.push(atom.result);
	        pos = atom.position;
	    }
	    var res = new ParseResult(this.handleInfixNodes(body, mode), pos);
	    res.peek = lex;
	    return res;
	};

	/**
	 * Rewrites infix operators such as \over with corresponding commands such
	 * as \frac.
	 *
	 * There can only be one infix operator per group.  If there's more than one
	 * then the expression is ambiguous.  This can be resolved by adding {}.
	 *
	 * @returns {Array}
	 */
	Parser.prototype.handleInfixNodes = function (body, mode) {
	    var overIndex = -1;
	    var func;
	    var funcName;

	    for (var i = 0; i < body.length; i++) {
	        var node = body[i];
	        if (node.type === "infix") {
	            if (overIndex !== -1) {
	                throw new ParseError("only one infix operator per group",
	                    this.lexer, -1);
	            }
	            overIndex = i;
	            funcName = node.value.replaceWith;
	            func = functions.funcs[funcName];
	        }
	    }

	    if (overIndex !== -1) {
	        var numerNode, denomNode;

	        var numerBody = body.slice(0, overIndex);
	        var denomBody = body.slice(overIndex + 1);

	        if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
	            numerNode = numerBody[0];
	        } else {
	            numerNode = new ParseNode("ordgroup", numerBody, mode);
	        }

	        if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
	            denomNode = denomBody[0];
	        } else {
	            denomNode = new ParseNode("ordgroup", denomBody, mode);
	        }

	        var value = func.handler(funcName, numerNode, denomNode);
	        return [new ParseNode(value.type, value, mode)];
	    } else {
	        return body;
	    }
	};

	// The greediness of a superscript or subscript
	var SUPSUB_GREEDINESS = 1;

	/**
	 * Handle a subscript or superscript with nice errors.
	 */
	Parser.prototype.handleSupSubscript = function(pos, mode, symbol, name) {
	    var group = this.parseGroup(pos, mode);

	    if (!group) {
	        var lex = this.lexer.lex(pos, mode);

	        if (!this.settings.throwOnError && lex.text[0] === "\\") {
	            return new ParseResult(
	                this.handleUnsupportedCmd(lex.text, mode),
	                lex.position);
	        } else {
	            throw new ParseError(
	                "Expected group after '" + symbol + "'", this.lexer, pos);
	        }
	    } else if (group.isFunction) {
	        // ^ and _ have a greediness, so handle interactions with functions'
	        // greediness
	        var funcGreediness = functions.funcs[group.result.result].greediness;
	        if (funcGreediness > SUPSUB_GREEDINESS) {
	            return this.parseFunction(pos, mode);
	        } else {
	            throw new ParseError(
	                "Got function '" + group.result.result + "' with no arguments " +
	                    "as " + name,
	                this.lexer, pos);
	        }
	    } else {
	        return group.result;
	    }
	};

	/**
	 * Converts the textual input of an unsupported command into a text node
	 * contained within a color node whose color is determined by errorColor
	 */
	 Parser.prototype.handleUnsupportedCmd = function(text, mode) {
	     var textordArray = [];

	     for (var i = 0; i < text.length; i++) {
	        textordArray.push(new ParseNode("textord", text[i], "text"));
	     }

	     var textNode = new ParseNode(
	         "text",
	         {
	             body: textordArray,
	             type: "text"
	         },
	         mode);

	     var colorNode = new ParseNode(
	        "color",
	        {
	            color: this.settings.errorColor,
	            value: [textNode],
	            type: "color"
	        },
	        mode);

	     return colorNode;
	 };

	/**
	 * Parses a group with optional super/subscripts.
	 *
	 * @return {?ParseResult}
	 */
	Parser.prototype.parseAtom = function(pos, mode) {
	    // The body of an atom is an implicit group, so that things like
	    // \left(x\right)^2 work correctly.
	    var base = this.parseImplicitGroup(pos, mode);

	    // In text mode, we don't have superscripts or subscripts
	    if (mode === "text") {
	        return base;
	    }

	    // Handle an empty base
	    var currPos;
	    if (!base) {
	        currPos = pos;
	        base = undefined;
	    } else {
	        currPos = base.position;
	    }

	    var superscript;
	    var subscript;
	    var result;
	    while (true) {
	        // Lex the first token
	        var lex = this.lexer.lex(currPos, mode);

	        if (lex.text === "\\limits" || lex.text === "\\nolimits") {
	            // We got a limit control
	            if (!base || base.result.type !== "op") {
	                throw new ParseError("Limit controls must follow a math operator",
	                    this.lexer, currPos);
	            }
	            else {
	                var limits = lex.text === "\\limits";
	                base.result.value.limits = limits;
	                base.result.value.alwaysHandleSupSub = true;
	                currPos = lex.position;
	            }
	        } else if (lex.text === "^") {
	            // We got a superscript start
	            if (superscript) {
	                throw new ParseError(
	                    "Double superscript", this.lexer, currPos);
	            }
	            result = this.handleSupSubscript(
	                lex.position, mode, lex.text, "superscript");
	            currPos = result.position;
	            superscript = result.result;
	        } else if (lex.text === "_") {
	            // We got a subscript start
	            if (subscript) {
	                throw new ParseError(
	                    "Double subscript", this.lexer, currPos);
	            }
	            result = this.handleSupSubscript(
	                lex.position, mode, lex.text, "subscript");
	            currPos = result.position;
	            subscript = result.result;
	        } else if (lex.text === "'") {
	            // We got a prime
	            var prime = new ParseNode("textord", "\\prime", mode);

	            // Many primes can be grouped together, so we handle this here
	            var primes = [prime];
	            currPos = lex.position;
	            // Keep lexing tokens until we get something that's not a prime
	            while ((lex = this.lexer.lex(currPos, mode)).text === "'") {
	                // For each one, add another prime to the list
	                primes.push(prime);
	                currPos = lex.position;
	            }
	            // Put them into an ordgroup as the superscript
	            superscript = new ParseNode("ordgroup", primes, mode);
	        } else {
	            // If it wasn't ^, _, or ', stop parsing super/subscripts
	            break;
	        }
	    }

	    if (superscript || subscript) {
	        // If we got either a superscript or subscript, create a supsub
	        return new ParseResult(
	            new ParseNode("supsub", {
	                base: base && base.result,
	                sup: superscript,
	                sub: subscript
	            }, mode),
	            currPos);
	    } else {
	        // Otherwise return the original body
	        return base;
	    }
	};

	// A list of the size-changing functions, for use in parseImplicitGroup
	var sizeFuncs = [
	    "\\tiny", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize",
	    "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"
	];

	// A list of the style-changing functions, for use in parseImplicitGroup
	var styleFuncs = [
	    "\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"
	];

	/**
	 * Parses an implicit group, which is a group that starts at the end of a
	 * specified, and ends right before a higher explicit group ends, or at EOL. It
	 * is used for functions that appear to affect the current style, like \Large or
	 * \textrm, where instead of keeping a style we just pretend that there is an
	 * implicit grouping after it until the end of the group. E.g.
	 *   small text {\Large large text} small text again
	 * It is also used for \left and \right to get the correct grouping.
	 *
	 * @return {?ParseResult}
	 */
	Parser.prototype.parseImplicitGroup = function(pos, mode) {
	    var start = this.parseSymbol(pos, mode);

	    if (!start || !start.result) {
	        // If we didn't get anything we handle, fall back to parseFunction
	        return this.parseFunction(pos, mode);
	    }

	    var func = start.result.result;
	    var body;

	    if (func === "\\left") {
	        // If we see a left:
	        // Parse the entire left function (including the delimiter)
	        var left = this.parseFunction(pos, mode);
	        // Parse out the implicit body
	        body = this.parseExpression(left.position, mode, false);
	        // Check the next token
	        this.expect(body.peek, "\\right");
	        var right = this.parseFunction(body.position, mode);
	        return new ParseResult(
	            new ParseNode("leftright", {
	                body: body.result,
	                left: left.result.value.value,
	                right: right.result.value.value
	            }, mode),
	            right.position);
	    } else if (func === "\\begin") {
	        // begin...end is similar to left...right
	        var begin = this.parseFunction(pos, mode);
	        var envName = begin.result.value.name;
	        if (!environments.hasOwnProperty(envName)) {
	            throw new ParseError(
	                "No such environment: " + envName,
	                this.lexer, begin.result.value.namepos);
	        }
	        // Build the environment object. Arguments and other information will
	        // be made available to the begin and end methods using properties.
	        var env = environments[envName];
	        var args = [null, mode, envName];
	        var newPos = this.parseArguments(
	            begin.position, mode, "\\begin{" + envName + "}", env, args);
	        args[0] = newPos;
	        var result = env.handler.apply(this, args);
	        var endLex = this.lexer.lex(result.position, mode);
	        this.expect(endLex, "\\end");
	        var end = this.parseFunction(result.position, mode);
	        if (end.result.value.name !== envName) {
	            throw new ParseError(
	                "Mismatch: \\begin{" + envName + "} matched " +
	                "by \\end{" + end.result.value.name + "}",
	                this.lexer, end.namepos);
	        }
	        result.position = end.position;
	        return result;
	    } else if (utils.contains(sizeFuncs, func)) {
	        // If we see a sizing function, parse out the implict body
	        body = this.parseExpression(start.result.position, mode, false);
	        return new ParseResult(
	            new ParseNode("sizing", {
	                // Figure out what size to use based on the list of functions above
	                size: "size" + (utils.indexOf(sizeFuncs, func) + 1),
	                value: body.result
	            }, mode),
	            body.position);
	    } else if (utils.contains(styleFuncs, func)) {
	        // If we see a styling function, parse out the implict body
	        body = this.parseExpression(start.result.position, mode, true);
	        return new ParseResult(
	            new ParseNode("styling", {
	                // Figure out what style to use by pulling out the style from
	                // the function name
	                style: func.slice(1, func.length - 5),
	                value: body.result
	            }, mode),
	            body.position);
	    } else {
	        // Defer to parseFunction if it's not a function we handle
	        return this.parseFunction(pos, mode);
	    }
	};

	/**
	 * Parses an entire function, including its base and all of its arguments
	 *
	 * @return {?ParseResult}
	 */
	Parser.prototype.parseFunction = function(pos, mode) {
	    var baseGroup = this.parseGroup(pos, mode);

	    if (baseGroup) {
	        if (baseGroup.isFunction) {
	            var func = baseGroup.result.result;
	            var funcData = functions.funcs[func];
	            if (mode === "text" && !funcData.allowedInText) {
	                throw new ParseError(
	                    "Can't use function '" + func + "' in text mode",
	                    this.lexer, baseGroup.position);
	            }

	            var args = [func];
	            var newPos = this.parseArguments(
	                baseGroup.result.position, mode, func, funcData, args);
	            var result = functions.funcs[func].handler.apply(this, args);
	            return new ParseResult(
	                new ParseNode(result.type, result, mode),
	                newPos);
	        } else {
	            return baseGroup.result;
	        }
	    } else {
	        return null;
	    }
	};


	/**
	 * Parses the arguments of a function or environment
	 *
	 * @param {string} func  "\name" or "\begin{name}"
	 * @param {{numArgs:number,numOptionalArgs:number|undefined}} funcData
	 * @param {Array} args  list of arguments to which new ones will be pushed
	 * @return the position after all arguments have been parsed
	 */
	Parser.prototype.parseArguments = function(pos, mode, func, funcData, args) {
	    var totalArgs = funcData.numArgs + funcData.numOptionalArgs;
	    if (totalArgs === 0) {
	        return pos;
	    }

	    var newPos = pos;
	    var baseGreediness = funcData.greediness;
	    var positions = [newPos];

	    for (var i = 0; i < totalArgs; i++) {
	        var argType = funcData.argTypes && funcData.argTypes[i];
	        var arg;
	        if (i < funcData.numOptionalArgs) {
	            if (argType) {
	                arg = this.parseSpecialGroup(newPos, argType, mode, true);
	            } else {
	                arg = this.parseOptionalGroup(newPos, mode);
	            }
	            if (!arg) {
	                args.push(null);
	                positions.push(newPos);
	                continue;
	            }
	        } else {
	            if (argType) {
	                arg = this.parseSpecialGroup(newPos, argType, mode);
	            } else {
	                arg = this.parseGroup(newPos, mode);
	            }
	            if (!arg) {
	                var lex = this.lexer.lex(newPos, mode);

	                if (!this.settings.throwOnError && lex.text[0] === "\\") {
	                    arg = new ParseFuncOrArgument(
	                        new ParseResult(
	                            this.handleUnsupportedCmd(lex.text, mode),
	                            lex.position),
	                        false);
	                } else {
	                    throw new ParseError(
	                        "Expected group after '" + func + "'", this.lexer, pos);
	                }
	            }
	        }
	        var argNode;
	        if (arg.isFunction) {
	            var argGreediness =
	                functions.funcs[arg.result.result].greediness;
	            if (argGreediness > baseGreediness) {
	                argNode = this.parseFunction(newPos, mode);
	            } else {
	                throw new ParseError(
	                    "Got function '" + arg.result.result + "' as " +
	                    "argument to '" + func + "'",
	                    this.lexer, arg.result.position - 1);
	            }
	        } else {
	            argNode = arg.result;
	        }
	        args.push(argNode.result);
	        positions.push(argNode.position);
	        newPos = argNode.position;
	    }

	    args.push(positions);

	    return newPos;
	};


	/**
	 * Parses a group when the mode is changing. Takes a position, a new mode, and
	 * an outer mode that is used to parse the outside.
	 *
	 * @return {?ParseFuncOrArgument}
	 */
	Parser.prototype.parseSpecialGroup = function(pos, mode, outerMode, optional) {
	    // Handle `original` argTypes
	    if (mode === "original") {
	        mode = outerMode;
	    }

	    if (mode === "color" || mode === "size") {
	        // color and size modes are special because they should have braces and
	        // should only lex a single symbol inside
	        var openBrace = this.lexer.lex(pos, outerMode);
	        if (optional && openBrace.text !== "[") {
	            // optional arguments should return null if they don't exist
	            return null;
	        }
	        this.expect(openBrace, optional ? "[" : "{");
	        var inner = this.lexer.lex(openBrace.position, mode);
	        var data;
	        if (mode === "color") {
	            data = inner.text;
	        } else {
	            data = inner.data;
	        }
	        var closeBrace = this.lexer.lex(inner.position, outerMode);
	        this.expect(closeBrace, optional ? "]" : "}");
	        return new ParseFuncOrArgument(
	            new ParseResult(
	                new ParseNode(mode, data, outerMode),
	                closeBrace.position),
	            false);
	    } else if (mode === "text") {
	        // text mode is special because it should ignore the whitespace before
	        // it
	        var whitespace = this.lexer.lex(pos, "whitespace");
	        pos = whitespace.position;
	    }

	    if (optional) {
	        return this.parseOptionalGroup(pos, mode);
	    } else {
	        return this.parseGroup(pos, mode);
	    }
	};

	/**
	 * Parses a group, which is either a single nucleus (like "x") or an expression
	 * in braces (like "{x+y}")
	 *
	 * @return {?ParseFuncOrArgument}
	 */
	Parser.prototype.parseGroup = function(pos, mode) {
	    var start = this.lexer.lex(pos, mode);
	    // Try to parse an open brace
	    if (start.text === "{") {
	        // If we get a brace, parse an expression
	        var expression = this.parseExpression(start.position, mode, false);
	        // Make sure we get a close brace
	        var closeBrace = this.lexer.lex(expression.position, mode);
	        this.expect(closeBrace, "}");
	        return new ParseFuncOrArgument(
	            new ParseResult(
	                new ParseNode("ordgroup", expression.result, mode),
	                closeBrace.position),
	            false);
	    } else {
	        // Otherwise, just return a nucleus
	        return this.parseSymbol(pos, mode);
	    }
	};

	/**
	 * Parses a group, which is an expression in brackets (like "[x+y]")
	 *
	 * @return {?ParseFuncOrArgument}
	 */
	Parser.prototype.parseOptionalGroup = function(pos, mode) {
	    var start = this.lexer.lex(pos, mode);
	    // Try to parse an open bracket
	    if (start.text === "[") {
	        // If we get a brace, parse an expression
	        var expression = this.parseExpression(start.position, mode, false, "]");
	        // Make sure we get a close bracket
	        var closeBracket = this.lexer.lex(expression.position, mode);
	        this.expect(closeBracket, "]");
	        return new ParseFuncOrArgument(
	            new ParseResult(
	                new ParseNode("ordgroup", expression.result, mode),
	                closeBracket.position),
	            false);
	    } else {
	        // Otherwise, return null,
	        return null;
	    }
	};

	/**
	 * Parse a single symbol out of the string. Here, we handle both the functions
	 * we have defined, as well as the single character symbols
	 *
	 * @return {?ParseFuncOrArgument}
	 */
	Parser.prototype.parseSymbol = function(pos, mode) {
	    var nucleus = this.lexer.lex(pos, mode);

	    if (functions.funcs[nucleus.text]) {
	        // If there exists a function with this name, we return the function and
	        // say that it is a function.
	        return new ParseFuncOrArgument(
	            new ParseResult(nucleus.text, nucleus.position),
	            true);
	    } else if (symbols[mode][nucleus.text]) {
	        // Otherwise if this is a no-argument function, find the type it
	        // corresponds to in the symbols map
	        return new ParseFuncOrArgument(
	            new ParseResult(
	                new ParseNode(symbols[mode][nucleus.text].group,
	                              nucleus.text, mode),
	                nucleus.position),
	            false);
	    } else {
	        return null;
	    }
	};

	Parser.prototype.ParseNode = ParseNode;

	module.exports = Parser;


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var utils = __webpack_require__(12);
	var ParseError = __webpack_require__(5);

	// This file contains a list of functions that we parse. The functions map
	// contains the following data:

	/*
	 * Keys are the name of the functions to parse
	 * The data contains the following keys:
	 *  - numArgs: The number of arguments the function takes.
	 *  - argTypes: (optional) An array corresponding to each argument of the
	 *              function, giving the type of argument that should be parsed. Its
	 *              length should be equal to `numArgs + numOptionalArgs`. Valid
	 *              types:
	 *               - "size": A size-like thing, such as "1em" or "5ex"
	 *               - "color": An html color, like "#abc" or "blue"
	 *               - "original": The same type as the environment that the
	 *                             function being parsed is in (e.g. used for the
	 *                             bodies of functions like \color where the first
	 *                             argument is special and the second argument is
	 *                             parsed normally)
	 *              Other possible types (probably shouldn't be used)
	 *               - "text": Text-like (e.g. \text)
	 *               - "math": Normal math
	 *              If undefined, this will be treated as an appropriate length
	 *              array of "original" strings
	 *  - greediness: (optional) The greediness of the function to use ungrouped
	 *                arguments.
	 *
	 *                E.g. if you have an expression
	 *                  \sqrt \frac 1 2
	 *                since \frac has greediness=2 vs \sqrt's greediness=1, \frac
	 *                will use the two arguments '1' and '2' as its two arguments,
	 *                then that whole function will be used as the argument to
	 *                \sqrt. On the other hand, the expressions
	 *                  \frac \frac 1 2 3
	 *                and
	 *                  \frac \sqrt 1 2
	 *                will fail because \frac and \frac have equal greediness
	 *                and \sqrt has a lower greediness than \frac respectively. To
	 *                make these parse, we would have to change them to:
	 *                  \frac {\frac 1 2} 3
	 *                and
	 *                  \frac {\sqrt 1} 2
	 *
	 *                The default value is `1`
	 *  - allowedInText: (optional) Whether or not the function is allowed inside
	 *                   text mode (default false)
	 *  - numOptionalArgs: (optional) The number of optional arguments the function
	 *                     should parse. If the optional arguments aren't found,
	 *                     `null` will be passed to the handler in their place.
	 *                     (default 0)
	 *  - handler: The function that is called to handle this function and its
	 *             arguments. The arguments are:
	 *              - func: the text of the function
	 *              - [args]: the next arguments are the arguments to the function,
	 *                        of which there are numArgs of them
	 *              - positions: the positions in the overall string of the function
	 *                           and the arguments. Should only be used to produce
	 *                           error messages
	 *             The function should return an object with the following keys:
	 *              - type: The type of element that this is. This is then used in
	 *                      buildHTML/buildMathML to determine which function
	 *                      should be called to build this node into a DOM node
	 *             Any other data can be added to the object, which will be passed
	 *             in to the function in buildHTML/buildMathML as `group.value`.
	 */

	var functions = {
	    // A normal square root
	    "\\sqrt": {
	        numArgs: 1,
	        numOptionalArgs: 1,
	        handler: function(func, index, body, positions) {
	            return {
	                type: "sqrt",
	                body: body,
	                index: index
	            };
	        }
	    },

	    // Some non-mathy text
	    "\\text": {
	        numArgs: 1,
	        argTypes: ["text"],
	        greediness: 2,
	        handler: function(func, body) {
	            // Since the corresponding buildHTML/buildMathML function expects a
	            // list of elements, we normalize for different kinds of arguments
	            // TODO(emily): maybe this should be done somewhere else
	            var inner;
	            if (body.type === "ordgroup") {
	                inner = body.value;
	            } else {
	                inner = [body];
	            }

	            return {
	                type: "text",
	                body: inner
	            };
	        }
	    },

	    // A two-argument custom color
	    "\\color": {
	        numArgs: 2,
	        allowedInText: true,
	        greediness: 3,
	        argTypes: ["color", "original"],
	        handler: function(func, color, body) {
	            // Normalize the different kinds of bodies (see \text above)
	            var inner;
	            if (body.type === "ordgroup") {
	                inner = body.value;
	            } else {
	                inner = [body];
	            }

	            return {
	                type: "color",
	                color: color.value,
	                value: inner
	            };
	        }
	    },

	    // An overline
	    "\\overline": {
	        numArgs: 1,
	        handler: function(func, body) {
	            return {
	                type: "overline",
	                body: body
	            };
	        }
	    },

	    // A box of the width and height
	    "\\rule": {
	        numArgs: 2,
	        numOptionalArgs: 1,
	        argTypes: ["size", "size", "size"],
	        handler: function(func, shift, width, height) {
	            return {
	                type: "rule",
	                shift: shift && shift.value,
	                width: width.value,
	                height: height.value
	            };
	        }
	    },

	    // A KaTeX logo
	    "\\KaTeX": {
	        numArgs: 0,
	        handler: function(func) {
	            return {
	                type: "katex"
	            };
	        }
	    },

	    "\\phantom": {
	        numArgs: 1,
	        handler: function(func, body) {
	            var inner;
	            if (body.type === "ordgroup") {
	                inner = body.value;
	            } else {
	                inner = [body];
	            }

	            return {
	                type: "phantom",
	                value: inner
	            };
	        }
	    }
	};

	// Extra data needed for the delimiter handler down below
	var delimiterSizes = {
	    "\\bigl" : {type: "open",    size: 1},
	    "\\Bigl" : {type: "open",    size: 2},
	    "\\biggl": {type: "open",    size: 3},
	    "\\Biggl": {type: "open",    size: 4},
	    "\\bigr" : {type: "close",   size: 1},
	    "\\Bigr" : {type: "close",   size: 2},
	    "\\biggr": {type: "close",   size: 3},
	    "\\Biggr": {type: "close",   size: 4},
	    "\\bigm" : {type: "rel",     size: 1},
	    "\\Bigm" : {type: "rel",     size: 2},
	    "\\biggm": {type: "rel",     size: 3},
	    "\\Biggm": {type: "rel",     size: 4},
	    "\\big"  : {type: "textord", size: 1},
	    "\\Big"  : {type: "textord", size: 2},
	    "\\bigg" : {type: "textord", size: 3},
	    "\\Bigg" : {type: "textord", size: 4}
	};

	var delimiters = [
	    "(", ")", "[", "\\lbrack", "]", "\\rbrack",
	    "\\{", "\\lbrace", "\\}", "\\rbrace",
	    "\\lfloor", "\\rfloor", "\\lceil", "\\rceil",
	    "<", ">", "\\langle", "\\rangle",
	    "\\lvert", "\\rvert", "\\lVert", "\\rVert",
	    "\\lgroup", "\\rgroup", "\\lmoustache", "\\rmoustache",
	    "/", "\\backslash",
	    "|", "\\vert", "\\|", "\\Vert",
	    "\\uparrow", "\\Uparrow",
	    "\\downarrow", "\\Downarrow",
	    "\\updownarrow", "\\Updownarrow",
	    "."
	];

	var fontAliases = {
	    "\\Bbb": "\\mathbb",
	    "\\bold": "\\mathbf",
	    "\\frak": "\\mathfrak"
	};

	/*
	 * This is a list of functions which each have the same function but have
	 * different names so that we don't have to duplicate the data a bunch of times.
	 * Each element in the list is an object with the following keys:
	 *  - funcs: A list of function names to be associated with the data
	 *  - data: An objecty with the same data as in each value of the `function`
	 *          table above
	 */
	var duplicatedFunctions = [
	    // Single-argument color functions
	    {
	        funcs: [
	            "\\blue", "\\orange", "\\pink", "\\red",
	            "\\green", "\\gray", "\\purple",
	            "\\blueA", "\\blueB", "\\blueC", "\\blueD", "\\blueE",
	            "\\tealA", "\\tealB", "\\tealC", "\\tealD", "\\tealE",
	            "\\greenA", "\\greenB", "\\greenC", "\\greenD", "\\greenE",
	            "\\goldA", "\\goldB", "\\goldC", "\\goldD", "\\goldE",
	            "\\redA", "\\redB", "\\redC", "\\redD", "\\redE",
	            "\\maroonA", "\\maroonB", "\\maroonC", "\\maroonD", "\\maroonE",
	            "\\purpleA", "\\purpleB", "\\purpleC", "\\purpleD", "\\purpleE",
	            "\\mintA", "\\mintB", "\\mintC",
	            "\\grayA", "\\grayB", "\\grayC", "\\grayD", "\\grayE",
	            "\\grayF", "\\grayG", "\\grayH", "\\grayI",
	            "\\kaBlue", "\\kaGreen"
	        ],
	        data: {
	            numArgs: 1,
	            allowedInText: true,
	            greediness: 3,
	            handler: function(func, body) {
	                var atoms;
	                if (body.type === "ordgroup") {
	                    atoms = body.value;
	                } else {
	                    atoms = [body];
	                }

	                return {
	                    type: "color",
	                    color: "katex-" + func.slice(1),
	                    value: atoms
	                };
	            }
	        }
	    },

	    // There are 2 flags for operators; whether they produce limits in
	    // displaystyle, and whether they are symbols and should grow in
	    // displaystyle. These four groups cover the four possible choices.

	    // No limits, not symbols
	    {
	        funcs: [
	            "\\arcsin", "\\arccos", "\\arctan", "\\arg", "\\cos", "\\cosh",
	            "\\cot", "\\coth", "\\csc", "\\deg", "\\dim", "\\exp", "\\hom",
	            "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh",
	            "\\tan","\\tanh"
	        ],
	        data: {
	            numArgs: 0,
	            handler: function(func) {
	                return {
	                    type: "op",
	                    limits: false,
	                    symbol: false,
	                    body: func
	                };
	            }
	        }
	    },

	    // Limits, not symbols
	    {
	        funcs: [
	            "\\det", "\\gcd", "\\inf", "\\lim", "\\liminf", "\\limsup", "\\max",
	            "\\min", "\\Pr", "\\sup"
	        ],
	        data: {
	            numArgs: 0,
	            handler: function(func) {
	                return {
	                    type: "op",
	                    limits: true,
	                    symbol: false,
	                    body: func
	                };
	            }
	        }
	    },

	    // No limits, symbols
	    {
	        funcs: [
	            "\\int", "\\iint", "\\iiint", "\\oint"
	        ],
	        data: {
	            numArgs: 0,
	            handler: function(func) {
	                return {
	                    type: "op",
	                    limits: false,
	                    symbol: true,
	                    body: func
	                };
	            }
	        }
	    },

	    // Limits, symbols
	    {
	        funcs: [
	            "\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap",
	            "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes",
	            "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint"
	        ],
	        data: {
	            numArgs: 0,
	            handler: function(func) {
	                return {
	                    type: "op",
	                    limits: true,
	                    symbol: true,
	                    body: func
	                };
	            }
	        }
	    },

	    // Fractions
	    {
	        funcs: [
	            "\\dfrac", "\\frac", "\\tfrac",
	            "\\dbinom", "\\binom", "\\tbinom"
	        ],
	        data: {
	            numArgs: 2,
	            greediness: 2,
	            handler: function(func, numer, denom) {
	                var hasBarLine;
	                var leftDelim = null;
	                var rightDelim = null;
	                var size = "auto";

	                switch (func) {
	                    case "\\dfrac":
	                    case "\\frac":
	                    case "\\tfrac":
	                        hasBarLine = true;
	                        break;
	                    case "\\dbinom":
	                    case "\\binom":
	                    case "\\tbinom":
	                        hasBarLine = false;
	                        leftDelim = "(";
	                        rightDelim = ")";
	                        break;
	                    default:
	                        throw new Error("Unrecognized genfrac command");
	                }

	                switch (func) {
	                    case "\\dfrac":
	                    case "\\dbinom":
	                        size = "display";
	                        break;
	                    case "\\tfrac":
	                    case "\\tbinom":
	                        size = "text";
	                        break;
	                }

	                return {
	                    type: "genfrac",
	                    numer: numer,
	                    denom: denom,
	                    hasBarLine: hasBarLine,
	                    leftDelim: leftDelim,
	                    rightDelim: rightDelim,
	                    size: size
	                };
	            }
	        }
	    },

	    // Left and right overlap functions
	    {
	        funcs: ["\\llap", "\\rlap"],
	        data: {
	            numArgs: 1,
	            allowedInText: true,
	            handler: function(func, body) {
	                return {
	                    type: func.slice(1),
	                    body: body
	                };
	            }
	        }
	    },

	    // Delimiter functions
	    {
	        funcs: [
	            "\\bigl", "\\Bigl", "\\biggl", "\\Biggl",
	            "\\bigr", "\\Bigr", "\\biggr", "\\Biggr",
	            "\\bigm", "\\Bigm", "\\biggm", "\\Biggm",
	            "\\big",  "\\Big",  "\\bigg",  "\\Bigg",
	            "\\left", "\\right"
	        ],
	        data: {
	            numArgs: 1,
	            handler: function(func, delim, positions) {
	                if (!utils.contains(delimiters, delim.value)) {
	                    throw new ParseError(
	                        "Invalid delimiter: '" + delim.value + "' after '" +
	                            func + "'",
	                        this.lexer, positions[1]);
	                }

	                // \left and \right are caught somewhere in Parser.js, which is
	                // why this data doesn't match what is in buildHTML.
	                if (func === "\\left" || func === "\\right") {
	                    return {
	                        type: "leftright",
	                        value: delim.value
	                    };
	                } else {
	                    return {
	                        type: "delimsizing",
	                        size: delimiterSizes[func].size,
	                        delimType: delimiterSizes[func].type,
	                        value: delim.value
	                    };
	                }
	            }
	        }
	    },

	    // Sizing functions (handled in Parser.js explicitly, hence no handler)
	    {
	        funcs: [
	            "\\tiny", "\\scriptsize", "\\footnotesize", "\\small",
	            "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"
	        ],
	        data: {
	            numArgs: 0
	        }
	    },

	    // Style changing functions (handled in Parser.js explicitly, hence no
	    // handler)
	    {
	        funcs: [
	            "\\displaystyle", "\\textstyle", "\\scriptstyle",
	            "\\scriptscriptstyle"
	        ],
	        data: {
	            numArgs: 0
	        }
	    },

	    {
	        funcs: [
	            // styles
	            "\\mathrm", "\\mathit", "\\mathbf",

	            // families
	            "\\mathbb", "\\mathcal", "\\mathfrak", "\\mathscr", "\\mathsf",
	            "\\mathtt",

	            // aliases
	            "\\Bbb", "\\bold", "\\frak"
	        ],
	        data: {
	            numArgs: 1,
	            handler: function (func, body) {
	                if (func in fontAliases) {
	                    func = fontAliases[func];
	                }
	                return {
	                    type: "font",
	                    font: func.slice(1),
	                    body: body
	                };
	            }
	        }
	    },

	    // Accents
	    {
	        funcs: [
	            "\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve",
	            "\\check", "\\hat", "\\vec", "\\dot"
	            // We don't support expanding accents yet
	            // "\\widetilde", "\\widehat"
	        ],
	        data: {
	            numArgs: 1,
	            handler: function(func, base) {
	                return {
	                    type: "accent",
	                    accent: func,
	                    base: base
	                };
	            }
	        }
	    },

	    // Infix generalized fractions
	    {
	        funcs: ["\\over", "\\choose"],
	        data: {
	            numArgs: 0,
	            handler: function (func) {
	                var replaceWith;
	                switch (func) {
	                    case "\\over":
	                        replaceWith = "\\frac";
	                        break;
	                    case "\\choose":
	                        replaceWith = "\\binom";
	                        break;
	                    default:
	                        throw new Error("Unrecognized infix genfrac command");
	                }
	                return {
	                    type: "infix",
	                    replaceWith: replaceWith
	                };
	            }
	        }
	    },

	    // Row breaks for aligned data
	    {
	        funcs: ["\\\\", "\\cr"],
	        data: {
	            numArgs: 0,
	            numOptionalArgs: 1,
	            argTypes: ["size"],
	            handler: function(func, size) {
	                return {
	                    type: "cr",
	                    size: size
	                };
	            }
	        }
	    },

	    // Environment delimiters
	    {
	        funcs: ["\\begin", "\\end"],
	        data: {
	            numArgs: 1,
	            argTypes: ["text"],
	            handler: function(func, nameGroup, positions) {
	                if (nameGroup.type !== "ordgroup") {
	                    throw new ParseError(
	                        "Invalid environment name",
	                        this.lexer, positions[1]);
	                }
	                var name = "";
	                for (var i = 0; i < nameGroup.value.length; ++i) {
	                    name += nameGroup.value[i].value;
	                }
	                return {
	                    type: "environment",
	                    name: name,
	                    namepos: positions[1]
	                };
	            }
	        }
	    }
	];

	var addFuncsWithData = function(funcs, data) {
	    for (var i = 0; i < funcs.length; i++) {
	        functions[funcs[i]] = data;
	    }
	};

	// Add all of the functions in duplicatedFunctions to the functions map
	for (var i = 0; i < duplicatedFunctions.length; i++) {
	    addFuncsWithData(duplicatedFunctions[i].funcs, duplicatedFunctions[i].data);
	}

	// Set default values of functions
	for (var f in functions) {
	    if (functions.hasOwnProperty(f)) {
	        var func = functions[f];

	        functions[f] = {
	            numArgs: func.numArgs,
	            argTypes: func.argTypes,
	            greediness: (func.greediness === undefined) ? 1 : func.greediness,
	            allowedInText: func.allowedInText ? func.allowedInText : false,
	            numOptionalArgs: (func.numOptionalArgs === undefined) ? 0 :
	                func.numOptionalArgs,
	            handler: func.handler
	        };
	    }
	}

	module.exports = {
	    funcs: functions
	};


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var fontMetrics = __webpack_require__(13);
	var parseData = __webpack_require__(24);
	var ParseError = __webpack_require__(5);

	var ParseNode = parseData.ParseNode;
	var ParseResult = parseData.ParseResult;

	/**
	 * Parse the body of the environment, with rows delimited by \\ and
	 * columns delimited by &, and create a nested list in row-major order
	 * with one group per cell.
	 */
	function parseArray(parser, pos, mode, result) {
	    var row = [], body = [row], rowGaps = [];
	    while (true) {
	        var cell = parser.parseExpression(pos, mode, false, null);
	        row.push(new ParseNode("ordgroup", cell.result, mode));
	        pos = cell.position;
	        var next = cell.peek.text;
	        if (next === "&") {
	            pos = cell.peek.position;
	        } else if (next === "\\end") {
	            break;
	        } else if (next === "\\\\" || next === "\\cr") {
	            var cr = parser.parseFunction(pos, mode);
	            rowGaps.push(cr.result.value.size);
	            pos = cr.position;
	            row = [];
	            body.push(row);
	        } else {
	            throw new ParseError("Expected & or \\\\ or \\end",
	                                 parser.lexer, cell.peek.position);
	        }
	    }
	    result.body = body;
	    result.rowGaps = rowGaps;
	    return new ParseResult(new ParseNode(result.type, result, mode), pos);
	}

	/*
	 * An environment definition is very similar to a function definition.
	 * Each element of the following array may contain
	 *  - names: The names associated with a function. This can be used to
	 *           share one implementation between several similar environments.
	 *  - numArgs: The number of arguments after the \begin{name} function.
	 *  - argTypes: (optional) Just like for a function
	 *  - allowedInText: (optional) Whether or not the environment is allowed inside
	 *                   text mode (default false) (not enforced yet)
	 *  - numOptionalArgs: (optional) Just like for a function
	 *  - handler: The function that is called to handle this environment.
	 *             It will receive the following arguments:
	 *             - pos: the current position of the parser.
	 *             - mode: the current parsing mode.
	 *             - envName: the name of the environment, one of the listed names.
	 *             - [args]: the arguments passed to \begin.
	 *             - positions: the positions associated with these arguments.
	 */

	var environmentDefinitions = [

	    // Arrays are part of LaTeX, defined in lttab.dtx so its documentation
	    // is part of the source2e.pdf file of LaTeX2e source documentation.
	    {
	        names: ["array"],
	        numArgs: 1,
	        handler: function(pos, mode, envName, colalign, positions) {
	            var parser = this;
	            colalign = colalign.value.map ? colalign.value : [colalign];
	            var cols = colalign.map(function(node) {
	                var ca = node.value;
	                if ("lcr".indexOf(ca) !== -1) {
	                    return {
	                        type: "align",
	                        align: ca
	                    };
	                } else if (ca === "|") {
	                    return {
	                        type: "separator",
	                        separator: "|"
	                    };
	                }
	                throw new ParseError(
	                    "Unknown column alignment: " + node.value,
	                    parser.lexer, positions[1]);
	            });
	            var res = {
	                type: "array",
	                cols: cols,
	                hskipBeforeAndAfter: true // \@preamble in lttab.dtx
	            };
	            res = parseArray(parser, pos, mode, res);
	            return res;
	        }
	    },

	    // The matrix environments of amsmath builds on the array environment
	    // of LaTeX, which is discussed above.
	    {
	        names: [
	            "matrix",
	            "pmatrix",
	            "bmatrix",
	            "Bmatrix",
	            "vmatrix",
	            "Vmatrix"
	        ],
	        handler: function(pos, mode, envName) {
	            var delimiters = {
	                "matrix": null,
	                "pmatrix": ["(", ")"],
	                "bmatrix": ["[", "]"],
	                "Bmatrix": ["\\{", "\\}"],
	                "vmatrix": ["|", "|"],
	                "Vmatrix": ["\\Vert", "\\Vert"]
	            }[envName];
	            var res = {
	                type: "array",
	                hskipBeforeAndAfter: false // \hskip -\arraycolsep in amsmath
	            };
	            res = parseArray(this, pos, mode, res);
	            if (delimiters) {
	                res.result = new ParseNode("leftright", {
	                    body: [res.result],
	                    left: delimiters[0],
	                    right: delimiters[1]
	                }, mode);
	            }
	            return res;
	        }
	    },

	    // A cases environment (in amsmath.sty) is almost equivalent to
	    // \def\arraystretch{1.2}%
	    // \left\{\begin{array}{@{}l@{\quad}l@{}} … \end{array}\right.
	    {
	        names: ["cases"],
	        handler: function(pos, mode, envName) {
	            var res = {
	                type: "array",
	                arraystretch: 1.2,
	                cols: [{
	                    type: "align",
	                    align: "l",
	                    pregap: 0,
	                    postgap: fontMetrics.metrics.quad
	                }, {
	                    type: "align",
	                    align: "l",
	                    pregap: 0,
	                    postgap: 0
	                }]
	            };
	            res = parseArray(this, pos, mode, res);
	            res.result = new ParseNode("leftright", {
	                body: [res.result],
	                left: "\\{",
	                right: "."
	            }, mode);
	            return res;
	        }
	    }
	];

	module.exports = (function() {
	    // nested function so we don't leak i and j into the module scope
	    var exports = {};
	    for (var i = 0; i < environmentDefinitions.length; ++i) {
	        var def = environmentDefinitions[i];
	        def.greediness = 1;
	        def.allowedInText = !!def.allowedInText;
	        def.numArgs = def.numArgs || 0;
	        def.numOptionalArgs = def.numOptionalArgs || 0;
	        for (var j = 0; j < def.names.length; ++j) {
	            exports[def.names[j]] = def;
	        }
	    }
	    return exports;
	})();


/***/ },
/* 24 */
/***/ function(module, exports) {

	/**
	 * The resulting parse tree nodes of the parse tree.
	 */
	function ParseNode(type, value, mode) {
	    this.type = type;
	    this.value = value;
	    this.mode = mode;
	}

	/**
	 * A result and final position returned by the `.parse...` functions.
	 * 
	 */
	function ParseResult(result, newPosition, peek) {
	    this.result = result;
	    this.position = newPosition;
	}

	module.exports = {
	    ParseNode: ParseNode,
	    ParseResult: ParseResult
	};



/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * The Lexer class handles tokenizing the input in various ways. Since our
	 * parser expects us to be able to backtrack, the lexer allows lexing from any
	 * given starting point.
	 *
	 * Its main exposed function is the `lex` function, which takes a position to
	 * lex from and a type of token to lex. It defers to the appropriate `_innerLex`
	 * function.
	 *
	 * The various `_innerLex` functions perform the actual lexing of different
	 * kinds.
	 */

	var matchAt = __webpack_require__(26);

	var ParseError = __webpack_require__(5);

	// The main lexer class
	function Lexer(input) {
	    this._input = input;
	}

	// The resulting token returned from `lex`.
	function Token(text, data, position) {
	    this.text = text;
	    this.data = data;
	    this.position = position;
	}

	// "normal" types of tokens. These are tokens which can be matched by a simple
	// regex
	var mathNormals = [
	    /[/|@.""`0-9a-zA-Z]/, // ords
	    /[*+-]/, // bins
	    /[=<>:]/, // rels
	    /[,;]/, // punctuation
	    /['\^_{}]/, // misc
	    /[(\[]/, // opens
	    /[)\]?!]/, // closes
	    /~/, // spacing
	    /&/, // horizontal alignment
	    /\\\\/ // line break
	];

	// These are "normal" tokens like above, but should instead be parsed in text
	// mode.
	var textNormals = [
	    /[a-zA-Z0-9`!@*()-=+\[\]'";:?\/.,]/, // ords
	    /[{}]/, // grouping
	    /~/, // spacing
	    /&/, // horizontal alignment
	    /\\\\/ // line break
	];

	// Regexes for matching whitespace
	var whitespaceRegex = /\s*/;
	var whitespaceConcatRegex = / +|\\  +/;

	// This regex matches any other TeX function, which is a backslash followed by a
	// word or a single symbol
	var anyFunc = /\\(?:[a-zA-Z]+|.)/;

	/**
	 * This function lexes a single normal token. It takes a position, a list of
	 * "normal" tokens to try, and whether it should completely ignore whitespace or
	 * not.
	 */
	Lexer.prototype._innerLex = function(pos, normals, ignoreWhitespace) {
	    var input = this._input;
	    var whitespace;

	    if (ignoreWhitespace) {
	        // Get rid of whitespace.
	        whitespace = matchAt(whitespaceRegex, input, pos)[0];
	        pos += whitespace.length;
	    } else {
	        // Do the funky concatenation of whitespace that happens in text mode.
	        whitespace = matchAt(whitespaceConcatRegex, input, pos);
	        if (whitespace !== null) {
	            return new Token(" ", null, pos + whitespace[0].length);
	        }
	    }

	    // If there's no more input to parse, return an EOF token
	    if (pos === input.length) {
	        return new Token("EOF", null, pos);
	    }

	    var match;
	    if ((match = matchAt(anyFunc, input, pos))) {
	        // If we match a function token, return it
	        return new Token(match[0], null, pos + match[0].length);
	    } else {
	        // Otherwise, we look through the normal token regexes and see if it's
	        // one of them.
	        for (var i = 0; i < normals.length; i++) {
	            var normal = normals[i];

	            if ((match = matchAt(normal, input, pos))) {
	                // If it is, return it
	                return new Token(
	                    match[0], null, pos + match[0].length);
	            }
	        }
	    }

	    throw new ParseError(
	            "Unexpected character: '" + input[pos] + "'",
	            this, pos);
	};

	// A regex to match a CSS color (like #ffffff or BlueViolet)
	var cssColor = /#[a-z0-9]+|[a-z]+/i;

	/**
	 * This function lexes a CSS color.
	 */
	Lexer.prototype._innerLexColor = function(pos) {
	    var input = this._input;

	    // Ignore whitespace
	    var whitespace = matchAt(whitespaceRegex, input, pos)[0];
	    pos += whitespace.length;

	    var match;
	    if ((match = matchAt(cssColor, input, pos))) {
	        // If we look like a color, return a color
	        return new Token(match[0], null, pos + match[0].length);
	    } else {
	        throw new ParseError("Invalid color", this, pos);
	    }
	};

	// A regex to match a dimension. Dimensions look like
	// "1.2em" or ".4pt" or "1 ex"
	var sizeRegex = /(-?)\s*(\d+(?:\.\d*)?|\.\d+)\s*([a-z]{2})/;

	/**
	 * This function lexes a dimension.
	 */
	Lexer.prototype._innerLexSize = function(pos) {
	    var input = this._input;

	    // Ignore whitespace
	    var whitespace = matchAt(whitespaceRegex, input, pos)[0];
	    pos += whitespace.length;

	    var match;
	    if ((match = matchAt(sizeRegex, input, pos))) {
	        var unit = match[3];
	        // We only currently handle "em" and "ex" units
	        if (unit !== "em" && unit !== "ex") {
	            throw new ParseError("Invalid unit: '" + unit + "'", this, pos);
	        }
	        return new Token(match[0], {
	                number: +(match[1] + match[2]),
	                unit: unit
	            }, pos + match[0].length);
	    }

	    throw new ParseError("Invalid size", this, pos);
	};

	/**
	 * This function lexes a string of whitespace.
	 */
	Lexer.prototype._innerLexWhitespace = function(pos) {
	    var input = this._input;

	    var whitespace = matchAt(whitespaceRegex, input, pos)[0];
	    pos += whitespace.length;

	    return new Token(whitespace[0], null, pos);
	};

	/**
	 * This function lexes a single token starting at `pos` and of the given mode.
	 * Based on the mode, we defer to one of the `_innerLex` functions.
	 */
	Lexer.prototype.lex = function(pos, mode) {
	    if (mode === "math") {
	        return this._innerLex(pos, mathNormals, true);
	    } else if (mode === "text") {
	        return this._innerLex(pos, textNormals, false);
	    } else if (mode === "color") {
	        return this._innerLexColor(pos);
	    } else if (mode === "size") {
	        return this._innerLexSize(pos);
	    } else if (mode === "whitespace") {
	        return this._innerLexWhitespace(pos);
	    }
	};

	module.exports = Lexer;


/***/ },
/* 26 */
/***/ function(module, exports) {

	/** @flow */

	"use strict";

	function getRelocatable(re) {
	  // In the future, this could use a WeakMap instead of an expando.
	  if (!re.__matchAtRelocatable) {
	    // Disjunctions are the lowest-precedence operator, so we can make any
	    // pattern match the empty string by appending `|()` to it:
	    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-patterns
	    var source = re.source + "|()";

	    // We always make the new regex global.
	    var flags = "g" + (re.ignoreCase ? "i" : "") + (re.multiline ? "m" : "") + (re.unicode ? "u" : "")
	    // sticky (/.../y) doesn't make sense in conjunction with our relocation
	    // logic, so we ignore it here.
	    ;

	    re.__matchAtRelocatable = new RegExp(source, flags);
	  }
	  return re.__matchAtRelocatable;
	}

	function matchAt(re, str, pos) {
	  if (re.global || re.sticky) {
	    throw new Error("matchAt(...): Only non-global regexes are supported");
	  }
	  var reloc = getRelocatable(re);
	  reloc.lastIndex = pos;
	  var match = reloc.exec(str);
	  // Last capturing group is our sentinel that indicates whether the regex
	  // matched at the given location.
	  if (match[match.length - 1] == null) {
	    // Original regex matched.
	    match.length = match.length - 1;
	    return match;
	  } else {
	    return null;
	  }
	}

	module.exports = matchAt;

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/* Process inline math */
	/*
	Like markdown-it-simplemath, this is a stripped down, simplified version of:
	https://github.com/runarberg/markdown-it-math
	It differs in that it takes (a subset of) LaTeX as input and relies on KaTeX
	for rendering output.
	*/

	'use strict';

	var katex = __webpack_require__(4);


	function scanDelims(state, start, delimLength) {
	  var pos = start, lastChar, nextChar, count, can_open, can_close,
	      isLastWhiteSpace, isLastPunctChar,
	      isNextWhiteSpace, isNextPunctChar,
	      left_flanking = true,
	      right_flanking = true,
	      max = state.posMax,
	      isWhiteSpace = state.md.utils.isWhiteSpace,
	      isPunctChar = state.md.utils.isPunctChar,
	      isMdAsciiPunct = state.md.utils.isMdAsciiPunct;

	  // treat beginning of the line as a whitespace
	  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : 0x20;

	  if (pos >= max) {
	    can_open = false;
	  }

	  pos += delimLength;

	  count = pos - start;

	  // treat end of the line as a whitespace
	  nextChar = pos < max ? state.src.charCodeAt(pos) : 0x20;

	  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
	  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

	  isLastWhiteSpace = isWhiteSpace(lastChar);
	  isNextWhiteSpace = isWhiteSpace(nextChar);

	  if (isNextWhiteSpace) {
	    left_flanking = false;
	  } else if (isNextPunctChar) {
	    if (!(isLastWhiteSpace || isLastPunctChar)) {
	      left_flanking = false;
	    }
	  }

	  if (isLastWhiteSpace) {
	    right_flanking = false;
	  } else if (isLastPunctChar) {
	    if (!(isNextWhiteSpace || isNextPunctChar)) {
	      right_flanking = false;
	    }
	  }

	  can_open = left_flanking;
	  can_close = right_flanking;

	  return {
	    can_open: can_open,
	    can_close: can_close,
	    delims: count
	  };
	}


	function makeMath_inline(open, close) {
	  return function math_inline(state, silent) {
	    console.log(state, silent)
	    var startCount,
	        found,
	        res,
	        token,
	        closeDelim,
	        max = state.posMax,
	        start = state.pos,
	        openDelim = state.src.slice(start, start + open.length);

	    if (openDelim !== open) { return false; }
	    if (silent) { return false; }    // Don’t run any pairs in validation mode

	    res = scanDelims(state, start, openDelim.length);
	    startCount = res.delims;

	    if (!res.can_open) {
	      state.pos += startCount;
	      // Earlier we checked !silent, but this implementation does not need it
	      state.pending += state.src.slice(start, state.pos);
	      return true;
	    }

	    state.pos = start + open.length;

	    while (state.pos < max) {
	      closeDelim = state.src.slice(state.pos, state.pos + close.length);
	      if (closeDelim === close) {
	        res = scanDelims(state, state.pos, close.length);
	        if (res.can_close) {
	          found = true;
	          break;
	        }
	      }

	      state.md.inline.skipToken(state);
	    }

	    if (!found) {
	      // Parser failed to find ending tag, so it is not a valid math
	      state.pos = start;
	      return false;
	    }

	    // Found!
	    state.posMax = state.pos;
	    state.pos = start + close.length;

	    // Earlier we checked !silent, but this implementation does not need it
	    token = state.push('math_inline', 'math', 0);
	    token.content = state.src.slice(state.pos, state.posMax);
	    token.markup = open;

	    state.pos = state.posMax + close.length;
	    state.posMax = max;

	    return true;
	  };
	}

	function makeMath_block(open, close) {
	  return function math_block(state, startLine, endLine, silent) {
	    var openDelim, len, params, nextLine, token, firstLine, lastLine, lastLinePos,
	        haveEndMarker = false,
	        pos = state.bMarks[startLine] + state.tShift[startLine],
	        max = state.eMarks[startLine];

	    if (pos + open.length > max) { return false; }

	    openDelim = state.src.slice(pos, pos + open.length);

	    if (openDelim !== open) { return false; }

	    pos += open.length;
	    firstLine = state.src.slice(pos, max);

	    // Since start is found, we can report success here in validation mode
	    if (silent) { return true; }

	    if (firstLine.trim().slice(-close.length) === close) {
	      // Single line expression
	      firstLine = firstLine.trim().slice(0, -close.length);
	      haveEndMarker = true;
	    }

	    // search end of block
	    nextLine = startLine;

	    for (;;) {
	      if (haveEndMarker) { break; }

	      nextLine++;

	      if (nextLine >= endLine) {
	        // unclosed block should be autoclosed by end of document.
	        // also block seems to be autoclosed by end of parent
	        break;
	      }

	      pos = state.bMarks[nextLine] + state.tShift[nextLine];
	      max = state.eMarks[nextLine];

	      if (pos < max && state.tShift[nextLine] < state.blkIndent) {
	        // non-empty line with negative indent should stop the list:
	        break;
	      }

	      if (state.src.slice(pos, max).trim().slice(-close.length) !== close) {
	        continue;
	      }

	      if (state.tShift[nextLine] - state.blkIndent >= 4) {
	        // closing block math should be indented less then 4 spaces
	        continue;
	      }

	      lastLinePos = state.src.slice(0, max).lastIndexOf(close);
	      lastLine = state.src.slice(pos, lastLinePos);

	      pos += lastLine.length + close.length;

	      // make sure tail has spaces only
	      pos = state.skipSpaces(pos);

	      if (pos < max) { continue; }

	      // found!
	      haveEndMarker = true;
	    }

	    // If math block has heading spaces, they should be removed from its inner block
	    len = state.tShift[startLine];

	    state.line = nextLine + (haveEndMarker ? 1 : 0);

	    token = state.push('math_block', 'math', 0);
	    token.block = true;
	    token.content = (firstLine && firstLine.trim() ? firstLine + '\n' : '') +
	      state.getLines(startLine + 1, nextLine, len, true) +
	      (lastLine && lastLine.trim() ? lastLine : '');
	    token.info = params;
	    token.map = [ startLine, state.line ];
	    token.markup = open;

	    return true;
	  };
	}


	module.exports = function math_plugin(md, options) {
	  // Default options

	  var inlineOpen = '$',
	      inlineClose = '$',
	      blockOpen = '$$',
	      blockClose = '$$';

	  options = options || {};

	  // set KaTeX as the renderer for markdown-it-simplemath
	  var katexInline = function(latex){
	    options.displayMode = false;
	    console.log(latex)
	    return katex.renderToString(latex, options);
	  };

	  var inlineRenderer = function(tokens, idx){
	    return katexInline(tokens[idx].content);
	  };

	  var katexBlock = function(latex){
	    options.displayMode = true;
	    return katex.renderToString(latex, options);
	  }

	  var blockRenderer = function(tokens, idx){
	    return  katexBlock(tokens[idx].content) + '\n';
	  }

	  var math_inline = makeMath_inline(inlineOpen, inlineClose);
	  var math_block = makeMath_block(blockOpen, blockClose);

	  md.inline.ruler.before('escape', 'math_inline', math_inline);
	  md.block.ruler.after('blockquote', 'math_block', math_block, {
	    alt: [ 'paragraph', 'reference', 'blockquote', 'list' ]
	  });
	  md.renderer.rules.math_inline = inlineRenderer;
	  md.renderer.rules.math_block = blockRenderer;
	};

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	module.exports = __webpack_require__(29);


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	// Main perser class

	'use strict';


	var utils        = __webpack_require__(30);
	var helpers      = __webpack_require__(44);
	var Renderer     = __webpack_require__(48);
	var ParserCore   = __webpack_require__(49);
	var ParserBlock  = __webpack_require__(59);
	var ParserInline = __webpack_require__(74);
	var LinkifyIt    = __webpack_require__(88);
	var mdurl        = __webpack_require__(34);
	var punycode     = __webpack_require__(90);


	var config = {
	  'default': __webpack_require__(92),
	  zero: __webpack_require__(93),
	  commonmark: __webpack_require__(94)
	};

	////////////////////////////////////////////////////////////////////////////////
	//
	// This validator can prohibit more than really needed to prevent XSS. It's a
	// tradeoff to keep code simple and to be secure by default.
	//
	// If you need different setup - override validator method as you wish. Or
	// replace it with dummy function and use external sanitizer.
	//

	var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
	var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;

	function validateLink(url) {
	  // url should be normalized at this point, and existing entities are decoded
	  var str = url.trim().toLowerCase();

	  return BAD_PROTO_RE.test(str) ? (GOOD_DATA_RE.test(str) ? true : false) : true;
	}

	////////////////////////////////////////////////////////////////////////////////


	var RECODE_HOSTNAME_FOR = [ 'http:', 'https:', 'mailto:' ];

	function normalizeLink(url) {
	  var parsed = mdurl.parse(url, true);

	  if (parsed.hostname) {
	    // Encode hostnames in urls like:
	    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
	    //
	    // We don't encode unknown schemas, because it's likely that we encode
	    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
	    //
	    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
	      try {
	        parsed.hostname = punycode.toASCII(parsed.hostname);
	      } catch(er) {}
	    }
	  }

	  return mdurl.encode(mdurl.format(parsed));
	}

	function normalizeLinkText(url) {
	  var parsed = mdurl.parse(url, true);

	  if (parsed.hostname) {
	    // Encode hostnames in urls like:
	    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
	    //
	    // We don't encode unknown schemas, because it's likely that we encode
	    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
	    //
	    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
	      try {
	        parsed.hostname = punycode.toUnicode(parsed.hostname);
	      } catch(er) {}
	    }
	  }

	  return mdurl.decode(mdurl.format(parsed));
	}


	/**
	 * class MarkdownIt
	 *
	 * Main parser/renderer class.
	 *
	 * ##### Usage
	 *
	 * ```javascript
	 * // node.js, "classic" way:
	 * var MarkdownIt = require('markdown-it'),
	 *     md = new MarkdownIt();
	 * var result = md.render('# markdown-it rulezz!');
	 *
	 * // node.js, the same, but with sugar:
	 * var md = require('markdown-it')();
	 * var result = md.render('# markdown-it rulezz!');
	 *
	 * // browser without AMD, added to "window" on script load
	 * // Note, there are no dash.
	 * var md = window.markdownit();
	 * var result = md.render('# markdown-it rulezz!');
	 * ```
	 *
	 * Single line rendering, without paragraph wrap:
	 *
	 * ```javascript
	 * var md = require('markdown-it')();
	 * var result = md.renderInline('__markdown-it__ rulezz!');
	 * ```
	 **/

	/**
	 * new MarkdownIt([presetName, options])
	 * - presetName (String): optional, `commonmark` / `zero`
	 * - options (Object)
	 *
	 * Creates parser instanse with given config. Can be called without `new`.
	 *
	 * ##### presetName
	 *
	 * MarkdownIt provides named presets as a convenience to quickly
	 * enable/disable active syntax rules and options for common use cases.
	 *
	 * - ["commonmark"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -
	 *   configures parser to strict [CommonMark](http://commonmark.org/) mode.
	 * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -
	 *   similar to GFM, used when no preset name given. Enables all available rules,
	 *   but still without html, typographer & autolinker.
	 * - ["zero"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -
	 *   all rules disabled. Useful to quickly setup your config via `.enable()`.
	 *   For example, when you need only `bold` and `italic` markup and nothing else.
	 *
	 * ##### options:
	 *
	 * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!
	 *   That's not safe! You may need external sanitizer to protect output from XSS.
	 *   It's better to extend features via plugins, instead of enabling HTML.
	 * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags
	 *   (`<br />`). This is needed only for full CommonMark compatibility. In real
	 *   world you will need HTML output.
	 * - __breaks__ - `false`. Set `true` to convert `\n` in paragraphs into `<br>`.
	 * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.
	 *   Can be useful for external highlighters.
	 * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.
	 * - __typographer__  - `false`. Set `true` to enable [some language-neutral
	 *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +
	 *   quotes beautification (smartquotes).
	 * - __quotes__ - `“”‘’`, String or Array. Double + single quotes replacement
	 *   pairs, when typographer enabled and smartquotes on. For example, you can
	 *   use `'«»„“'` for Russian, `'„“‚‘'` for German, and
	 *   `['«\xA0', '\xA0»', '‹\xA0', '\xA0›']` for French (including nbsp).
	 * - __highlight__ - `null`. Highlighter function for fenced code blocks.
	 *   Highlighter `function (str, lang)` should return escaped HTML. It can also
	 *   return empty string if the source was not changed and should be escaped externaly.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * // commonmark mode
	 * var md = require('markdown-it')('commonmark');
	 *
	 * // default mode
	 * var md = require('markdown-it')();
	 *
	 * // enable everything
	 * var md = require('markdown-it')({
	 *   html: true,
	 *   linkify: true,
	 *   typographer: true
	 * });
	 * ```
	 *
	 * ##### Syntax highlighting
	 *
	 * ```js
	 * var hljs = require('highlight.js') // https://highlightjs.org/
	 *
	 * var md = require('markdown-it')({
	 *   highlight: function (str, lang) {
	 *     if (lang && hljs.getLanguage(lang)) {
	 *       try {
	 *         return hljs.highlight(lang, str).value;
	 *       } catch (__) {}
	 *     }
	 *
	 *     try {
	 *       return hljs.highlightAuto(str).value;
	 *     } catch (__) {}
	 *
	 *     return ''; // use external default escaping
	 *   }
	 * });
	 * ```
	 **/
	function MarkdownIt(presetName, options) {
	  if (!(this instanceof MarkdownIt)) {
	    return new MarkdownIt(presetName, options);
	  }

	  if (!options) {
	    if (!utils.isString(presetName)) {
	      options = presetName || {};
	      presetName = 'default';
	    }
	  }

	  /**
	   * MarkdownIt#inline -> ParserInline
	   *
	   * Instance of [[ParserInline]]. You may need it to add new rules when
	   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
	   * [[MarkdownIt.enable]].
	   **/
	  this.inline = new ParserInline();

	  /**
	   * MarkdownIt#block -> ParserBlock
	   *
	   * Instance of [[ParserBlock]]. You may need it to add new rules when
	   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
	   * [[MarkdownIt.enable]].
	   **/
	  this.block = new ParserBlock();

	  /**
	   * MarkdownIt#core -> Core
	   *
	   * Instance of [[Core]] chain executor. You may need it to add new rules when
	   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
	   * [[MarkdownIt.enable]].
	   **/
	  this.core = new ParserCore();

	  /**
	   * MarkdownIt#renderer -> Renderer
	   *
	   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering
	   * rules for new token types, generated by plugins.
	   *
	   * ##### Example
	   *
	   * ```javascript
	   * var md = require('markdown-it')();
	   *
	   * function myToken(tokens, idx, options, env, self) {
	   *   //...
	   *   return result;
	   * };
	   *
	   * md.renderer.rules['my_token'] = myToken
	   * ```
	   *
	   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).
	   **/
	  this.renderer = new Renderer();

	  /**
	   * MarkdownIt#linkify -> LinkifyIt
	   *
	   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.
	   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)
	   * rule.
	   **/
	  this.linkify = new LinkifyIt();

	  /**
	   * MarkdownIt#validateLink(url) -> Boolean
	   *
	   * Link validation function. CommonMark allows too much in links. By default
	   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas
	   * except some embedded image types.
	   *
	   * You can change this behaviour:
	   *
	   * ```javascript
	   * var md = require('markdown-it')();
	   * // enable everything
	   * md.validateLink = function () { return true; }
	   * ```
	   **/
	  this.validateLink = validateLink;

	  /**
	   * MarkdownIt#normalizeLink(url) -> String
	   *
	   * Function used to encode link url to a machine-readable format,
	   * which includes url-encoding, punycode, etc.
	   **/
	  this.normalizeLink = normalizeLink;

	  /**
	   * MarkdownIt#normalizeLinkText(url) -> String
	   *
	   * Function used to decode link url to a human-readable format`
	   **/
	  this.normalizeLinkText = normalizeLinkText;


	  // Expose utils & helpers for easy acces from plugins

	  /**
	   * MarkdownIt#utils -> utils
	   *
	   * Assorted utility functions, useful to write plugins. See details
	   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).
	   **/
	  this.utils = utils;

	  /**
	   * MarkdownIt#helpers -> helpers
	   *
	   * Link components parser functions, useful to write plugins. See details
	   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).
	   **/
	  this.helpers = helpers;


	  this.options = {};
	  this.configure(presetName);

	  if (options) { this.set(options); }
	}


	/** chainable
	 * MarkdownIt.set(options)
	 *
	 * Set parser options (in the same format as in constructor). Probably, you
	 * will never need it, but you can change options after constructor call.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * var md = require('markdown-it')()
	 *             .set({ html: true, breaks: true })
	 *             .set({ typographer, true });
	 * ```
	 *
	 * __Note:__ To achieve the best possible performance, don't modify a
	 * `markdown-it` instance options on the fly. If you need multiple configurations
	 * it's best to create multiple instances and initialize each with separate
	 * config.
	 **/
	MarkdownIt.prototype.set = function (options) {
	  utils.assign(this.options, options);
	  return this;
	};


	/** chainable, internal
	 * MarkdownIt.configure(presets)
	 *
	 * Batch load of all options and compenent settings. This is internal method,
	 * and you probably will not need it. But if you with - see available presets
	 * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)
	 *
	 * We strongly recommend to use presets instead of direct config loads. That
	 * will give better compatibility with next versions.
	 **/
	MarkdownIt.prototype.configure = function (presets) {
	  var self = this, presetName;

	  if (utils.isString(presets)) {
	    presetName = presets;
	    presets = config[presetName];
	    if (!presets) { throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name'); }
	  }

	  if (!presets) { throw new Error('Wrong `markdown-it` preset, can\'t be empty'); }

	  if (presets.options) { self.set(presets.options); }

	  if (presets.components) {
	    Object.keys(presets.components).forEach(function (name) {
	      if (presets.components[name].rules) {
	        self[name].ruler.enableOnly(presets.components[name].rules);
	      }
	    });
	  }
	  return this;
	};


	/** chainable
	 * MarkdownIt.enable(list, ignoreInvalid)
	 * - list (String|Array): rule name or list of rule names to enable
	 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
	 *
	 * Enable list or rules. It will automatically find appropriate components,
	 * containing rules with given names. If rule not found, and `ignoreInvalid`
	 * not set - throws exception.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * var md = require('markdown-it')()
	 *             .enable(['sub', 'sup'])
	 *             .disable('smartquotes');
	 * ```
	 **/
	MarkdownIt.prototype.enable = function (list, ignoreInvalid) {
	  var result = [];

	  if (!Array.isArray(list)) { list = [ list ]; }

	  [ 'core', 'block', 'inline' ].forEach(function (chain) {
	    result = result.concat(this[chain].ruler.enable(list, true));
	  }, this);

	  var missed = list.filter(function (name) { return result.indexOf(name) < 0; });

	  if (missed.length && !ignoreInvalid) {
	    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);
	  }

	  return this;
	};


	/** chainable
	 * MarkdownIt.disable(list, ignoreInvalid)
	 * - list (String|Array): rule name or list of rule names to disable.
	 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
	 *
	 * The same as [[MarkdownIt.enable]], but turn specified rules off.
	 **/
	MarkdownIt.prototype.disable = function (list, ignoreInvalid) {
	  var result = [];

	  if (!Array.isArray(list)) { list = [ list ]; }

	  [ 'core', 'block', 'inline' ].forEach(function (chain) {
	    result = result.concat(this[chain].ruler.disable(list, true));
	  }, this);

	  var missed = list.filter(function (name) { return result.indexOf(name) < 0; });

	  if (missed.length && !ignoreInvalid) {
	    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);
	  }
	  return this;
	};


	/** chainable
	 * MarkdownIt.use(plugin, params)
	 *
	 * Load specified plugin with given params into current parser instance.
	 * It's just a sugar to call `plugin(md, params)` with curring.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * var iterator = require('markdown-it-for-inline');
	 * var md = require('markdown-it')()
	 *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {
	 *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');
	 *             });
	 * ```
	 **/
	MarkdownIt.prototype.use = function (plugin /*, params, ... */) {
	  var args = [ this ].concat(Array.prototype.slice.call(arguments, 1));
	  plugin.apply(plugin, args);
	  return this;
	};


	/** internal
	 * MarkdownIt.parse(src, env) -> Array
	 * - src (String): source string
	 * - env (Object): environment sandbox
	 *
	 * Parse input string and returns list of block tokens (special token type
	 * "inline" will contain list of inline tokens). You should not call this
	 * method directly, until you write custom renderer (for example, to produce
	 * AST).
	 *
	 * `env` is used to pass data between "distributed" rules and return additional
	 * metadata like reference info, needed for for renderer. It also can be used to
	 * inject data in specific cases. Usually, you will be ok to pass `{}`,
	 * and then pass updated object to renderer.
	 **/
	MarkdownIt.prototype.parse = function (src, env) {
	  var state = new this.core.State(src, this, env);

	  this.core.process(state);

	  return state.tokens;
	};


	/**
	 * MarkdownIt.render(src [, env]) -> String
	 * - src (String): source string
	 * - env (Object): environment sandbox
	 *
	 * Render markdown string into html. It does all magic for you :).
	 *
	 * `env` can be used to inject additional metadata (`{}` by default).
	 * But you will not need it with high probability. See also comment
	 * in [[MarkdownIt.parse]].
	 **/
	MarkdownIt.prototype.render = function (src, env) {
	  env = env || {};

	  return this.renderer.render(this.parse(src, env), this.options, env);
	};


	/** internal
	 * MarkdownIt.parseInline(src, env) -> Array
	 * - src (String): source string
	 * - env (Object): environment sandbox
	 *
	 * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the
	 * block tokens list with the single `inline` element, containing parsed inline
	 * tokens in `children` property. Also updates `env` object.
	 **/
	MarkdownIt.prototype.parseInline = function (src, env) {
	  var state = new this.core.State(src, this, env);

	  state.inlineMode = true;
	  this.core.process(state);

	  return state.tokens;
	};


	/**
	 * MarkdownIt.renderInline(src [, env]) -> String
	 * - src (String): source string
	 * - env (Object): environment sandbox
	 *
	 * Similar to [[MarkdownIt.render]] but for single paragraph content. Result
	 * will NOT be wrapped into `<p>` tags.
	 **/
	MarkdownIt.prototype.renderInline = function (src, env) {
	  env = env || {};

	  return this.renderer.render(this.parseInline(src, env), this.options, env);
	};


	module.exports = MarkdownIt;


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	// Utilities
	//
	'use strict';


	function _class(obj) { return Object.prototype.toString.call(obj); }

	function isString(obj) { return _class(obj) === '[object String]'; }

	var _hasOwnProperty = Object.prototype.hasOwnProperty;

	function has(object, key) {
	  return _hasOwnProperty.call(object, key);
	}

	// Merge objects
	//
	function assign(obj /*from1, from2, from3, ...*/) {
	  var sources = Array.prototype.slice.call(arguments, 1);

	  sources.forEach(function (source) {
	    if (!source) { return; }

	    if (typeof source !== 'object') {
	      throw new TypeError(source + 'must be object');
	    }

	    Object.keys(source).forEach(function (key) {
	      obj[key] = source[key];
	    });
	  });

	  return obj;
	}

	// Remove element from array and put another array at those position.
	// Useful for some operations with tokens
	function arrayReplaceAt(src, pos, newElements) {
	  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
	}

	////////////////////////////////////////////////////////////////////////////////

	function isValidEntityCode(c) {
	  /*eslint no-bitwise:0*/
	  // broken sequence
	  if (c >= 0xD800 && c <= 0xDFFF) { return false; }
	  // never used
	  if (c >= 0xFDD0 && c <= 0xFDEF) { return false; }
	  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) { return false; }
	  // control codes
	  if (c >= 0x00 && c <= 0x08) { return false; }
	  if (c === 0x0B) { return false; }
	  if (c >= 0x0E && c <= 0x1F) { return false; }
	  if (c >= 0x7F && c <= 0x9F) { return false; }
	  // out of range
	  if (c > 0x10FFFF) { return false; }
	  return true;
	}

	function fromCodePoint(c) {
	  /*eslint no-bitwise:0*/
	  if (c > 0xffff) {
	    c -= 0x10000;
	    var surrogate1 = 0xd800 + (c >> 10),
	        surrogate2 = 0xdc00 + (c & 0x3ff);

	    return String.fromCharCode(surrogate1, surrogate2);
	  }
	  return String.fromCharCode(c);
	}


	var UNESCAPE_MD_RE  = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
	var ENTITY_RE       = /&([a-z#][a-z0-9]{1,31});/gi;
	var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');

	var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;

	var entities = __webpack_require__(31);

	function replaceEntityPattern(match, name) {
	  var code = 0;

	  if (has(entities, name)) {
	    return entities[name];
	  }

	  if (name.charCodeAt(0) === 0x23/* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {
	    code = name[1].toLowerCase() === 'x' ?
	      parseInt(name.slice(2), 16)
	    :
	      parseInt(name.slice(1), 10);
	    if (isValidEntityCode(code)) {
	      return fromCodePoint(code);
	    }
	  }

	  return match;
	}

	/*function replaceEntities(str) {
	  if (str.indexOf('&') < 0) { return str; }

	  return str.replace(ENTITY_RE, replaceEntityPattern);
	}*/

	function unescapeMd(str) {
	  if (str.indexOf('\\') < 0) { return str; }
	  return str.replace(UNESCAPE_MD_RE, '$1');
	}

	function unescapeAll(str) {
	  if (str.indexOf('\\') < 0 && str.indexOf('&') < 0) { return str; }

	  return str.replace(UNESCAPE_ALL_RE, function(match, escaped, entity) {
	    if (escaped) { return escaped; }
	    return replaceEntityPattern(match, entity);
	  });
	}

	////////////////////////////////////////////////////////////////////////////////

	var HTML_ESCAPE_TEST_RE = /[&<>"]/;
	var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
	var HTML_REPLACEMENTS = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;'
	};

	function replaceUnsafeChar(ch) {
	  return HTML_REPLACEMENTS[ch];
	}

	function escapeHtml(str) {
	  if (HTML_ESCAPE_TEST_RE.test(str)) {
	    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
	  }
	  return str;
	}

	////////////////////////////////////////////////////////////////////////////////

	var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;

	function escapeRE (str) {
	  return str.replace(REGEXP_ESCAPE_RE, '\\$&');
	}

	////////////////////////////////////////////////////////////////////////////////

	// Zs (unicode class) || [\t\f\v\r\n]
	function isWhiteSpace(code) {
	  if (code >= 0x2000 && code <= 0x200A) { return true; }
	  switch (code) {
	    case 0x09: // \t
	    case 0x0A: // \n
	    case 0x0B: // \v
	    case 0x0C: // \f
	    case 0x0D: // \r
	    case 0x20:
	    case 0xA0:
	    case 0x1680:
	    case 0x202F:
	    case 0x205F:
	    case 0x3000:
	      return true;
	  }
	  return false;
	}

	////////////////////////////////////////////////////////////////////////////////

	/*eslint-disable max-len*/
	var UNICODE_PUNCT_RE = __webpack_require__(33);

	// Currently without astral characters support.
	function isPunctChar(char) {
	  return UNICODE_PUNCT_RE.test(char);
	}


	// Markdown ASCII punctuation characters.
	//
	// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
	// http://spec.commonmark.org/0.15/#ascii-punctuation-character
	//
	// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.
	//
	function isMdAsciiPunct(ch) {
	  switch (ch) {
	    case 0x21/* ! */:
	    case 0x22/* " */:
	    case 0x23/* # */:
	    case 0x24/* $ */:
	    case 0x25/* % */:
	    case 0x26/* & */:
	    case 0x27/* ' */:
	    case 0x28/* ( */:
	    case 0x29/* ) */:
	    case 0x2A/* * */:
	    case 0x2B/* + */:
	    case 0x2C/* , */:
	    case 0x2D/* - */:
	    case 0x2E/* . */:
	    case 0x2F/* / */:
	    case 0x3A/* : */:
	    case 0x3B/* ; */:
	    case 0x3C/* < */:
	    case 0x3D/* = */:
	    case 0x3E/* > */:
	    case 0x3F/* ? */:
	    case 0x40/* @ */:
	    case 0x5B/* [ */:
	    case 0x5C/* \ */:
	    case 0x5D/* ] */:
	    case 0x5E/* ^ */:
	    case 0x5F/* _ */:
	    case 0x60/* ` */:
	    case 0x7B/* { */:
	    case 0x7C/* | */:
	    case 0x7D/* } */:
	    case 0x7E/* ~ */:
	      return true;
	    default:
	      return false;
	  }
	}

	// Hepler to unify [reference labels].
	//
	function normalizeReference(str) {
	  // use .toUpperCase() instead of .toLowerCase()
	  // here to avoid a conflict with Object.prototype
	  // members (most notably, `__proto__`)
	  return str.trim().replace(/\s+/g, ' ').toUpperCase();
	}

	////////////////////////////////////////////////////////////////////////////////

	// Re-export libraries commonly used in both markdown-it and its plugins,
	// so plugins won't have to depend on them explicitly, which reduces their
	// bundled size (e.g. a browser build).
	//
	exports.lib                 = {};
	exports.lib.mdurl           = __webpack_require__(34);
	exports.lib.ucmicro         = __webpack_require__(39);

	exports.assign              = assign;
	exports.isString            = isString;
	exports.has                 = has;
	exports.unescapeMd          = unescapeMd;
	exports.unescapeAll         = unescapeAll;
	exports.isValidEntityCode   = isValidEntityCode;
	exports.fromCodePoint       = fromCodePoint;
	// exports.replaceEntities     = replaceEntities;
	exports.escapeHtml          = escapeHtml;
	exports.arrayReplaceAt      = arrayReplaceAt;
	exports.isWhiteSpace        = isWhiteSpace;
	exports.isMdAsciiPunct      = isMdAsciiPunct;
	exports.isPunctChar         = isPunctChar;
	exports.escapeRE            = escapeRE;
	exports.normalizeReference  = normalizeReference;


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	// HTML5 entities map: { name -> utf16string }
	//
	'use strict';

	/*eslint quotes:0*/
	module.exports = __webpack_require__(32);


/***/ },
/* 32 */
/***/ function(module, exports) {

	module.exports = {
		"Aacute": "Á",
		"aacute": "á",
		"Abreve": "Ă",
		"abreve": "ă",
		"ac": "∾",
		"acd": "∿",
		"acE": "∾̳",
		"Acirc": "Â",
		"acirc": "â",
		"acute": "´",
		"Acy": "А",
		"acy": "а",
		"AElig": "Æ",
		"aelig": "æ",
		"af": "⁡",
		"Afr": "𝔄",
		"afr": "𝔞",
		"Agrave": "À",
		"agrave": "à",
		"alefsym": "ℵ",
		"aleph": "ℵ",
		"Alpha": "Α",
		"alpha": "α",
		"Amacr": "Ā",
		"amacr": "ā",
		"amalg": "⨿",
		"amp": "&",
		"AMP": "&",
		"andand": "⩕",
		"And": "⩓",
		"and": "∧",
		"andd": "⩜",
		"andslope": "⩘",
		"andv": "⩚",
		"ang": "∠",
		"ange": "⦤",
		"angle": "∠",
		"angmsdaa": "⦨",
		"angmsdab": "⦩",
		"angmsdac": "⦪",
		"angmsdad": "⦫",
		"angmsdae": "⦬",
		"angmsdaf": "⦭",
		"angmsdag": "⦮",
		"angmsdah": "⦯",
		"angmsd": "∡",
		"angrt": "∟",
		"angrtvb": "⊾",
		"angrtvbd": "⦝",
		"angsph": "∢",
		"angst": "Å",
		"angzarr": "⍼",
		"Aogon": "Ą",
		"aogon": "ą",
		"Aopf": "𝔸",
		"aopf": "𝕒",
		"apacir": "⩯",
		"ap": "≈",
		"apE": "⩰",
		"ape": "≊",
		"apid": "≋",
		"apos": "'",
		"ApplyFunction": "⁡",
		"approx": "≈",
		"approxeq": "≊",
		"Aring": "Å",
		"aring": "å",
		"Ascr": "𝒜",
		"ascr": "𝒶",
		"Assign": "≔",
		"ast": "*",
		"asymp": "≈",
		"asympeq": "≍",
		"Atilde": "Ã",
		"atilde": "ã",
		"Auml": "Ä",
		"auml": "ä",
		"awconint": "∳",
		"awint": "⨑",
		"backcong": "≌",
		"backepsilon": "϶",
		"backprime": "‵",
		"backsim": "∽",
		"backsimeq": "⋍",
		"Backslash": "∖",
		"Barv": "⫧",
		"barvee": "⊽",
		"barwed": "⌅",
		"Barwed": "⌆",
		"barwedge": "⌅",
		"bbrk": "⎵",
		"bbrktbrk": "⎶",
		"bcong": "≌",
		"Bcy": "Б",
		"bcy": "б",
		"bdquo": "„",
		"becaus": "∵",
		"because": "∵",
		"Because": "∵",
		"bemptyv": "⦰",
		"bepsi": "϶",
		"bernou": "ℬ",
		"Bernoullis": "ℬ",
		"Beta": "Β",
		"beta": "β",
		"beth": "ℶ",
		"between": "≬",
		"Bfr": "𝔅",
		"bfr": "𝔟",
		"bigcap": "⋂",
		"bigcirc": "◯",
		"bigcup": "⋃",
		"bigodot": "⨀",
		"bigoplus": "⨁",
		"bigotimes": "⨂",
		"bigsqcup": "⨆",
		"bigstar": "★",
		"bigtriangledown": "▽",
		"bigtriangleup": "△",
		"biguplus": "⨄",
		"bigvee": "⋁",
		"bigwedge": "⋀",
		"bkarow": "⤍",
		"blacklozenge": "⧫",
		"blacksquare": "▪",
		"blacktriangle": "▴",
		"blacktriangledown": "▾",
		"blacktriangleleft": "◂",
		"blacktriangleright": "▸",
		"blank": "␣",
		"blk12": "▒",
		"blk14": "░",
		"blk34": "▓",
		"block": "█",
		"bne": "=⃥",
		"bnequiv": "≡⃥",
		"bNot": "⫭",
		"bnot": "⌐",
		"Bopf": "𝔹",
		"bopf": "𝕓",
		"bot": "⊥",
		"bottom": "⊥",
		"bowtie": "⋈",
		"boxbox": "⧉",
		"boxdl": "┐",
		"boxdL": "╕",
		"boxDl": "╖",
		"boxDL": "╗",
		"boxdr": "┌",
		"boxdR": "╒",
		"boxDr": "╓",
		"boxDR": "╔",
		"boxh": "─",
		"boxH": "═",
		"boxhd": "┬",
		"boxHd": "╤",
		"boxhD": "╥",
		"boxHD": "╦",
		"boxhu": "┴",
		"boxHu": "╧",
		"boxhU": "╨",
		"boxHU": "╩",
		"boxminus": "⊟",
		"boxplus": "⊞",
		"boxtimes": "⊠",
		"boxul": "┘",
		"boxuL": "╛",
		"boxUl": "╜",
		"boxUL": "╝",
		"boxur": "└",
		"boxuR": "╘",
		"boxUr": "╙",
		"boxUR": "╚",
		"boxv": "│",
		"boxV": "║",
		"boxvh": "┼",
		"boxvH": "╪",
		"boxVh": "╫",
		"boxVH": "╬",
		"boxvl": "┤",
		"boxvL": "╡",
		"boxVl": "╢",
		"boxVL": "╣",
		"boxvr": "├",
		"boxvR": "╞",
		"boxVr": "╟",
		"boxVR": "╠",
		"bprime": "‵",
		"breve": "˘",
		"Breve": "˘",
		"brvbar": "¦",
		"bscr": "𝒷",
		"Bscr": "ℬ",
		"bsemi": "⁏",
		"bsim": "∽",
		"bsime": "⋍",
		"bsolb": "⧅",
		"bsol": "\\",
		"bsolhsub": "⟈",
		"bull": "•",
		"bullet": "•",
		"bump": "≎",
		"bumpE": "⪮",
		"bumpe": "≏",
		"Bumpeq": "≎",
		"bumpeq": "≏",
		"Cacute": "Ć",
		"cacute": "ć",
		"capand": "⩄",
		"capbrcup": "⩉",
		"capcap": "⩋",
		"cap": "∩",
		"Cap": "⋒",
		"capcup": "⩇",
		"capdot": "⩀",
		"CapitalDifferentialD": "ⅅ",
		"caps": "∩︀",
		"caret": "⁁",
		"caron": "ˇ",
		"Cayleys": "ℭ",
		"ccaps": "⩍",
		"Ccaron": "Č",
		"ccaron": "č",
		"Ccedil": "Ç",
		"ccedil": "ç",
		"Ccirc": "Ĉ",
		"ccirc": "ĉ",
		"Cconint": "∰",
		"ccups": "⩌",
		"ccupssm": "⩐",
		"Cdot": "Ċ",
		"cdot": "ċ",
		"cedil": "¸",
		"Cedilla": "¸",
		"cemptyv": "⦲",
		"cent": "¢",
		"centerdot": "·",
		"CenterDot": "·",
		"cfr": "𝔠",
		"Cfr": "ℭ",
		"CHcy": "Ч",
		"chcy": "ч",
		"check": "✓",
		"checkmark": "✓",
		"Chi": "Χ",
		"chi": "χ",
		"circ": "ˆ",
		"circeq": "≗",
		"circlearrowleft": "↺",
		"circlearrowright": "↻",
		"circledast": "⊛",
		"circledcirc": "⊚",
		"circleddash": "⊝",
		"CircleDot": "⊙",
		"circledR": "®",
		"circledS": "Ⓢ",
		"CircleMinus": "⊖",
		"CirclePlus": "⊕",
		"CircleTimes": "⊗",
		"cir": "○",
		"cirE": "⧃",
		"cire": "≗",
		"cirfnint": "⨐",
		"cirmid": "⫯",
		"cirscir": "⧂",
		"ClockwiseContourIntegral": "∲",
		"CloseCurlyDoubleQuote": "”",
		"CloseCurlyQuote": "’",
		"clubs": "♣",
		"clubsuit": "♣",
		"colon": ":",
		"Colon": "∷",
		"Colone": "⩴",
		"colone": "≔",
		"coloneq": "≔",
		"comma": ",",
		"commat": "@",
		"comp": "∁",
		"compfn": "∘",
		"complement": "∁",
		"complexes": "ℂ",
		"cong": "≅",
		"congdot": "⩭",
		"Congruent": "≡",
		"conint": "∮",
		"Conint": "∯",
		"ContourIntegral": "∮",
		"copf": "𝕔",
		"Copf": "ℂ",
		"coprod": "∐",
		"Coproduct": "∐",
		"copy": "©",
		"COPY": "©",
		"copysr": "℗",
		"CounterClockwiseContourIntegral": "∳",
		"crarr": "↵",
		"cross": "✗",
		"Cross": "⨯",
		"Cscr": "𝒞",
		"cscr": "𝒸",
		"csub": "⫏",
		"csube": "⫑",
		"csup": "⫐",
		"csupe": "⫒",
		"ctdot": "⋯",
		"cudarrl": "⤸",
		"cudarrr": "⤵",
		"cuepr": "⋞",
		"cuesc": "⋟",
		"cularr": "↶",
		"cularrp": "⤽",
		"cupbrcap": "⩈",
		"cupcap": "⩆",
		"CupCap": "≍",
		"cup": "∪",
		"Cup": "⋓",
		"cupcup": "⩊",
		"cupdot": "⊍",
		"cupor": "⩅",
		"cups": "∪︀",
		"curarr": "↷",
		"curarrm": "⤼",
		"curlyeqprec": "⋞",
		"curlyeqsucc": "⋟",
		"curlyvee": "⋎",
		"curlywedge": "⋏",
		"curren": "¤",
		"curvearrowleft": "↶",
		"curvearrowright": "↷",
		"cuvee": "⋎",
		"cuwed": "⋏",
		"cwconint": "∲",
		"cwint": "∱",
		"cylcty": "⌭",
		"dagger": "†",
		"Dagger": "‡",
		"daleth": "ℸ",
		"darr": "↓",
		"Darr": "↡",
		"dArr": "⇓",
		"dash": "‐",
		"Dashv": "⫤",
		"dashv": "⊣",
		"dbkarow": "⤏",
		"dblac": "˝",
		"Dcaron": "Ď",
		"dcaron": "ď",
		"Dcy": "Д",
		"dcy": "д",
		"ddagger": "‡",
		"ddarr": "⇊",
		"DD": "ⅅ",
		"dd": "ⅆ",
		"DDotrahd": "⤑",
		"ddotseq": "⩷",
		"deg": "°",
		"Del": "∇",
		"Delta": "Δ",
		"delta": "δ",
		"demptyv": "⦱",
		"dfisht": "⥿",
		"Dfr": "𝔇",
		"dfr": "𝔡",
		"dHar": "⥥",
		"dharl": "⇃",
		"dharr": "⇂",
		"DiacriticalAcute": "´",
		"DiacriticalDot": "˙",
		"DiacriticalDoubleAcute": "˝",
		"DiacriticalGrave": "`",
		"DiacriticalTilde": "˜",
		"diam": "⋄",
		"diamond": "⋄",
		"Diamond": "⋄",
		"diamondsuit": "♦",
		"diams": "♦",
		"die": "¨",
		"DifferentialD": "ⅆ",
		"digamma": "ϝ",
		"disin": "⋲",
		"div": "÷",
		"divide": "÷",
		"divideontimes": "⋇",
		"divonx": "⋇",
		"DJcy": "Ђ",
		"djcy": "ђ",
		"dlcorn": "⌞",
		"dlcrop": "⌍",
		"dollar": "$",
		"Dopf": "𝔻",
		"dopf": "𝕕",
		"Dot": "¨",
		"dot": "˙",
		"DotDot": "⃜",
		"doteq": "≐",
		"doteqdot": "≑",
		"DotEqual": "≐",
		"dotminus": "∸",
		"dotplus": "∔",
		"dotsquare": "⊡",
		"doublebarwedge": "⌆",
		"DoubleContourIntegral": "∯",
		"DoubleDot": "¨",
		"DoubleDownArrow": "⇓",
		"DoubleLeftArrow": "⇐",
		"DoubleLeftRightArrow": "⇔",
		"DoubleLeftTee": "⫤",
		"DoubleLongLeftArrow": "⟸",
		"DoubleLongLeftRightArrow": "⟺",
		"DoubleLongRightArrow": "⟹",
		"DoubleRightArrow": "⇒",
		"DoubleRightTee": "⊨",
		"DoubleUpArrow": "⇑",
		"DoubleUpDownArrow": "⇕",
		"DoubleVerticalBar": "∥",
		"DownArrowBar": "⤓",
		"downarrow": "↓",
		"DownArrow": "↓",
		"Downarrow": "⇓",
		"DownArrowUpArrow": "⇵",
		"DownBreve": "̑",
		"downdownarrows": "⇊",
		"downharpoonleft": "⇃",
		"downharpoonright": "⇂",
		"DownLeftRightVector": "⥐",
		"DownLeftTeeVector": "⥞",
		"DownLeftVectorBar": "⥖",
		"DownLeftVector": "↽",
		"DownRightTeeVector": "⥟",
		"DownRightVectorBar": "⥗",
		"DownRightVector": "⇁",
		"DownTeeArrow": "↧",
		"DownTee": "⊤",
		"drbkarow": "⤐",
		"drcorn": "⌟",
		"drcrop": "⌌",
		"Dscr": "𝒟",
		"dscr": "𝒹",
		"DScy": "Ѕ",
		"dscy": "ѕ",
		"dsol": "⧶",
		"Dstrok": "Đ",
		"dstrok": "đ",
		"dtdot": "⋱",
		"dtri": "▿",
		"dtrif": "▾",
		"duarr": "⇵",
		"duhar": "⥯",
		"dwangle": "⦦",
		"DZcy": "Џ",
		"dzcy": "џ",
		"dzigrarr": "⟿",
		"Eacute": "É",
		"eacute": "é",
		"easter": "⩮",
		"Ecaron": "Ě",
		"ecaron": "ě",
		"Ecirc": "Ê",
		"ecirc": "ê",
		"ecir": "≖",
		"ecolon": "≕",
		"Ecy": "Э",
		"ecy": "э",
		"eDDot": "⩷",
		"Edot": "Ė",
		"edot": "ė",
		"eDot": "≑",
		"ee": "ⅇ",
		"efDot": "≒",
		"Efr": "𝔈",
		"efr": "𝔢",
		"eg": "⪚",
		"Egrave": "È",
		"egrave": "è",
		"egs": "⪖",
		"egsdot": "⪘",
		"el": "⪙",
		"Element": "∈",
		"elinters": "⏧",
		"ell": "ℓ",
		"els": "⪕",
		"elsdot": "⪗",
		"Emacr": "Ē",
		"emacr": "ē",
		"empty": "∅",
		"emptyset": "∅",
		"EmptySmallSquare": "◻",
		"emptyv": "∅",
		"EmptyVerySmallSquare": "▫",
		"emsp13": " ",
		"emsp14": " ",
		"emsp": " ",
		"ENG": "Ŋ",
		"eng": "ŋ",
		"ensp": " ",
		"Eogon": "Ę",
		"eogon": "ę",
		"Eopf": "𝔼",
		"eopf": "𝕖",
		"epar": "⋕",
		"eparsl": "⧣",
		"eplus": "⩱",
		"epsi": "ε",
		"Epsilon": "Ε",
		"epsilon": "ε",
		"epsiv": "ϵ",
		"eqcirc": "≖",
		"eqcolon": "≕",
		"eqsim": "≂",
		"eqslantgtr": "⪖",
		"eqslantless": "⪕",
		"Equal": "⩵",
		"equals": "=",
		"EqualTilde": "≂",
		"equest": "≟",
		"Equilibrium": "⇌",
		"equiv": "≡",
		"equivDD": "⩸",
		"eqvparsl": "⧥",
		"erarr": "⥱",
		"erDot": "≓",
		"escr": "ℯ",
		"Escr": "ℰ",
		"esdot": "≐",
		"Esim": "⩳",
		"esim": "≂",
		"Eta": "Η",
		"eta": "η",
		"ETH": "Ð",
		"eth": "ð",
		"Euml": "Ë",
		"euml": "ë",
		"euro": "€",
		"excl": "!",
		"exist": "∃",
		"Exists": "∃",
		"expectation": "ℰ",
		"exponentiale": "ⅇ",
		"ExponentialE": "ⅇ",
		"fallingdotseq": "≒",
		"Fcy": "Ф",
		"fcy": "ф",
		"female": "♀",
		"ffilig": "ﬃ",
		"fflig": "ﬀ",
		"ffllig": "ﬄ",
		"Ffr": "𝔉",
		"ffr": "𝔣",
		"filig": "ﬁ",
		"FilledSmallSquare": "◼",
		"FilledVerySmallSquare": "▪",
		"fjlig": "fj",
		"flat": "♭",
		"fllig": "ﬂ",
		"fltns": "▱",
		"fnof": "ƒ",
		"Fopf": "𝔽",
		"fopf": "𝕗",
		"forall": "∀",
		"ForAll": "∀",
		"fork": "⋔",
		"forkv": "⫙",
		"Fouriertrf": "ℱ",
		"fpartint": "⨍",
		"frac12": "½",
		"frac13": "⅓",
		"frac14": "¼",
		"frac15": "⅕",
		"frac16": "⅙",
		"frac18": "⅛",
		"frac23": "⅔",
		"frac25": "⅖",
		"frac34": "¾",
		"frac35": "⅗",
		"frac38": "⅜",
		"frac45": "⅘",
		"frac56": "⅚",
		"frac58": "⅝",
		"frac78": "⅞",
		"frasl": "⁄",
		"frown": "⌢",
		"fscr": "𝒻",
		"Fscr": "ℱ",
		"gacute": "ǵ",
		"Gamma": "Γ",
		"gamma": "γ",
		"Gammad": "Ϝ",
		"gammad": "ϝ",
		"gap": "⪆",
		"Gbreve": "Ğ",
		"gbreve": "ğ",
		"Gcedil": "Ģ",
		"Gcirc": "Ĝ",
		"gcirc": "ĝ",
		"Gcy": "Г",
		"gcy": "г",
		"Gdot": "Ġ",
		"gdot": "ġ",
		"ge": "≥",
		"gE": "≧",
		"gEl": "⪌",
		"gel": "⋛",
		"geq": "≥",
		"geqq": "≧",
		"geqslant": "⩾",
		"gescc": "⪩",
		"ges": "⩾",
		"gesdot": "⪀",
		"gesdoto": "⪂",
		"gesdotol": "⪄",
		"gesl": "⋛︀",
		"gesles": "⪔",
		"Gfr": "𝔊",
		"gfr": "𝔤",
		"gg": "≫",
		"Gg": "⋙",
		"ggg": "⋙",
		"gimel": "ℷ",
		"GJcy": "Ѓ",
		"gjcy": "ѓ",
		"gla": "⪥",
		"gl": "≷",
		"glE": "⪒",
		"glj": "⪤",
		"gnap": "⪊",
		"gnapprox": "⪊",
		"gne": "⪈",
		"gnE": "≩",
		"gneq": "⪈",
		"gneqq": "≩",
		"gnsim": "⋧",
		"Gopf": "𝔾",
		"gopf": "𝕘",
		"grave": "`",
		"GreaterEqual": "≥",
		"GreaterEqualLess": "⋛",
		"GreaterFullEqual": "≧",
		"GreaterGreater": "⪢",
		"GreaterLess": "≷",
		"GreaterSlantEqual": "⩾",
		"GreaterTilde": "≳",
		"Gscr": "𝒢",
		"gscr": "ℊ",
		"gsim": "≳",
		"gsime": "⪎",
		"gsiml": "⪐",
		"gtcc": "⪧",
		"gtcir": "⩺",
		"gt": ">",
		"GT": ">",
		"Gt": "≫",
		"gtdot": "⋗",
		"gtlPar": "⦕",
		"gtquest": "⩼",
		"gtrapprox": "⪆",
		"gtrarr": "⥸",
		"gtrdot": "⋗",
		"gtreqless": "⋛",
		"gtreqqless": "⪌",
		"gtrless": "≷",
		"gtrsim": "≳",
		"gvertneqq": "≩︀",
		"gvnE": "≩︀",
		"Hacek": "ˇ",
		"hairsp": " ",
		"half": "½",
		"hamilt": "ℋ",
		"HARDcy": "Ъ",
		"hardcy": "ъ",
		"harrcir": "⥈",
		"harr": "↔",
		"hArr": "⇔",
		"harrw": "↭",
		"Hat": "^",
		"hbar": "ℏ",
		"Hcirc": "Ĥ",
		"hcirc": "ĥ",
		"hearts": "♥",
		"heartsuit": "♥",
		"hellip": "…",
		"hercon": "⊹",
		"hfr": "𝔥",
		"Hfr": "ℌ",
		"HilbertSpace": "ℋ",
		"hksearow": "⤥",
		"hkswarow": "⤦",
		"hoarr": "⇿",
		"homtht": "∻",
		"hookleftarrow": "↩",
		"hookrightarrow": "↪",
		"hopf": "𝕙",
		"Hopf": "ℍ",
		"horbar": "―",
		"HorizontalLine": "─",
		"hscr": "𝒽",
		"Hscr": "ℋ",
		"hslash": "ℏ",
		"Hstrok": "Ħ",
		"hstrok": "ħ",
		"HumpDownHump": "≎",
		"HumpEqual": "≏",
		"hybull": "⁃",
		"hyphen": "‐",
		"Iacute": "Í",
		"iacute": "í",
		"ic": "⁣",
		"Icirc": "Î",
		"icirc": "î",
		"Icy": "И",
		"icy": "и",
		"Idot": "İ",
		"IEcy": "Е",
		"iecy": "е",
		"iexcl": "¡",
		"iff": "⇔",
		"ifr": "𝔦",
		"Ifr": "ℑ",
		"Igrave": "Ì",
		"igrave": "ì",
		"ii": "ⅈ",
		"iiiint": "⨌",
		"iiint": "∭",
		"iinfin": "⧜",
		"iiota": "℩",
		"IJlig": "Ĳ",
		"ijlig": "ĳ",
		"Imacr": "Ī",
		"imacr": "ī",
		"image": "ℑ",
		"ImaginaryI": "ⅈ",
		"imagline": "ℐ",
		"imagpart": "ℑ",
		"imath": "ı",
		"Im": "ℑ",
		"imof": "⊷",
		"imped": "Ƶ",
		"Implies": "⇒",
		"incare": "℅",
		"in": "∈",
		"infin": "∞",
		"infintie": "⧝",
		"inodot": "ı",
		"intcal": "⊺",
		"int": "∫",
		"Int": "∬",
		"integers": "ℤ",
		"Integral": "∫",
		"intercal": "⊺",
		"Intersection": "⋂",
		"intlarhk": "⨗",
		"intprod": "⨼",
		"InvisibleComma": "⁣",
		"InvisibleTimes": "⁢",
		"IOcy": "Ё",
		"iocy": "ё",
		"Iogon": "Į",
		"iogon": "į",
		"Iopf": "𝕀",
		"iopf": "𝕚",
		"Iota": "Ι",
		"iota": "ι",
		"iprod": "⨼",
		"iquest": "¿",
		"iscr": "𝒾",
		"Iscr": "ℐ",
		"isin": "∈",
		"isindot": "⋵",
		"isinE": "⋹",
		"isins": "⋴",
		"isinsv": "⋳",
		"isinv": "∈",
		"it": "⁢",
		"Itilde": "Ĩ",
		"itilde": "ĩ",
		"Iukcy": "І",
		"iukcy": "і",
		"Iuml": "Ï",
		"iuml": "ï",
		"Jcirc": "Ĵ",
		"jcirc": "ĵ",
		"Jcy": "Й",
		"jcy": "й",
		"Jfr": "𝔍",
		"jfr": "𝔧",
		"jmath": "ȷ",
		"Jopf": "𝕁",
		"jopf": "𝕛",
		"Jscr": "𝒥",
		"jscr": "𝒿",
		"Jsercy": "Ј",
		"jsercy": "ј",
		"Jukcy": "Є",
		"jukcy": "є",
		"Kappa": "Κ",
		"kappa": "κ",
		"kappav": "ϰ",
		"Kcedil": "Ķ",
		"kcedil": "ķ",
		"Kcy": "К",
		"kcy": "к",
		"Kfr": "𝔎",
		"kfr": "𝔨",
		"kgreen": "ĸ",
		"KHcy": "Х",
		"khcy": "х",
		"KJcy": "Ќ",
		"kjcy": "ќ",
		"Kopf": "𝕂",
		"kopf": "𝕜",
		"Kscr": "𝒦",
		"kscr": "𝓀",
		"lAarr": "⇚",
		"Lacute": "Ĺ",
		"lacute": "ĺ",
		"laemptyv": "⦴",
		"lagran": "ℒ",
		"Lambda": "Λ",
		"lambda": "λ",
		"lang": "⟨",
		"Lang": "⟪",
		"langd": "⦑",
		"langle": "⟨",
		"lap": "⪅",
		"Laplacetrf": "ℒ",
		"laquo": "«",
		"larrb": "⇤",
		"larrbfs": "⤟",
		"larr": "←",
		"Larr": "↞",
		"lArr": "⇐",
		"larrfs": "⤝",
		"larrhk": "↩",
		"larrlp": "↫",
		"larrpl": "⤹",
		"larrsim": "⥳",
		"larrtl": "↢",
		"latail": "⤙",
		"lAtail": "⤛",
		"lat": "⪫",
		"late": "⪭",
		"lates": "⪭︀",
		"lbarr": "⤌",
		"lBarr": "⤎",
		"lbbrk": "❲",
		"lbrace": "{",
		"lbrack": "[",
		"lbrke": "⦋",
		"lbrksld": "⦏",
		"lbrkslu": "⦍",
		"Lcaron": "Ľ",
		"lcaron": "ľ",
		"Lcedil": "Ļ",
		"lcedil": "ļ",
		"lceil": "⌈",
		"lcub": "{",
		"Lcy": "Л",
		"lcy": "л",
		"ldca": "⤶",
		"ldquo": "“",
		"ldquor": "„",
		"ldrdhar": "⥧",
		"ldrushar": "⥋",
		"ldsh": "↲",
		"le": "≤",
		"lE": "≦",
		"LeftAngleBracket": "⟨",
		"LeftArrowBar": "⇤",
		"leftarrow": "←",
		"LeftArrow": "←",
		"Leftarrow": "⇐",
		"LeftArrowRightArrow": "⇆",
		"leftarrowtail": "↢",
		"LeftCeiling": "⌈",
		"LeftDoubleBracket": "⟦",
		"LeftDownTeeVector": "⥡",
		"LeftDownVectorBar": "⥙",
		"LeftDownVector": "⇃",
		"LeftFloor": "⌊",
		"leftharpoondown": "↽",
		"leftharpoonup": "↼",
		"leftleftarrows": "⇇",
		"leftrightarrow": "↔",
		"LeftRightArrow": "↔",
		"Leftrightarrow": "⇔",
		"leftrightarrows": "⇆",
		"leftrightharpoons": "⇋",
		"leftrightsquigarrow": "↭",
		"LeftRightVector": "⥎",
		"LeftTeeArrow": "↤",
		"LeftTee": "⊣",
		"LeftTeeVector": "⥚",
		"leftthreetimes": "⋋",
		"LeftTriangleBar": "⧏",
		"LeftTriangle": "⊲",
		"LeftTriangleEqual": "⊴",
		"LeftUpDownVector": "⥑",
		"LeftUpTeeVector": "⥠",
		"LeftUpVectorBar": "⥘",
		"LeftUpVector": "↿",
		"LeftVectorBar": "⥒",
		"LeftVector": "↼",
		"lEg": "⪋",
		"leg": "⋚",
		"leq": "≤",
		"leqq": "≦",
		"leqslant": "⩽",
		"lescc": "⪨",
		"les": "⩽",
		"lesdot": "⩿",
		"lesdoto": "⪁",
		"lesdotor": "⪃",
		"lesg": "⋚︀",
		"lesges": "⪓",
		"lessapprox": "⪅",
		"lessdot": "⋖",
		"lesseqgtr": "⋚",
		"lesseqqgtr": "⪋",
		"LessEqualGreater": "⋚",
		"LessFullEqual": "≦",
		"LessGreater": "≶",
		"lessgtr": "≶",
		"LessLess": "⪡",
		"lesssim": "≲",
		"LessSlantEqual": "⩽",
		"LessTilde": "≲",
		"lfisht": "⥼",
		"lfloor": "⌊",
		"Lfr": "𝔏",
		"lfr": "𝔩",
		"lg": "≶",
		"lgE": "⪑",
		"lHar": "⥢",
		"lhard": "↽",
		"lharu": "↼",
		"lharul": "⥪",
		"lhblk": "▄",
		"LJcy": "Љ",
		"ljcy": "љ",
		"llarr": "⇇",
		"ll": "≪",
		"Ll": "⋘",
		"llcorner": "⌞",
		"Lleftarrow": "⇚",
		"llhard": "⥫",
		"lltri": "◺",
		"Lmidot": "Ŀ",
		"lmidot": "ŀ",
		"lmoustache": "⎰",
		"lmoust": "⎰",
		"lnap": "⪉",
		"lnapprox": "⪉",
		"lne": "⪇",
		"lnE": "≨",
		"lneq": "⪇",
		"lneqq": "≨",
		"lnsim": "⋦",
		"loang": "⟬",
		"loarr": "⇽",
		"lobrk": "⟦",
		"longleftarrow": "⟵",
		"LongLeftArrow": "⟵",
		"Longleftarrow": "⟸",
		"longleftrightarrow": "⟷",
		"LongLeftRightArrow": "⟷",
		"Longleftrightarrow": "⟺",
		"longmapsto": "⟼",
		"longrightarrow": "⟶",
		"LongRightArrow": "⟶",
		"Longrightarrow": "⟹",
		"looparrowleft": "↫",
		"looparrowright": "↬",
		"lopar": "⦅",
		"Lopf": "𝕃",
		"lopf": "𝕝",
		"loplus": "⨭",
		"lotimes": "⨴",
		"lowast": "∗",
		"lowbar": "_",
		"LowerLeftArrow": "↙",
		"LowerRightArrow": "↘",
		"loz": "◊",
		"lozenge": "◊",
		"lozf": "⧫",
		"lpar": "(",
		"lparlt": "⦓",
		"lrarr": "⇆",
		"lrcorner": "⌟",
		"lrhar": "⇋",
		"lrhard": "⥭",
		"lrm": "‎",
		"lrtri": "⊿",
		"lsaquo": "‹",
		"lscr": "𝓁",
		"Lscr": "ℒ",
		"lsh": "↰",
		"Lsh": "↰",
		"lsim": "≲",
		"lsime": "⪍",
		"lsimg": "⪏",
		"lsqb": "[",
		"lsquo": "‘",
		"lsquor": "‚",
		"Lstrok": "Ł",
		"lstrok": "ł",
		"ltcc": "⪦",
		"ltcir": "⩹",
		"lt": "<",
		"LT": "<",
		"Lt": "≪",
		"ltdot": "⋖",
		"lthree": "⋋",
		"ltimes": "⋉",
		"ltlarr": "⥶",
		"ltquest": "⩻",
		"ltri": "◃",
		"ltrie": "⊴",
		"ltrif": "◂",
		"ltrPar": "⦖",
		"lurdshar": "⥊",
		"luruhar": "⥦",
		"lvertneqq": "≨︀",
		"lvnE": "≨︀",
		"macr": "¯",
		"male": "♂",
		"malt": "✠",
		"maltese": "✠",
		"Map": "⤅",
		"map": "↦",
		"mapsto": "↦",
		"mapstodown": "↧",
		"mapstoleft": "↤",
		"mapstoup": "↥",
		"marker": "▮",
		"mcomma": "⨩",
		"Mcy": "М",
		"mcy": "м",
		"mdash": "—",
		"mDDot": "∺",
		"measuredangle": "∡",
		"MediumSpace": " ",
		"Mellintrf": "ℳ",
		"Mfr": "𝔐",
		"mfr": "𝔪",
		"mho": "℧",
		"micro": "µ",
		"midast": "*",
		"midcir": "⫰",
		"mid": "∣",
		"middot": "·",
		"minusb": "⊟",
		"minus": "−",
		"minusd": "∸",
		"minusdu": "⨪",
		"MinusPlus": "∓",
		"mlcp": "⫛",
		"mldr": "…",
		"mnplus": "∓",
		"models": "⊧",
		"Mopf": "𝕄",
		"mopf": "𝕞",
		"mp": "∓",
		"mscr": "𝓂",
		"Mscr": "ℳ",
		"mstpos": "∾",
		"Mu": "Μ",
		"mu": "μ",
		"multimap": "⊸",
		"mumap": "⊸",
		"nabla": "∇",
		"Nacute": "Ń",
		"nacute": "ń",
		"nang": "∠⃒",
		"nap": "≉",
		"napE": "⩰̸",
		"napid": "≋̸",
		"napos": "ŉ",
		"napprox": "≉",
		"natural": "♮",
		"naturals": "ℕ",
		"natur": "♮",
		"nbsp": " ",
		"nbump": "≎̸",
		"nbumpe": "≏̸",
		"ncap": "⩃",
		"Ncaron": "Ň",
		"ncaron": "ň",
		"Ncedil": "Ņ",
		"ncedil": "ņ",
		"ncong": "≇",
		"ncongdot": "⩭̸",
		"ncup": "⩂",
		"Ncy": "Н",
		"ncy": "н",
		"ndash": "–",
		"nearhk": "⤤",
		"nearr": "↗",
		"neArr": "⇗",
		"nearrow": "↗",
		"ne": "≠",
		"nedot": "≐̸",
		"NegativeMediumSpace": "​",
		"NegativeThickSpace": "​",
		"NegativeThinSpace": "​",
		"NegativeVeryThinSpace": "​",
		"nequiv": "≢",
		"nesear": "⤨",
		"nesim": "≂̸",
		"NestedGreaterGreater": "≫",
		"NestedLessLess": "≪",
		"NewLine": "\n",
		"nexist": "∄",
		"nexists": "∄",
		"Nfr": "𝔑",
		"nfr": "𝔫",
		"ngE": "≧̸",
		"nge": "≱",
		"ngeq": "≱",
		"ngeqq": "≧̸",
		"ngeqslant": "⩾̸",
		"nges": "⩾̸",
		"nGg": "⋙̸",
		"ngsim": "≵",
		"nGt": "≫⃒",
		"ngt": "≯",
		"ngtr": "≯",
		"nGtv": "≫̸",
		"nharr": "↮",
		"nhArr": "⇎",
		"nhpar": "⫲",
		"ni": "∋",
		"nis": "⋼",
		"nisd": "⋺",
		"niv": "∋",
		"NJcy": "Њ",
		"njcy": "њ",
		"nlarr": "↚",
		"nlArr": "⇍",
		"nldr": "‥",
		"nlE": "≦̸",
		"nle": "≰",
		"nleftarrow": "↚",
		"nLeftarrow": "⇍",
		"nleftrightarrow": "↮",
		"nLeftrightarrow": "⇎",
		"nleq": "≰",
		"nleqq": "≦̸",
		"nleqslant": "⩽̸",
		"nles": "⩽̸",
		"nless": "≮",
		"nLl": "⋘̸",
		"nlsim": "≴",
		"nLt": "≪⃒",
		"nlt": "≮",
		"nltri": "⋪",
		"nltrie": "⋬",
		"nLtv": "≪̸",
		"nmid": "∤",
		"NoBreak": "⁠",
		"NonBreakingSpace": " ",
		"nopf": "𝕟",
		"Nopf": "ℕ",
		"Not": "⫬",
		"not": "¬",
		"NotCongruent": "≢",
		"NotCupCap": "≭",
		"NotDoubleVerticalBar": "∦",
		"NotElement": "∉",
		"NotEqual": "≠",
		"NotEqualTilde": "≂̸",
		"NotExists": "∄",
		"NotGreater": "≯",
		"NotGreaterEqual": "≱",
		"NotGreaterFullEqual": "≧̸",
		"NotGreaterGreater": "≫̸",
		"NotGreaterLess": "≹",
		"NotGreaterSlantEqual": "⩾̸",
		"NotGreaterTilde": "≵",
		"NotHumpDownHump": "≎̸",
		"NotHumpEqual": "≏̸",
		"notin": "∉",
		"notindot": "⋵̸",
		"notinE": "⋹̸",
		"notinva": "∉",
		"notinvb": "⋷",
		"notinvc": "⋶",
		"NotLeftTriangleBar": "⧏̸",
		"NotLeftTriangle": "⋪",
		"NotLeftTriangleEqual": "⋬",
		"NotLess": "≮",
		"NotLessEqual": "≰",
		"NotLessGreater": "≸",
		"NotLessLess": "≪̸",
		"NotLessSlantEqual": "⩽̸",
		"NotLessTilde": "≴",
		"NotNestedGreaterGreater": "⪢̸",
		"NotNestedLessLess": "⪡̸",
		"notni": "∌",
		"notniva": "∌",
		"notnivb": "⋾",
		"notnivc": "⋽",
		"NotPrecedes": "⊀",
		"NotPrecedesEqual": "⪯̸",
		"NotPrecedesSlantEqual": "⋠",
		"NotReverseElement": "∌",
		"NotRightTriangleBar": "⧐̸",
		"NotRightTriangle": "⋫",
		"NotRightTriangleEqual": "⋭",
		"NotSquareSubset": "⊏̸",
		"NotSquareSubsetEqual": "⋢",
		"NotSquareSuperset": "⊐̸",
		"NotSquareSupersetEqual": "⋣",
		"NotSubset": "⊂⃒",
		"NotSubsetEqual": "⊈",
		"NotSucceeds": "⊁",
		"NotSucceedsEqual": "⪰̸",
		"NotSucceedsSlantEqual": "⋡",
		"NotSucceedsTilde": "≿̸",
		"NotSuperset": "⊃⃒",
		"NotSupersetEqual": "⊉",
		"NotTilde": "≁",
		"NotTildeEqual": "≄",
		"NotTildeFullEqual": "≇",
		"NotTildeTilde": "≉",
		"NotVerticalBar": "∤",
		"nparallel": "∦",
		"npar": "∦",
		"nparsl": "⫽⃥",
		"npart": "∂̸",
		"npolint": "⨔",
		"npr": "⊀",
		"nprcue": "⋠",
		"nprec": "⊀",
		"npreceq": "⪯̸",
		"npre": "⪯̸",
		"nrarrc": "⤳̸",
		"nrarr": "↛",
		"nrArr": "⇏",
		"nrarrw": "↝̸",
		"nrightarrow": "↛",
		"nRightarrow": "⇏",
		"nrtri": "⋫",
		"nrtrie": "⋭",
		"nsc": "⊁",
		"nsccue": "⋡",
		"nsce": "⪰̸",
		"Nscr": "𝒩",
		"nscr": "𝓃",
		"nshortmid": "∤",
		"nshortparallel": "∦",
		"nsim": "≁",
		"nsime": "≄",
		"nsimeq": "≄",
		"nsmid": "∤",
		"nspar": "∦",
		"nsqsube": "⋢",
		"nsqsupe": "⋣",
		"nsub": "⊄",
		"nsubE": "⫅̸",
		"nsube": "⊈",
		"nsubset": "⊂⃒",
		"nsubseteq": "⊈",
		"nsubseteqq": "⫅̸",
		"nsucc": "⊁",
		"nsucceq": "⪰̸",
		"nsup": "⊅",
		"nsupE": "⫆̸",
		"nsupe": "⊉",
		"nsupset": "⊃⃒",
		"nsupseteq": "⊉",
		"nsupseteqq": "⫆̸",
		"ntgl": "≹",
		"Ntilde": "Ñ",
		"ntilde": "ñ",
		"ntlg": "≸",
		"ntriangleleft": "⋪",
		"ntrianglelefteq": "⋬",
		"ntriangleright": "⋫",
		"ntrianglerighteq": "⋭",
		"Nu": "Ν",
		"nu": "ν",
		"num": "#",
		"numero": "№",
		"numsp": " ",
		"nvap": "≍⃒",
		"nvdash": "⊬",
		"nvDash": "⊭",
		"nVdash": "⊮",
		"nVDash": "⊯",
		"nvge": "≥⃒",
		"nvgt": ">⃒",
		"nvHarr": "⤄",
		"nvinfin": "⧞",
		"nvlArr": "⤂",
		"nvle": "≤⃒",
		"nvlt": "<⃒",
		"nvltrie": "⊴⃒",
		"nvrArr": "⤃",
		"nvrtrie": "⊵⃒",
		"nvsim": "∼⃒",
		"nwarhk": "⤣",
		"nwarr": "↖",
		"nwArr": "⇖",
		"nwarrow": "↖",
		"nwnear": "⤧",
		"Oacute": "Ó",
		"oacute": "ó",
		"oast": "⊛",
		"Ocirc": "Ô",
		"ocirc": "ô",
		"ocir": "⊚",
		"Ocy": "О",
		"ocy": "о",
		"odash": "⊝",
		"Odblac": "Ő",
		"odblac": "ő",
		"odiv": "⨸",
		"odot": "⊙",
		"odsold": "⦼",
		"OElig": "Œ",
		"oelig": "œ",
		"ofcir": "⦿",
		"Ofr": "𝔒",
		"ofr": "𝔬",
		"ogon": "˛",
		"Ograve": "Ò",
		"ograve": "ò",
		"ogt": "⧁",
		"ohbar": "⦵",
		"ohm": "Ω",
		"oint": "∮",
		"olarr": "↺",
		"olcir": "⦾",
		"olcross": "⦻",
		"oline": "‾",
		"olt": "⧀",
		"Omacr": "Ō",
		"omacr": "ō",
		"Omega": "Ω",
		"omega": "ω",
		"Omicron": "Ο",
		"omicron": "ο",
		"omid": "⦶",
		"ominus": "⊖",
		"Oopf": "𝕆",
		"oopf": "𝕠",
		"opar": "⦷",
		"OpenCurlyDoubleQuote": "“",
		"OpenCurlyQuote": "‘",
		"operp": "⦹",
		"oplus": "⊕",
		"orarr": "↻",
		"Or": "⩔",
		"or": "∨",
		"ord": "⩝",
		"order": "ℴ",
		"orderof": "ℴ",
		"ordf": "ª",
		"ordm": "º",
		"origof": "⊶",
		"oror": "⩖",
		"orslope": "⩗",
		"orv": "⩛",
		"oS": "Ⓢ",
		"Oscr": "𝒪",
		"oscr": "ℴ",
		"Oslash": "Ø",
		"oslash": "ø",
		"osol": "⊘",
		"Otilde": "Õ",
		"otilde": "õ",
		"otimesas": "⨶",
		"Otimes": "⨷",
		"otimes": "⊗",
		"Ouml": "Ö",
		"ouml": "ö",
		"ovbar": "⌽",
		"OverBar": "‾",
		"OverBrace": "⏞",
		"OverBracket": "⎴",
		"OverParenthesis": "⏜",
		"para": "¶",
		"parallel": "∥",
		"par": "∥",
		"parsim": "⫳",
		"parsl": "⫽",
		"part": "∂",
		"PartialD": "∂",
		"Pcy": "П",
		"pcy": "п",
		"percnt": "%",
		"period": ".",
		"permil": "‰",
		"perp": "⊥",
		"pertenk": "‱",
		"Pfr": "𝔓",
		"pfr": "𝔭",
		"Phi": "Φ",
		"phi": "φ",
		"phiv": "ϕ",
		"phmmat": "ℳ",
		"phone": "☎",
		"Pi": "Π",
		"pi": "π",
		"pitchfork": "⋔",
		"piv": "ϖ",
		"planck": "ℏ",
		"planckh": "ℎ",
		"plankv": "ℏ",
		"plusacir": "⨣",
		"plusb": "⊞",
		"pluscir": "⨢",
		"plus": "+",
		"plusdo": "∔",
		"plusdu": "⨥",
		"pluse": "⩲",
		"PlusMinus": "±",
		"plusmn": "±",
		"plussim": "⨦",
		"plustwo": "⨧",
		"pm": "±",
		"Poincareplane": "ℌ",
		"pointint": "⨕",
		"popf": "𝕡",
		"Popf": "ℙ",
		"pound": "£",
		"prap": "⪷",
		"Pr": "⪻",
		"pr": "≺",
		"prcue": "≼",
		"precapprox": "⪷",
		"prec": "≺",
		"preccurlyeq": "≼",
		"Precedes": "≺",
		"PrecedesEqual": "⪯",
		"PrecedesSlantEqual": "≼",
		"PrecedesTilde": "≾",
		"preceq": "⪯",
		"precnapprox": "⪹",
		"precneqq": "⪵",
		"precnsim": "⋨",
		"pre": "⪯",
		"prE": "⪳",
		"precsim": "≾",
		"prime": "′",
		"Prime": "″",
		"primes": "ℙ",
		"prnap": "⪹",
		"prnE": "⪵",
		"prnsim": "⋨",
		"prod": "∏",
		"Product": "∏",
		"profalar": "⌮",
		"profline": "⌒",
		"profsurf": "⌓",
		"prop": "∝",
		"Proportional": "∝",
		"Proportion": "∷",
		"propto": "∝",
		"prsim": "≾",
		"prurel": "⊰",
		"Pscr": "𝒫",
		"pscr": "𝓅",
		"Psi": "Ψ",
		"psi": "ψ",
		"puncsp": " ",
		"Qfr": "𝔔",
		"qfr": "𝔮",
		"qint": "⨌",
		"qopf": "𝕢",
		"Qopf": "ℚ",
		"qprime": "⁗",
		"Qscr": "𝒬",
		"qscr": "𝓆",
		"quaternions": "ℍ",
		"quatint": "⨖",
		"quest": "?",
		"questeq": "≟",
		"quot": "\"",
		"QUOT": "\"",
		"rAarr": "⇛",
		"race": "∽̱",
		"Racute": "Ŕ",
		"racute": "ŕ",
		"radic": "√",
		"raemptyv": "⦳",
		"rang": "⟩",
		"Rang": "⟫",
		"rangd": "⦒",
		"range": "⦥",
		"rangle": "⟩",
		"raquo": "»",
		"rarrap": "⥵",
		"rarrb": "⇥",
		"rarrbfs": "⤠",
		"rarrc": "⤳",
		"rarr": "→",
		"Rarr": "↠",
		"rArr": "⇒",
		"rarrfs": "⤞",
		"rarrhk": "↪",
		"rarrlp": "↬",
		"rarrpl": "⥅",
		"rarrsim": "⥴",
		"Rarrtl": "⤖",
		"rarrtl": "↣",
		"rarrw": "↝",
		"ratail": "⤚",
		"rAtail": "⤜",
		"ratio": "∶",
		"rationals": "ℚ",
		"rbarr": "⤍",
		"rBarr": "⤏",
		"RBarr": "⤐",
		"rbbrk": "❳",
		"rbrace": "}",
		"rbrack": "]",
		"rbrke": "⦌",
		"rbrksld": "⦎",
		"rbrkslu": "⦐",
		"Rcaron": "Ř",
		"rcaron": "ř",
		"Rcedil": "Ŗ",
		"rcedil": "ŗ",
		"rceil": "⌉",
		"rcub": "}",
		"Rcy": "Р",
		"rcy": "р",
		"rdca": "⤷",
		"rdldhar": "⥩",
		"rdquo": "”",
		"rdquor": "”",
		"rdsh": "↳",
		"real": "ℜ",
		"realine": "ℛ",
		"realpart": "ℜ",
		"reals": "ℝ",
		"Re": "ℜ",
		"rect": "▭",
		"reg": "®",
		"REG": "®",
		"ReverseElement": "∋",
		"ReverseEquilibrium": "⇋",
		"ReverseUpEquilibrium": "⥯",
		"rfisht": "⥽",
		"rfloor": "⌋",
		"rfr": "𝔯",
		"Rfr": "ℜ",
		"rHar": "⥤",
		"rhard": "⇁",
		"rharu": "⇀",
		"rharul": "⥬",
		"Rho": "Ρ",
		"rho": "ρ",
		"rhov": "ϱ",
		"RightAngleBracket": "⟩",
		"RightArrowBar": "⇥",
		"rightarrow": "→",
		"RightArrow": "→",
		"Rightarrow": "⇒",
		"RightArrowLeftArrow": "⇄",
		"rightarrowtail": "↣",
		"RightCeiling": "⌉",
		"RightDoubleBracket": "⟧",
		"RightDownTeeVector": "⥝",
		"RightDownVectorBar": "⥕",
		"RightDownVector": "⇂",
		"RightFloor": "⌋",
		"rightharpoondown": "⇁",
		"rightharpoonup": "⇀",
		"rightleftarrows": "⇄",
		"rightleftharpoons": "⇌",
		"rightrightarrows": "⇉",
		"rightsquigarrow": "↝",
		"RightTeeArrow": "↦",
		"RightTee": "⊢",
		"RightTeeVector": "⥛",
		"rightthreetimes": "⋌",
		"RightTriangleBar": "⧐",
		"RightTriangle": "⊳",
		"RightTriangleEqual": "⊵",
		"RightUpDownVector": "⥏",
		"RightUpTeeVector": "⥜",
		"RightUpVectorBar": "⥔",
		"RightUpVector": "↾",
		"RightVectorBar": "⥓",
		"RightVector": "⇀",
		"ring": "˚",
		"risingdotseq": "≓",
		"rlarr": "⇄",
		"rlhar": "⇌",
		"rlm": "‏",
		"rmoustache": "⎱",
		"rmoust": "⎱",
		"rnmid": "⫮",
		"roang": "⟭",
		"roarr": "⇾",
		"robrk": "⟧",
		"ropar": "⦆",
		"ropf": "𝕣",
		"Ropf": "ℝ",
		"roplus": "⨮",
		"rotimes": "⨵",
		"RoundImplies": "⥰",
		"rpar": ")",
		"rpargt": "⦔",
		"rppolint": "⨒",
		"rrarr": "⇉",
		"Rrightarrow": "⇛",
		"rsaquo": "›",
		"rscr": "𝓇",
		"Rscr": "ℛ",
		"rsh": "↱",
		"Rsh": "↱",
		"rsqb": "]",
		"rsquo": "’",
		"rsquor": "’",
		"rthree": "⋌",
		"rtimes": "⋊",
		"rtri": "▹",
		"rtrie": "⊵",
		"rtrif": "▸",
		"rtriltri": "⧎",
		"RuleDelayed": "⧴",
		"ruluhar": "⥨",
		"rx": "℞",
		"Sacute": "Ś",
		"sacute": "ś",
		"sbquo": "‚",
		"scap": "⪸",
		"Scaron": "Š",
		"scaron": "š",
		"Sc": "⪼",
		"sc": "≻",
		"sccue": "≽",
		"sce": "⪰",
		"scE": "⪴",
		"Scedil": "Ş",
		"scedil": "ş",
		"Scirc": "Ŝ",
		"scirc": "ŝ",
		"scnap": "⪺",
		"scnE": "⪶",
		"scnsim": "⋩",
		"scpolint": "⨓",
		"scsim": "≿",
		"Scy": "С",
		"scy": "с",
		"sdotb": "⊡",
		"sdot": "⋅",
		"sdote": "⩦",
		"searhk": "⤥",
		"searr": "↘",
		"seArr": "⇘",
		"searrow": "↘",
		"sect": "§",
		"semi": ";",
		"seswar": "⤩",
		"setminus": "∖",
		"setmn": "∖",
		"sext": "✶",
		"Sfr": "𝔖",
		"sfr": "𝔰",
		"sfrown": "⌢",
		"sharp": "♯",
		"SHCHcy": "Щ",
		"shchcy": "щ",
		"SHcy": "Ш",
		"shcy": "ш",
		"ShortDownArrow": "↓",
		"ShortLeftArrow": "←",
		"shortmid": "∣",
		"shortparallel": "∥",
		"ShortRightArrow": "→",
		"ShortUpArrow": "↑",
		"shy": "­",
		"Sigma": "Σ",
		"sigma": "σ",
		"sigmaf": "ς",
		"sigmav": "ς",
		"sim": "∼",
		"simdot": "⩪",
		"sime": "≃",
		"simeq": "≃",
		"simg": "⪞",
		"simgE": "⪠",
		"siml": "⪝",
		"simlE": "⪟",
		"simne": "≆",
		"simplus": "⨤",
		"simrarr": "⥲",
		"slarr": "←",
		"SmallCircle": "∘",
		"smallsetminus": "∖",
		"smashp": "⨳",
		"smeparsl": "⧤",
		"smid": "∣",
		"smile": "⌣",
		"smt": "⪪",
		"smte": "⪬",
		"smtes": "⪬︀",
		"SOFTcy": "Ь",
		"softcy": "ь",
		"solbar": "⌿",
		"solb": "⧄",
		"sol": "/",
		"Sopf": "𝕊",
		"sopf": "𝕤",
		"spades": "♠",
		"spadesuit": "♠",
		"spar": "∥",
		"sqcap": "⊓",
		"sqcaps": "⊓︀",
		"sqcup": "⊔",
		"sqcups": "⊔︀",
		"Sqrt": "√",
		"sqsub": "⊏",
		"sqsube": "⊑",
		"sqsubset": "⊏",
		"sqsubseteq": "⊑",
		"sqsup": "⊐",
		"sqsupe": "⊒",
		"sqsupset": "⊐",
		"sqsupseteq": "⊒",
		"square": "□",
		"Square": "□",
		"SquareIntersection": "⊓",
		"SquareSubset": "⊏",
		"SquareSubsetEqual": "⊑",
		"SquareSuperset": "⊐",
		"SquareSupersetEqual": "⊒",
		"SquareUnion": "⊔",
		"squarf": "▪",
		"squ": "□",
		"squf": "▪",
		"srarr": "→",
		"Sscr": "𝒮",
		"sscr": "𝓈",
		"ssetmn": "∖",
		"ssmile": "⌣",
		"sstarf": "⋆",
		"Star": "⋆",
		"star": "☆",
		"starf": "★",
		"straightepsilon": "ϵ",
		"straightphi": "ϕ",
		"strns": "¯",
		"sub": "⊂",
		"Sub": "⋐",
		"subdot": "⪽",
		"subE": "⫅",
		"sube": "⊆",
		"subedot": "⫃",
		"submult": "⫁",
		"subnE": "⫋",
		"subne": "⊊",
		"subplus": "⪿",
		"subrarr": "⥹",
		"subset": "⊂",
		"Subset": "⋐",
		"subseteq": "⊆",
		"subseteqq": "⫅",
		"SubsetEqual": "⊆",
		"subsetneq": "⊊",
		"subsetneqq": "⫋",
		"subsim": "⫇",
		"subsub": "⫕",
		"subsup": "⫓",
		"succapprox": "⪸",
		"succ": "≻",
		"succcurlyeq": "≽",
		"Succeeds": "≻",
		"SucceedsEqual": "⪰",
		"SucceedsSlantEqual": "≽",
		"SucceedsTilde": "≿",
		"succeq": "⪰",
		"succnapprox": "⪺",
		"succneqq": "⪶",
		"succnsim": "⋩",
		"succsim": "≿",
		"SuchThat": "∋",
		"sum": "∑",
		"Sum": "∑",
		"sung": "♪",
		"sup1": "¹",
		"sup2": "²",
		"sup3": "³",
		"sup": "⊃",
		"Sup": "⋑",
		"supdot": "⪾",
		"supdsub": "⫘",
		"supE": "⫆",
		"supe": "⊇",
		"supedot": "⫄",
		"Superset": "⊃",
		"SupersetEqual": "⊇",
		"suphsol": "⟉",
		"suphsub": "⫗",
		"suplarr": "⥻",
		"supmult": "⫂",
		"supnE": "⫌",
		"supne": "⊋",
		"supplus": "⫀",
		"supset": "⊃",
		"Supset": "⋑",
		"supseteq": "⊇",
		"supseteqq": "⫆",
		"supsetneq": "⊋",
		"supsetneqq": "⫌",
		"supsim": "⫈",
		"supsub": "⫔",
		"supsup": "⫖",
		"swarhk": "⤦",
		"swarr": "↙",
		"swArr": "⇙",
		"swarrow": "↙",
		"swnwar": "⤪",
		"szlig": "ß",
		"Tab": "\t",
		"target": "⌖",
		"Tau": "Τ",
		"tau": "τ",
		"tbrk": "⎴",
		"Tcaron": "Ť",
		"tcaron": "ť",
		"Tcedil": "Ţ",
		"tcedil": "ţ",
		"Tcy": "Т",
		"tcy": "т",
		"tdot": "⃛",
		"telrec": "⌕",
		"Tfr": "𝔗",
		"tfr": "𝔱",
		"there4": "∴",
		"therefore": "∴",
		"Therefore": "∴",
		"Theta": "Θ",
		"theta": "θ",
		"thetasym": "ϑ",
		"thetav": "ϑ",
		"thickapprox": "≈",
		"thicksim": "∼",
		"ThickSpace": "  ",
		"ThinSpace": " ",
		"thinsp": " ",
		"thkap": "≈",
		"thksim": "∼",
		"THORN": "Þ",
		"thorn": "þ",
		"tilde": "˜",
		"Tilde": "∼",
		"TildeEqual": "≃",
		"TildeFullEqual": "≅",
		"TildeTilde": "≈",
		"timesbar": "⨱",
		"timesb": "⊠",
		"times": "×",
		"timesd": "⨰",
		"tint": "∭",
		"toea": "⤨",
		"topbot": "⌶",
		"topcir": "⫱",
		"top": "⊤",
		"Topf": "𝕋",
		"topf": "𝕥",
		"topfork": "⫚",
		"tosa": "⤩",
		"tprime": "‴",
		"trade": "™",
		"TRADE": "™",
		"triangle": "▵",
		"triangledown": "▿",
		"triangleleft": "◃",
		"trianglelefteq": "⊴",
		"triangleq": "≜",
		"triangleright": "▹",
		"trianglerighteq": "⊵",
		"tridot": "◬",
		"trie": "≜",
		"triminus": "⨺",
		"TripleDot": "⃛",
		"triplus": "⨹",
		"trisb": "⧍",
		"tritime": "⨻",
		"trpezium": "⏢",
		"Tscr": "𝒯",
		"tscr": "𝓉",
		"TScy": "Ц",
		"tscy": "ц",
		"TSHcy": "Ћ",
		"tshcy": "ћ",
		"Tstrok": "Ŧ",
		"tstrok": "ŧ",
		"twixt": "≬",
		"twoheadleftarrow": "↞",
		"twoheadrightarrow": "↠",
		"Uacute": "Ú",
		"uacute": "ú",
		"uarr": "↑",
		"Uarr": "↟",
		"uArr": "⇑",
		"Uarrocir": "⥉",
		"Ubrcy": "Ў",
		"ubrcy": "ў",
		"Ubreve": "Ŭ",
		"ubreve": "ŭ",
		"Ucirc": "Û",
		"ucirc": "û",
		"Ucy": "У",
		"ucy": "у",
		"udarr": "⇅",
		"Udblac": "Ű",
		"udblac": "ű",
		"udhar": "⥮",
		"ufisht": "⥾",
		"Ufr": "𝔘",
		"ufr": "𝔲",
		"Ugrave": "Ù",
		"ugrave": "ù",
		"uHar": "⥣",
		"uharl": "↿",
		"uharr": "↾",
		"uhblk": "▀",
		"ulcorn": "⌜",
		"ulcorner": "⌜",
		"ulcrop": "⌏",
		"ultri": "◸",
		"Umacr": "Ū",
		"umacr": "ū",
		"uml": "¨",
		"UnderBar": "_",
		"UnderBrace": "⏟",
		"UnderBracket": "⎵",
		"UnderParenthesis": "⏝",
		"Union": "⋃",
		"UnionPlus": "⊎",
		"Uogon": "Ų",
		"uogon": "ų",
		"Uopf": "𝕌",
		"uopf": "𝕦",
		"UpArrowBar": "⤒",
		"uparrow": "↑",
		"UpArrow": "↑",
		"Uparrow": "⇑",
		"UpArrowDownArrow": "⇅",
		"updownarrow": "↕",
		"UpDownArrow": "↕",
		"Updownarrow": "⇕",
		"UpEquilibrium": "⥮",
		"upharpoonleft": "↿",
		"upharpoonright": "↾",
		"uplus": "⊎",
		"UpperLeftArrow": "↖",
		"UpperRightArrow": "↗",
		"upsi": "υ",
		"Upsi": "ϒ",
		"upsih": "ϒ",
		"Upsilon": "Υ",
		"upsilon": "υ",
		"UpTeeArrow": "↥",
		"UpTee": "⊥",
		"upuparrows": "⇈",
		"urcorn": "⌝",
		"urcorner": "⌝",
		"urcrop": "⌎",
		"Uring": "Ů",
		"uring": "ů",
		"urtri": "◹",
		"Uscr": "𝒰",
		"uscr": "𝓊",
		"utdot": "⋰",
		"Utilde": "Ũ",
		"utilde": "ũ",
		"utri": "▵",
		"utrif": "▴",
		"uuarr": "⇈",
		"Uuml": "Ü",
		"uuml": "ü",
		"uwangle": "⦧",
		"vangrt": "⦜",
		"varepsilon": "ϵ",
		"varkappa": "ϰ",
		"varnothing": "∅",
		"varphi": "ϕ",
		"varpi": "ϖ",
		"varpropto": "∝",
		"varr": "↕",
		"vArr": "⇕",
		"varrho": "ϱ",
		"varsigma": "ς",
		"varsubsetneq": "⊊︀",
		"varsubsetneqq": "⫋︀",
		"varsupsetneq": "⊋︀",
		"varsupsetneqq": "⫌︀",
		"vartheta": "ϑ",
		"vartriangleleft": "⊲",
		"vartriangleright": "⊳",
		"vBar": "⫨",
		"Vbar": "⫫",
		"vBarv": "⫩",
		"Vcy": "В",
		"vcy": "в",
		"vdash": "⊢",
		"vDash": "⊨",
		"Vdash": "⊩",
		"VDash": "⊫",
		"Vdashl": "⫦",
		"veebar": "⊻",
		"vee": "∨",
		"Vee": "⋁",
		"veeeq": "≚",
		"vellip": "⋮",
		"verbar": "|",
		"Verbar": "‖",
		"vert": "|",
		"Vert": "‖",
		"VerticalBar": "∣",
		"VerticalLine": "|",
		"VerticalSeparator": "❘",
		"VerticalTilde": "≀",
		"VeryThinSpace": " ",
		"Vfr": "𝔙",
		"vfr": "𝔳",
		"vltri": "⊲",
		"vnsub": "⊂⃒",
		"vnsup": "⊃⃒",
		"Vopf": "𝕍",
		"vopf": "𝕧",
		"vprop": "∝",
		"vrtri": "⊳",
		"Vscr": "𝒱",
		"vscr": "𝓋",
		"vsubnE": "⫋︀",
		"vsubne": "⊊︀",
		"vsupnE": "⫌︀",
		"vsupne": "⊋︀",
		"Vvdash": "⊪",
		"vzigzag": "⦚",
		"Wcirc": "Ŵ",
		"wcirc": "ŵ",
		"wedbar": "⩟",
		"wedge": "∧",
		"Wedge": "⋀",
		"wedgeq": "≙",
		"weierp": "℘",
		"Wfr": "𝔚",
		"wfr": "𝔴",
		"Wopf": "𝕎",
		"wopf": "𝕨",
		"wp": "℘",
		"wr": "≀",
		"wreath": "≀",
		"Wscr": "𝒲",
		"wscr": "𝓌",
		"xcap": "⋂",
		"xcirc": "◯",
		"xcup": "⋃",
		"xdtri": "▽",
		"Xfr": "𝔛",
		"xfr": "𝔵",
		"xharr": "⟷",
		"xhArr": "⟺",
		"Xi": "Ξ",
		"xi": "ξ",
		"xlarr": "⟵",
		"xlArr": "⟸",
		"xmap": "⟼",
		"xnis": "⋻",
		"xodot": "⨀",
		"Xopf": "𝕏",
		"xopf": "𝕩",
		"xoplus": "⨁",
		"xotime": "⨂",
		"xrarr": "⟶",
		"xrArr": "⟹",
		"Xscr": "𝒳",
		"xscr": "𝓍",
		"xsqcup": "⨆",
		"xuplus": "⨄",
		"xutri": "△",
		"xvee": "⋁",
		"xwedge": "⋀",
		"Yacute": "Ý",
		"yacute": "ý",
		"YAcy": "Я",
		"yacy": "я",
		"Ycirc": "Ŷ",
		"ycirc": "ŷ",
		"Ycy": "Ы",
		"ycy": "ы",
		"yen": "¥",
		"Yfr": "𝔜",
		"yfr": "𝔶",
		"YIcy": "Ї",
		"yicy": "ї",
		"Yopf": "𝕐",
		"yopf": "𝕪",
		"Yscr": "𝒴",
		"yscr": "𝓎",
		"YUcy": "Ю",
		"yucy": "ю",
		"yuml": "ÿ",
		"Yuml": "Ÿ",
		"Zacute": "Ź",
		"zacute": "ź",
		"Zcaron": "Ž",
		"zcaron": "ž",
		"Zcy": "З",
		"zcy": "з",
		"Zdot": "Ż",
		"zdot": "ż",
		"zeetrf": "ℨ",
		"ZeroWidthSpace": "​",
		"Zeta": "Ζ",
		"zeta": "ζ",
		"zfr": "𝔷",
		"Zfr": "ℨ",
		"ZHcy": "Ж",
		"zhcy": "ж",
		"zigrarr": "⇝",
		"zopf": "𝕫",
		"Zopf": "ℤ",
		"Zscr": "𝒵",
		"zscr": "𝓏",
		"zwj": "‍",
		"zwnj": "‌"
	};

/***/ },
/* 33 */
/***/ function(module, exports) {

	module.exports=/[!-#%-\*,-/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDE38-\uDE3D]|\uD805[\uDCC6\uDDC1-\uDDC9\uDE41-\uDE43]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F/

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	module.exports.encode = __webpack_require__(35);
	module.exports.decode = __webpack_require__(36);
	module.exports.format = __webpack_require__(37);
	module.exports.parse  = __webpack_require__(38);


/***/ },
/* 35 */
/***/ function(module, exports) {

	
	'use strict';


	var encodeCache = {};


	// Create a lookup array where anything but characters in `chars` string
	// and alphanumeric chars is percent-encoded.
	//
	function getEncodeCache(exclude) {
	  var i, ch, cache = encodeCache[exclude];
	  if (cache) { return cache; }

	  cache = encodeCache[exclude] = [];

	  for (i = 0; i < 128; i++) {
	    ch = String.fromCharCode(i);

	    if (/^[0-9a-z]$/i.test(ch)) {
	      // always allow unencoded alphanumeric characters
	      cache.push(ch);
	    } else {
	      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
	    }
	  }

	  for (i = 0; i < exclude.length; i++) {
	    cache[exclude.charCodeAt(i)] = exclude[i];
	  }

	  return cache;
	}


	// Encode unsafe characters with percent-encoding, skipping already
	// encoded sequences.
	//
	//  - string       - string to encode
	//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
	//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
	//
	function encode(string, exclude, keepEscaped) {
	  var i, l, code, nextCode, cache,
	      result = '';

	  if (typeof exclude !== 'string') {
	    // encode(string, keepEscaped)
	    keepEscaped  = exclude;
	    exclude = encode.defaultChars;
	  }

	  if (typeof keepEscaped === 'undefined') {
	    keepEscaped = true;
	  }

	  cache = getEncodeCache(exclude);

	  for (i = 0, l = string.length; i < l; i++) {
	    code = string.charCodeAt(i);

	    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
	      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
	        result += string.slice(i, i + 3);
	        i += 2;
	        continue;
	      }
	    }

	    if (code < 128) {
	      result += cache[code];
	      continue;
	    }

	    if (code >= 0xD800 && code <= 0xDFFF) {
	      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
	        nextCode = string.charCodeAt(i + 1);
	        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
	          result += encodeURIComponent(string[i] + string[i + 1]);
	          i++;
	          continue;
	        }
	      }
	      result += '%EF%BF%BD';
	      continue;
	    }

	    result += encodeURIComponent(string[i]);
	  }

	  return result;
	}

	encode.defaultChars   = ";/?:@&=+$,-_.!~*'()#";
	encode.componentChars = "-_.!~*'()";


	module.exports = encode;


/***/ },
/* 36 */
/***/ function(module, exports) {

	
	'use strict';


	/* eslint-disable no-bitwise */

	var decodeCache = {};

	function getDecodeCache(exclude) {
	  var i, ch, cache = decodeCache[exclude];
	  if (cache) { return cache; }

	  cache = decodeCache[exclude] = [];

	  for (i = 0; i < 128; i++) {
	    ch = String.fromCharCode(i);
	    cache.push(ch);
	  }

	  for (i = 0; i < exclude.length; i++) {
	    ch = exclude.charCodeAt(i);
	    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
	  }

	  return cache;
	}


	// Decode percent-encoded string.
	//
	function decode(string, exclude) {
	  var cache;

	  if (typeof exclude !== 'string') {
	    exclude = decode.defaultChars;
	  }

	  cache = getDecodeCache(exclude);

	  return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
	    var i, l, b1, b2, b3, b4, chr,
	        result = '';

	    for (i = 0, l = seq.length; i < l; i += 3) {
	      b1 = parseInt(seq.slice(i + 1, i + 3), 16);

	      if (b1 < 0x80) {
	        result += cache[b1];
	        continue;
	      }

	      if ((b1 & 0xE0) === 0xC0 && (i + 3 < l)) {
	        // 110xxxxx 10xxxxxx
	        b2 = parseInt(seq.slice(i + 4, i + 6), 16);

	        if ((b2 & 0xC0) === 0x80) {
	          chr = ((b1 << 6) & 0x7C0) | (b2 & 0x3F);

	          if (chr < 0x80) {
	            result += '\ufffd\ufffd';
	          } else {
	            result += String.fromCharCode(chr);
	          }

	          i += 3;
	          continue;
	        }
	      }

	      if ((b1 & 0xF0) === 0xE0 && (i + 6 < l)) {
	        // 1110xxxx 10xxxxxx 10xxxxxx
	        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
	        b3 = parseInt(seq.slice(i + 7, i + 9), 16);

	        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
	          chr = ((b1 << 12) & 0xF000) | ((b2 << 6) & 0xFC0) | (b3 & 0x3F);

	          if (chr < 0x800 || (chr >= 0xD800 && chr <= 0xDFFF)) {
	            result += '\ufffd\ufffd\ufffd';
	          } else {
	            result += String.fromCharCode(chr);
	          }

	          i += 6;
	          continue;
	        }
	      }

	      if ((b1 & 0xF8) === 0xF0 && (i + 9 < l)) {
	        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
	        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
	        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
	        b4 = parseInt(seq.slice(i + 10, i + 12), 16);

	        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {
	          chr = ((b1 << 18) & 0x1C0000) | ((b2 << 12) & 0x3F000) | ((b3 << 6) & 0xFC0) | (b4 & 0x3F);

	          if (chr < 0x10000 || chr > 0x10FFFF) {
	            result += '\ufffd\ufffd\ufffd\ufffd';
	          } else {
	            chr -= 0x10000;
	            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
	          }

	          i += 9;
	          continue;
	        }
	      }

	      result += '\ufffd';
	    }

	    return result;
	  });
	}


	decode.defaultChars   = ';/?:@&=+$,#';
	decode.componentChars = '';


	module.exports = decode;


/***/ },
/* 37 */
/***/ function(module, exports) {

	
	'use strict';


	module.exports = function format(url) {
	  var result = '';

	  result += url.protocol || '';
	  result += url.slashes ? '//' : '';
	  result += url.auth ? url.auth + '@' : '';

	  if (url.hostname && url.hostname.indexOf(':') !== -1) {
	    // ipv6 address
	    result += '[' + url.hostname + ']';
	  } else {
	    result += url.hostname || '';
	  }

	  result += url.port ? ':' + url.port : '';
	  result += url.pathname || '';
	  result += url.search || '';
	  result += url.hash || '';

	  return result;
	};


/***/ },
/* 38 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	//
	// Changes from joyent/node:
	//
	// 1. No leading slash in paths,
	//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`
	//
	// 2. Backslashes are not replaced with slashes,
	//    so `http:\\example.org\` is treated like a relative path
	//
	// 3. Trailing colon is treated like a part of the path,
	//    i.e. in `http://example.org:foo` pathname is `:foo`
	//
	// 4. Nothing is URL-encoded in the resulting object,
	//    (in joyent/node some chars in auth and paths are encoded)
	//
	// 5. `url.parse()` does not have `parseQueryString` argument
	//
	// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,
	//    which can be constructed using other parts of the url.
	//


	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.pathname = null;
	}

	// Reference: RFC 3986, RFC 1808, RFC 2396

	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,

	    // Special case for a simple path URL
	    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

	    // RFC 2396: characters reserved for delimiting URLs.
	    // We actually just auto-escape these.
	    delims = [ '<', '>', '"', '`', ' ', '\r', '\n', '\t' ],

	    // RFC 2396: characters not allowed for various reasons.
	    unwise = [ '{', '}', '|', '\\', '^', '`' ].concat(delims),

	    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	    autoEscape = [ '\'' ].concat(unwise),
	    // Characters that are never ever allowed in a hostname.
	    // Note that any invalid chars are also handled, but these
	    // are the ones that are *expected* to be seen, so we fast-path
	    // them.
	    nonHostChars = [ '%', '/', '?', ';', '#' ].concat(autoEscape),
	    hostEndingChars = [ '/', '?', '#' ],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
	    // protocols that can allow "unsafe" and "unwise" chars.
	    /* eslint-disable no-script-url */
	    // protocols that never have a hostname.
	    hostlessProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that always contain a // bit.
	    slashedProtocol = {
	      'http': true,
	      'https': true,
	      'ftp': true,
	      'gopher': true,
	      'file': true,
	      'http:': true,
	      'https:': true,
	      'ftp:': true,
	      'gopher:': true,
	      'file:': true
	    };
	    /* eslint-enable no-script-url */

	function urlParse(url, slashesDenoteHost) {
	  if (url && url instanceof Url) { return url; }

	  var u = new Url();
	  u.parse(url, slashesDenoteHost);
	  return u;
	}

	Url.prototype.parse = function(url, slashesDenoteHost) {
	  var i, l, lowerProto, hec, slashes,
	      rest = url;

	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();

	  if (!slashesDenoteHost && url.split('#').length === 1) {
	    // Try fast path regexp
	    var simplePath = simplePathPattern.exec(rest);
	    if (simplePath) {
	      this.pathname = simplePath[1];
	      if (simplePath[2]) {
	        this.search = simplePath[2];
	      }
	      return this;
	    }
	  }

	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    lowerProto = proto.toLowerCase();
	    this.protocol = proto;
	    rest = rest.substr(proto.length);
	  }

	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }

	  if (!hostlessProtocol[proto] &&
	      (slashes || (proto && !slashedProtocol[proto]))) {

	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c

	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.

	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (i = 0; i < hostEndingChars.length; i++) {
	      hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
	        hostEnd = hec;
	      }
	    }

	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }

	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = auth;
	    }

	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (i = 0; i < nonHostChars.length; i++) {
	      hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
	        hostEnd = hec;
	      }
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1) {
	      hostEnd = rest.length;
	    }

	    if (rest[hostEnd - 1] === ':') { hostEnd--; }
	    var host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);

	    // pull out port.
	    this.parseHost(host);

	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';

	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' &&
	        this.hostname[this.hostname.length - 1] === ']';

	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) { continue; }
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }

	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    }

	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	    }
	  }

	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    rest = rest.slice(0, qm);
	  }
	  if (rest) { this.pathname = rest; }
	  if (slashedProtocol[lowerProto] &&
	      this.hostname && !this.pathname) {
	    this.pathname = '';
	  }

	  return this;
	};

	Url.prototype.parseHost = function(host) {
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) { this.hostname = host; }
	};

	module.exports = urlParse;


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	
	module.exports.Any = __webpack_require__(40);
	module.exports.Cc  = __webpack_require__(41);
	module.exports.Cf  = __webpack_require__(42);
	module.exports.P   = __webpack_require__(33);
	module.exports.Z   = __webpack_require__(43);


/***/ },
/* 40 */
/***/ function(module, exports) {

	module.exports=/[\0-\uD7FF\uDC00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF]/

/***/ },
/* 41 */
/***/ function(module, exports) {

	module.exports=/[\0-\x1F\x7F-\x9F]/

/***/ },
/* 42 */
/***/ function(module, exports) {

	module.exports=/[\xAD\u0600-\u0605\u061C\u06DD\u070F\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804\uDCBD|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/

/***/ },
/* 43 */
/***/ function(module, exports) {

	module.exports=/[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	// Just a shortcut for bulk export
	'use strict';


	exports.parseLinkLabel       = __webpack_require__(45);
	exports.parseLinkDestination = __webpack_require__(46);
	exports.parseLinkTitle       = __webpack_require__(47);


/***/ },
/* 45 */
/***/ function(module, exports) {

	// Parse link label
	//
	// this function assumes that first character ("[") already matches;
	// returns the end of the label
	//
	'use strict';

	module.exports = function parseLinkLabel(state, start, disableNested) {
	  var level, found, marker, prevPos,
	      labelEnd = -1,
	      max = state.posMax,
	      oldPos = state.pos;

	  state.pos = start + 1;
	  level = 1;

	  while (state.pos < max) {
	    marker = state.src.charCodeAt(state.pos);
	    if (marker === 0x5D /* ] */) {
	      level--;
	      if (level === 0) {
	        found = true;
	        break;
	      }
	    }

	    prevPos = state.pos;
	    state.md.inline.skipToken(state);
	    if (marker === 0x5B /* [ */) {
	      if (prevPos === state.pos - 1) {
	        // increase level if we find text `[`, which is not a part of any token
	        level++;
	      } else if (disableNested) {
	        state.pos = oldPos;
	        return -1;
	      }
	    }
	  }

	  if (found) {
	    labelEnd = state.pos;
	  }

	  // restore old state
	  state.pos = oldPos;

	  return labelEnd;
	};


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	// Parse link destination
	//
	'use strict';


	var unescapeAll   = __webpack_require__(30).unescapeAll;


	module.exports = function parseLinkDestination(str, pos, max) {
	  var code, level,
	      lines = 0,
	      start = pos,
	      result = {
	        ok: false,
	        pos: 0,
	        lines: 0,
	        str: ''
	      };

	  if (str.charCodeAt(pos) === 0x3C /* < */) {
	    pos++;
	    while (pos < max) {
	      code = str.charCodeAt(pos);
	      if (code === 0x0A /* \n */) { return result; }
	      if (code === 0x3E /* > */) {
	        result.pos = pos + 1;
	        result.str = unescapeAll(str.slice(start + 1, pos));
	        result.ok = true;
	        return result;
	      }
	      if (code === 0x5C /* \ */ && pos + 1 < max) {
	        pos += 2;
	        continue;
	      }

	      pos++;
	    }

	    // no closing '>'
	    return result;
	  }

	  // this should be ... } else { ... branch

	  level = 0;
	  while (pos < max) {
	    code = str.charCodeAt(pos);

	    if (code === 0x20) { break; }

	    // ascii control characters
	    if (code < 0x20 || code === 0x7F) { break; }

	    if (code === 0x5C /* \ */ && pos + 1 < max) {
	      pos += 2;
	      continue;
	    }

	    if (code === 0x28 /* ( */) {
	      level++;
	      if (level > 1) { break; }
	    }

	    if (code === 0x29 /* ) */) {
	      level--;
	      if (level < 0) { break; }
	    }

	    pos++;
	  }

	  if (start === pos) { return result; }

	  result.str = unescapeAll(str.slice(start, pos));
	  result.lines = lines;
	  result.pos = pos;
	  result.ok = true;
	  return result;
	};


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	// Parse link title
	//
	'use strict';


	var unescapeAll = __webpack_require__(30).unescapeAll;


	module.exports = function parseLinkTitle(str, pos, max) {
	  var code,
	      marker,
	      lines = 0,
	      start = pos,
	      result = {
	        ok: false,
	        pos: 0,
	        lines: 0,
	        str: ''
	      };

	  if (pos >= max) { return result; }

	  marker = str.charCodeAt(pos);

	  if (marker !== 0x22 /* " */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) { return result; }

	  pos++;

	  // if opening marker is "(", switch it to closing marker ")"
	  if (marker === 0x28) { marker = 0x29; }

	  while (pos < max) {
	    code = str.charCodeAt(pos);
	    if (code === marker) {
	      result.pos = pos + 1;
	      result.lines = lines;
	      result.str = unescapeAll(str.slice(start + 1, pos));
	      result.ok = true;
	      return result;
	    } else if (code === 0x0A) {
	      lines++;
	    } else if (code === 0x5C /* \ */ && pos + 1 < max) {
	      pos++;
	      if (str.charCodeAt(pos) === 0x0A) {
	        lines++;
	      }
	    }

	    pos++;
	  }

	  return result;
	};


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * class Renderer
	 *
	 * Generates HTML from parsed token stream. Each instance has independent
	 * copy of rules. Those can be rewritten with ease. Also, you can add new
	 * rules if you create plugin and adds new token types.
	 **/
	'use strict';


	var assign          = __webpack_require__(30).assign;
	var unescapeAll     = __webpack_require__(30).unescapeAll;
	var escapeHtml      = __webpack_require__(30).escapeHtml;


	////////////////////////////////////////////////////////////////////////////////

	var default_rules = {};


	default_rules.code_inline = function (tokens, idx /*, options, env */) {
	  return '<code>' + escapeHtml(tokens[idx].content) + '</code>';
	};


	default_rules.code_block = function (tokens, idx /*, options, env */) {
	  return '<pre><code>' + escapeHtml(tokens[idx].content) + '</code></pre>\n';
	};


	default_rules.fence = function (tokens, idx, options, env, self) {
	  var token = tokens[idx],
	      info = token.info ? unescapeAll(token.info).trim() : '',
	      langName = '',
	      highlighted;

	  if (info) {
	    langName = info.split(/\s+/g)[0];
	    token.attrPush([ 'class', options.langPrefix + langName ]);
	  }

	  if (options.highlight) {
	    highlighted = options.highlight(token.content, langName) || escapeHtml(token.content);
	  } else {
	    highlighted = escapeHtml(token.content);
	  }

	  return  '<pre><code' + self.renderAttrs(token) + '>'
	        + highlighted
	        + '</code></pre>\n';
	};


	default_rules.image = function (tokens, idx, options, env, self) {
	  var token = tokens[idx];

	  // "alt" attr MUST be set, even if empty. Because it's mandatory and
	  // should be placed on proper position for tests.
	  //
	  // Replace content with actual value

	  token.attrs[token.attrIndex('alt')][1] =
	    self.renderInlineAsText(token.children, options, env);

	  return self.renderToken(tokens, idx, options);
	};


	default_rules.hardbreak = function (tokens, idx, options /*, env */) {
	  return options.xhtmlOut ? '<br />\n' : '<br>\n';
	};
	default_rules.softbreak = function (tokens, idx, options /*, env */) {
	  return options.breaks ? (options.xhtmlOut ? '<br />\n' : '<br>\n') : '\n';
	};


	default_rules.text = function (tokens, idx /*, options, env */) {
	  return escapeHtml(tokens[idx].content);
	};


	default_rules.html_block = function (tokens, idx /*, options, env */) {
	  return tokens[idx].content;
	};
	default_rules.html_inline = function (tokens, idx /*, options, env */) {
	  return tokens[idx].content;
	};


	/**
	 * new Renderer()
	 *
	 * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.
	 **/
	function Renderer() {

	  /**
	   * Renderer#rules -> Object
	   *
	   * Contains render rules for tokens. Can be updated and extended.
	   *
	   * ##### Example
	   *
	   * ```javascript
	   * var md = require('markdown-it')();
	   *
	   * md.renderer.rules.strong_open  = function () { return '<b>'; };
	   * md.renderer.rules.strong_close = function () { return '</b>'; };
	   *
	   * var result = md.renderInline(...);
	   * ```
	   *
	   * Each rule is called as independed static function with fixed signature:
	   *
	   * ```javascript
	   * function my_token_render(tokens, idx, options, env, renderer) {
	   *   // ...
	   *   return renderedHTML;
	   * }
	   * ```
	   *
	   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)
	   * for more details and examples.
	   **/
	  this.rules = assign({}, default_rules);
	}


	/**
	 * Renderer.renderAttrs(token) -> String
	 *
	 * Render token attributes to string.
	 **/
	Renderer.prototype.renderAttrs = function renderAttrs(token) {
	  var i, l, result;

	  if (!token.attrs) { return ''; }

	  result = '';

	  for (i = 0, l = token.attrs.length; i < l; i++) {
	    result += ' ' + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
	  }

	  return result;
	};


	/**
	 * Renderer.renderToken(tokens, idx, options) -> String
	 * - tokens (Array): list of tokens
	 * - idx (Numbed): token index to render
	 * - options (Object): params of parser instance
	 *
	 * Default token renderer. Can be overriden by custom function
	 * in [[Renderer#rules]].
	 **/
	Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
	  var nextToken,
	      result = '',
	      needLf = false,
	      token = tokens[idx];

	  // Tight list paragraphs
	  if (token.hidden) {
	    return '';
	  }

	  // Insert a newline between hidden paragraph and subsequent opening
	  // block-level tag.
	  //
	  // For example, here we should insert a newline before blockquote:
	  //  - a
	  //    >
	  //
	  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
	    result += '\n';
	  }

	  // Add token name, e.g. `<img`
	  result += (token.nesting === -1 ? '</' : '<') + token.tag;

	  // Encode attributes, e.g. `<img src="foo"`
	  result += this.renderAttrs(token);

	  // Add a slash for self-closing tags, e.g. `<img src="foo" /`
	  if (token.nesting === 0 && options.xhtmlOut) {
	    result += ' /';
	  }

	  // Check if we need to add a newline after this tag
	  if (token.block) {
	    needLf = true;

	    if (token.nesting === 1) {
	      if (idx + 1 < tokens.length) {
	        nextToken = tokens[idx + 1];

	        if (nextToken.type === 'inline' || nextToken.hidden) {
	          // Block-level tag containing an inline tag.
	          //
	          needLf = false;

	        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
	          // Opening tag + closing tag of the same type. E.g. `<li></li>`.
	          //
	          needLf = false;
	        }
	      }
	    }
	  }

	  result += needLf ? '>\n' : '>';

	  return result;
	};


	/**
	 * Renderer.renderInline(tokens, options, env) -> String
	 * - tokens (Array): list on block tokens to renter
	 * - options (Object): params of parser instance
	 * - env (Object): additional data from parsed input (references, for example)
	 *
	 * The same as [[Renderer.render]], but for single token of `inline` type.
	 **/
	Renderer.prototype.renderInline = function (tokens, options, env) {
	  var type,
	      result = '',
	      rules = this.rules;

	  for (var i = 0, len = tokens.length; i < len; i++) {
	    type = tokens[i].type;

	    if (typeof rules[type] !== 'undefined') {
	      result += rules[type](tokens, i, options, env, this);
	    } else {
	      result += this.renderToken(tokens, i, options);
	    }
	  }

	  return result;
	};


	/** internal
	 * Renderer.renderInlineAsText(tokens, options, env) -> String
	 * - tokens (Array): list on block tokens to renter
	 * - options (Object): params of parser instance
	 * - env (Object): additional data from parsed input (references, for example)
	 *
	 * Special kludge for image `alt` attributes to conform CommonMark spec.
	 * Don't try to use it! Spec requires to show `alt` content with stripped markup,
	 * instead of simple escaping.
	 **/
	Renderer.prototype.renderInlineAsText = function (tokens, options, env) {
	  var result = '',
	      rules = this.rules;

	  for (var i = 0, len = tokens.length; i < len; i++) {
	    if (tokens[i].type === 'text') {
	      result += rules.text(tokens, i, options, env, this);
	    } else if (tokens[i].type === 'image') {
	      result += this.renderInlineAsText(tokens[i].children, options, env);
	    }
	  }

	  return result;
	};


	/**
	 * Renderer.render(tokens, options, env) -> String
	 * - tokens (Array): list on block tokens to renter
	 * - options (Object): params of parser instance
	 * - env (Object): additional data from parsed input (references, for example)
	 *
	 * Takes token stream and generates HTML. Probably, you will never need to call
	 * this method directly.
	 **/
	Renderer.prototype.render = function (tokens, options, env) {
	  var i, len, type,
	      result = '',
	      rules = this.rules;

	  for (i = 0, len = tokens.length; i < len; i++) {
	    type = tokens[i].type;

	    if (type === 'inline') {
	      result += this.renderInline(tokens[i].children, options, env);
	    } else if (typeof rules[type] !== 'undefined') {
	      result += rules[tokens[i].type](tokens, i, options, env, this);
	    } else {
	      result += this.renderToken(tokens, i, options, env);
	    }
	  }

	  return result;
	};

	module.exports = Renderer;


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/** internal
	 * class Core
	 *
	 * Top-level rules executor. Glues block/inline parsers and does intermediate
	 * transformations.
	 **/
	'use strict';


	var Ruler  = __webpack_require__(50);


	var _rules = [
	  [ 'normalize',      __webpack_require__(51)      ],
	  [ 'block',          __webpack_require__(52)          ],
	  [ 'inline',         __webpack_require__(53)         ],
	  [ 'linkify',        __webpack_require__(54)        ],
	  [ 'replacements',   __webpack_require__(55)   ],
	  [ 'smartquotes',    __webpack_require__(56)    ]
	];


	/**
	 * new Core()
	 **/
	function Core() {
	  /**
	   * Core#ruler -> Ruler
	   *
	   * [[Ruler]] instance. Keep configuration of core rules.
	   **/
	  this.ruler = new Ruler();

	  for (var i = 0; i < _rules.length; i++) {
	    this.ruler.push(_rules[i][0], _rules[i][1]);
	  }
	}


	/**
	 * Core.process(state)
	 *
	 * Executes core chain rules.
	 **/
	Core.prototype.process = function (state) {
	  var i, l, rules;

	  rules = this.ruler.getRules('');

	  for (i = 0, l = rules.length; i < l; i++) {
	    rules[i](state);
	  }
	};

	Core.prototype.State = __webpack_require__(57);


	module.exports = Core;


/***/ },
/* 50 */
/***/ function(module, exports) {

	/**
	 * class Ruler
	 *
	 * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and
	 * [[MarkdownIt#inline]] to manage sequences of functions (rules):
	 *
	 * - keep rules in defined order
	 * - assign the name to each rule
	 * - enable/disable rules
	 * - add/replace rules
	 * - allow assign rules to additional named chains (in the same)
	 * - cacheing lists of active rules
	 *
	 * You will not need use this class directly until write plugins. For simple
	 * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and
	 * [[MarkdownIt.use]].
	 **/
	'use strict';


	/**
	 * new Ruler()
	 **/
	function Ruler() {
	  // List of added rules. Each element is:
	  //
	  // {
	  //   name: XXX,
	  //   enabled: Boolean,
	  //   fn: Function(),
	  //   alt: [ name2, name3 ]
	  // }
	  //
	  this.__rules__ = [];

	  // Cached rule chains.
	  //
	  // First level - chain name, '' for default.
	  // Second level - diginal anchor for fast filtering by charcodes.
	  //
	  this.__cache__ = null;
	}

	////////////////////////////////////////////////////////////////////////////////
	// Helper methods, should not be used directly


	// Find rule index by name
	//
	Ruler.prototype.__find__ = function (name) {
	  for (var i = 0; i < this.__rules__.length; i++) {
	    if (this.__rules__[i].name === name) {
	      return i;
	    }
	  }
	  return -1;
	};


	// Build rules lookup cache
	//
	Ruler.prototype.__compile__ = function () {
	  var self = this;
	  var chains = [ '' ];

	  // collect unique names
	  self.__rules__.forEach(function (rule) {
	    if (!rule.enabled) { return; }

	    rule.alt.forEach(function (altName) {
	      if (chains.indexOf(altName) < 0) {
	        chains.push(altName);
	      }
	    });
	  });

	  self.__cache__ = {};

	  chains.forEach(function (chain) {
	    self.__cache__[chain] = [];
	    self.__rules__.forEach(function (rule) {
	      if (!rule.enabled) { return; }

	      if (chain && rule.alt.indexOf(chain) < 0) { return; }

	      self.__cache__[chain].push(rule.fn);
	    });
	  });
	};


	/**
	 * Ruler.at(name, fn [, options])
	 * - name (String): rule name to replace.
	 * - fn (Function): new rule function.
	 * - options (Object): new rule options (not mandatory).
	 *
	 * Replace rule by name with new function & options. Throws error if name not
	 * found.
	 *
	 * ##### Options:
	 *
	 * - __alt__ - array with names of "alternate" chains.
	 *
	 * ##### Example
	 *
	 * Replace existing typorgapher replacement rule with new one:
	 *
	 * ```javascript
	 * var md = require('markdown-it')();
	 *
	 * md.core.ruler.at('replacements', function replace(state) {
	 *   //...
	 * });
	 * ```
	 **/
	Ruler.prototype.at = function (name, fn, options) {
	  var index = this.__find__(name);
	  var opt = options || {};

	  if (index === -1) { throw new Error('Parser rule not found: ' + name); }

	  this.__rules__[index].fn = fn;
	  this.__rules__[index].alt = opt.alt || [];
	  this.__cache__ = null;
	};


	/**
	 * Ruler.before(beforeName, ruleName, fn [, options])
	 * - beforeName (String): new rule will be added before this one.
	 * - ruleName (String): name of added rule.
	 * - fn (Function): rule function.
	 * - options (Object): rule options (not mandatory).
	 *
	 * Add new rule to chain before one with given name. See also
	 * [[Ruler.after]], [[Ruler.push]].
	 *
	 * ##### Options:
	 *
	 * - __alt__ - array with names of "alternate" chains.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * var md = require('markdown-it')();
	 *
	 * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {
	 *   //...
	 * });
	 * ```
	 **/
	Ruler.prototype.before = function (beforeName, ruleName, fn, options) {
	  var index = this.__find__(beforeName);
	  var opt = options || {};

	  if (index === -1) { throw new Error('Parser rule not found: ' + beforeName); }

	  this.__rules__.splice(index, 0, {
	    name: ruleName,
	    enabled: true,
	    fn: fn,
	    alt: opt.alt || []
	  });

	  this.__cache__ = null;
	};


	/**
	 * Ruler.after(afterName, ruleName, fn [, options])
	 * - afterName (String): new rule will be added after this one.
	 * - ruleName (String): name of added rule.
	 * - fn (Function): rule function.
	 * - options (Object): rule options (not mandatory).
	 *
	 * Add new rule to chain after one with given name. See also
	 * [[Ruler.before]], [[Ruler.push]].
	 *
	 * ##### Options:
	 *
	 * - __alt__ - array with names of "alternate" chains.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * var md = require('markdown-it')();
	 *
	 * md.inline.ruler.after('text', 'my_rule', function replace(state) {
	 *   //...
	 * });
	 * ```
	 **/
	Ruler.prototype.after = function (afterName, ruleName, fn, options) {
	  var index = this.__find__(afterName);
	  var opt = options || {};

	  if (index === -1) { throw new Error('Parser rule not found: ' + afterName); }

	  this.__rules__.splice(index + 1, 0, {
	    name: ruleName,
	    enabled: true,
	    fn: fn,
	    alt: opt.alt || []
	  });

	  this.__cache__ = null;
	};

	/**
	 * Ruler.push(ruleName, fn [, options])
	 * - ruleName (String): name of added rule.
	 * - fn (Function): rule function.
	 * - options (Object): rule options (not mandatory).
	 *
	 * Push new rule to the end of chain. See also
	 * [[Ruler.before]], [[Ruler.after]].
	 *
	 * ##### Options:
	 *
	 * - __alt__ - array with names of "alternate" chains.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * var md = require('markdown-it')();
	 *
	 * md.core.ruler.push('my_rule', function replace(state) {
	 *   //...
	 * });
	 * ```
	 **/
	Ruler.prototype.push = function (ruleName, fn, options) {
	  var opt = options || {};

	  this.__rules__.push({
	    name: ruleName,
	    enabled: true,
	    fn: fn,
	    alt: opt.alt || []
	  });

	  this.__cache__ = null;
	};


	/**
	 * Ruler.enable(list [, ignoreInvalid]) -> Array
	 * - list (String|Array): list of rule names to enable.
	 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
	 *
	 * Enable rules with given names. If any rule name not found - throw Error.
	 * Errors can be disabled by second param.
	 *
	 * Returns list of found rule names (if no exception happened).
	 *
	 * See also [[Ruler.disable]], [[Ruler.enableOnly]].
	 **/
	Ruler.prototype.enable = function (list, ignoreInvalid) {
	  if (!Array.isArray(list)) { list = [ list ]; }

	  var result = [];

	  // Search by name and enable
	  list.forEach(function (name) {
	    var idx = this.__find__(name);

	    if (idx < 0) {
	      if (ignoreInvalid) { return; }
	      throw new Error('Rules manager: invalid rule name ' + name);
	    }
	    this.__rules__[idx].enabled = true;
	    result.push(name);
	  }, this);

	  this.__cache__ = null;
	  return result;
	};


	/**
	 * Ruler.enableOnly(list [, ignoreInvalid])
	 * - list (String|Array): list of rule names to enable (whitelist).
	 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
	 *
	 * Enable rules with given names, and disable everything else. If any rule name
	 * not found - throw Error. Errors can be disabled by second param.
	 *
	 * See also [[Ruler.disable]], [[Ruler.enable]].
	 **/
	Ruler.prototype.enableOnly = function (list, ignoreInvalid) {
	  if (!Array.isArray(list)) { list = [ list ]; }

	  this.__rules__.forEach(function (rule) { rule.enabled = false; });

	  this.enable(list, ignoreInvalid);
	};


	/**
	 * Ruler.disable(list [, ignoreInvalid]) -> Array
	 * - list (String|Array): list of rule names to disable.
	 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
	 *
	 * Disable rules with given names. If any rule name not found - throw Error.
	 * Errors can be disabled by second param.
	 *
	 * Returns list of found rule names (if no exception happened).
	 *
	 * See also [[Ruler.enable]], [[Ruler.enableOnly]].
	 **/
	Ruler.prototype.disable = function (list, ignoreInvalid) {
	  if (!Array.isArray(list)) { list = [ list ]; }

	  var result = [];

	  // Search by name and disable
	  list.forEach(function (name) {
	    var idx = this.__find__(name);

	    if (idx < 0) {
	      if (ignoreInvalid) { return; }
	      throw new Error('Rules manager: invalid rule name ' + name);
	    }
	    this.__rules__[idx].enabled = false;
	    result.push(name);
	  }, this);

	  this.__cache__ = null;
	  return result;
	};


	/**
	 * Ruler.getRules(chainName) -> Array
	 *
	 * Return array of active functions (rules) for given chain name. It analyzes
	 * rules configuration, compiles caches if not exists and returns result.
	 *
	 * Default chain name is `''` (empty string). It can't be skipped. That's
	 * done intentionally, to keep signature monomorphic for high speed.
	 **/
	Ruler.prototype.getRules = function (chainName) {
	  if (this.__cache__ === null) {
	    this.__compile__();
	  }

	  // Chain can be empty, if rules disabled. But we still have to return Array.
	  return this.__cache__[chainName] || [];
	};

	module.exports = Ruler;


/***/ },
/* 51 */
/***/ function(module, exports) {

	// Normalize input string

	'use strict';


	var TABS_SCAN_RE = /[\n\t]/g;
	var NEWLINES_RE  = /\r[\n\u0085]|[\u2424\u2028\u0085]/g;
	var NULL_RE      = /\u0000/g;


	module.exports = function inline(state) {
	  var str, lineStart, lastTabPos;

	  // Normalize newlines
	  str = state.src.replace(NEWLINES_RE, '\n');

	  // Replace NULL characters
	  str = str.replace(NULL_RE, '\uFFFD');

	  // Replace tabs with proper number of spaces (1..4)
	  if (str.indexOf('\t') >= 0) {
	    lineStart = 0;
	    lastTabPos = 0;

	    str = str.replace(TABS_SCAN_RE, function (match, offset) {
	      var result;
	      if (str.charCodeAt(offset) === 0x0A) {
	        lineStart = offset + 1;
	        lastTabPos = 0;
	        return match;
	      }
	      result = '    '.slice((offset - lineStart - lastTabPos) % 4);
	      lastTabPos = offset - lineStart + 1;
	      return result;
	    });
	  }

	  state.src = str;
	};


/***/ },
/* 52 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function block(state) {
	  var token;

	  if (state.inlineMode) {
	    token          = new state.Token('inline', '', 0);
	    token.content  = state.src;
	    token.map      = [ 0, 1 ];
	    token.children = [];
	    state.tokens.push(token);
	  } else {
	    state.md.block.parse(state.src, state.md, state.env, state.tokens);
	  }
	};


/***/ },
/* 53 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function inline(state) {
	  var tokens = state.tokens, tok, i, l;

	  // Parse inlines
	  for (i = 0, l = tokens.length; i < l; i++) {
	    tok = tokens[i];
	    if (tok.type === 'inline') {
	      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
	    }
	  }
	};


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	// Replace link-like texts with link nodes.
	//
	// Currently restricted by `md.validateLink()` to http/https/ftp
	//
	'use strict';


	var arrayReplaceAt = __webpack_require__(30).arrayReplaceAt;


	function isLinkOpen(str) {
	  return /^<a[>\s]/i.test(str);
	}
	function isLinkClose(str) {
	  return /^<\/a\s*>/i.test(str);
	}


	module.exports = function linkify(state) {
	  var i, j, l, tokens, token, currentToken, nodes, ln, text, pos, lastPos,
	      level, htmlLinkLevel, url, fullUrl, urlText,
	      blockTokens = state.tokens,
	      links;

	  if (!state.md.options.linkify) { return; }

	  for (j = 0, l = blockTokens.length; j < l; j++) {
	    if (blockTokens[j].type !== 'inline' ||
	        !state.md.linkify.pretest(blockTokens[j].content)) {
	      continue;
	    }

	    tokens = blockTokens[j].children;

	    htmlLinkLevel = 0;

	    // We scan from the end, to keep position when new tags added.
	    // Use reversed logic in links start/end match
	    for (i = tokens.length - 1; i >= 0; i--) {
	      currentToken = tokens[i];

	      // Skip content of markdown links
	      if (currentToken.type === 'link_close') {
	        i--;
	        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {
	          i--;
	        }
	        continue;
	      }

	      // Skip content of html tag links
	      if (currentToken.type === 'html_inline') {
	        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
	          htmlLinkLevel--;
	        }
	        if (isLinkClose(currentToken.content)) {
	          htmlLinkLevel++;
	        }
	      }
	      if (htmlLinkLevel > 0) { continue; }

	      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {

	        text = currentToken.content;
	        links = state.md.linkify.match(text);

	        // Now split string to nodes
	        nodes = [];
	        level = currentToken.level;
	        lastPos = 0;

	        for (ln = 0; ln < links.length; ln++) {

	          url = links[ln].url;
	          fullUrl = state.md.normalizeLink(url);
	          if (!state.md.validateLink(fullUrl)) { continue; }

	          urlText = links[ln].text;

	          // Linkifier might send raw hostnames like "example.com", where url
	          // starts with domain name. So we prepend http:// in those cases,
	          // and remove it afterwards.
	          //
	          if (!links[ln].schema) {
	            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\/\//, '');
	          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {
	            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');
	          } else {
	            urlText = state.md.normalizeLinkText(urlText);
	          }

	          pos = links[ln].index;

	          if (pos > lastPos) {
	            token         = new state.Token('text', '', 0);
	            token.content = text.slice(lastPos, pos);
	            token.level   = level;
	            nodes.push(token);
	          }

	          token         = new state.Token('link_open', 'a', 1);
	          token.attrs   = [ [ 'href', fullUrl ] ];
	          token.level   = level++;
	          token.markup  = 'linkify';
	          token.info    = 'auto';
	          nodes.push(token);

	          token         = new state.Token('text', '', 0);
	          token.content = urlText;
	          token.level   = level;
	          nodes.push(token);

	          token         = new state.Token('link_close', 'a', -1);
	          token.level   = --level;
	          token.markup  = 'linkify';
	          token.info    = 'auto';
	          nodes.push(token);

	          lastPos = links[ln].lastIndex;
	        }
	        if (lastPos < text.length) {
	          token         = new state.Token('text', '', 0);
	          token.content = text.slice(lastPos);
	          token.level   = level;
	          nodes.push(token);
	        }

	        // replace current node
	        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
	      }
	    }
	  }
	};


/***/ },
/* 55 */
/***/ function(module, exports) {

	// Simple typographyc replacements
	//
	// (c) (C) → ©
	// (tm) (TM) → ™
	// (r) (R) → ®
	// +- → ±
	// (p) (P) -> §
	// ... → … (also ?.... → ?.., !.... → !..)
	// ???????? → ???, !!!!! → !!!, `,,` → `,`
	// -- → &ndash;, --- → &mdash;
	//
	'use strict';

	// TODO:
	// - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾
	// - miltiplication 2 x 4 -> 2 × 4

	var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;

	// Workaround for phantomjs - need regex without /g flag,
	// or root check will fail every second time
	var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;

	var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
	var SCOPED_ABBR = {
	  'c': '©',
	  'r': '®',
	  'p': '§',
	  'tm': '™'
	};

	function replaceFn(match, name) {
	  return SCOPED_ABBR[name.toLowerCase()];
	}

	function replace_scoped(inlineTokens) {
	  var i, token;

	  for (i = inlineTokens.length - 1; i >= 0; i--) {
	    token = inlineTokens[i];
	    if (token.type === 'text') {
	      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
	    }
	  }
	}

	function replace_rare(inlineTokens) {
	  var i, token;

	  for (i = inlineTokens.length - 1; i >= 0; i--) {
	    token = inlineTokens[i];
	    if (token.type === 'text') {
	      if (RARE_RE.test(token.content)) {
	        token.content = token.content
	                    .replace(/\+-/g, '±')
	                    // .., ..., ....... -> …
	                    // but ?..... & !..... -> ?.. & !..
	                    .replace(/\.{2,}/g, '…').replace(/([?!])…/g, '$1..')
	                    .replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')
	                    // em-dash
	                    .replace(/(^|[^-])---([^-]|$)/mg, '$1\u2014$2')
	                    // en-dash
	                    .replace(/(^|\s)--(\s|$)/mg, '$1\u2013$2')
	                    .replace(/(^|[^-\s])--([^-\s]|$)/mg, '$1\u2013$2');
	      }
	    }
	  }
	}


	module.exports = function replace(state) {
	  var blkIdx;

	  if (!state.md.options.typographer) { return; }

	  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

	    if (state.tokens[blkIdx].type !== 'inline') { continue; }

	    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
	      replace_scoped(state.tokens[blkIdx].children);
	    }

	    if (RARE_RE.test(state.tokens[blkIdx].content)) {
	      replace_rare(state.tokens[blkIdx].children);
	    }

	  }
	};


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	// Convert straight quotation marks to typographic ones
	//
	'use strict';


	var isWhiteSpace   = __webpack_require__(30).isWhiteSpace;
	var isPunctChar    = __webpack_require__(30).isPunctChar;
	var isMdAsciiPunct = __webpack_require__(30).isMdAsciiPunct;

	var QUOTE_TEST_RE = /['"]/;
	var QUOTE_RE = /['"]/g;
	var APOSTROPHE = '\u2019'; /* ’ */


	function replaceAt(str, index, ch) {
	  return str.substr(0, index) + ch + str.substr(index + 1);
	}

	function process_inlines(tokens, state) {
	  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar,
	      isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace,
	      canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;

	  stack = [];

	  for (i = 0; i < tokens.length; i++) {
	    token = tokens[i];

	    thisLevel = tokens[i].level;

	    for (j = stack.length - 1; j >= 0; j--) {
	      if (stack[j].level <= thisLevel) { break; }
	    }
	    stack.length = j + 1;

	    if (token.type !== 'text') { continue; }

	    text = token.content;
	    pos = 0;
	    max = text.length;

	    /*eslint no-labels:0,block-scoped-var:0*/
	    OUTER:
	    while (pos < max) {
	      QUOTE_RE.lastIndex = pos;
	      t = QUOTE_RE.exec(text);
	      if (!t) { break; }

	      canOpen = canClose = true;
	      pos = t.index + 1;
	      isSingle = (t[0] === "'");

	      // treat begin/end of the line as a whitespace
	      lastChar = t.index - 1 >= 0 ? text.charCodeAt(t.index - 1) : 0x20;
	      nextChar = pos < max ? text.charCodeAt(pos) : 0x20;

	      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
	      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

	      isLastWhiteSpace = isWhiteSpace(lastChar);
	      isNextWhiteSpace = isWhiteSpace(nextChar);

	      if (isNextWhiteSpace) {
	        canOpen = false;
	      } else if (isNextPunctChar) {
	        if (!(isLastWhiteSpace || isLastPunctChar)) {
	          canOpen = false;
	        }
	      }

	      if (isLastWhiteSpace) {
	        canClose = false;
	      } else if (isLastPunctChar) {
	        if (!(isNextWhiteSpace || isNextPunctChar)) {
	          canClose = false;
	        }
	      }

	      if (nextChar === 0x22 /* " */ && t[0] === '"') {
	        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {
	          // special case: 1"" - count first quote as an inch
	          canClose = canOpen = false;
	        }
	      }

	      if (canOpen && canClose) {
	        // treat this as the middle of the word
	        canOpen = false;
	        canClose = isNextPunctChar;
	      }

	      if (!canOpen && !canClose) {
	        // middle of word
	        if (isSingle) {
	          token.content = replaceAt(token.content, t.index, APOSTROPHE);
	        }
	        continue;
	      }

	      if (canClose) {
	        // this could be a closing quote, rewind the stack to get a match
	        for (j = stack.length - 1; j >= 0; j--) {
	          item = stack[j];
	          if (stack[j].level < thisLevel) { break; }
	          if (item.single === isSingle && stack[j].level === thisLevel) {
	            item = stack[j];

	            if (isSingle) {
	              openQuote = state.md.options.quotes[2];
	              closeQuote = state.md.options.quotes[3];
	            } else {
	              openQuote = state.md.options.quotes[0];
	              closeQuote = state.md.options.quotes[1];
	            }

	            // replace token.content *before* tokens[item.token].content,
	            // because, if they are pointing at the same token, replaceAt
	            // could mess up indices when quote length != 1
	            token.content = replaceAt(token.content, t.index, closeQuote);
	            tokens[item.token].content = replaceAt(
	              tokens[item.token].content, item.pos, openQuote);

	            pos += closeQuote.length - 1;
	            if (item.token === i) { pos += openQuote.length - 1; }

	            text = token.content;
	            max = text.length;

	            stack.length = j;
	            continue OUTER;
	          }
	        }
	      }

	      if (canOpen) {
	        stack.push({
	          token: i,
	          pos: t.index,
	          single: isSingle,
	          level: thisLevel
	        });
	      } else if (canClose && isSingle) {
	        token.content = replaceAt(token.content, t.index, APOSTROPHE);
	      }
	    }
	  }
	}


	module.exports = function smartquotes(state) {
	  /*eslint max-depth:0*/
	  var blkIdx;

	  if (!state.md.options.typographer) { return; }

	  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

	    if (state.tokens[blkIdx].type !== 'inline' ||
	        !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
	      continue;
	    }

	    process_inlines(state.tokens[blkIdx].children, state);
	  }
	};


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	// Core state object
	//
	'use strict';

	var Token = __webpack_require__(58);


	function StateCore(src, md, env) {
	  this.src = src;
	  this.env = env;
	  this.tokens = [];
	  this.inlineMode = false;
	  this.md = md; // link to parser instance
	}

	// re-export Token class to use in core rules
	StateCore.prototype.Token = Token;


	module.exports = StateCore;


/***/ },
/* 58 */
/***/ function(module, exports) {

	// Token class

	'use strict';


	/**
	 * class Token
	 **/

	/**
	 * new Token(type, tag, nesting)
	 *
	 * Create new token and fill passed properties.
	 **/
	function Token(type, tag, nesting) {
	  /**
	   * Token#type -> String
	   *
	   * Type of the token (string, e.g. "paragraph_open")
	   **/
	  this.type     = type;

	  /**
	   * Token#tag -> String
	   *
	   * html tag name, e.g. "p"
	   **/
	  this.tag      = tag;

	  /**
	   * Token#attrs -> Array
	   *
	   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
	   **/
	  this.attrs    = null;

	  /**
	   * Token#map -> Array
	   *
	   * Source map info. Format: `[ line_begin, line_end ]`
	   **/
	  this.map      = null;

	  /**
	   * Token#nesting -> Number
	   *
	   * Level change (number in {-1, 0, 1} set), where:
	   *
	   * -  `1` means the tag is opening
	   * -  `0` means the tag is self-closing
	   * - `-1` means the tag is closing
	   **/
	  this.nesting  = nesting;

	  /**
	   * Token#level -> Number
	   *
	   * nesting level, the same as `state.level`
	   **/
	  this.level    = 0;

	  /**
	   * Token#children -> Array
	   *
	   * An array of child nodes (inline and img tokens)
	   **/
	  this.children = null;

	  /**
	   * Token#content -> String
	   *
	   * In a case of self-closing tag (code, html, fence, etc.),
	   * it has contents of this tag.
	   **/
	  this.content  = '';

	  /**
	   * Token#markup -> String
	   *
	   * '*' or '_' for emphasis, fence string for fence, etc.
	   **/
	  this.markup   = '';

	  /**
	   * Token#info -> String
	   *
	   * fence infostring
	   **/
	  this.info     = '';

	  /**
	   * Token#meta -> Object
	   *
	   * A place for plugins to store an arbitrary data
	   **/
	  this.meta     = null;

	  /**
	   * Token#block -> Boolean
	   *
	   * True for block-level tokens, false for inline tokens.
	   * Used in renderer to calculate line breaks
	   **/
	  this.block    = false;

	  /**
	   * Token#hidden -> Boolean
	   *
	   * If it's true, ignore this element when rendering. Used for tight lists
	   * to hide paragraphs.
	   **/
	  this.hidden   = false;
	}


	/**
	 * Token.attrIndex(name) -> Number
	 *
	 * Search attribute index by name.
	 **/
	Token.prototype.attrIndex = function attrIndex(name) {
	  var attrs, i, len;

	  if (!this.attrs) { return -1; }

	  attrs = this.attrs;

	  for (i = 0, len = attrs.length; i < len; i++) {
	    if (attrs[i][0] === name) { return i; }
	  }
	  return -1;
	};


	/**
	 * Token.attrPush(attrData)
	 *
	 * Add `[ name, value ]` attribute to list. Init attrs if necessary
	 **/
	Token.prototype.attrPush = function attrPush(attrData) {
	  if (this.attrs) {
	    this.attrs.push(attrData);
	  } else {
	    this.attrs = [ attrData ];
	  }
	};


	module.exports = Token;


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/** internal
	 * class ParserBlock
	 *
	 * Block-level tokenizer.
	 **/
	'use strict';


	var Ruler           = __webpack_require__(50);


	var _rules = [
	  // First 2 params - rule name & source. Secondary array - list of rules,
	  // which can be terminated by this one.
	  [ 'code',       __webpack_require__(60) ],
	  [ 'fence',      __webpack_require__(61),      [ 'paragraph', 'reference', 'blockquote', 'list' ] ],
	  [ 'blockquote', __webpack_require__(62), [ 'paragraph', 'reference', 'list' ] ],
	  [ 'hr',         __webpack_require__(63),         [ 'paragraph', 'reference', 'blockquote', 'list' ] ],
	  [ 'list',       __webpack_require__(64),       [ 'paragraph', 'reference', 'blockquote' ] ],
	  [ 'reference',  __webpack_require__(65) ],
	  [ 'heading',    __webpack_require__(66),    [ 'paragraph', 'reference', 'blockquote' ] ],
	  [ 'lheading',   __webpack_require__(67) ],
	  [ 'html_block', __webpack_require__(68), [ 'paragraph', 'reference', 'blockquote' ] ],
	  [ 'table',      __webpack_require__(71),      [ 'paragraph', 'reference' ] ],
	  [ 'paragraph',  __webpack_require__(72) ]
	];


	/**
	 * new ParserBlock()
	 **/
	function ParserBlock() {
	  /**
	   * ParserBlock#ruler -> Ruler
	   *
	   * [[Ruler]] instance. Keep configuration of block rules.
	   **/
	  this.ruler = new Ruler();

	  for (var i = 0; i < _rules.length; i++) {
	    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });
	  }
	}


	// Generate tokens for input range
	//
	ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
	  var ok, i,
	      rules = this.ruler.getRules(''),
	      len = rules.length,
	      line = startLine,
	      hasEmptyLines = false,
	      maxNesting = state.md.options.maxNesting;

	  while (line < endLine) {
	    state.line = line = state.skipEmptyLines(line);
	    if (line >= endLine) { break; }

	    // Termination condition for nested calls.
	    // Nested calls currently used for blockquotes & lists
	    if (state.tShift[line] < state.blkIndent) { break; }

	    // If nesting level exceeded - skip tail to the end. That's not ordinary
	    // situation and we should not care about content.
	    if (state.level >= maxNesting) {
	      state.line = endLine;
	      break;
	    }

	    // Try all possible rules.
	    // On success, rule should:
	    //
	    // - update `state.line`
	    // - update `state.tokens`
	    // - return true

	    for (i = 0; i < len; i++) {
	      ok = rules[i](state, line, endLine, false);
	      if (ok) { break; }
	    }

	    // set state.tight iff we had an empty line before current tag
	    // i.e. latest empty line should not count
	    state.tight = !hasEmptyLines;

	    // paragraph might "eat" one newline after it in nested lists
	    if (state.isEmpty(state.line - 1)) {
	      hasEmptyLines = true;
	    }

	    line = state.line;

	    if (line < endLine && state.isEmpty(line)) {
	      hasEmptyLines = true;
	      line++;

	      // two empty lines should stop the parser in list mode
	      if (line < endLine && state.parentType === 'list' && state.isEmpty(line)) { break; }
	      state.line = line;
	    }
	  }
	};


	/**
	 * ParserBlock.parse(str, md, env, outTokens)
	 *
	 * Process input string and push block tokens into `outTokens`
	 **/
	ParserBlock.prototype.parse = function (src, md, env, outTokens) {
	  var state;

	  if (!src) { return []; }

	  state = new this.State(src, md, env, outTokens);

	  this.tokenize(state, state.line, state.lineMax);
	};


	ParserBlock.prototype.State = __webpack_require__(73);


	module.exports = ParserBlock;


/***/ },
/* 60 */
/***/ function(module, exports) {

	// Code block (4 spaces padded)

	'use strict';


	module.exports = function code(state, startLine, endLine/*, silent*/) {
	  var nextLine, last, token;

	  if (state.tShift[startLine] - state.blkIndent < 4) { return false; }

	  last = nextLine = startLine + 1;

	  while (nextLine < endLine) {
	    if (state.isEmpty(nextLine)) {
	      nextLine++;
	      continue;
	    }
	    if (state.tShift[nextLine] - state.blkIndent >= 4) {
	      nextLine++;
	      last = nextLine;
	      continue;
	    }
	    break;
	  }

	  state.line = nextLine;

	  token         = state.push('code_block', 'code', 0);
	  token.content = state.getLines(startLine, last, 4 + state.blkIndent, true);
	  token.map     = [ startLine, state.line ];

	  return true;
	};


/***/ },
/* 61 */
/***/ function(module, exports) {

	// fences (``` lang, ~~~ lang)

	'use strict';


	module.exports = function fence(state, startLine, endLine, silent) {
	  var marker, len, params, nextLine, mem, token, markup,
	      haveEndMarker = false,
	      pos = state.bMarks[startLine] + state.tShift[startLine],
	      max = state.eMarks[startLine];

	  if (pos + 3 > max) { return false; }

	  marker = state.src.charCodeAt(pos);

	  if (marker !== 0x7E/* ~ */ && marker !== 0x60 /* ` */) {
	    return false;
	  }

	  // scan marker length
	  mem = pos;
	  pos = state.skipChars(pos, marker);

	  len = pos - mem;

	  if (len < 3) { return false; }

	  markup = state.src.slice(mem, pos);
	  params = state.src.slice(pos, max);

	  if (params.indexOf('`') >= 0) { return false; }

	  // Since start is found, we can report success here in validation mode
	  if (silent) { return true; }

	  // search end of block
	  nextLine = startLine;

	  for (;;) {
	    nextLine++;
	    if (nextLine >= endLine) {
	      // unclosed block should be autoclosed by end of document.
	      // also block seems to be autoclosed by end of parent
	      break;
	    }

	    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
	    max = state.eMarks[nextLine];

	    if (pos < max && state.tShift[nextLine] < state.blkIndent) {
	      // non-empty line with negative indent should stop the list:
	      // - ```
	      //  test
	      break;
	    }

	    if (state.src.charCodeAt(pos) !== marker) { continue; }

	    if (state.tShift[nextLine] - state.blkIndent >= 4) {
	      // closing fence should be indented less than 4 spaces
	      continue;
	    }

	    pos = state.skipChars(pos, marker);

	    // closing code fence must be at least as long as the opening one
	    if (pos - mem < len) { continue; }

	    // make sure tail has spaces only
	    pos = state.skipSpaces(pos);

	    if (pos < max) { continue; }

	    haveEndMarker = true;
	    // found!
	    break;
	  }

	  // If a fence has heading spaces, they should be removed from its inner block
	  len = state.tShift[startLine];

	  state.line = nextLine + (haveEndMarker ? 1 : 0);

	  token         = state.push('fence', 'code', 0);
	  token.info    = params;
	  token.content = state.getLines(startLine + 1, nextLine, len, true);
	  token.markup  = markup;
	  token.map     = [ startLine, state.line ];

	  return true;
	};


/***/ },
/* 62 */
/***/ function(module, exports) {

	// Block quotes

	'use strict';


	module.exports = function blockquote(state, startLine, endLine, silent) {
	  var nextLine, lastLineEmpty, oldTShift, oldBMarks, oldIndent, oldParentType, lines,
	      terminatorRules, token,
	      i, l, terminate,
	      pos = state.bMarks[startLine] + state.tShift[startLine],
	      max = state.eMarks[startLine];

	  // check the block quote marker
	  if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }

	  // we know that it's going to be a valid blockquote,
	  // so no point trying to find the end of it in silent mode
	  if (silent) { return true; }

	  // skip one optional space after '>'
	  if (state.src.charCodeAt(pos) === 0x20) { pos++; }

	  oldIndent = state.blkIndent;
	  state.blkIndent = 0;

	  oldBMarks = [ state.bMarks[startLine] ];
	  state.bMarks[startLine] = pos;

	  // check if we have an empty blockquote
	  pos = pos < max ? state.skipSpaces(pos) : pos;
	  lastLineEmpty = pos >= max;

	  oldTShift = [ state.tShift[startLine] ];
	  state.tShift[startLine] = pos - state.bMarks[startLine];

	  terminatorRules = state.md.block.ruler.getRules('blockquote');

	  // Search the end of the block
	  //
	  // Block ends with either:
	  //  1. an empty line outside:
	  //     ```
	  //     > test
	  //
	  //     ```
	  //  2. an empty line inside:
	  //     ```
	  //     >
	  //     test
	  //     ```
	  //  3. another tag
	  //     ```
	  //     > test
	  //      - - -
	  //     ```
	  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
	    if (state.tShift[nextLine] < oldIndent) { break; }

	    pos = state.bMarks[nextLine] + state.tShift[nextLine];
	    max = state.eMarks[nextLine];

	    if (pos >= max) {
	      // Case 1: line is not inside the blockquote, and this line is empty.
	      break;
	    }

	    if (state.src.charCodeAt(pos++) === 0x3E/* > */) {
	      // This line is inside the blockquote.

	      // skip one optional space after '>'
	      if (state.src.charCodeAt(pos) === 0x20) { pos++; }

	      oldBMarks.push(state.bMarks[nextLine]);
	      state.bMarks[nextLine] = pos;

	      pos = pos < max ? state.skipSpaces(pos) : pos;
	      lastLineEmpty = pos >= max;

	      oldTShift.push(state.tShift[nextLine]);
	      state.tShift[nextLine] = pos - state.bMarks[nextLine];
	      continue;
	    }

	    // Case 2: line is not inside the blockquote, and the last line was empty.
	    if (lastLineEmpty) { break; }

	    // Case 3: another tag found.
	    terminate = false;
	    for (i = 0, l = terminatorRules.length; i < l; i++) {
	      if (terminatorRules[i](state, nextLine, endLine, true)) {
	        terminate = true;
	        break;
	      }
	    }
	    if (terminate) { break; }

	    oldBMarks.push(state.bMarks[nextLine]);
	    oldTShift.push(state.tShift[nextLine]);

	    // A negative number means that this is a paragraph continuation;
	    //
	    // Any negative number will do the job here, but it's better for it
	    // to be large enough to make any bugs obvious.
	    state.tShift[nextLine] = -1;
	  }

	  oldParentType = state.parentType;
	  state.parentType = 'blockquote';

	  token        = state.push('blockquote_open', 'blockquote', 1);
	  token.markup = '>';
	  token.map    = lines = [ startLine, 0 ];

	  state.md.block.tokenize(state, startLine, nextLine);

	  token        = state.push('blockquote_close', 'blockquote', -1);
	  token.markup = '>';

	  state.parentType = oldParentType;
	  lines[1] = state.line;

	  // Restore original tShift; this might not be necessary since the parser
	  // has already been here, but just to make sure we can do that.
	  for (i = 0; i < oldTShift.length; i++) {
	    state.bMarks[i + startLine] = oldBMarks[i];
	    state.tShift[i + startLine] = oldTShift[i];
	  }
	  state.blkIndent = oldIndent;

	  return true;
	};


/***/ },
/* 63 */
/***/ function(module, exports) {

	// Horizontal rule

	'use strict';


	module.exports = function hr(state, startLine, endLine, silent) {
	  var marker, cnt, ch, token,
	      pos = state.bMarks[startLine] + state.tShift[startLine],
	      max = state.eMarks[startLine];

	  marker = state.src.charCodeAt(pos++);

	  // Check hr marker
	  if (marker !== 0x2A/* * */ &&
	      marker !== 0x2D/* - */ &&
	      marker !== 0x5F/* _ */) {
	    return false;
	  }

	  // markers can be mixed with spaces, but there should be at least 3 one

	  cnt = 1;
	  while (pos < max) {
	    ch = state.src.charCodeAt(pos++);
	    if (ch !== marker && ch !== 0x20/* space */) { return false; }
	    if (ch === marker) { cnt++; }
	  }

	  if (cnt < 3) { return false; }

	  if (silent) { return true; }

	  state.line = startLine + 1;

	  token        = state.push('hr', 'hr', 0);
	  token.map    = [ startLine, state.line ];
	  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));

	  return true;
	};


/***/ },
/* 64 */
/***/ function(module, exports) {

	// Lists

	'use strict';


	// Search `[-+*][\n ]`, returns next pos arter marker on success
	// or -1 on fail.
	function skipBulletListMarker(state, startLine) {
	  var marker, pos, max;

	  pos = state.bMarks[startLine] + state.tShift[startLine];
	  max = state.eMarks[startLine];

	  marker = state.src.charCodeAt(pos++);
	  // Check bullet
	  if (marker !== 0x2A/* * */ &&
	      marker !== 0x2D/* - */ &&
	      marker !== 0x2B/* + */) {
	    return -1;
	  }

	  if (pos < max && state.src.charCodeAt(pos) !== 0x20) {
	    // " 1.test " - is not a list item
	    return -1;
	  }

	  return pos;
	}

	// Search `\d+[.)][\n ]`, returns next pos arter marker on success
	// or -1 on fail.
	function skipOrderedListMarker(state, startLine) {
	  var ch,
	      start = state.bMarks[startLine] + state.tShift[startLine],
	      pos = start,
	      max = state.eMarks[startLine];

	  // List marker should have at least 2 chars (digit + dot)
	  if (pos + 1 >= max) { return -1; }

	  ch = state.src.charCodeAt(pos++);

	  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1; }

	  for (;;) {
	    // EOL -> fail
	    if (pos >= max) { return -1; }

	    ch = state.src.charCodeAt(pos++);

	    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {

	      // List marker should have no more than 9 digits
	      // (prevents integer overflow in browsers)
	      if (pos - start >= 10) { return -1; }

	      continue;
	    }

	    // found valid marker
	    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {
	      break;
	    }

	    return -1;
	  }


	  if (pos < max && state.src.charCodeAt(pos) !== 0x20/* space */) {
	    // " 1.test " - is not a list item
	    return -1;
	  }
	  return pos;
	}

	function markTightParagraphs(state, idx) {
	  var i, l,
	      level = state.level + 2;

	  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
	    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
	      state.tokens[i + 2].hidden = true;
	      state.tokens[i].hidden = true;
	      i += 2;
	    }
	  }
	}


	module.exports = function list(state, startLine, endLine, silent) {
	  var nextLine,
	      indent,
	      oldTShift,
	      oldIndent,
	      oldTight,
	      oldParentType,
	      start,
	      posAfterMarker,
	      max,
	      indentAfterMarker,
	      markerValue,
	      markerCharCode,
	      isOrdered,
	      contentStart,
	      listTokIdx,
	      prevEmptyEnd,
	      listLines,
	      itemLines,
	      tight = true,
	      terminatorRules,
	      token,
	      i, l, terminate;

	  // Detect list type and position after marker
	  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
	    isOrdered = true;
	  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
	    isOrdered = false;
	  } else {
	    return false;
	  }

	  // We should terminate list on style change. Remember first one to compare.
	  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);

	  // For validation mode we can terminate immediately
	  if (silent) { return true; }

	  // Start list
	  listTokIdx = state.tokens.length;

	  if (isOrdered) {
	    start = state.bMarks[startLine] + state.tShift[startLine];
	    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));

	    token       = state.push('ordered_list_open', 'ol', 1);
	    if (markerValue !== 1) {
	      token.attrs = [ [ 'start', markerValue ] ];
	    }

	  } else {
	    token       = state.push('bullet_list_open', 'ul', 1);
	  }

	  token.map    = listLines = [ startLine, 0 ];
	  token.markup = String.fromCharCode(markerCharCode);

	  //
	  // Iterate list items
	  //

	  nextLine = startLine;
	  prevEmptyEnd = false;
	  terminatorRules = state.md.block.ruler.getRules('list');

	  while (nextLine < endLine) {
	    contentStart = state.skipSpaces(posAfterMarker);
	    max = state.eMarks[nextLine];

	    if (contentStart >= max) {
	      // trimming space in "-    \n  3" case, indent is 1 here
	      indentAfterMarker = 1;
	    } else {
	      indentAfterMarker = contentStart - posAfterMarker;
	    }

	    // If we have more than 4 spaces, the indent is 1
	    // (the rest is just indented code block)
	    if (indentAfterMarker > 4) { indentAfterMarker = 1; }

	    // "  -  test"
	    //  ^^^^^ - calculating total length of this thing
	    indent = (posAfterMarker - state.bMarks[nextLine]) + indentAfterMarker;

	    // Run subparser & write tokens
	    token        = state.push('list_item_open', 'li', 1);
	    token.markup = String.fromCharCode(markerCharCode);
	    token.map    = itemLines = [ startLine, 0 ];

	    oldIndent = state.blkIndent;
	    oldTight = state.tight;
	    oldTShift = state.tShift[startLine];
	    oldParentType = state.parentType;
	    state.tShift[startLine] = contentStart - state.bMarks[startLine];
	    state.blkIndent = indent;
	    state.tight = true;
	    state.parentType = 'list';

	    state.md.block.tokenize(state, startLine, endLine, true);

	    // If any of list item is tight, mark list as tight
	    if (!state.tight || prevEmptyEnd) {
	      tight = false;
	    }
	    // Item become loose if finish with empty line,
	    // but we should filter last element, because it means list finish
	    prevEmptyEnd = (state.line - startLine) > 1 && state.isEmpty(state.line - 1);

	    state.blkIndent = oldIndent;
	    state.tShift[startLine] = oldTShift;
	    state.tight = oldTight;
	    state.parentType = oldParentType;

	    token        = state.push('list_item_close', 'li', -1);
	    token.markup = String.fromCharCode(markerCharCode);

	    nextLine = startLine = state.line;
	    itemLines[1] = nextLine;
	    contentStart = state.bMarks[startLine];

	    if (nextLine >= endLine) { break; }

	    if (state.isEmpty(nextLine)) {
	      break;
	    }

	    //
	    // Try to check if list is terminated or continued.
	    //
	    if (state.tShift[nextLine] < state.blkIndent) { break; }

	    // fail if terminating block found
	    terminate = false;
	    for (i = 0, l = terminatorRules.length; i < l; i++) {
	      if (terminatorRules[i](state, nextLine, endLine, true)) {
	        terminate = true;
	        break;
	      }
	    }
	    if (terminate) { break; }

	    // fail if list has another type
	    if (isOrdered) {
	      posAfterMarker = skipOrderedListMarker(state, nextLine);
	      if (posAfterMarker < 0) { break; }
	    } else {
	      posAfterMarker = skipBulletListMarker(state, nextLine);
	      if (posAfterMarker < 0) { break; }
	    }

	    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break; }
	  }

	  // Finilize list
	  if (isOrdered) {
	    token = state.push('ordered_list_close', 'ol', -1);
	  } else {
	    token = state.push('bullet_list_close', 'ul', -1);
	  }
	  token.markup = String.fromCharCode(markerCharCode);

	  listLines[1] = nextLine;
	  state.line = nextLine;

	  // mark paragraphs tight if needed
	  if (tight) {
	    markTightParagraphs(state, listTokIdx);
	  }

	  return true;
	};


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	var parseLinkDestination = __webpack_require__(46);
	var parseLinkTitle       = __webpack_require__(47);
	var normalizeReference   = __webpack_require__(30).normalizeReference;


	module.exports = function reference(state, startLine, _endLine, silent) {
	  var ch,
	      destEndPos,
	      destEndLineNo,
	      endLine,
	      href,
	      i,
	      l,
	      label,
	      labelEnd,
	      res,
	      start,
	      str,
	      terminate,
	      terminatorRules,
	      title,
	      lines = 0,
	      pos = state.bMarks[startLine] + state.tShift[startLine],
	      max = state.eMarks[startLine],
	      nextLine = startLine + 1;

	  if (state.src.charCodeAt(pos) !== 0x5B/* [ */) { return false; }

	  // Simple check to quickly interrupt scan on [link](url) at the start of line.
	  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54
	  while (++pos < max) {
	    if (state.src.charCodeAt(pos) === 0x5D /* ] */ &&
	        state.src.charCodeAt(pos - 1) !== 0x5C/* \ */) {
	      if (pos + 1 === max) { return false; }
	      if (state.src.charCodeAt(pos + 1) !== 0x3A/* : */) { return false; }
	      break;
	    }
	  }

	  endLine = state.lineMax;

	  // jump line-by-line until empty one or EOF
	  terminatorRules = state.md.block.ruler.getRules('reference');

	  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
	    // this would be a code block normally, but after paragraph
	    // it's considered a lazy continuation regardless of what's there
	    if (state.tShift[nextLine] - state.blkIndent > 3) { continue; }

	    // quirk for blockquotes, this line should already be checked by that rule
	    if (state.tShift[nextLine] < 0) { continue; }

	    // Some tags can terminate paragraph without empty line.
	    terminate = false;
	    for (i = 0, l = terminatorRules.length; i < l; i++) {
	      if (terminatorRules[i](state, nextLine, endLine, true)) {
	        terminate = true;
	        break;
	      }
	    }
	    if (terminate) { break; }
	  }

	  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
	  max = str.length;

	  for (pos = 1; pos < max; pos++) {
	    ch = str.charCodeAt(pos);
	    if (ch === 0x5B /* [ */) {
	      return false;
	    } else if (ch === 0x5D /* ] */) {
	      labelEnd = pos;
	      break;
	    } else if (ch === 0x0A /* \n */) {
	      lines++;
	    } else if (ch === 0x5C /* \ */) {
	      pos++;
	      if (pos < max && str.charCodeAt(pos) === 0x0A) {
	        lines++;
	      }
	    }
	  }

	  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return false; }

	  // [label]:   destination   'title'
	  //         ^^^ skip optional whitespace here
	  for (pos = labelEnd + 2; pos < max; pos++) {
	    ch = str.charCodeAt(pos);
	    if (ch === 0x0A) {
	      lines++;
	    } else if (ch === 0x20) {
	      /*eslint no-empty:0*/
	    } else {
	      break;
	    }
	  }

	  // [label]:   destination   'title'
	  //            ^^^^^^^^^^^ parse this
	  res = parseLinkDestination(str, pos, max);
	  if (!res.ok) { return false; }

	  href = state.md.normalizeLink(res.str);
	  if (!state.md.validateLink(href)) { return false; }

	  pos = res.pos;
	  lines += res.lines;

	  // save cursor state, we could require to rollback later
	  destEndPos = pos;
	  destEndLineNo = lines;

	  // [label]:   destination   'title'
	  //                       ^^^ skipping those spaces
	  start = pos;
	  for (; pos < max; pos++) {
	    ch = str.charCodeAt(pos);
	    if (ch === 0x0A) {
	      lines++;
	    } else if (ch === 0x20) {
	      /*eslint no-empty:0*/
	    } else {
	      break;
	    }
	  }

	  // [label]:   destination   'title'
	  //                          ^^^^^^^ parse this
	  res = parseLinkTitle(str, pos, max);
	  if (pos < max && start !== pos && res.ok) {
	    title = res.str;
	    pos = res.pos;
	    lines += res.lines;
	  } else {
	    title = '';
	    pos = destEndPos;
	    lines = destEndLineNo;
	  }

	  // skip trailing spaces until the rest of the line
	  while (pos < max && str.charCodeAt(pos) === 0x20/* space */) { pos++; }

	  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
	    if (title) {
	      // garbage at the end of the line after title,
	      // but it could still be a valid reference if we roll back
	      title = '';
	      pos = destEndPos;
	      lines = destEndLineNo;
	      while (pos < max && str.charCodeAt(pos) === 0x20/* space */) { pos++; }
	    }
	  }

	  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
	    // garbage at the end of the line
	    return false;
	  }

	  label = normalizeReference(str.slice(1, labelEnd));
	  if (!label) {
	    // CommonMark 0.20 disallows empty labels
	    return false;
	  }

	  // Reference can not terminate anything. This check is for safety only.
	  /*istanbul ignore if*/
	  if (silent) { return true; }

	  if (typeof state.env.references === 'undefined') {
	    state.env.references = {};
	  }
	  if (typeof state.env.references[label] === 'undefined') {
	    state.env.references[label] = { title: title, href: href };
	  }

	  state.line = startLine + lines + 1;
	  return true;
	};


/***/ },
/* 66 */
/***/ function(module, exports) {

	// heading (#, ##, ...)

	'use strict';


	module.exports = function heading(state, startLine, endLine, silent) {
	  var ch, level, tmp, token,
	      pos = state.bMarks[startLine] + state.tShift[startLine],
	      max = state.eMarks[startLine];

	  ch  = state.src.charCodeAt(pos);

	  if (ch !== 0x23/* # */ || pos >= max) { return false; }

	  // count heading level
	  level = 1;
	  ch = state.src.charCodeAt(++pos);
	  while (ch === 0x23/* # */ && pos < max && level <= 6) {
	    level++;
	    ch = state.src.charCodeAt(++pos);
	  }

	  if (level > 6 || (pos < max && ch !== 0x20/* space */)) { return false; }

	  if (silent) { return true; }

	  // Let's cut tails like '    ###  ' from the end of string

	  max = state.skipCharsBack(max, 0x20, pos); // space
	  tmp = state.skipCharsBack(max, 0x23, pos); // #
	  if (tmp > pos && state.src.charCodeAt(tmp - 1) === 0x20/* space */) {
	    max = tmp;
	  }

	  state.line = startLine + 1;

	  token        = state.push('heading_open', 'h' + String(level), 1);
	  token.markup = '########'.slice(0, level);
	  token.map    = [ startLine, state.line ];

	  token          = state.push('inline', '', 0);
	  token.content  = state.src.slice(pos, max).trim();
	  token.map      = [ startLine, state.line ];
	  token.children = [];

	  token        = state.push('heading_close', 'h' + String(level), -1);
	  token.markup = '########'.slice(0, level);

	  return true;
	};


/***/ },
/* 67 */
/***/ function(module, exports) {

	// lheading (---, ===)

	'use strict';


	module.exports = function lheading(state, startLine, endLine/*, silent*/) {
	  var marker, pos, max, token, level,
	      next = startLine + 1;

	  if (next >= endLine) { return false; }
	  if (state.tShift[next] < state.blkIndent) { return false; }

	  // Scan next line

	  if (state.tShift[next] - state.blkIndent > 3) { return false; }

	  pos = state.bMarks[next] + state.tShift[next];
	  max = state.eMarks[next];

	  if (pos >= max) { return false; }

	  marker = state.src.charCodeAt(pos);

	  if (marker !== 0x2D/* - */ && marker !== 0x3D/* = */) { return false; }

	  pos = state.skipChars(pos, marker);

	  pos = state.skipSpaces(pos);

	  if (pos < max) { return false; }

	  pos = state.bMarks[startLine] + state.tShift[startLine];

	  state.line = next + 1;
	  level = (marker === 0x3D/* = */ ? 1 : 2);

	  token          = state.push('heading_open', 'h' + String(level), 1);
	  token.markup   = String.fromCharCode(marker);
	  token.map      = [ startLine, state.line ];

	  token          = state.push('inline', '', 0);
	  token.content  = state.src.slice(pos, state.eMarks[startLine]).trim();
	  token.map      = [ startLine, state.line - 1 ];
	  token.children = [];

	  token          = state.push('heading_close', 'h' + String(level), -1);
	  token.markup   = String.fromCharCode(marker);

	  return true;
	};


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	// HTML block

	'use strict';


	var block_names = __webpack_require__(69);
	var HTML_OPEN_CLOSE_TAG_RE = __webpack_require__(70).HTML_OPEN_CLOSE_TAG_RE;

	// An array of opening and corresponding closing sequences for html tags,
	// last argument defines whether it can terminate a paragraph or not
	//
	var HTML_SEQUENCES = [
	  [ /^<(script|pre|style)(?=(\s|>|$))/i, /<\/(script|pre|style)>/i, true ],
	  [ /^<!--/,        /-->/,   true ],
	  [ /^<\?/,         /\?>/,   true ],
	  [ /^<![A-Z]/,     />/,     true ],
	  [ /^<!\[CDATA\[/, /\]\]>/, true ],
	  [ new RegExp('^</?(' + block_names.join('|') + ')(?=(\\s|/?>|$))', 'i'), /^$/, true ],
	  [ new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\s*$'),  /^$/, false ]
	];


	module.exports = function html_block(state, startLine, endLine, silent) {
	  var i, nextLine, token, lineText,
	      pos = state.bMarks[startLine] + state.tShift[startLine],
	      max = state.eMarks[startLine];

	  if (!state.md.options.html) { return false; }

	  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }

	  lineText = state.src.slice(pos, max);

	  for (i = 0; i < HTML_SEQUENCES.length; i++) {
	    if (HTML_SEQUENCES[i][0].test(lineText)) { break; }
	  }

	  if (i === HTML_SEQUENCES.length) { return false; }

	  if (silent) {
	    // true if this sequence can be a terminator, false otherwise
	    return HTML_SEQUENCES[i][2];
	  }

	  nextLine = startLine + 1;

	  // If we are here - we detected HTML block.
	  // Let's roll down till block end.
	  if (!HTML_SEQUENCES[i][1].test(lineText)) {
	    for (; nextLine < endLine; nextLine++) {
	      if (state.tShift[nextLine] < state.blkIndent) { break; }

	      pos = state.bMarks[nextLine] + state.tShift[nextLine];
	      max = state.eMarks[nextLine];
	      lineText = state.src.slice(pos, max);

	      if (HTML_SEQUENCES[i][1].test(lineText)) {
	        if (lineText.length !== 0) { nextLine++; }
	        break;
	      }
	    }
	  }

	  state.line = nextLine;

	  token         = state.push('html_block', '', 0);
	  token.map     = [ startLine, nextLine ];
	  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);

	  return true;
	};


/***/ },
/* 69 */
/***/ function(module, exports) {

	// List of valid html blocks names, accorting to commonmark spec
	// http://jgm.github.io/CommonMark/spec.html#html-blocks

	'use strict';


	module.exports = [
	  'address',
	  'article',
	  'aside',
	  'base',
	  'basefont',
	  'blockquote',
	  'body',
	  'caption',
	  'center',
	  'col',
	  'colgroup',
	  'dd',
	  'details',
	  'dialog',
	  'dir',
	  'div',
	  'dl',
	  'dt',
	  'fieldset',
	  'figcaption',
	  'figure',
	  'footer',
	  'form',
	  'frame',
	  'frameset',
	  'h1',
	  'head',
	  'header',
	  'hr',
	  'html',
	  'legend',
	  'li',
	  'link',
	  'main',
	  'menu',
	  'menuitem',
	  'meta',
	  'nav',
	  'noframes',
	  'ol',
	  'optgroup',
	  'option',
	  'p',
	  'param',
	  'pre',
	  'section',
	  'source',
	  'title',
	  'summary',
	  'table',
	  'tbody',
	  'td',
	  'tfoot',
	  'th',
	  'thead',
	  'title',
	  'tr',
	  'track',
	  'ul'
	];


/***/ },
/* 70 */
/***/ function(module, exports) {

	// Regexps to match html elements

	'use strict';

	var attr_name     = '[a-zA-Z_:][a-zA-Z0-9:._-]*';

	var unquoted      = '[^"\'=<>`\\x00-\\x20]+';
	var single_quoted = "'[^']*'";
	var double_quoted = '"[^"]*"';

	var attr_value  = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';

	var attribute   = '(?:\\s+' + attr_name + '(?:\\s*=\\s*' + attr_value + ')?)';

	var open_tag    = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>';

	var close_tag   = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
	var comment     = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
	var processing  = '<[?].*?[?]>';
	var declaration = '<![A-Z]+\\s+[^>]*>';
	var cdata       = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';

	var HTML_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment +
	                        '|' + processing + '|' + declaration + '|' + cdata + ')');
	var HTML_OPEN_CLOSE_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');

	module.exports.HTML_TAG_RE = HTML_TAG_RE;
	module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;


/***/ },
/* 71 */
/***/ function(module, exports) {

	// GFM table, non-standard

	'use strict';


	function getLine(state, line) {
	  var pos = state.bMarks[line] + state.blkIndent,
	      max = state.eMarks[line];

	  return state.src.substr(pos, max - pos);
	}

	function escapedSplit(str) {
	  var result = [],
	      pos = 0,
	      max = str.length,
	      ch,
	      escapes = 0,
	      lastPos = 0,
	      backTicked = false,
	      lastBackTick = 0;

	  ch  = str.charCodeAt(pos);

	  while (pos < max) {
	    if (ch === 0x60/* ` */ && (escapes % 2 === 0)) {
	      backTicked = !backTicked;
	      lastBackTick = pos;
	    } else if (ch === 0x7c/* | */ && (escapes % 2 === 0) && !backTicked) {
	      result.push(str.substring(lastPos, pos));
	      lastPos = pos + 1;
	    } else if (ch === 0x5c/* \ */) {
	      escapes++;
	    } else {
	      escapes = 0;
	    }

	    pos++;

	    // If there was an un-closed backtick, go back to just after
	    // the last backtick, but as if it was a normal character
	    if (pos === max && backTicked) {
	      backTicked = false;
	      pos = lastBackTick + 1;
	    }

	    ch = str.charCodeAt(pos);
	  }

	  result.push(str.substring(lastPos));

	  return result;
	}


	module.exports = function table(state, startLine, endLine, silent) {
	  var ch, lineText, pos, i, nextLine, rows, token,
	      aligns, t, tableLines, tbodyLines;

	  // should have at least three lines
	  if (startLine + 2 > endLine) { return false; }

	  nextLine = startLine + 1;

	  if (state.tShift[nextLine] < state.blkIndent) { return false; }

	  // first character of the second line should be '|' or '-'

	  pos = state.bMarks[nextLine] + state.tShift[nextLine];
	  if (pos >= state.eMarks[nextLine]) { return false; }

	  ch = state.src.charCodeAt(pos);
	  if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */) { return false; }

	  lineText = getLine(state, startLine + 1);
	  if (!/^[-:| ]+$/.test(lineText)) { return false; }

	  rows = lineText.split('|');
	  if (rows.length < 2) { return false; }
	  aligns = [];
	  for (i = 0; i < rows.length; i++) {
	    t = rows[i].trim();
	    if (!t) {
	      // allow empty columns before and after table, but not in between columns;
	      // e.g. allow ` |---| `, disallow ` ---||--- `
	      if (i === 0 || i === rows.length - 1) {
	        continue;
	      } else {
	        return false;
	      }
	    }

	    if (!/^:?-+:?$/.test(t)) { return false; }
	    if (t.charCodeAt(t.length - 1) === 0x3A/* : */) {
	      aligns.push(t.charCodeAt(0) === 0x3A/* : */ ? 'center' : 'right');
	    } else if (t.charCodeAt(0) === 0x3A/* : */) {
	      aligns.push('left');
	    } else {
	      aligns.push('');
	    }
	  }

	  lineText = getLine(state, startLine).trim();
	  if (lineText.indexOf('|') === -1) { return false; }
	  rows = escapedSplit(lineText.replace(/^\||\|$/g, ''));
	  if (aligns.length !== rows.length) { return false; }
	  if (silent) { return true; }

	  token     = state.push('table_open', 'table', 1);
	  token.map = tableLines = [ startLine, 0 ];

	  token     = state.push('thead_open', 'thead', 1);
	  token.map = [ startLine, startLine + 1 ];

	  token     = state.push('tr_open', 'tr', 1);
	  token.map = [ startLine, startLine + 1 ];

	  for (i = 0; i < rows.length; i++) {
	    token          = state.push('th_open', 'th', 1);
	    token.map      = [ startLine, startLine + 1 ];
	    if (aligns[i]) {
	      token.attrs  = [ [ 'style', 'text-align:' + aligns[i] ] ];
	    }

	    token          = state.push('inline', '', 0);
	    token.content  = rows[i].trim();
	    token.map      = [ startLine, startLine + 1 ];
	    token.children = [];

	    token          = state.push('th_close', 'th', -1);
	  }

	  token     = state.push('tr_close', 'tr', -1);
	  token     = state.push('thead_close', 'thead', -1);

	  token     = state.push('tbody_open', 'tbody', 1);
	  token.map = tbodyLines = [ startLine + 2, 0 ];

	  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
	    if (state.tShift[nextLine] < state.blkIndent) { break; }

	    lineText = getLine(state, nextLine).trim();
	    if (lineText.indexOf('|') === -1) { break; }
	    rows = escapedSplit(lineText.replace(/^\||\|$/g, ''));

	    // set number of columns to number of columns in header row
	    rows.length = aligns.length;

	    token = state.push('tr_open', 'tr', 1);
	    for (i = 0; i < rows.length; i++) {
	      token          = state.push('td_open', 'td', 1);
	      if (aligns[i]) {
	        token.attrs  = [ [ 'style', 'text-align:' + aligns[i] ] ];
	      }

	      token          = state.push('inline', '', 0);
	      token.content  = rows[i] ? rows[i].trim() : '';
	      token.children = [];

	      token          = state.push('td_close', 'td', -1);
	    }
	    token = state.push('tr_close', 'tr', -1);
	  }
	  token = state.push('tbody_close', 'tbody', -1);
	  token = state.push('table_close', 'table', -1);

	  tableLines[1] = tbodyLines[1] = nextLine;
	  state.line = nextLine;
	  return true;
	};


/***/ },
/* 72 */
/***/ function(module, exports) {

	// Paragraph

	'use strict';


	module.exports = function paragraph(state, startLine/*, endLine*/) {
	  var content, terminate, i, l, token,
	      nextLine = startLine + 1,
	      terminatorRules = state.md.block.ruler.getRules('paragraph'),
	      endLine = state.lineMax;

	  // jump line-by-line until empty one or EOF
	  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
	    // this would be a code block normally, but after paragraph
	    // it's considered a lazy continuation regardless of what's there
	    if (state.tShift[nextLine] - state.blkIndent > 3) { continue; }

	    // quirk for blockquotes, this line should already be checked by that rule
	    if (state.tShift[nextLine] < 0) { continue; }

	    // Some tags can terminate paragraph without empty line.
	    terminate = false;
	    for (i = 0, l = terminatorRules.length; i < l; i++) {
	      if (terminatorRules[i](state, nextLine, endLine, true)) {
	        terminate = true;
	        break;
	      }
	    }
	    if (terminate) { break; }
	  }

	  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

	  state.line = nextLine;

	  token          = state.push('paragraph_open', 'p', 1);
	  token.map      = [ startLine, state.line ];

	  token          = state.push('inline', '', 0);
	  token.content  = content;
	  token.map      = [ startLine, state.line ];
	  token.children = [];

	  token          = state.push('paragraph_close', 'p', -1);

	  return true;
	};


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	// Parser state class

	'use strict';

	var Token = __webpack_require__(58);


	function StateBlock(src, md, env, tokens) {
	  var ch, s, start, pos, len, indent, indent_found;

	  this.src = src;

	  // link to parser instance
	  this.md     = md;

	  this.env = env;

	  //
	  // Internal state vartiables
	  //

	  this.tokens = tokens;

	  this.bMarks = [];  // line begin offsets for fast jumps
	  this.eMarks = [];  // line end offsets for fast jumps
	  this.tShift = [];  // indent for each line

	  // block parser variables
	  this.blkIndent  = 0; // required block content indent
	                       // (for example, if we are in list)
	  this.line       = 0; // line index in src
	  this.lineMax    = 0; // lines count
	  this.tight      = false;  // loose/tight mode for lists
	  this.parentType = 'root'; // if `list`, block parser stops on two newlines
	  this.ddIndent   = -1; // indent of the current dd block (-1 if there isn't any)

	  this.level = 0;

	  // renderer
	  this.result = '';

	  // Create caches
	  // Generate markers.
	  s = this.src;
	  indent = 0;
	  indent_found = false;

	  for (start = pos = indent = 0, len = s.length; pos < len; pos++) {
	    ch = s.charCodeAt(pos);

	    if (!indent_found) {
	      if (ch === 0x20/* space */) {
	        indent++;
	        continue;
	      } else {
	        indent_found = true;
	      }
	    }

	    if (ch === 0x0A || pos === len - 1) {
	      if (ch !== 0x0A) { pos++; }
	      this.bMarks.push(start);
	      this.eMarks.push(pos);
	      this.tShift.push(indent);

	      indent_found = false;
	      indent = 0;
	      start = pos + 1;
	    }
	  }

	  // Push fake entry to simplify cache bounds checks
	  this.bMarks.push(s.length);
	  this.eMarks.push(s.length);
	  this.tShift.push(0);

	  this.lineMax = this.bMarks.length - 1; // don't count last fake line
	}

	// Push new token to "stream".
	//
	StateBlock.prototype.push = function (type, tag, nesting) {
	  var token = new Token(type, tag, nesting);
	  token.block = true;

	  if (nesting < 0) { this.level--; }
	  token.level = this.level;
	  if (nesting > 0) { this.level++; }

	  this.tokens.push(token);
	  return token;
	};

	StateBlock.prototype.isEmpty = function isEmpty(line) {
	  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
	};

	StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
	  for (var max = this.lineMax; from < max; from++) {
	    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
	      break;
	    }
	  }
	  return from;
	};

	// Skip spaces from given position.
	StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
	  for (var max = this.src.length; pos < max; pos++) {
	    if (this.src.charCodeAt(pos) !== 0x20/* space */) { break; }
	  }
	  return pos;
	};

	// Skip char codes from given position
	StateBlock.prototype.skipChars = function skipChars(pos, code) {
	  for (var max = this.src.length; pos < max; pos++) {
	    if (this.src.charCodeAt(pos) !== code) { break; }
	  }
	  return pos;
	};

	// Skip char codes reverse from given position - 1
	StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
	  if (pos <= min) { return pos; }

	  while (pos > min) {
	    if (code !== this.src.charCodeAt(--pos)) { return pos + 1; }
	  }
	  return pos;
	};

	// cut lines range from source.
	StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
	  var i, first, last, queue, shift,
	      line = begin;

	  if (begin >= end) {
	    return '';
	  }

	  // Opt: don't use push queue for single line;
	  if (line + 1 === end) {
	    first = this.bMarks[line] + Math.min(this.tShift[line], indent);
	    last = this.eMarks[end - 1] + (keepLastLF ? 1 : 0);
	    return this.src.slice(first, last);
	  }

	  queue = new Array(end - begin);

	  for (i = 0; line < end; line++, i++) {
	    shift = this.tShift[line];
	    if (shift > indent) { shift = indent; }
	    if (shift < 0) { shift = 0; }

	    first = this.bMarks[line] + shift;

	    if (line + 1 < end || keepLastLF) {
	      // No need for bounds check because we have fake entry on tail.
	      last = this.eMarks[line] + 1;
	    } else {
	      last = this.eMarks[line];
	    }

	    queue[i] = this.src.slice(first, last);
	  }

	  return queue.join('');
	};

	// re-export Token class to use in block rules
	StateBlock.prototype.Token = Token;


	module.exports = StateBlock;


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/** internal
	 * class ParserInline
	 *
	 * Tokenizes paragraph content.
	 **/
	'use strict';


	var Ruler           = __webpack_require__(50);


	////////////////////////////////////////////////////////////////////////////////
	// Parser rules

	var _rules = [
	  [ 'text',            __webpack_require__(75) ],
	  [ 'newline',         __webpack_require__(76) ],
	  [ 'escape',          __webpack_require__(77) ],
	  [ 'backticks',       __webpack_require__(78) ],
	  [ 'strikethrough',   __webpack_require__(79) ],
	  [ 'emphasis',        __webpack_require__(80) ],
	  [ 'link',            __webpack_require__(81) ],
	  [ 'image',           __webpack_require__(82) ],
	  [ 'autolink',        __webpack_require__(83) ],
	  [ 'html_inline',     __webpack_require__(85) ],
	  [ 'entity',          __webpack_require__(86) ]
	];


	/**
	 * new ParserInline()
	 **/
	function ParserInline() {
	  /**
	   * ParserInline#ruler -> Ruler
	   *
	   * [[Ruler]] instance. Keep configuration of inline rules.
	   **/
	  this.ruler = new Ruler();

	  for (var i = 0; i < _rules.length; i++) {
	    this.ruler.push(_rules[i][0], _rules[i][1]);
	  }
	}


	// Skip single token by running all rules in validation mode;
	// returns `true` if any rule reported success
	//
	ParserInline.prototype.skipToken = function (state) {
	  var i, pos = state.pos,
	      rules = this.ruler.getRules(''),
	      len = rules.length,
	      maxNesting = state.md.options.maxNesting,
	      cache = state.cache;


	  if (typeof cache[pos] !== 'undefined') {
	    state.pos = cache[pos];
	    return;
	  }

	  /*istanbul ignore else*/
	  if (state.level < maxNesting) {
	    for (i = 0; i < len; i++) {
	      if (rules[i](state, true)) {
	        cache[pos] = state.pos;
	        return;
	      }
	    }
	  }

	  state.pos++;
	  cache[pos] = state.pos;
	};


	// Generate tokens for input range
	//
	ParserInline.prototype.tokenize = function (state) {
	  var ok, i,
	      rules = this.ruler.getRules(''),
	      len = rules.length,
	      end = state.posMax,
	      maxNesting = state.md.options.maxNesting;

	  while (state.pos < end) {
	    // Try all possible rules.
	    // On success, rule should:
	    //
	    // - update `state.pos`
	    // - update `state.tokens`
	    // - return true

	    if (state.level < maxNesting) {
	      for (i = 0; i < len; i++) {
	        ok = rules[i](state, false);
	        if (ok) { break; }
	      }
	    }

	    if (ok) {
	      if (state.pos >= end) { break; }
	      continue;
	    }

	    state.pending += state.src[state.pos++];
	  }

	  if (state.pending) {
	    state.pushPending();
	  }
	};


	/**
	 * ParserInline.parse(str, md, env, outTokens)
	 *
	 * Process input string and push inline tokens into `outTokens`
	 **/
	ParserInline.prototype.parse = function (str, md, env, outTokens) {
	  var state = new this.State(str, md, env, outTokens);

	  this.tokenize(state);
	};


	ParserInline.prototype.State = __webpack_require__(87);


	module.exports = ParserInline;


/***/ },
/* 75 */
/***/ function(module, exports) {

	// Skip text characters for text token, place those to pending buffer
	// and increment current pos

	'use strict';


	// Rule to skip pure text
	// '{}$%@~+=:' reserved for extentions

	// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~

	// !!!! Don't confuse with "Markdown ASCII Punctuation" chars
	// http://spec.commonmark.org/0.15/#ascii-punctuation-character
	function isTerminatorChar(ch) {
	  switch (ch) {
	    case 0x0A/* \n */:
	    case 0x21/* ! */:
	    case 0x23/* # */:
	    case 0x24/* $ */:
	    case 0x25/* % */:
	    case 0x26/* & */:
	    case 0x2A/* * */:
	    case 0x2B/* + */:
	    case 0x2D/* - */:
	    case 0x3A/* : */:
	    case 0x3C/* < */:
	    case 0x3D/* = */:
	    case 0x3E/* > */:
	    case 0x40/* @ */:
	    case 0x5B/* [ */:
	    case 0x5C/* \ */:
	    case 0x5D/* ] */:
	    case 0x5E/* ^ */:
	    case 0x5F/* _ */:
	    case 0x60/* ` */:
	    case 0x7B/* { */:
	    case 0x7D/* } */:
	    case 0x7E/* ~ */:
	      return true;
	    default:
	      return false;
	  }
	}

	module.exports = function text(state, silent) {
	  var pos = state.pos;

	  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
	    pos++;
	  }

	  if (pos === state.pos) { return false; }

	  if (!silent) { state.pending += state.src.slice(state.pos, pos); }

	  state.pos = pos;

	  return true;
	};

	// Alternative implementation, for memory.
	//
	// It costs 10% of performance, but allows extend terminators list, if place it
	// to `ParcerInline` property. Probably, will switch to it sometime, such
	// flexibility required.

	/*
	var TERMINATOR_RE = /[\n!#$%&*+\-:<=>@[\\\]^_`{}~]/;

	module.exports = function text(state, silent) {
	  var pos = state.pos,
	      idx = state.src.slice(pos).search(TERMINATOR_RE);

	  // first char is terminator -> empty text
	  if (idx === 0) { return false; }

	  // no terminator -> text till end of string
	  if (idx < 0) {
	    if (!silent) { state.pending += state.src.slice(pos); }
	    state.pos = state.src.length;
	    return true;
	  }

	  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }

	  state.pos += idx;

	  return true;
	};*/


/***/ },
/* 76 */
/***/ function(module, exports) {

	// Proceess '\n'

	'use strict';

	module.exports = function newline(state, silent) {
	  var pmax, max, pos = state.pos;

	  if (state.src.charCodeAt(pos) !== 0x0A/* \n */) { return false; }

	  pmax = state.pending.length - 1;
	  max = state.posMax;

	  // '  \n' -> hardbreak
	  // Lookup in pending chars is bad practice! Don't copy to other rules!
	  // Pending string is stored in concat mode, indexed lookups will cause
	  // convertion to flat mode.
	  if (!silent) {
	    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {
	      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {
	        state.pending = state.pending.replace(/ +$/, '');
	        state.push('hardbreak', 'br', 0);
	      } else {
	        state.pending = state.pending.slice(0, -1);
	        state.push('softbreak', 'br', 0);
	      }

	    } else {
	      state.push('softbreak', 'br', 0);
	    }
	  }

	  pos++;

	  // skip heading spaces for next line
	  while (pos < max && state.src.charCodeAt(pos) === 0x20) { pos++; }

	  state.pos = pos;
	  return true;
	};


/***/ },
/* 77 */
/***/ function(module, exports) {

	// Proceess escaped chars and hardbreaks

	'use strict';

	var ESCAPED = [];

	for (var i = 0; i < 256; i++) { ESCAPED.push(0); }

	'\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'
	  .split('').forEach(function(ch) { ESCAPED[ch.charCodeAt(0)] = 1; });


	module.exports = function escape(state, silent) {
	  var ch, pos = state.pos, max = state.posMax;

	  if (state.src.charCodeAt(pos) !== 0x5C/* \ */) { return false; }

	  pos++;

	  if (pos < max) {
	    ch = state.src.charCodeAt(pos);

	    if (ch < 256 && ESCAPED[ch] !== 0) {
	      if (!silent) { state.pending += state.src[pos]; }
	      state.pos += 2;
	      return true;
	    }

	    if (ch === 0x0A) {
	      if (!silent) {
	        state.push('hardbreak', 'br', 0);
	      }

	      pos++;
	      // skip leading whitespaces from next line
	      while (pos < max && state.src.charCodeAt(pos) === 0x20) { pos++; }

	      state.pos = pos;
	      return true;
	    }
	  }

	  if (!silent) { state.pending += '\\'; }
	  state.pos++;
	  return true;
	};


/***/ },
/* 78 */
/***/ function(module, exports) {

	// Parse backticks

	'use strict';

	module.exports = function backtick(state, silent) {
	  var start, max, marker, matchStart, matchEnd, token,
	      pos = state.pos,
	      ch = state.src.charCodeAt(pos);

	  if (ch !== 0x60/* ` */) { return false; }

	  start = pos;
	  pos++;
	  max = state.posMax;

	  while (pos < max && state.src.charCodeAt(pos) === 0x60/* ` */) { pos++; }

	  marker = state.src.slice(start, pos);

	  matchStart = matchEnd = pos;

	  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
	    matchEnd = matchStart + 1;

	    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60/* ` */) { matchEnd++; }

	    if (matchEnd - matchStart === marker.length) {
	      if (!silent) {
	        token         = state.push('code_inline', 'code', 0);
	        token.markup  = marker;
	        token.content = state.src.slice(pos, matchStart)
	                                 .replace(/[ \n]+/g, ' ')
	                                 .trim();
	      }
	      state.pos = matchEnd;
	      return true;
	    }
	  }

	  if (!silent) { state.pending += marker; }
	  state.pos += marker.length;
	  return true;
	};


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	// ~~strike through~~
	//
	'use strict';


	var isWhiteSpace   = __webpack_require__(30).isWhiteSpace;
	var isPunctChar    = __webpack_require__(30).isPunctChar;
	var isMdAsciiPunct = __webpack_require__(30).isMdAsciiPunct;


	// parse sequence of markers,
	// "start" should point at a valid marker
	function scanDelims(state, start) {
	  var pos = start, lastChar, nextChar, count,
	      isLastWhiteSpace, isLastPunctChar,
	      isNextWhiteSpace, isNextPunctChar,
	      can_open = true,
	      can_close = true,
	      max = state.posMax,
	      marker = state.src.charCodeAt(start);

	  // treat beginning of the line as a whitespace
	  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : 0x20;

	  while (pos < max && state.src.charCodeAt(pos) === marker) { pos++; }

	  if (pos >= max) {
	    can_open = false;
	  }

	  count = pos - start;

	  // treat end of the line as a whitespace
	  nextChar = pos < max ? state.src.charCodeAt(pos) : 0x20;

	  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
	  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

	  isLastWhiteSpace = isWhiteSpace(lastChar);
	  isNextWhiteSpace = isWhiteSpace(nextChar);

	  if (isNextWhiteSpace) {
	    can_open = false;
	  } else if (isNextPunctChar) {
	    if (!(isLastWhiteSpace || isLastPunctChar)) {
	      can_open = false;
	    }
	  }

	  if (isLastWhiteSpace) {
	    can_close = false;
	  } else if (isLastPunctChar) {
	    if (!(isNextWhiteSpace || isNextPunctChar)) {
	      can_close = false;
	    }
	  }

	  return {
	    can_open: can_open,
	    can_close: can_close,
	    delims: count
	  };
	}


	module.exports = function strikethrough(state, silent) {
	  var startCount,
	      count,
	      tagCount,
	      found,
	      stack,
	      res,
	      token,
	      max = state.posMax,
	      start = state.pos,
	      marker = state.src.charCodeAt(start);

	  if (marker !== 0x7E/* ~ */) { return false; }
	  if (silent) { return false; } // don't run any pairs in validation mode

	  res = scanDelims(state, start);
	  startCount = res.delims;
	  if (!res.can_open) {
	    state.pos += startCount;
	    // Earlier we checked !silent, but this implementation does not need it
	    state.pending += state.src.slice(start, state.pos);
	    return true;
	  }

	  stack = Math.floor(startCount / 2);
	  if (stack <= 0) { return false; }
	  state.pos = start + startCount;

	  while (state.pos < max) {
	    if (state.src.charCodeAt(state.pos) === marker) {
	      res = scanDelims(state, state.pos);
	      count = res.delims;
	      tagCount = Math.floor(count / 2);
	      if (res.can_close) {
	        if (tagCount >= stack) {
	          state.pos += count - 2;
	          found = true;
	          break;
	        }
	        stack -= tagCount;
	        state.pos += count;
	        continue;
	      }

	      if (res.can_open) { stack += tagCount; }
	      state.pos += count;
	      continue;
	    }

	    state.md.inline.skipToken(state);
	  }

	  if (!found) {
	    // parser failed to find ending tag, so it's not valid emphasis
	    state.pos = start;
	    return false;
	  }

	  // found!
	  state.posMax = state.pos;
	  state.pos = start + 2;

	  // Earlier we checked !silent, but this implementation does not need it
	  token        = state.push('s_open', 's', 1);
	  token.markup = '~~';

	  state.md.inline.tokenize(state);

	  token        = state.push('s_close', 's', -1);
	  token.markup = '~~';

	  state.pos = state.posMax + 2;
	  state.posMax = max;
	  return true;
	};


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	// Process *this* and _that_
	//
	'use strict';


	var isWhiteSpace   = __webpack_require__(30).isWhiteSpace;
	var isPunctChar    = __webpack_require__(30).isPunctChar;
	var isMdAsciiPunct = __webpack_require__(30).isMdAsciiPunct;


	// parse sequence of emphasis markers,
	// "start" should point at a valid marker
	function scanDelims(state, start) {
	  var pos = start, lastChar, nextChar, count, can_open, can_close,
	      isLastWhiteSpace, isLastPunctChar,
	      isNextWhiteSpace, isNextPunctChar,
	      left_flanking = true,
	      right_flanking = true,
	      max = state.posMax,
	      marker = state.src.charCodeAt(start);

	  // treat beginning of the line as a whitespace
	  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : 0x20;

	  while (pos < max && state.src.charCodeAt(pos) === marker) { pos++; }

	  count = pos - start;

	  // treat end of the line as a whitespace
	  nextChar = pos < max ? state.src.charCodeAt(pos) : 0x20;

	  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
	  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

	  isLastWhiteSpace = isWhiteSpace(lastChar);
	  isNextWhiteSpace = isWhiteSpace(nextChar);

	  if (isNextWhiteSpace) {
	    left_flanking = false;
	  } else if (isNextPunctChar) {
	    if (!(isLastWhiteSpace || isLastPunctChar)) {
	      left_flanking = false;
	    }
	  }

	  if (isLastWhiteSpace) {
	    right_flanking = false;
	  } else if (isLastPunctChar) {
	    if (!(isNextWhiteSpace || isNextPunctChar)) {
	      right_flanking = false;
	    }
	  }

	  if (marker === 0x5F /* _ */) {
	    // "_" inside a word can neither open nor close an emphasis
	    can_open  = left_flanking  && (!right_flanking || isLastPunctChar);
	    can_close = right_flanking && (!left_flanking  || isNextPunctChar);
	  } else {
	    can_open  = left_flanking;
	    can_close = right_flanking;
	  }

	  return {
	    can_open: can_open,
	    can_close: can_close,
	    delims: count
	  };
	}

	module.exports = function emphasis(state, silent) {
	  var startCount,
	      count,
	      found,
	      oldCount,
	      newCount,
	      stack,
	      res,
	      token,
	      max = state.posMax,
	      start = state.pos,
	      marker = state.src.charCodeAt(start);

	  if (marker !== 0x5F/* _ */ && marker !== 0x2A /* * */) { return false; }
	  if (silent) { return false; } // don't run any pairs in validation mode

	  res = scanDelims(state, start);
	  startCount = res.delims;
	  if (!res.can_open) {
	    state.pos += startCount;
	    // Earlier we checked !silent, but this implementation does not need it
	    state.pending += state.src.slice(start, state.pos);
	    return true;
	  }

	  state.pos = start + startCount;
	  stack = [ startCount ];

	  while (state.pos < max) {
	    if (state.src.charCodeAt(state.pos) === marker) {
	      res = scanDelims(state, state.pos);
	      count = res.delims;
	      if (res.can_close) {
	        oldCount = stack.pop();
	        newCount = count;

	        while (oldCount !== newCount) {
	          if (newCount < oldCount) {
	            stack.push(oldCount - newCount);
	            break;
	          }

	          // assert(newCount > oldCount)
	          newCount -= oldCount;

	          if (stack.length === 0) { break; }
	          state.pos += oldCount;
	          oldCount = stack.pop();
	        }

	        if (stack.length === 0) {
	          startCount = oldCount;
	          found = true;
	          break;
	        }
	        state.pos += count;
	        continue;
	      }

	      if (res.can_open) { stack.push(count); }
	      state.pos += count;
	      continue;
	    }

	    state.md.inline.skipToken(state);
	  }

	  if (!found) {
	    // parser failed to find ending tag, so it's not valid emphasis
	    state.pos = start;
	    return false;
	  }

	  // found!
	  state.posMax = state.pos;
	  state.pos = start + startCount;

	  // Earlier we checked !silent, but this implementation does not need it

	  // we have `startCount` starting and ending markers,
	  // now trying to serialize them into tokens
	  for (count = startCount; count > 1; count -= 2) {
	    token        = state.push('strong_open', 'strong', 1);
	    token.markup = String.fromCharCode(marker) + String.fromCharCode(marker);
	  }
	  if (count % 2) {
	    token        = state.push('em_open', 'em', 1);
	    token.markup = String.fromCharCode(marker);
	  }

	  state.md.inline.tokenize(state);

	  if (count % 2) {
	    token        = state.push('em_close', 'em', -1);
	    token.markup = String.fromCharCode(marker);
	  }
	  for (count = startCount; count > 1; count -= 2) {
	    token        = state.push('strong_close', 'strong', -1);
	    token.markup = String.fromCharCode(marker) + String.fromCharCode(marker);
	  }

	  state.pos = state.posMax + startCount;
	  state.posMax = max;
	  return true;
	};


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	// Process [link](<to> "stuff")

	'use strict';

	var parseLinkLabel       = __webpack_require__(45);
	var parseLinkDestination = __webpack_require__(46);
	var parseLinkTitle       = __webpack_require__(47);
	var normalizeReference   = __webpack_require__(30).normalizeReference;


	module.exports = function link(state, silent) {
	  var attrs,
	      code,
	      label,
	      labelEnd,
	      labelStart,
	      pos,
	      res,
	      ref,
	      title,
	      token,
	      href = '',
	      oldPos = state.pos,
	      max = state.posMax,
	      start = state.pos;

	  if (state.src.charCodeAt(state.pos) !== 0x5B/* [ */) { return false; }

	  labelStart = state.pos + 1;
	  labelEnd = parseLinkLabel(state, state.pos, true);

	  // parser failed to find ']', so it's not a valid link
	  if (labelEnd < 0) { return false; }

	  pos = labelEnd + 1;
	  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {
	    //
	    // Inline link
	    //

	    // [link](  <href>  "title"  )
	    //        ^^ skipping these spaces
	    pos++;
	    for (; pos < max; pos++) {
	      code = state.src.charCodeAt(pos);
	      if (code !== 0x20 && code !== 0x0A) { break; }
	    }
	    if (pos >= max) { return false; }

	    // [link](  <href>  "title"  )
	    //          ^^^^^^ parsing link destination
	    start = pos;
	    res = parseLinkDestination(state.src, pos, state.posMax);
	    if (res.ok) {
	      href = state.md.normalizeLink(res.str);
	      if (state.md.validateLink(href)) {
	        pos = res.pos;
	      } else {
	        href = '';
	      }
	    }

	    // [link](  <href>  "title"  )
	    //                ^^ skipping these spaces
	    start = pos;
	    for (; pos < max; pos++) {
	      code = state.src.charCodeAt(pos);
	      if (code !== 0x20 && code !== 0x0A) { break; }
	    }

	    // [link](  <href>  "title"  )
	    //                  ^^^^^^^ parsing link title
	    res = parseLinkTitle(state.src, pos, state.posMax);
	    if (pos < max && start !== pos && res.ok) {
	      title = res.str;
	      pos = res.pos;

	      // [link](  <href>  "title"  )
	      //                         ^^ skipping these spaces
	      for (; pos < max; pos++) {
	        code = state.src.charCodeAt(pos);
	        if (code !== 0x20 && code !== 0x0A) { break; }
	      }
	    } else {
	      title = '';
	    }

	    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {
	      state.pos = oldPos;
	      return false;
	    }
	    pos++;
	  } else {
	    //
	    // Link reference
	    //
	    if (typeof state.env.references === 'undefined') { return false; }

	    // [foo]  [bar]
	    //      ^^ optional whitespace (can include newlines)
	    for (; pos < max; pos++) {
	      code = state.src.charCodeAt(pos);
	      if (code !== 0x20 && code !== 0x0A) { break; }
	    }

	    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {
	      start = pos + 1;
	      pos = parseLinkLabel(state, pos);
	      if (pos >= 0) {
	        label = state.src.slice(start, pos++);
	      } else {
	        pos = labelEnd + 1;
	      }
	    } else {
	      pos = labelEnd + 1;
	    }

	    // covers label === '' and label === undefined
	    // (collapsed reference link and shortcut reference link respectively)
	    if (!label) { label = state.src.slice(labelStart, labelEnd); }

	    ref = state.env.references[normalizeReference(label)];
	    if (!ref) {
	      state.pos = oldPos;
	      return false;
	    }
	    href = ref.href;
	    title = ref.title;
	  }

	  //
	  // We found the end of the link, and know for a fact it's a valid link;
	  // so all that's left to do is to call tokenizer.
	  //
	  if (!silent) {
	    state.pos = labelStart;
	    state.posMax = labelEnd;

	    token        = state.push('link_open', 'a', 1);
	    token.attrs  = attrs = [ [ 'href', href ] ];
	    if (title) {
	      attrs.push([ 'title', title ]);
	    }

	    state.md.inline.tokenize(state);

	    token        = state.push('link_close', 'a', -1);
	  }

	  state.pos = pos;
	  state.posMax = max;
	  return true;
	};


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	// Process ![image](<src> "title")

	'use strict';

	var parseLinkLabel       = __webpack_require__(45);
	var parseLinkDestination = __webpack_require__(46);
	var parseLinkTitle       = __webpack_require__(47);
	var normalizeReference   = __webpack_require__(30).normalizeReference;


	module.exports = function image(state, silent) {
	  var attrs,
	      code,
	      label,
	      labelEnd,
	      labelStart,
	      pos,
	      ref,
	      res,
	      title,
	      token,
	      tokens,
	      start,
	      href = '',
	      oldPos = state.pos,
	      max = state.posMax;

	  if (state.src.charCodeAt(state.pos) !== 0x21/* ! */) { return false; }
	  if (state.src.charCodeAt(state.pos + 1) !== 0x5B/* [ */) { return false; }

	  labelStart = state.pos + 2;
	  labelEnd = parseLinkLabel(state, state.pos + 1, false);

	  // parser failed to find ']', so it's not a valid link
	  if (labelEnd < 0) { return false; }

	  pos = labelEnd + 1;
	  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {
	    //
	    // Inline link
	    //

	    // [link](  <href>  "title"  )
	    //        ^^ skipping these spaces
	    pos++;
	    for (; pos < max; pos++) {
	      code = state.src.charCodeAt(pos);
	      if (code !== 0x20 && code !== 0x0A) { break; }
	    }
	    if (pos >= max) { return false; }

	    // [link](  <href>  "title"  )
	    //          ^^^^^^ parsing link destination
	    start = pos;
	    res = parseLinkDestination(state.src, pos, state.posMax);
	    if (res.ok) {
	      href = state.md.normalizeLink(res.str);
	      if (state.md.validateLink(href)) {
	        pos = res.pos;
	      } else {
	        href = '';
	      }
	    }

	    // [link](  <href>  "title"  )
	    //                ^^ skipping these spaces
	    start = pos;
	    for (; pos < max; pos++) {
	      code = state.src.charCodeAt(pos);
	      if (code !== 0x20 && code !== 0x0A) { break; }
	    }

	    // [link](  <href>  "title"  )
	    //                  ^^^^^^^ parsing link title
	    res = parseLinkTitle(state.src, pos, state.posMax);
	    if (pos < max && start !== pos && res.ok) {
	      title = res.str;
	      pos = res.pos;

	      // [link](  <href>  "title"  )
	      //                         ^^ skipping these spaces
	      for (; pos < max; pos++) {
	        code = state.src.charCodeAt(pos);
	        if (code !== 0x20 && code !== 0x0A) { break; }
	      }
	    } else {
	      title = '';
	    }

	    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {
	      state.pos = oldPos;
	      return false;
	    }
	    pos++;
	  } else {
	    //
	    // Link reference
	    //
	    if (typeof state.env.references === 'undefined') { return false; }

	    // [foo]  [bar]
	    //      ^^ optional whitespace (can include newlines)
	    for (; pos < max; pos++) {
	      code = state.src.charCodeAt(pos);
	      if (code !== 0x20 && code !== 0x0A) { break; }
	    }

	    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {
	      start = pos + 1;
	      pos = parseLinkLabel(state, pos);
	      if (pos >= 0) {
	        label = state.src.slice(start, pos++);
	      } else {
	        pos = labelEnd + 1;
	      }
	    } else {
	      pos = labelEnd + 1;
	    }

	    // covers label === '' and label === undefined
	    // (collapsed reference link and shortcut reference link respectively)
	    if (!label) { label = state.src.slice(labelStart, labelEnd); }

	    ref = state.env.references[normalizeReference(label)];
	    if (!ref) {
	      state.pos = oldPos;
	      return false;
	    }
	    href = ref.href;
	    title = ref.title;
	  }

	  //
	  // We found the end of the link, and know for a fact it's a valid link;
	  // so all that's left to do is to call tokenizer.
	  //
	  if (!silent) {
	    state.pos = labelStart;
	    state.posMax = labelEnd;

	    var newState = new state.md.inline.State(
	      state.src.slice(labelStart, labelEnd),
	      state.md,
	      state.env,
	      tokens = []
	    );
	    newState.md.inline.tokenize(newState);

	    token          = state.push('image', 'img', 0);
	    token.attrs    = attrs = [ [ 'src', href ], [ 'alt', '' ] ];
	    token.children = tokens;
	    if (title) {
	      attrs.push([ 'title', title ]);
	    }
	  }

	  state.pos = pos;
	  state.posMax = max;
	  return true;
	};


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	// Process autolinks '<protocol:...>'

	'use strict';

	var url_schemas = __webpack_require__(84);


	/*eslint max-len:0*/
	var EMAIL_RE    = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
	var AUTOLINK_RE = /^<([a-zA-Z.\-]{1,25}):([^<>\x00-\x20]*)>/;


	module.exports = function autolink(state, silent) {
	  var tail, linkMatch, emailMatch, url, fullUrl, token,
	      pos = state.pos;

	  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }

	  tail = state.src.slice(pos);

	  if (tail.indexOf('>') < 0) { return false; }

	  if (AUTOLINK_RE.test(tail)) {
	    linkMatch = tail.match(AUTOLINK_RE);

	    if (url_schemas.indexOf(linkMatch[1].toLowerCase()) < 0) { return false; }

	    url = linkMatch[0].slice(1, -1);
	    fullUrl = state.md.normalizeLink(url);
	    if (!state.md.validateLink(fullUrl)) { return false; }

	    if (!silent) {
	      token         = state.push('link_open', 'a', 1);
	      token.attrs   = [ [ 'href', fullUrl ] ];

	      token         = state.push('text', '', 0);
	      token.content = state.md.normalizeLinkText(url);

	      token         = state.push('link_close', 'a', -1);
	    }

	    state.pos += linkMatch[0].length;
	    return true;
	  }

	  if (EMAIL_RE.test(tail)) {
	    emailMatch = tail.match(EMAIL_RE);

	    url = emailMatch[0].slice(1, -1);
	    fullUrl = state.md.normalizeLink('mailto:' + url);
	    if (!state.md.validateLink(fullUrl)) { return false; }

	    if (!silent) {
	      token         = state.push('link_open', 'a', 1);
	      token.attrs   = [ [ 'href', fullUrl ] ];
	      token.markup  = 'autolink';
	      token.info    = 'auto';

	      token         = state.push('text', '', 0);
	      token.content = state.md.normalizeLinkText(url);

	      token         = state.push('link_close', 'a', -1);
	      token.markup  = 'autolink';
	      token.info    = 'auto';
	    }

	    state.pos += emailMatch[0].length;
	    return true;
	  }

	  return false;
	};


/***/ },
/* 84 */
/***/ function(module, exports) {

	// List of valid url schemas, accorting to commonmark spec
	// http://jgm.github.io/CommonMark/spec.html#autolinks

	'use strict';


	module.exports = [
	  'coap',
	  'doi',
	  'javascript',
	  'aaa',
	  'aaas',
	  'about',
	  'acap',
	  'cap',
	  'cid',
	  'crid',
	  'data',
	  'dav',
	  'dict',
	  'dns',
	  'file',
	  'ftp',
	  'geo',
	  'go',
	  'gopher',
	  'h323',
	  'http',
	  'https',
	  'iax',
	  'icap',
	  'im',
	  'imap',
	  'info',
	  'ipp',
	  'iris',
	  'iris.beep',
	  'iris.xpc',
	  'iris.xpcs',
	  'iris.lwz',
	  'ldap',
	  'mailto',
	  'mid',
	  'msrp',
	  'msrps',
	  'mtqp',
	  'mupdate',
	  'news',
	  'nfs',
	  'ni',
	  'nih',
	  'nntp',
	  'opaquelocktoken',
	  'pop',
	  'pres',
	  'rtsp',
	  'service',
	  'session',
	  'shttp',
	  'sieve',
	  'sip',
	  'sips',
	  'sms',
	  'snmp',
	  'soap.beep',
	  'soap.beeps',
	  'tag',
	  'tel',
	  'telnet',
	  'tftp',
	  'thismessage',
	  'tn3270',
	  'tip',
	  'tv',
	  'urn',
	  'vemmi',
	  'ws',
	  'wss',
	  'xcon',
	  'xcon-userid',
	  'xmlrpc.beep',
	  'xmlrpc.beeps',
	  'xmpp',
	  'z39.50r',
	  'z39.50s',
	  'adiumxtra',
	  'afp',
	  'afs',
	  'aim',
	  'apt',
	  'attachment',
	  'aw',
	  'beshare',
	  'bitcoin',
	  'bolo',
	  'callto',
	  'chrome',
	  'chrome-extension',
	  'com-eventbrite-attendee',
	  'content',
	  'cvs',
	  'dlna-playsingle',
	  'dlna-playcontainer',
	  'dtn',
	  'dvb',
	  'ed2k',
	  'facetime',
	  'feed',
	  'finger',
	  'fish',
	  'gg',
	  'git',
	  'gizmoproject',
	  'gtalk',
	  'hcp',
	  'icon',
	  'ipn',
	  'irc',
	  'irc6',
	  'ircs',
	  'itms',
	  'jar',
	  'jms',
	  'keyparc',
	  'lastfm',
	  'ldaps',
	  'magnet',
	  'maps',
	  'market',
	  'message',
	  'mms',
	  'ms-help',
	  'msnim',
	  'mumble',
	  'mvn',
	  'notes',
	  'oid',
	  'palm',
	  'paparazzi',
	  'platform',
	  'proxy',
	  'psyc',
	  'query',
	  'res',
	  'resource',
	  'rmi',
	  'rsync',
	  'rtmp',
	  'secondlife',
	  'sftp',
	  'sgn',
	  'skype',
	  'smb',
	  'soldat',
	  'spotify',
	  'ssh',
	  'steam',
	  'svn',
	  'teamspeak',
	  'things',
	  'udp',
	  'unreal',
	  'ut2004',
	  'ventrilo',
	  'view-source',
	  'webcal',
	  'wtai',
	  'wyciwyg',
	  'xfire',
	  'xri',
	  'ymsgr'
	];


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	// Process html tags

	'use strict';


	var HTML_TAG_RE = __webpack_require__(70).HTML_TAG_RE;


	function isLetter(ch) {
	  /*eslint no-bitwise:0*/
	  var lc = ch | 0x20; // to lower case
	  return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);
	}


	module.exports = function html_inline(state, silent) {
	  var ch, match, max, token,
	      pos = state.pos;

	  if (!state.md.options.html) { return false; }

	  // Check start
	  max = state.posMax;
	  if (state.src.charCodeAt(pos) !== 0x3C/* < */ ||
	      pos + 2 >= max) {
	    return false;
	  }

	  // Quick fail on second char
	  ch = state.src.charCodeAt(pos + 1);
	  if (ch !== 0x21/* ! */ &&
	      ch !== 0x3F/* ? */ &&
	      ch !== 0x2F/* / */ &&
	      !isLetter(ch)) {
	    return false;
	  }

	  match = state.src.slice(pos).match(HTML_TAG_RE);
	  if (!match) { return false; }

	  if (!silent) {
	    token         = state.push('html_inline', '', 0);
	    token.content = state.src.slice(pos, pos + match[0].length);
	  }
	  state.pos += match[0].length;
	  return true;
	};


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	// Process html entity - &#123;, &#xAF;, &quot;, ...

	'use strict';

	var entities          = __webpack_require__(31);
	var has               = __webpack_require__(30).has;
	var isValidEntityCode = __webpack_require__(30).isValidEntityCode;
	var fromCodePoint     = __webpack_require__(30).fromCodePoint;


	var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;
	var NAMED_RE   = /^&([a-z][a-z0-9]{1,31});/i;


	module.exports = function entity(state, silent) {
	  var ch, code, match, pos = state.pos, max = state.posMax;

	  if (state.src.charCodeAt(pos) !== 0x26/* & */) { return false; }

	  if (pos + 1 < max) {
	    ch = state.src.charCodeAt(pos + 1);

	    if (ch === 0x23 /* # */) {
	      match = state.src.slice(pos).match(DIGITAL_RE);
	      if (match) {
	        if (!silent) {
	          code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
	          state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);
	        }
	        state.pos += match[0].length;
	        return true;
	      }
	    } else {
	      match = state.src.slice(pos).match(NAMED_RE);
	      if (match) {
	        if (has(entities, match[1])) {
	          if (!silent) { state.pending += entities[match[1]]; }
	          state.pos += match[0].length;
	          return true;
	        }
	      }
	    }
	  }

	  if (!silent) { state.pending += '&'; }
	  state.pos++;
	  return true;
	};


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	// Inline parser state

	'use strict';


	var Token = __webpack_require__(58);

	function StateInline(src, md, env, outTokens) {
	  this.src = src;
	  this.env = env;
	  this.md = md;
	  this.tokens = outTokens;

	  this.pos = 0;
	  this.posMax = this.src.length;
	  this.level = 0;
	  this.pending = '';
	  this.pendingLevel = 0;

	  this.cache = {};        // Stores { start: end } pairs. Useful for backtrack
	                          // optimization of pairs parse (emphasis, strikes).
	}


	// Flush pending text
	//
	StateInline.prototype.pushPending = function () {
	  var token = new Token('text', '', 0);
	  token.content = this.pending;
	  token.level = this.pendingLevel;
	  this.tokens.push(token);
	  this.pending = '';
	  return token;
	};


	// Push new token to "stream".
	// If pending text exists - flush it as text token
	//
	StateInline.prototype.push = function (type, tag, nesting) {
	  if (this.pending) {
	    this.pushPending();
	  }

	  var token = new Token(type, tag, nesting);

	  if (nesting < 0) { this.level--; }
	  token.level = this.level;
	  if (nesting > 0) { this.level++; }

	  this.pendingLevel = this.level;
	  this.tokens.push(token);
	  return token;
	};

	// re-export Token class to use in block rules
	StateInline.prototype.Token = Token;


	module.exports = StateInline;


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	////////////////////////////////////////////////////////////////////////////////
	// Helpers

	// Merge objects
	//
	function assign(obj /*from1, from2, from3, ...*/) {
	  var sources = Array.prototype.slice.call(arguments, 1);

	  sources.forEach(function (source) {
	    if (!source) { return; }

	    Object.keys(source).forEach(function (key) {
	      obj[key] = source[key];
	    });
	  });

	  return obj;
	}

	function _class(obj) { return Object.prototype.toString.call(obj); }
	function isString(obj) { return _class(obj) === '[object String]'; }
	function isObject(obj) { return _class(obj) === '[object Object]'; }
	function isRegExp(obj) { return _class(obj) === '[object RegExp]'; }
	function isFunction(obj) { return _class(obj) === '[object Function]'; }


	function escapeRE (str) { return str.replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&'); }

	////////////////////////////////////////////////////////////////////////////////


	var defaultOptions = {
	  fuzzyLink: true,
	  fuzzyEmail: true,
	  fuzzyIP: false
	};


	function isOptionsObj(obj) {
	  return Object.keys(obj || {}).reduce(function (acc, k) {
	    return acc || defaultOptions.hasOwnProperty(k);
	  }, false);
	}


	var defaultSchemas = {
	  'http:': {
	    validate: function (text, pos, self) {
	      var tail = text.slice(pos);

	      if (!self.re.http) {
	        // compile lazily, because "host"-containing variables can change on tlds update.
	        self.re.http =  new RegExp(
	          '^\\/\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i'
	        );
	      }
	      if (self.re.http.test(tail)) {
	        return tail.match(self.re.http)[0].length;
	      }
	      return 0;
	    }
	  },
	  'https:':  'http:',
	  'ftp:':    'http:',
	  '//':      {
	    validate: function (text, pos, self) {
	      var tail = text.slice(pos);

	      if (!self.re.no_http) {
	      // compile lazily, becayse "host"-containing variables can change on tlds update.
	        self.re.no_http =  new RegExp(
	          '^' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i'
	        );
	      }

	      if (self.re.no_http.test(tail)) {
	        // should not be `://`, that protects from errors in protocol name
	        if (pos >= 3 && text[pos - 3] === ':') { return 0; }
	        return tail.match(self.re.no_http)[0].length;
	      }
	      return 0;
	    }
	  },
	  'mailto:': {
	    validate: function (text, pos, self) {
	      var tail = text.slice(pos);

	      if (!self.re.mailto) {
	        self.re.mailto =  new RegExp(
	          '^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i'
	        );
	      }
	      if (self.re.mailto.test(tail)) {
	        return tail.match(self.re.mailto)[0].length;
	      }
	      return 0;
	    }
	  }
	};

	/*eslint-disable max-len*/

	// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)
	var tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]';

	// DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead
	var tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф'.split('|');

	/*eslint-enable max-len*/

	////////////////////////////////////////////////////////////////////////////////

	function resetScanCache(self) {
	  self.__index__ = -1;
	  self.__text_cache__   = '';
	}

	function createValidator(re) {
	  return function (text, pos) {
	    var tail = text.slice(pos);

	    if (re.test(tail)) {
	      return tail.match(re)[0].length;
	    }
	    return 0;
	  };
	}

	function createNormalizer() {
	  return function (match, self) {
	    self.normalize(match);
	  };
	}

	// Schemas compiler. Build regexps.
	//
	function compile(self) {

	  // Load & clone RE patterns.
	  var re = self.re = assign({}, __webpack_require__(89));

	  // Define dynamic patterns
	  var tlds = self.__tlds__.slice();

	  if (!self.__tlds_replaced__) {
	    tlds.push(tlds_2ch_src_re);
	  }
	  tlds.push(re.src_xn);

	  re.src_tlds = tlds.join('|');

	  function untpl(tpl) { return tpl.replace('%TLDS%', re.src_tlds); }

	  re.email_fuzzy      = RegExp(untpl(re.tpl_email_fuzzy), 'i');
	  re.link_fuzzy       = RegExp(untpl(re.tpl_link_fuzzy), 'i');
	  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), 'i');
	  re.host_fuzzy_test  = RegExp(untpl(re.tpl_host_fuzzy_test), 'i');

	  //
	  // Compile each schema
	  //

	  var aliases = [];

	  self.__compiled__ = {}; // Reset compiled data

	  function schemaError(name, val) {
	    throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
	  }

	  Object.keys(self.__schemas__).forEach(function (name) {
	    var val = self.__schemas__[name];

	    // skip disabled methods
	    if (val === null) { return; }

	    var compiled = { validate: null, link: null };

	    self.__compiled__[name] = compiled;

	    if (isObject(val)) {
	      if (isRegExp(val.validate)) {
	        compiled.validate = createValidator(val.validate);
	      } else if (isFunction(val.validate)) {
	        compiled.validate = val.validate;
	      } else {
	        schemaError(name, val);
	      }

	      if (isFunction(val.normalize)) {
	        compiled.normalize = val.normalize;
	      } else if (!val.normalize) {
	        compiled.normalize = createNormalizer();
	      } else {
	        schemaError(name, val);
	      }

	      return;
	    }

	    if (isString(val)) {
	      aliases.push(name);
	      return;
	    }

	    schemaError(name, val);
	  });

	  //
	  // Compile postponed aliases
	  //

	  aliases.forEach(function (alias) {
	    if (!self.__compiled__[self.__schemas__[alias]]) {
	      // Silently fail on missed schemas to avoid errons on disable.
	      // schemaError(alias, self.__schemas__[alias]);
	      return;
	    }

	    self.__compiled__[alias].validate =
	      self.__compiled__[self.__schemas__[alias]].validate;
	    self.__compiled__[alias].normalize =
	      self.__compiled__[self.__schemas__[alias]].normalize;
	  });

	  //
	  // Fake record for guessed links
	  //
	  self.__compiled__[''] = { validate: null, normalize: createNormalizer() };

	  //
	  // Build schema condition
	  //
	  var slist = Object.keys(self.__compiled__)
	                      .filter(function(name) {
	                        // Filter disabled & fake schemas
	                        return name.length > 0 && self.__compiled__[name];
	                      })
	                      .map(escapeRE)
	                      .join('|');
	  // (?!_) cause 1.5x slowdown
	  self.re.schema_test   = RegExp('(^|(?!_)(?:>|' + re.src_ZPCc + '))(' + slist + ')', 'i');
	  self.re.schema_search = RegExp('(^|(?!_)(?:>|' + re.src_ZPCc + '))(' + slist + ')', 'ig');

	  self.re.pretest       = RegExp(
	                            '(' + self.re.schema_test.source + ')|' +
	                            '(' + self.re.host_fuzzy_test.source + ')|' +
	                            '@',
	                            'i');

	  //
	  // Cleanup
	  //

	  resetScanCache(self);
	}

	/**
	 * class Match
	 *
	 * Match result. Single element of array, returned by [[LinkifyIt#match]]
	 **/
	function Match(self, shift) {
	  var start = self.__index__,
	      end   = self.__last_index__,
	      text  = self.__text_cache__.slice(start, end);

	  /**
	   * Match#schema -> String
	   *
	   * Prefix (protocol) for matched string.
	   **/
	  this.schema    = self.__schema__.toLowerCase();
	  /**
	   * Match#index -> Number
	   *
	   * First position of matched string.
	   **/
	  this.index     = start + shift;
	  /**
	   * Match#lastIndex -> Number
	   *
	   * Next position after matched string.
	   **/
	  this.lastIndex = end + shift;
	  /**
	   * Match#raw -> String
	   *
	   * Matched string.
	   **/
	  this.raw       = text;
	  /**
	   * Match#text -> String
	   *
	   * Notmalized text of matched string.
	   **/
	  this.text      = text;
	  /**
	   * Match#url -> String
	   *
	   * Normalized url of matched string.
	   **/
	  this.url       = text;
	}

	function createMatch(self, shift) {
	  var match = new Match(self, shift);

	  self.__compiled__[match.schema].normalize(match, self);

	  return match;
	}


	/**
	 * class LinkifyIt
	 **/

	/**
	 * new LinkifyIt(schemas, options)
	 * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)
	 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
	 *
	 * Creates new linkifier instance with optional additional schemas.
	 * Can be called without `new` keyword for convenience.
	 *
	 * By default understands:
	 *
	 * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links
	 * - "fuzzy" links and emails (example.com, foo@bar.com).
	 *
	 * `schemas` is an object, where each key/value describes protocol/rule:
	 *
	 * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`
	 *   for example). `linkify-it` makes shure that prefix is not preceeded with
	 *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.
	 * - __value__ - rule to check tail after link prefix
	 *   - _String_ - just alias to existing rule
	 *   - _Object_
	 *     - _validate_ - validator function (should return matched length on success),
	 *       or `RegExp`.
	 *     - _normalize_ - optional function to normalize text & url of matched result
	 *       (for example, for @twitter mentions).
	 *
	 * `options`:
	 *
	 * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.
	 * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts
	 *   like version numbers. Default `false`.
	 * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.
	 *
	 **/
	function LinkifyIt(schemas, options) {
	  if (!(this instanceof LinkifyIt)) {
	    return new LinkifyIt(schemas, options);
	  }

	  if (!options) {
	    if (isOptionsObj(schemas)) {
	      options = schemas;
	      schemas = {};
	    }
	  }

	  this.__opts__           = assign({}, defaultOptions, options);

	  // Cache last tested result. Used to skip repeating steps on next `match` call.
	  this.__index__          = -1;
	  this.__last_index__     = -1; // Next scan position
	  this.__schema__         = '';
	  this.__text_cache__     = '';

	  this.__schemas__        = assign({}, defaultSchemas, schemas);
	  this.__compiled__       = {};

	  this.__tlds__           = tlds_default;
	  this.__tlds_replaced__  = false;

	  this.re = {};

	  compile(this);
	}


	/** chainable
	 * LinkifyIt#add(schema, definition)
	 * - schema (String): rule name (fixed pattern prefix)
	 * - definition (String|RegExp|Object): schema definition
	 *
	 * Add new rule definition. See constructor description for details.
	 **/
	LinkifyIt.prototype.add = function add(schema, definition) {
	  this.__schemas__[schema] = definition;
	  compile(this);
	  return this;
	};


	/** chainable
	 * LinkifyIt#set(options)
	 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
	 *
	 * Set recognition options for links without schema.
	 **/
	LinkifyIt.prototype.set = function set(options) {
	  this.__opts__ = assign(this.__opts__, options);
	  return this;
	};


	/**
	 * LinkifyIt#test(text) -> Boolean
	 *
	 * Searches linkifiable pattern and returns `true` on success or `false` on fail.
	 **/
	LinkifyIt.prototype.test = function test(text) {
	  // Reset scan cache
	  this.__text_cache__ = text;
	  this.__index__      = -1;

	  if (!text.length) { return false; }

	  var m, ml, me, len, shift, next, re, tld_pos, at_pos;

	  // try to scan for link with schema - that's the most simple rule
	  if (this.re.schema_test.test(text)) {
	    re = this.re.schema_search;
	    re.lastIndex = 0;
	    while ((m = re.exec(text)) !== null) {
	      len = this.testSchemaAt(text, m[2], re.lastIndex);
	      if (len) {
	        this.__schema__     = m[2];
	        this.__index__      = m.index + m[1].length;
	        this.__last_index__ = m.index + m[0].length + len;
	        break;
	      }
	    }
	  }

	  if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {
	    // guess schemaless links
	    tld_pos = text.search(this.re.host_fuzzy_test);
	    if (tld_pos >= 0) {
	      // if tld is located after found link - no need to check fuzzy pattern
	      if (this.__index__ < 0 || tld_pos < this.__index__) {
	        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {

	          shift = ml.index + ml[1].length;

	          if (this.__index__ < 0 || shift < this.__index__) {
	            this.__schema__     = '';
	            this.__index__      = shift;
	            this.__last_index__ = ml.index + ml[0].length;
	          }
	        }
	      }
	    }
	  }

	  if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {
	    // guess schemaless emails
	    at_pos = text.indexOf('@');
	    if (at_pos >= 0) {
	      // We can't skip this check, because this cases are possible:
	      // 192.168.1.1@gmail.com, my.in@example.com
	      if ((me = text.match(this.re.email_fuzzy)) !== null) {

	        shift = me.index + me[1].length;
	        next  = me.index + me[0].length;

	        if (this.__index__ < 0 || shift < this.__index__ ||
	            (shift === this.__index__ && next > this.__last_index__)) {
	          this.__schema__     = 'mailto:';
	          this.__index__      = shift;
	          this.__last_index__ = next;
	        }
	      }
	    }
	  }

	  return this.__index__ >= 0;
	};


	/**
	 * LinkifyIt#pretest(text) -> Boolean
	 *
	 * Very quick check, that can give false positives. Returns true if link MAY BE
	 * can exists. Can be used for speed optimization, when you need to check that
	 * link NOT exists.
	 **/
	LinkifyIt.prototype.pretest = function pretest(text) {
	  return this.re.pretest.test(text);
	};


	/**
	 * LinkifyIt#testSchemaAt(text, name, position) -> Number
	 * - text (String): text to scan
	 * - name (String): rule (schema) name
	 * - position (Number): text offset to check from
	 *
	 * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly
	 * at given position. Returns length of found pattern (0 on fail).
	 **/
	LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
	  // If not supported schema check requested - terminate
	  if (!this.__compiled__[schema.toLowerCase()]) {
	    return 0;
	  }
	  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
	};


	/**
	 * LinkifyIt#match(text) -> Array|null
	 *
	 * Returns array of found link descriptions or `null` on fail. We strongly
	 * to use [[LinkifyIt#test]] first, for best speed.
	 *
	 * ##### Result match description
	 *
	 * - __schema__ - link schema, can be empty for fuzzy links, or `//` for
	 *   protocol-neutral  links.
	 * - __index__ - offset of matched text
	 * - __lastIndex__ - index of next char after mathch end
	 * - __raw__ - matched text
	 * - __text__ - normalized text
	 * - __url__ - link, generated from matched text
	 **/
	LinkifyIt.prototype.match = function match(text) {
	  var shift = 0, result = [];

	  // Try to take previous element from cache, if .test() called before
	  if (this.__index__ >= 0 && this.__text_cache__ === text) {
	    result.push(createMatch(this, shift));
	    shift = this.__last_index__;
	  }

	  // Cut head if cache was used
	  var tail = shift ? text.slice(shift) : text;

	  // Scan string until end reached
	  while (this.test(tail)) {
	    result.push(createMatch(this, shift));

	    tail = tail.slice(this.__last_index__);
	    shift += this.__last_index__;
	  }

	  if (result.length) {
	    return result;
	  }

	  return null;
	};


	/** chainable
	 * LinkifyIt#tlds(list [, keepOld]) -> this
	 * - list (Array): list of tlds
	 * - keepOld (Boolean): merge with current list if `true` (`false` by default)
	 *
	 * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)
	 * to avoid false positives. By default this algorythm used:
	 *
	 * - hostname with any 2-letter root zones are ok.
	 * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф
	 *   are ok.
	 * - encoded (`xn--...`) root zones are ok.
	 *
	 * If list is replaced, then exact match for 2-chars root zones will be checked.
	 **/
	LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
	  list = Array.isArray(list) ? list : [ list ];

	  if (!keepOld) {
	    this.__tlds__ = list.slice();
	    this.__tlds_replaced__ = true;
	    compile(this);
	    return this;
	  }

	  this.__tlds__ = this.__tlds__.concat(list)
	                                  .sort()
	                                  .filter(function(el, idx, arr) {
	                                    return el !== arr[idx - 1];
	                                  })
	                                  .reverse();

	  compile(this);
	  return this;
	};

	/**
	 * LinkifyIt#normalize(match)
	 *
	 * Default normalizer (if schema does not define it's own).
	 **/
	LinkifyIt.prototype.normalize = function normalize(match) {

	  // Do minimal possible changes by default. Need to collect feedback prior
	  // to move forward https://github.com/markdown-it/linkify-it/issues/1

	  if (!match.schema) { match.url = 'http://' + match.url; }

	  if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {
	    match.url = 'mailto:' + match.url;
	  }
	};


	module.exports = LinkifyIt;


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// Use direct extract instead of `regenerate` to reduse browserified size
	var src_Any = exports.src_Any = __webpack_require__(40).source;
	var src_Cc  = exports.src_Cc = __webpack_require__(41).source;
	var src_Z   = exports.src_Z  = __webpack_require__(43).source;
	var src_P   = exports.src_P  = __webpack_require__(33).source;

	// \p{\Z\P\Cc\CF} (white spaces + control + format + punctuation)
	var src_ZPCc = exports.src_ZPCc = [ src_Z, src_P, src_Cc ].join('|');

	// \p{\Z\Cc} (white spaces + control)
	var src_ZCc = exports.src_ZCc = [ src_Z, src_Cc ].join('|');

	// All possible word characters (everything without punctuation, spaces & controls)
	// Defined via punctuation & spaces to save space
	// Should be something like \p{\L\N\S\M} (\w but without `_`)
	var src_pseudo_letter       = '(?:(?!' + src_ZPCc + ')' + src_Any + ')';
	// The same as abothe but without [0-9]
	var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';

	////////////////////////////////////////////////////////////////////////////////

	var src_ip4 = exports.src_ip4 =

	  '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';

	exports.src_auth    = '(?:(?:(?!' + src_ZCc + ').)+@)?';

	var src_port = exports.src_port =

	  '(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?';

	var src_host_terminator = exports.src_host_terminator =

	  '(?=$|' + src_ZPCc + ')(?!-|_|:\\d|\\.-|\\.(?!$|' + src_ZPCc + '))';

	var src_path = exports.src_path =

	  '(?:' +
	    '[/?#]' +
	      '(?:' +
	        '(?!' + src_ZCc + '|[()[\\]{}.,"\'?!\\-]).|' +
	        '\\[(?:(?!' + src_ZCc + '|\\]).)*\\]|' +
	        '\\((?:(?!' + src_ZCc + '|[)]).)*\\)|' +
	        '\\{(?:(?!' + src_ZCc + '|[}]).)*\\}|' +
	        '\\"(?:(?!' + src_ZCc + '|["]).)+\\"|' +
	        "\\'(?:(?!" + src_ZCc + "|[']).)+\\'|" +
	        "\\'(?=" + src_pseudo_letter + ').|' +  // allow `I'm_king` if no pair found
	        '\\.{2,3}[a-zA-Z0-9%/]|' + // github has ... in commit range links. Restrict to
	                                   // - english
	                                   // - percent-encoded
	                                   // - parts of file path
	                                   // until more examples found.
	        '\\.(?!' + src_ZCc + '|[.]).|' +
	        '\\-(?!--(?:[^-]|$))(?:-*)|' +  // `---` => long dash, terminate
	        '\\,(?!' + src_ZCc + ').|' +      // allow `,,,` in paths
	        '\\!(?!' + src_ZCc + '|[!]).|' +
	        '\\?(?!' + src_ZCc + '|[?]).' +
	      ')+' +
	    '|\\/' +
	  ')?';

	var src_email_name = exports.src_email_name =

	  '[\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]+';

	var src_xn = exports.src_xn =

	  'xn--[a-z0-9\\-]{1,59}';

	// More to read about domain names
	// http://serverfault.com/questions/638260/

	var src_domain_root = exports.src_domain_root =

	  // Can't have digits and dashes
	  '(?:' +
	    src_xn +
	    '|' +
	    src_pseudo_letter_non_d + '{1,63}' +
	  ')';

	var src_domain = exports.src_domain =

	  '(?:' +
	    src_xn +
	    '|' +
	    '(?:' + src_pseudo_letter + ')' +
	    '|' +
	    // don't allow `--` in domain names, because:
	    // - that can conflict with markdown &mdash; / &ndash;
	    // - nobody use those anyway
	    '(?:' + src_pseudo_letter + '(?:-(?!-)|' + src_pseudo_letter + '){0,61}' + src_pseudo_letter + ')' +
	  ')';

	var src_host = exports.src_host =

	  '(?:' +
	    src_ip4 +
	  '|' +
	    '(?:(?:(?:' + src_domain + ')\\.)*' + src_domain_root + ')' +
	  ')';

	var tpl_host_fuzzy = exports.tpl_host_fuzzy =

	  '(?:' +
	    src_ip4 +
	  '|' +
	    '(?:(?:(?:' + src_domain + ')\\.)+(?:%TLDS%))' +
	  ')';

	var tpl_host_no_ip_fuzzy = exports.tpl_host_no_ip_fuzzy =

	  '(?:(?:(?:' + src_domain + ')\\.)+(?:%TLDS%))';

	exports.src_host_strict =

	  src_host + src_host_terminator;

	var tpl_host_fuzzy_strict = exports.tpl_host_fuzzy_strict =

	  tpl_host_fuzzy + src_host_terminator;

	exports.src_host_port_strict =

	  src_host + src_port + src_host_terminator;

	var tpl_host_port_fuzzy_strict = exports.tpl_host_port_fuzzy_strict =

	  tpl_host_fuzzy + src_port + src_host_terminator;

	var tpl_host_port_no_ip_fuzzy_strict = exports.tpl_host_port_no_ip_fuzzy_strict =

	  tpl_host_no_ip_fuzzy + src_port + src_host_terminator;


	////////////////////////////////////////////////////////////////////////////////
	// Main rules

	// Rude test fuzzy links by host, for quick deny
	exports.tpl_host_fuzzy_test =

	  'localhost|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:' + src_ZPCc + '|$))';

	exports.tpl_email_fuzzy =

	    '(^|>|' + src_ZCc + ')(' + src_email_name + '@' + tpl_host_fuzzy_strict + ')';

	exports.tpl_link_fuzzy =
	    // Fuzzy link can't be prepended with .:/\- and non punctuation.
	    // but can start with > (markdown blockquote)
	    '(^|(?![.:/\\-_@])(?:[$+<=>^`|]|' + src_ZPCc + '))' +
	    '((?![$+<=>^`|])' + tpl_host_port_fuzzy_strict + src_path + ')';

	exports.tpl_link_no_ip_fuzzy =
	    // Fuzzy link can't be prepended with .:/\- and non punctuation.
	    // but can start with > (markdown blockquote)
	    '(^|(?![.:/\\-_@])(?:[$+<=>^`|]|' + src_ZPCc + '))' +
	    '((?![$+<=>^`|])' + tpl_host_port_no_ip_fuzzy_strict + src_path + ')';


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.4.1 by @mathias */
	;(function(root) {

		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}

		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,

		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'

		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},

		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,

		/** Temporary variable */
		key;

		/*--------------------------------------------------------------------------*/

		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw new RangeError(errors[type]);
		}

		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}

		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}

		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}

		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}

		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}

		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * https://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}

		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;

			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.

			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}

			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}

			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.

			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

					if (index >= inputLength) {
						error('invalid-input');
					}

					digit = basicToDigit(input.charCodeAt(index++));

					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}

					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

					if (digit < t) {
						break;
					}

					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}

					w *= baseMinusT;

				}

				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);

				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}

				n += floor(i / out);
				i %= out;

				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);

			}

			return ucs2encode(output);
		}

		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;

			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);

			// Cache the length
			inputLength = input.length;

			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;

			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}

			handledCPCount = basicLength = output.length;

			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.

			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}

			// Main encoding loop:
			while (handledCPCount < inputLength) {

				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}

				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}

				delta += (m - n) * handledCPCountPlusOne;
				n = m;

				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];

					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}

					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}

						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}

				++delta;
				++n;

			}
			return output.join('');
		}

		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}

		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}

		/*--------------------------------------------------------------------------*/

		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.4.1',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};

		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) {
				// in Node.js, io.js, or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else {
				// in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else {
			// in Rhino or a web browser
			root.punycode = punycode;
		}

	}(this));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(91)(module), (function() { return this; }())))

/***/ },
/* 91 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 92 */
/***/ function(module, exports) {

	// markdown-it default options

	'use strict';


	module.exports = {
	  options: {
	    html:         false,        // Enable HTML tags in source
	    xhtmlOut:     false,        // Use '/' to close single tags (<br />)
	    breaks:       false,        // Convert '\n' in paragraphs into <br>
	    langPrefix:   'language-',  // CSS language prefix for fenced blocks
	    linkify:      false,        // autoconvert URL-like texts to links

	    // Enable some language-neutral replacements + quotes beautification
	    typographer:  false,

	    // Double + single quotes replacement pairs, when typographer enabled,
	    // and smartquotes on. Could be either a String or an Array.
	    //
	    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
	    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
	    quotes: '\u201c\u201d\u2018\u2019' /* “”‘’ */,

	    // Highlighter function. Should return escaped HTML,
	    // or '' if input not changed
	    //
	    // function (/*str, lang*/) { return ''; }
	    //
	    highlight: null,

	    maxNesting:   20            // Internal protection, recursion limit
	  },

	  components: {

	    core: {},
	    block: {},
	    inline: {}
	  }
	};


/***/ },
/* 93 */
/***/ function(module, exports) {

	// "Zero" preset, with nothing enabled. Useful for manual configuring of simple
	// modes. For example, to parse bold/italic only.

	'use strict';


	module.exports = {
	  options: {
	    html:         false,        // Enable HTML tags in source
	    xhtmlOut:     false,        // Use '/' to close single tags (<br />)
	    breaks:       false,        // Convert '\n' in paragraphs into <br>
	    langPrefix:   'language-',  // CSS language prefix for fenced blocks
	    linkify:      false,        // autoconvert URL-like texts to links

	    // Enable some language-neutral replacements + quotes beautification
	    typographer:  false,

	    // Double + single quotes replacement pairs, when typographer enabled,
	    // and smartquotes on. Could be either a String or an Array.
	    //
	    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
	    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
	    quotes: '\u201c\u201d\u2018\u2019' /* “”‘’ */,

	    // Highlighter function. Should return escaped HTML,
	    // or '' if input not changed
	    //
	    // function (/*str, lang*/) { return ''; }
	    //
	    highlight: null,

	    maxNesting:   20            // Internal protection, recursion limit
	  },

	  components: {

	    core: {
	      rules: [
	        'normalize',
	        'block',
	        'inline'
	      ]
	    },

	    block: {
	      rules: [
	        'paragraph'
	      ]
	    },

	    inline: {
	      rules: [
	        'text'
	      ]
	    }
	  }
	};


/***/ },
/* 94 */
/***/ function(module, exports) {

	// Commonmark default options

	'use strict';


	module.exports = {
	  options: {
	    html:         true,         // Enable HTML tags in source
	    xhtmlOut:     true,         // Use '/' to close single tags (<br />)
	    breaks:       false,        // Convert '\n' in paragraphs into <br>
	    langPrefix:   'language-',  // CSS language prefix for fenced blocks
	    linkify:      false,        // autoconvert URL-like texts to links

	    // Enable some language-neutral replacements + quotes beautification
	    typographer:  false,

	    // Double + single quotes replacement pairs, when typographer enabled,
	    // and smartquotes on. Could be either a String or an Array.
	    //
	    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
	    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
	    quotes: '\u201c\u201d\u2018\u2019' /* “”‘’ */,

	    // Highlighter function. Should return escaped HTML,
	    // or '' if input not changed
	    //
	    // function (/*str, lang*/) { return ''; }
	    //
	    highlight: null,

	    maxNesting:   20            // Internal protection, recursion limit
	  },

	  components: {

	    core: {
	      rules: [
	        'normalize',
	        'block',
	        'inline'
	      ]
	    },

	    block: {
	      rules: [
	        'blockquote',
	        'code',
	        'fence',
	        'heading',
	        'hr',
	        'html_block',
	        'lheading',
	        'list',
	        'reference',
	        'paragraph'
	      ]
	    },

	    inline: {
	      rules: [
	        'autolink',
	        'backticks',
	        'emphasis',
	        'entity',
	        'escape',
	        'html_inline',
	        'image',
	        'link',
	        'newline',
	        'text'
	      ]
	    }
	  }
	};


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	/* ***** BEGIN LICENSE BLOCK *****
	 * Distributed under the BSD license:
	 *
	 * Copyright (c) 2010, Ajax.org B.V.
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *     * Redistributions of source code must retain the above copyright
	 *       notice, this list of conditions and the following disclaimer.
	 *     * Redistributions in binary form must reproduce the above copyright
	 *       notice, this list of conditions and the following disclaimer in the
	 *       documentation and/or other materials provided with the distribution.
	 *     * Neither the name of Ajax.org B.V. nor the
	 *       names of its contributors may be used to endorse or promote products
	 *       derived from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
	 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 *
	 * ***** END LICENSE BLOCK ***** */

	/**
	 * Define a module along with a payload
	 * @param module a name for the payload
	 * @param payload a function to call with (acequire, exports, module) params
	 */

	(function() {

	var ACE_NAMESPACE = "ace";

	var global = (function() { return this; })();
	if (!global && typeof window != "undefined") global = window; // strict mode


	if (!ACE_NAMESPACE && typeof acequirejs !== "undefined")
	    return;


	var define = function(module, deps, payload) {
	    if (typeof module !== "string") {
	        if (define.original)
	            define.original.apply(this, arguments);
	        else {
	            console.error("dropping module because define wasn\'t a string.");
	            console.trace();
	        }
	        return;
	    }
	    if (arguments.length == 2)
	        payload = deps;
	    if (!define.modules[module]) {
	        define.payloads[module] = payload;
	        define.modules[module] = null;
	    }
	};

	define.modules = {};
	define.payloads = {};

	/**
	 * Get at functionality define()ed using the function above
	 */
	var _acequire = function(parentId, module, callback) {
	    if (typeof module === "string") {
	        var payload = lookup(parentId, module);
	        if (payload != undefined) {
	            callback && callback();
	            return payload;
	        }
	    } else if (Object.prototype.toString.call(module) === "[object Array]") {
	        var params = [];
	        for (var i = 0, l = module.length; i < l; ++i) {
	            var dep = lookup(parentId, module[i]);
	            if (dep == undefined && acequire.original)
	                return;
	            params.push(dep);
	        }
	        return callback && callback.apply(null, params) || true;
	    }
	};

	var acequire = function(module, callback) {
	    var packagedModule = _acequire("", module, callback);
	    if (packagedModule == undefined && acequire.original)
	        return acequire.original.apply(this, arguments);
	    return packagedModule;
	};

	var normalizeModule = function(parentId, moduleName) {
	    // normalize plugin acequires
	    if (moduleName.indexOf("!") !== -1) {
	        var chunks = moduleName.split("!");
	        return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
	    }
	    // normalize relative acequires
	    if (moduleName.charAt(0) == ".") {
	        var base = parentId.split("/").slice(0, -1).join("/");
	        moduleName = base + "/" + moduleName;

	        while(moduleName.indexOf(".") !== -1 && previous != moduleName) {
	            var previous = moduleName;
	            moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
	        }
	    }
	    return moduleName;
	};

	/**
	 * Internal function to lookup moduleNames and resolve them by calling the
	 * definition function if needed.
	 */
	var lookup = function(parentId, moduleName) {
	    moduleName = normalizeModule(parentId, moduleName);

	    var module = define.modules[moduleName];
	    if (!module) {
	        module = define.payloads[moduleName];
	        if (typeof module === 'function') {
	            var exports = {};
	            var mod = {
	                id: moduleName,
	                uri: '',
	                exports: exports,
	                packaged: true
	            };

	            var req = function(module, callback) {
	                return _acequire(moduleName, module, callback);
	            };

	            var returnValue = module(req, exports, mod);
	            exports = returnValue || mod.exports;
	            define.modules[moduleName] = exports;
	            delete define.payloads[moduleName];
	        }
	        module = define.modules[moduleName] = exports || module;
	    }
	    return module;
	};

	function exportAce(ns) {
	    var root = global;
	    if (ns) {
	        if (!global[ns])
	            global[ns] = {};
	        root = global[ns];
	    }

	    if (!root.define || !root.define.packaged) {
	        define.original = root.define;
	        root.define = define;
	        root.define.packaged = true;
	    }

	    if (!root.acequire || !root.acequire.packaged) {
	        acequire.original = root.acequire;
	        root.acequire = acequire;
	        root.acequire.packaged = true;
	    }
	}

	exportAce(ACE_NAMESPACE);

	})();

	ace.define("ace/lib/regexp",["require","exports","module"], function(acequire, exports, module) {
	"use strict";

	    var real = {
	            exec: RegExp.prototype.exec,
	            test: RegExp.prototype.test,
	            match: String.prototype.match,
	            replace: String.prototype.replace,
	            split: String.prototype.split
	        },
	        compliantExecNpcg = real.exec.call(/()??/, "")[1] === undefined, // check `exec` handling of nonparticipating capturing groups
	        compliantLastIndexIncrement = function () {
	            var x = /^/g;
	            real.test.call(x, "");
	            return !x.lastIndex;
	        }();

	    if (compliantLastIndexIncrement && compliantExecNpcg)
	        return;
	    RegExp.prototype.exec = function (str) {
	        var match = real.exec.apply(this, arguments),
	            name, r2;
	        if ( typeof(str) == 'string' && match) {
	            if (!compliantExecNpcg && match.length > 1 && indexOf(match, "") > -1) {
	                r2 = RegExp(this.source, real.replace.call(getNativeFlags(this), "g", ""));
	                real.replace.call(str.slice(match.index), r2, function () {
	                    for (var i = 1; i < arguments.length - 2; i++) {
	                        if (arguments[i] === undefined)
	                            match[i] = undefined;
	                    }
	                });
	            }
	            if (this._xregexp && this._xregexp.captureNames) {
	                for (var i = 1; i < match.length; i++) {
	                    name = this._xregexp.captureNames[i - 1];
	                    if (name)
	                       match[name] = match[i];
	                }
	            }
	            if (!compliantLastIndexIncrement && this.global && !match[0].length && (this.lastIndex > match.index))
	                this.lastIndex--;
	        }
	        return match;
	    };
	    if (!compliantLastIndexIncrement) {
	        RegExp.prototype.test = function (str) {
	            var match = real.exec.call(this, str);
	            if (match && this.global && !match[0].length && (this.lastIndex > match.index))
	                this.lastIndex--;
	            return !!match;
	        };
	    }

	    function getNativeFlags (regex) {
	        return (regex.global     ? "g" : "") +
	               (regex.ignoreCase ? "i" : "") +
	               (regex.multiline  ? "m" : "") +
	               (regex.extended   ? "x" : "") + // Proposed for ES4; included in AS3
	               (regex.sticky     ? "y" : "");
	    }

	    function indexOf (array, item, from) {
	        if (Array.prototype.indexOf) // Use the native array method if available
	            return array.indexOf(item, from);
	        for (var i = from || 0; i < array.length; i++) {
	            if (array[i] === item)
	                return i;
	        }
	        return -1;
	    }

	});

	ace.define("ace/lib/es5-shim",["require","exports","module"], function(acequire, exports, module) {

	function Empty() {}

	if (!Function.prototype.bind) {
	    Function.prototype.bind = function bind(that) { // .length is 1
	        var target = this;
	        if (typeof target != "function") {
	            throw new TypeError("Function.prototype.bind called on incompatible " + target);
	        }
	        var args = slice.call(arguments, 1); // for normal call
	        var bound = function () {

	            if (this instanceof bound) {

	                var result = target.apply(
	                    this,
	                    args.concat(slice.call(arguments))
	                );
	                if (Object(result) === result) {
	                    return result;
	                }
	                return this;

	            } else {
	                return target.apply(
	                    that,
	                    args.concat(slice.call(arguments))
	                );

	            }

	        };
	        if(target.prototype) {
	            Empty.prototype = target.prototype;
	            bound.prototype = new Empty();
	            Empty.prototype = null;
	        }
	        return bound;
	    };
	}
	var call = Function.prototype.call;
	var prototypeOfArray = Array.prototype;
	var prototypeOfObject = Object.prototype;
	var slice = prototypeOfArray.slice;
	var _toString = call.bind(prototypeOfObject.toString);
	var owns = call.bind(prototypeOfObject.hasOwnProperty);
	var defineGetter;
	var defineSetter;
	var lookupGetter;
	var lookupSetter;
	var supportsAccessors;
	if ((supportsAccessors = owns(prototypeOfObject, "__defineGetter__"))) {
	    defineGetter = call.bind(prototypeOfObject.__defineGetter__);
	    defineSetter = call.bind(prototypeOfObject.__defineSetter__);
	    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
	    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
	}
	if ([1,2].splice(0).length != 2) {
	    if(function() { // test IE < 9 to splice bug - see issue #138
	        function makeArray(l) {
	            var a = new Array(l+2);
	            a[0] = a[1] = 0;
	            return a;
	        }
	        var array = [], lengthBefore;
	        
	        array.splice.apply(array, makeArray(20));
	        array.splice.apply(array, makeArray(26));

	        lengthBefore = array.length; //46
	        array.splice(5, 0, "XXX"); // add one element

	        lengthBefore + 1 == array.length

	        if (lengthBefore + 1 == array.length) {
	            return true;// has right splice implementation without bugs
	        }
	    }()) {//IE 6/7
	        var array_splice = Array.prototype.splice;
	        Array.prototype.splice = function(start, deleteCount) {
	            if (!arguments.length) {
	                return [];
	            } else {
	                return array_splice.apply(this, [
	                    start === void 0 ? 0 : start,
	                    deleteCount === void 0 ? (this.length - start) : deleteCount
	                ].concat(slice.call(arguments, 2)))
	            }
	        };
	    } else {//IE8
	        Array.prototype.splice = function(pos, removeCount){
	            var length = this.length;
	            if (pos > 0) {
	                if (pos > length)
	                    pos = length;
	            } else if (pos == void 0) {
	                pos = 0;
	            } else if (pos < 0) {
	                pos = Math.max(length + pos, 0);
	            }

	            if (!(pos+removeCount < length))
	                removeCount = length - pos;

	            var removed = this.slice(pos, pos+removeCount);
	            var insert = slice.call(arguments, 2);
	            var add = insert.length;            
	            if (pos === length) {
	                if (add) {
	                    this.push.apply(this, insert);
	                }
	            } else {
	                var remove = Math.min(removeCount, length - pos);
	                var tailOldPos = pos + remove;
	                var tailNewPos = tailOldPos + add - remove;
	                var tailCount = length - tailOldPos;
	                var lengthAfterRemove = length - remove;

	                if (tailNewPos < tailOldPos) { // case A
	                    for (var i = 0; i < tailCount; ++i) {
	                        this[tailNewPos+i] = this[tailOldPos+i];
	                    }
	                } else if (tailNewPos > tailOldPos) { // case B
	                    for (i = tailCount; i--; ) {
	                        this[tailNewPos+i] = this[tailOldPos+i];
	                    }
	                } // else, add == remove (nothing to do)

	                if (add && pos === lengthAfterRemove) {
	                    this.length = lengthAfterRemove; // truncate array
	                    this.push.apply(this, insert);
	                } else {
	                    this.length = lengthAfterRemove + add; // reserves space
	                    for (i = 0; i < add; ++i) {
	                        this[pos+i] = insert[i];
	                    }
	                }
	            }
	            return removed;
	        };
	    }
	}
	if (!Array.isArray) {
	    Array.isArray = function isArray(obj) {
	        return _toString(obj) == "[object Array]";
	    };
	}
	var boxedString = Object("a"),
	    splitString = boxedString[0] != "a" || !(0 in boxedString);

	if (!Array.prototype.forEach) {
	    Array.prototype.forEach = function forEach(fun /*, thisp*/) {
	        var object = toObject(this),
	            self = splitString && _toString(this) == "[object String]" ?
	                this.split("") :
	                object,
	            thisp = arguments[1],
	            i = -1,
	            length = self.length >>> 0;
	        if (_toString(fun) != "[object Function]") {
	            throw new TypeError(); // TODO message
	        }

	        while (++i < length) {
	            if (i in self) {
	                fun.call(thisp, self[i], i, object);
	            }
	        }
	    };
	}
	if (!Array.prototype.map) {
	    Array.prototype.map = function map(fun /*, thisp*/) {
	        var object = toObject(this),
	            self = splitString && _toString(this) == "[object String]" ?
	                this.split("") :
	                object,
	            length = self.length >>> 0,
	            result = Array(length),
	            thisp = arguments[1];
	        if (_toString(fun) != "[object Function]") {
	            throw new TypeError(fun + " is not a function");
	        }

	        for (var i = 0; i < length; i++) {
	            if (i in self)
	                result[i] = fun.call(thisp, self[i], i, object);
	        }
	        return result;
	    };
	}
	if (!Array.prototype.filter) {
	    Array.prototype.filter = function filter(fun /*, thisp */) {
	        var object = toObject(this),
	            self = splitString && _toString(this) == "[object String]" ?
	                this.split("") :
	                    object,
	            length = self.length >>> 0,
	            result = [],
	            value,
	            thisp = arguments[1];
	        if (_toString(fun) != "[object Function]") {
	            throw new TypeError(fun + " is not a function");
	        }

	        for (var i = 0; i < length; i++) {
	            if (i in self) {
	                value = self[i];
	                if (fun.call(thisp, value, i, object)) {
	                    result.push(value);
	                }
	            }
	        }
	        return result;
	    };
	}
	if (!Array.prototype.every) {
	    Array.prototype.every = function every(fun /*, thisp */) {
	        var object = toObject(this),
	            self = splitString && _toString(this) == "[object String]" ?
	                this.split("") :
	                object,
	            length = self.length >>> 0,
	            thisp = arguments[1];
	        if (_toString(fun) != "[object Function]") {
	            throw new TypeError(fun + " is not a function");
	        }

	        for (var i = 0; i < length; i++) {
	            if (i in self && !fun.call(thisp, self[i], i, object)) {
	                return false;
	            }
	        }
	        return true;
	    };
	}
	if (!Array.prototype.some) {
	    Array.prototype.some = function some(fun /*, thisp */) {
	        var object = toObject(this),
	            self = splitString && _toString(this) == "[object String]" ?
	                this.split("") :
	                object,
	            length = self.length >>> 0,
	            thisp = arguments[1];
	        if (_toString(fun) != "[object Function]") {
	            throw new TypeError(fun + " is not a function");
	        }

	        for (var i = 0; i < length; i++) {
	            if (i in self && fun.call(thisp, self[i], i, object)) {
	                return true;
	            }
	        }
	        return false;
	    };
	}
	if (!Array.prototype.reduce) {
	    Array.prototype.reduce = function reduce(fun /*, initial*/) {
	        var object = toObject(this),
	            self = splitString && _toString(this) == "[object String]" ?
	                this.split("") :
	                object,
	            length = self.length >>> 0;
	        if (_toString(fun) != "[object Function]") {
	            throw new TypeError(fun + " is not a function");
	        }
	        if (!length && arguments.length == 1) {
	            throw new TypeError("reduce of empty array with no initial value");
	        }

	        var i = 0;
	        var result;
	        if (arguments.length >= 2) {
	            result = arguments[1];
	        } else {
	            do {
	                if (i in self) {
	                    result = self[i++];
	                    break;
	                }
	                if (++i >= length) {
	                    throw new TypeError("reduce of empty array with no initial value");
	                }
	            } while (true);
	        }

	        for (; i < length; i++) {
	            if (i in self) {
	                result = fun.call(void 0, result, self[i], i, object);
	            }
	        }

	        return result;
	    };
	}
	if (!Array.prototype.reduceRight) {
	    Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {
	        var object = toObject(this),
	            self = splitString && _toString(this) == "[object String]" ?
	                this.split("") :
	                object,
	            length = self.length >>> 0;
	        if (_toString(fun) != "[object Function]") {
	            throw new TypeError(fun + " is not a function");
	        }
	        if (!length && arguments.length == 1) {
	            throw new TypeError("reduceRight of empty array with no initial value");
	        }

	        var result, i = length - 1;
	        if (arguments.length >= 2) {
	            result = arguments[1];
	        } else {
	            do {
	                if (i in self) {
	                    result = self[i--];
	                    break;
	                }
	                if (--i < 0) {
	                    throw new TypeError("reduceRight of empty array with no initial value");
	                }
	            } while (true);
	        }

	        do {
	            if (i in this) {
	                result = fun.call(void 0, result, self[i], i, object);
	            }
	        } while (i--);

	        return result;
	    };
	}
	if (!Array.prototype.indexOf || ([0, 1].indexOf(1, 2) != -1)) {
	    Array.prototype.indexOf = function indexOf(sought /*, fromIndex */ ) {
	        var self = splitString && _toString(this) == "[object String]" ?
	                this.split("") :
	                toObject(this),
	            length = self.length >>> 0;

	        if (!length) {
	            return -1;
	        }

	        var i = 0;
	        if (arguments.length > 1) {
	            i = toInteger(arguments[1]);
	        }
	        i = i >= 0 ? i : Math.max(0, length + i);
	        for (; i < length; i++) {
	            if (i in self && self[i] === sought) {
	                return i;
	            }
	        }
	        return -1;
	    };
	}
	if (!Array.prototype.lastIndexOf || ([0, 1].lastIndexOf(0, -3) != -1)) {
	    Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {
	        var self = splitString && _toString(this) == "[object String]" ?
	                this.split("") :
	                toObject(this),
	            length = self.length >>> 0;

	        if (!length) {
	            return -1;
	        }
	        var i = length - 1;
	        if (arguments.length > 1) {
	            i = Math.min(i, toInteger(arguments[1]));
	        }
	        i = i >= 0 ? i : length - Math.abs(i);
	        for (; i >= 0; i--) {
	            if (i in self && sought === self[i]) {
	                return i;
	            }
	        }
	        return -1;
	    };
	}
	if (!Object.getPrototypeOf) {
	    Object.getPrototypeOf = function getPrototypeOf(object) {
	        return object.__proto__ || (
	            object.constructor ?
	            object.constructor.prototype :
	            prototypeOfObject
	        );
	    };
	}
	if (!Object.getOwnPropertyDescriptor) {
	    var ERR_NON_OBJECT = "Object.getOwnPropertyDescriptor called on a " +
	                         "non-object: ";
	    Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
	        if ((typeof object != "object" && typeof object != "function") || object === null)
	            throw new TypeError(ERR_NON_OBJECT + object);
	        if (!owns(object, property))
	            return;

	        var descriptor, getter, setter;
	        descriptor =  { enumerable: true, configurable: true };
	        if (supportsAccessors) {
	            var prototype = object.__proto__;
	            object.__proto__ = prototypeOfObject;

	            var getter = lookupGetter(object, property);
	            var setter = lookupSetter(object, property);
	            object.__proto__ = prototype;

	            if (getter || setter) {
	                if (getter) descriptor.get = getter;
	                if (setter) descriptor.set = setter;
	                return descriptor;
	            }
	        }
	        descriptor.value = object[property];
	        return descriptor;
	    };
	}
	if (!Object.getOwnPropertyNames) {
	    Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
	        return Object.keys(object);
	    };
	}
	if (!Object.create) {
	    var createEmpty;
	    if (Object.prototype.__proto__ === null) {
	        createEmpty = function () {
	            return { "__proto__": null };
	        };
	    } else {
	        createEmpty = function () {
	            var empty = {};
	            for (var i in empty)
	                empty[i] = null;
	            empty.constructor =
	            empty.hasOwnProperty =
	            empty.propertyIsEnumerable =
	            empty.isPrototypeOf =
	            empty.toLocaleString =
	            empty.toString =
	            empty.valueOf =
	            empty.__proto__ = null;
	            return empty;
	        }
	    }

	    Object.create = function create(prototype, properties) {
	        var object;
	        if (prototype === null) {
	            object = createEmpty();
	        } else {
	            if (typeof prototype != "object")
	                throw new TypeError("typeof prototype["+(typeof prototype)+"] != 'object'");
	            var Type = function () {};
	            Type.prototype = prototype;
	            object = new Type();
	            object.__proto__ = prototype;
	        }
	        if (properties !== void 0)
	            Object.defineProperties(object, properties);
	        return object;
	    };
	}

	function doesDefinePropertyWork(object) {
	    try {
	        Object.defineProperty(object, "sentinel", {});
	        return "sentinel" in object;
	    } catch (exception) {
	    }
	}
	if (Object.defineProperty) {
	    var definePropertyWorksOnObject = doesDefinePropertyWork({});
	    var definePropertyWorksOnDom = typeof document == "undefined" ||
	        doesDefinePropertyWork(document.createElement("div"));
	    if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
	        var definePropertyFallback = Object.defineProperty;
	    }
	}

	if (!Object.defineProperty || definePropertyFallback) {
	    var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
	    var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: "
	    var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined " +
	                                      "on this javascript engine";

	    Object.defineProperty = function defineProperty(object, property, descriptor) {
	        if ((typeof object != "object" && typeof object != "function") || object === null)
	            throw new TypeError(ERR_NON_OBJECT_TARGET + object);
	        if ((typeof descriptor != "object" && typeof descriptor != "function") || descriptor === null)
	            throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
	        if (definePropertyFallback) {
	            try {
	                return definePropertyFallback.call(Object, object, property, descriptor);
	            } catch (exception) {
	            }
	        }
	        if (owns(descriptor, "value")) {

	            if (supportsAccessors && (lookupGetter(object, property) ||
	                                      lookupSetter(object, property)))
	            {
	                var prototype = object.__proto__;
	                object.__proto__ = prototypeOfObject;
	                delete object[property];
	                object[property] = descriptor.value;
	                object.__proto__ = prototype;
	            } else {
	                object[property] = descriptor.value;
	            }
	        } else {
	            if (!supportsAccessors)
	                throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
	            if (owns(descriptor, "get"))
	                defineGetter(object, property, descriptor.get);
	            if (owns(descriptor, "set"))
	                defineSetter(object, property, descriptor.set);
	        }

	        return object;
	    };
	}
	if (!Object.defineProperties) {
	    Object.defineProperties = function defineProperties(object, properties) {
	        for (var property in properties) {
	            if (owns(properties, property))
	                Object.defineProperty(object, property, properties[property]);
	        }
	        return object;
	    };
	}
	if (!Object.seal) {
	    Object.seal = function seal(object) {
	        return object;
	    };
	}
	if (!Object.freeze) {
	    Object.freeze = function freeze(object) {
	        return object;
	    };
	}
	try {
	    Object.freeze(function () {});
	} catch (exception) {
	    Object.freeze = (function freeze(freezeObject) {
	        return function freeze(object) {
	            if (typeof object == "function") {
	                return object;
	            } else {
	                return freezeObject(object);
	            }
	        };
	    })(Object.freeze);
	}
	if (!Object.preventExtensions) {
	    Object.preventExtensions = function preventExtensions(object) {
	        return object;
	    };
	}
	if (!Object.isSealed) {
	    Object.isSealed = function isSealed(object) {
	        return false;
	    };
	}
	if (!Object.isFrozen) {
	    Object.isFrozen = function isFrozen(object) {
	        return false;
	    };
	}
	if (!Object.isExtensible) {
	    Object.isExtensible = function isExtensible(object) {
	        if (Object(object) === object) {
	            throw new TypeError(); // TODO message
	        }
	        var name = '';
	        while (owns(object, name)) {
	            name += '?';
	        }
	        object[name] = true;
	        var returnValue = owns(object, name);
	        delete object[name];
	        return returnValue;
	    };
	}
	if (!Object.keys) {
	    var hasDontEnumBug = true,
	        dontEnums = [
	            "toString",
	            "toLocaleString",
	            "valueOf",
	            "hasOwnProperty",
	            "isPrototypeOf",
	            "propertyIsEnumerable",
	            "constructor"
	        ],
	        dontEnumsLength = dontEnums.length;

	    for (var key in {"toString": null}) {
	        hasDontEnumBug = false;
	    }

	    Object.keys = function keys(object) {

	        if (
	            (typeof object != "object" && typeof object != "function") ||
	            object === null
	        ) {
	            throw new TypeError("Object.keys called on a non-object");
	        }

	        var keys = [];
	        for (var name in object) {
	            if (owns(object, name)) {
	                keys.push(name);
	            }
	        }

	        if (hasDontEnumBug) {
	            for (var i = 0, ii = dontEnumsLength; i < ii; i++) {
	                var dontEnum = dontEnums[i];
	                if (owns(object, dontEnum)) {
	                    keys.push(dontEnum);
	                }
	            }
	        }
	        return keys;
	    };

	}
	if (!Date.now) {
	    Date.now = function now() {
	        return new Date().getTime();
	    };
	}
	var ws = "\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003" +
	    "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028" +
	    "\u2029\uFEFF";
	if (!String.prototype.trim || ws.trim()) {
	    ws = "[" + ws + "]";
	    var trimBeginRegexp = new RegExp("^" + ws + ws + "*"),
	        trimEndRegexp = new RegExp(ws + ws + "*$");
	    String.prototype.trim = function trim() {
	        return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
	    };
	}

	function toInteger(n) {
	    n = +n;
	    if (n !== n) { // isNaN
	        n = 0;
	    } else if (n !== 0 && n !== (1/0) && n !== -(1/0)) {
	        n = (n > 0 || -1) * Math.floor(Math.abs(n));
	    }
	    return n;
	}

	function isPrimitive(input) {
	    var type = typeof input;
	    return (
	        input === null ||
	        type === "undefined" ||
	        type === "boolean" ||
	        type === "number" ||
	        type === "string"
	    );
	}

	function toPrimitive(input) {
	    var val, valueOf, toString;
	    if (isPrimitive(input)) {
	        return input;
	    }
	    valueOf = input.valueOf;
	    if (typeof valueOf === "function") {
	        val = valueOf.call(input);
	        if (isPrimitive(val)) {
	            return val;
	        }
	    }
	    toString = input.toString;
	    if (typeof toString === "function") {
	        val = toString.call(input);
	        if (isPrimitive(val)) {
	            return val;
	        }
	    }
	    throw new TypeError();
	}
	var toObject = function (o) {
	    if (o == null) { // this matches both null and undefined
	        throw new TypeError("can't convert "+o+" to object");
	    }
	    return Object(o);
	};

	});

	ace.define("ace/lib/fixoldbrowsers",["require","exports","module","ace/lib/regexp","ace/lib/es5-shim"], function(acequire, exports, module) {
	"use strict";

	acequire("./regexp");
	acequire("./es5-shim");

	});

	ace.define("ace/lib/dom",["require","exports","module"], function(acequire, exports, module) {
	"use strict";

	var XHTML_NS = "http://www.w3.org/1999/xhtml";

	exports.getDocumentHead = function(doc) {
	    if (!doc)
	        doc = document;
	    return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
	};

	exports.createElement = function(tag, ns) {
	    return document.createElementNS ?
	           document.createElementNS(ns || XHTML_NS, tag) :
	           document.createElement(tag);
	};

	exports.hasCssClass = function(el, name) {
	    var classes = (el.className || "").split(/\s+/g);
	    return classes.indexOf(name) !== -1;
	};
	exports.addCssClass = function(el, name) {
	    if (!exports.hasCssClass(el, name)) {
	        el.className += " " + name;
	    }
	};
	exports.removeCssClass = function(el, name) {
	    var classes = el.className.split(/\s+/g);
	    while (true) {
	        var index = classes.indexOf(name);
	        if (index == -1) {
	            break;
	        }
	        classes.splice(index, 1);
	    }
	    el.className = classes.join(" ");
	};

	exports.toggleCssClass = function(el, name) {
	    var classes = el.className.split(/\s+/g), add = true;
	    while (true) {
	        var index = classes.indexOf(name);
	        if (index == -1) {
	            break;
	        }
	        add = false;
	        classes.splice(index, 1);
	    }
	    if (add)
	        classes.push(name);

	    el.className = classes.join(" ");
	    return add;
	};
	exports.setCssClass = function(node, className, include) {
	    if (include) {
	        exports.addCssClass(node, className);
	    } else {
	        exports.removeCssClass(node, className);
	    }
	};

	exports.hasCssString = function(id, doc) {
	    var index = 0, sheets;
	    doc = doc || document;

	    if (doc.createStyleSheet && (sheets = doc.styleSheets)) {
	        while (index < sheets.length)
	            if (sheets[index++].owningElement.id === id) return true;
	    } else if ((sheets = doc.getElementsByTagName("style"))) {
	        while (index < sheets.length)
	            if (sheets[index++].id === id) return true;
	    }

	    return false;
	};

	exports.importCssString = function importCssString(cssText, id, doc) {
	    doc = doc || document;
	    if (id && exports.hasCssString(id, doc))
	        return null;
	    
	    var style;
	    
	    if (id)
	        cssText += "\n/*# sourceURL=ace/css/" + id + " */";
	    
	    if (doc.createStyleSheet) {
	        style = doc.createStyleSheet();
	        style.cssText = cssText;
	        if (id)
	            style.owningElement.id = id;
	    } else {
	        style = exports.createElement("style");
	        style.appendChild(doc.createTextNode(cssText));
	        if (id)
	            style.id = id;

	        exports.getDocumentHead(doc).appendChild(style);
	    }
	};

	exports.importCssStylsheet = function(uri, doc) {
	    if (doc.createStyleSheet) {
	        doc.createStyleSheet(uri);
	    } else {
	        var link = exports.createElement('link');
	        link.rel = 'stylesheet';
	        link.href = uri;

	        exports.getDocumentHead(doc).appendChild(link);
	    }
	};

	exports.getInnerWidth = function(element) {
	    return (
	        parseInt(exports.computedStyle(element, "paddingLeft"), 10) +
	        parseInt(exports.computedStyle(element, "paddingRight"), 10) + 
	        element.clientWidth
	    );
	};

	exports.getInnerHeight = function(element) {
	    return (
	        parseInt(exports.computedStyle(element, "paddingTop"), 10) +
	        parseInt(exports.computedStyle(element, "paddingBottom"), 10) +
	        element.clientHeight
	    );
	};

	exports.scrollbarWidth = function(document) {
	    var inner = exports.createElement("ace_inner");
	    inner.style.width = "100%";
	    inner.style.minWidth = "0px";
	    inner.style.height = "200px";
	    inner.style.display = "block";

	    var outer = exports.createElement("ace_outer");
	    var style = outer.style;

	    style.position = "absolute";
	    style.left = "-10000px";
	    style.overflow = "hidden";
	    style.width = "200px";
	    style.minWidth = "0px";
	    style.height = "150px";
	    style.display = "block";

	    outer.appendChild(inner);

	    var body = document.documentElement;
	    body.appendChild(outer);

	    var noScrollbar = inner.offsetWidth;

	    style.overflow = "scroll";
	    var withScrollbar = inner.offsetWidth;

	    if (noScrollbar == withScrollbar) {
	        withScrollbar = outer.clientWidth;
	    }

	    body.removeChild(outer);

	    return noScrollbar-withScrollbar;
	};

	if (typeof document == "undefined") {
	    exports.importCssString = function() {};
	    return;
	}

	if (window.pageYOffset !== undefined) {
	    exports.getPageScrollTop = function() {
	        return window.pageYOffset;
	    };

	    exports.getPageScrollLeft = function() {
	        return window.pageXOffset;
	    };
	}
	else {
	    exports.getPageScrollTop = function() {
	        return document.body.scrollTop;
	    };

	    exports.getPageScrollLeft = function() {
	        return document.body.scrollLeft;
	    };
	}

	if (window.getComputedStyle)
	    exports.computedStyle = function(element, style) {
	        if (style)
	            return (window.getComputedStyle(element, "") || {})[style] || "";
	        return window.getComputedStyle(element, "") || {};
	    };
	else
	    exports.computedStyle = function(element, style) {
	        if (style)
	            return element.currentStyle[style];
	        return element.currentStyle;
	    };
	exports.setInnerHtml = function(el, innerHtml) {
	    var element = el.cloneNode(false);//document.createElement("div");
	    element.innerHTML = innerHtml;
	    el.parentNode.replaceChild(element, el);
	    return element;
	};

	if ("textContent" in document.documentElement) {
	    exports.setInnerText = function(el, innerText) {
	        el.textContent = innerText;
	    };

	    exports.getInnerText = function(el) {
	        return el.textContent;
	    };
	}
	else {
	    exports.setInnerText = function(el, innerText) {
	        el.innerText = innerText;
	    };

	    exports.getInnerText = function(el) {
	        return el.innerText;
	    };
	}

	exports.getParentWindow = function(document) {
	    return document.defaultView || document.parentWindow;
	};

	});

	ace.define("ace/lib/oop",["require","exports","module"], function(acequire, exports, module) {
	"use strict";

	exports.inherits = function(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    ctor.prototype = Object.create(superCtor.prototype, {
	        constructor: {
	            value: ctor,
	            enumerable: false,
	            writable: true,
	            configurable: true
	        }
	    });
	};

	exports.mixin = function(obj, mixin) {
	    for (var key in mixin) {
	        obj[key] = mixin[key];
	    }
	    return obj;
	};

	exports.implement = function(proto, mixin) {
	    exports.mixin(proto, mixin);
	};

	});

	ace.define("ace/lib/keys",["require","exports","module","ace/lib/fixoldbrowsers","ace/lib/oop"], function(acequire, exports, module) {
	"use strict";

	acequire("./fixoldbrowsers");

	var oop = acequire("./oop");
	var Keys = (function() {
	    var ret = {
	        MODIFIER_KEYS: {
	            16: 'Shift', 17: 'Ctrl', 18: 'Alt', 224: 'Meta'
	        },

	        KEY_MODS: {
	            "ctrl": 1, "alt": 2, "option" : 2, "shift": 4,
	            "super": 8, "meta": 8, "command": 8, "cmd": 8
	        },

	        FUNCTION_KEYS : {
	            8  : "Backspace",
	            9  : "Tab",
	            13 : "Return",
	            19 : "Pause",
	            27 : "Esc",
	            32 : "Space",
	            33 : "PageUp",
	            34 : "PageDown",
	            35 : "End",
	            36 : "Home",
	            37 : "Left",
	            38 : "Up",
	            39 : "Right",
	            40 : "Down",
	            44 : "Print",
	            45 : "Insert",
	            46 : "Delete",
	            96 : "Numpad0",
	            97 : "Numpad1",
	            98 : "Numpad2",
	            99 : "Numpad3",
	            100: "Numpad4",
	            101: "Numpad5",
	            102: "Numpad6",
	            103: "Numpad7",
	            104: "Numpad8",
	            105: "Numpad9",
	            '-13': "NumpadEnter",
	            112: "F1",
	            113: "F2",
	            114: "F3",
	            115: "F4",
	            116: "F5",
	            117: "F6",
	            118: "F7",
	            119: "F8",
	            120: "F9",
	            121: "F10",
	            122: "F11",
	            123: "F12",
	            144: "Numlock",
	            145: "Scrolllock"
	        },

	        PRINTABLE_KEYS: {
	           32: ' ',  48: '0',  49: '1',  50: '2',  51: '3',  52: '4', 53:  '5',
	           54: '6',  55: '7',  56: '8',  57: '9',  59: ';',  61: '=', 65:  'a',
	           66: 'b',  67: 'c',  68: 'd',  69: 'e',  70: 'f',  71: 'g', 72:  'h',
	           73: 'i',  74: 'j',  75: 'k',  76: 'l',  77: 'm',  78: 'n', 79:  'o',
	           80: 'p',  81: 'q',  82: 'r',  83: 's',  84: 't',  85: 'u', 86:  'v',
	           87: 'w',  88: 'x',  89: 'y',  90: 'z', 107: '+', 109: '-', 110: '.',
	          186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`',
	          219: '[', 220: '\\',221: ']', 222: "'", 111: '/', 106: '*'
	        }
	    };
	    var name, i;
	    for (i in ret.FUNCTION_KEYS) {
	        name = ret.FUNCTION_KEYS[i].toLowerCase();
	        ret[name] = parseInt(i, 10);
	    }
	    for (i in ret.PRINTABLE_KEYS) {
	        name = ret.PRINTABLE_KEYS[i].toLowerCase();
	        ret[name] = parseInt(i, 10);
	    }
	    oop.mixin(ret, ret.MODIFIER_KEYS);
	    oop.mixin(ret, ret.PRINTABLE_KEYS);
	    oop.mixin(ret, ret.FUNCTION_KEYS);
	    ret.enter = ret["return"];
	    ret.escape = ret.esc;
	    ret.del = ret["delete"];
	    ret[173] = '-';
	    
	    (function() {
	        var mods = ["cmd", "ctrl", "alt", "shift"];
	        for (var i = Math.pow(2, mods.length); i--;) {            
	            ret.KEY_MODS[i] = mods.filter(function(x) {
	                return i & ret.KEY_MODS[x];
	            }).join("-") + "-";
	        }
	    })();

	    ret.KEY_MODS[0] = "";
	    ret.KEY_MODS[-1] = "input-";

	    return ret;
	})();
	oop.mixin(exports, Keys);

	exports.keyCodeToString = function(keyCode) {
	    var keyString = Keys[keyCode];
	    if (typeof keyString != "string")
	        keyString = String.fromCharCode(keyCode);
	    return keyString.toLowerCase();
	};

	});

	ace.define("ace/lib/useragent",["require","exports","module"], function(acequire, exports, module) {
	"use strict";
	exports.OS = {
	    LINUX: "LINUX",
	    MAC: "MAC",
	    WINDOWS: "WINDOWS"
	};
	exports.getOS = function() {
	    if (exports.isMac) {
	        return exports.OS.MAC;
	    } else if (exports.isLinux) {
	        return exports.OS.LINUX;
	    } else {
	        return exports.OS.WINDOWS;
	    }
	};
	if (typeof navigator != "object")
	    return;

	var os = (navigator.platform.match(/mac|win|linux/i) || ["other"])[0].toLowerCase();
	var ua = navigator.userAgent;
	exports.isWin = (os == "win");
	exports.isMac = (os == "mac");
	exports.isLinux = (os == "linux");
	exports.isIE = 
	    (navigator.appName == "Microsoft Internet Explorer" || navigator.appName.indexOf("MSAppHost") >= 0)
	    ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1])
	    : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1]); // for ie
	    
	exports.isOldIE = exports.isIE && exports.isIE < 9;
	exports.isGecko = exports.isMozilla = (window.Controllers || window.controllers) && window.navigator.product === "Gecko";
	exports.isOldGecko = exports.isGecko && parseInt((ua.match(/rv\:(\d+)/)||[])[1], 10) < 4;
	exports.isOpera = window.opera && Object.prototype.toString.call(window.opera) == "[object Opera]";
	exports.isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;

	exports.isChrome = parseFloat(ua.split(" Chrome/")[1]) || undefined;

	exports.isAIR = ua.indexOf("AdobeAIR") >= 0;

	exports.isIPad = ua.indexOf("iPad") >= 0;

	exports.isTouchPad = ua.indexOf("TouchPad") >= 0;

	exports.isChromeOS = ua.indexOf(" CrOS ") >= 0;

	});

	ace.define("ace/lib/event",["require","exports","module","ace/lib/keys","ace/lib/useragent"], function(acequire, exports, module) {
	"use strict";

	var keys = acequire("./keys");
	var useragent = acequire("./useragent");

	var pressedKeys = null;
	var ts = 0;

	exports.addListener = function(elem, type, callback) {
	    if (elem.addEventListener) {
	        return elem.addEventListener(type, callback, false);
	    }
	    if (elem.attachEvent) {
	        var wrapper = function() {
	            callback.call(elem, window.event);
	        };
	        callback._wrapper = wrapper;
	        elem.attachEvent("on" + type, wrapper);
	    }
	};

	exports.removeListener = function(elem, type, callback) {
	    if (elem.removeEventListener) {
	        return elem.removeEventListener(type, callback, false);
	    }
	    if (elem.detachEvent) {
	        elem.detachEvent("on" + type, callback._wrapper || callback);
	    }
	};
	exports.stopEvent = function(e) {
	    exports.stopPropagation(e);
	    exports.preventDefault(e);
	    return false;
	};

	exports.stopPropagation = function(e) {
	    if (e.stopPropagation)
	        e.stopPropagation();
	    else
	        e.cancelBubble = true;
	};

	exports.preventDefault = function(e) {
	    if (e.preventDefault)
	        e.preventDefault();
	    else
	        e.returnValue = false;
	};
	exports.getButton = function(e) {
	    if (e.type == "dblclick")
	        return 0;
	    if (e.type == "contextmenu" || (useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey)))
	        return 2;
	    if (e.preventDefault) {
	        return e.button;
	    }
	    else {
	        return {1:0, 2:2, 4:1}[e.button];
	    }
	};

	exports.capture = function(el, eventHandler, releaseCaptureHandler) {
	    function onMouseUp(e) {
	        eventHandler && eventHandler(e);
	        releaseCaptureHandler && releaseCaptureHandler(e);

	        exports.removeListener(document, "mousemove", eventHandler, true);
	        exports.removeListener(document, "mouseup", onMouseUp, true);
	        exports.removeListener(document, "dragstart", onMouseUp, true);
	    }

	    exports.addListener(document, "mousemove", eventHandler, true);
	    exports.addListener(document, "mouseup", onMouseUp, true);
	    exports.addListener(document, "dragstart", onMouseUp, true);
	    
	    return onMouseUp;
	};

	exports.addTouchMoveListener = function (el, callback) {
	    if ("ontouchmove" in el) {
	        var startx, starty;
	        exports.addListener(el, "touchstart", function (e) {
	            var touchObj = e.changedTouches[0];
	            startx = touchObj.clientX;
	            starty = touchObj.clientY;
	        });
	        exports.addListener(el, "touchmove", function (e) {
	            var factor = 1,
	            touchObj = e.changedTouches[0];

	            e.wheelX = -(touchObj.clientX - startx) / factor;
	            e.wheelY = -(touchObj.clientY - starty) / factor;

	            startx = touchObj.clientX;
	            starty = touchObj.clientY;

	            callback(e);
	        });
	    } 
	};

	exports.addMouseWheelListener = function(el, callback) {
	    if ("onmousewheel" in el) {
	        exports.addListener(el, "mousewheel", function(e) {
	            var factor = 8;
	            if (e.wheelDeltaX !== undefined) {
	                e.wheelX = -e.wheelDeltaX / factor;
	                e.wheelY = -e.wheelDeltaY / factor;
	            } else {
	                e.wheelX = 0;
	                e.wheelY = -e.wheelDelta / factor;
	            }
	            callback(e);
	        });
	    } else if ("onwheel" in el) {
	        exports.addListener(el, "wheel",  function(e) {
	            var factor = 0.35;
	            switch (e.deltaMode) {
	                case e.DOM_DELTA_PIXEL:
	                    e.wheelX = e.deltaX * factor || 0;
	                    e.wheelY = e.deltaY * factor || 0;
	                    break;
	                case e.DOM_DELTA_LINE:
	                case e.DOM_DELTA_PAGE:
	                    e.wheelX = (e.deltaX || 0) * 5;
	                    e.wheelY = (e.deltaY || 0) * 5;
	                    break;
	            }
	            
	            callback(e);
	        });
	    } else {
	        exports.addListener(el, "DOMMouseScroll", function(e) {
	            if (e.axis && e.axis == e.HORIZONTAL_AXIS) {
	                e.wheelX = (e.detail || 0) * 5;
	                e.wheelY = 0;
	            } else {
	                e.wheelX = 0;
	                e.wheelY = (e.detail || 0) * 5;
	            }
	            callback(e);
	        });
	    }
	};

	exports.addMultiMouseDownListener = function(elements, timeouts, eventHandler, callbackName) {
	    var clicks = 0;
	    var startX, startY, timer; 
	    var eventNames = {
	        2: "dblclick",
	        3: "tripleclick",
	        4: "quadclick"
	    };

	    function onMousedown(e) {
	        if (exports.getButton(e) !== 0) {
	            clicks = 0;
	        } else if (e.detail > 1) {
	            clicks++;
	            if (clicks > 4)
	                clicks = 1;
	        } else {
	            clicks = 1;
	        }
	        if (useragent.isIE) {
	            var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
	            if (!timer || isNewClick)
	                clicks = 1;
	            if (timer)
	                clearTimeout(timer);
	            timer = setTimeout(function() {timer = null}, timeouts[clicks - 1] || 600);

	            if (clicks == 1) {
	                startX = e.clientX;
	                startY = e.clientY;
	            }
	        }
	        
	        e._clicks = clicks;

	        eventHandler[callbackName]("mousedown", e);

	        if (clicks > 4)
	            clicks = 0;
	        else if (clicks > 1)
	            return eventHandler[callbackName](eventNames[clicks], e);
	    }
	    function onDblclick(e) {
	        clicks = 2;
	        if (timer)
	            clearTimeout(timer);
	        timer = setTimeout(function() {timer = null}, timeouts[clicks - 1] || 600);
	        eventHandler[callbackName]("mousedown", e);
	        eventHandler[callbackName](eventNames[clicks], e);
	    }
	    if (!Array.isArray(elements))
	        elements = [elements];
	    elements.forEach(function(el) {
	        exports.addListener(el, "mousedown", onMousedown);
	        if (useragent.isOldIE)
	            exports.addListener(el, "dblclick", onDblclick);
	    });
	};

	var getModifierHash = useragent.isMac && useragent.isOpera && !("KeyboardEvent" in window)
	    ? function(e) {
	        return 0 | (e.metaKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.ctrlKey ? 8 : 0);
	    }
	    : function(e) {
	        return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
	    };

	exports.getModifierString = function(e) {
	    return keys.KEY_MODS[getModifierHash(e)];
	};

	function normalizeCommandKeys(callback, e, keyCode) {
	    var hashId = getModifierHash(e);

	    if (!useragent.isMac && pressedKeys) {
	        if (pressedKeys.OSKey)
	            hashId |= 8;
	        if (pressedKeys.altGr) {
	            if ((3 & hashId) != 3)
	                pressedKeys.altGr = 0;
	            else
	                return;
	        }
	        if (keyCode === 18 || keyCode === 17) {
	            var location = "location" in e ? e.location : e.keyLocation;
	            if (keyCode === 17 && location === 1) {
	                if (pressedKeys[keyCode] == 1)
	                    ts = e.timeStamp;
	            } else if (keyCode === 18 && hashId === 3 && location === 2) {
	                var dt = e.timeStamp - ts;
	                if (dt < 50)
	                    pressedKeys.altGr = true;
	            }
	        }
	    }
	    
	    if (keyCode in keys.MODIFIER_KEYS) {
	        keyCode = -1;
	    }
	    if (hashId & 8 && (keyCode >= 91 && keyCode <= 93)) {
	        keyCode = -1;
	    }
	    
	    if (!hashId && keyCode === 13) {
	        var location = "location" in e ? e.location : e.keyLocation;
	        if (location === 3) {
	            callback(e, hashId, -keyCode);
	            if (e.defaultPrevented)
	                return;
	        }
	    }
	    
	    if (useragent.isChromeOS && hashId & 8) {
	        callback(e, hashId, keyCode);
	        if (e.defaultPrevented)
	            return;
	        else
	            hashId &= ~8;
	    }
	    if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
	        return false;
	    }
	    
	    return callback(e, hashId, keyCode);
	}


	exports.addCommandKeyListener = function(el, callback) {
	    var addListener = exports.addListener;
	    if (useragent.isOldGecko || (useragent.isOpera && !("KeyboardEvent" in window))) {
	        var lastKeyDownKeyCode = null;
	        addListener(el, "keydown", function(e) {
	            lastKeyDownKeyCode = e.keyCode;
	        });
	        addListener(el, "keypress", function(e) {
	            return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
	        });
	    } else {
	        var lastDefaultPrevented = null;

	        addListener(el, "keydown", function(e) {
	            var keyCode = e.keyCode;
	            pressedKeys[keyCode] = (pressedKeys[keyCode] || 0) + 1;
	            if (keyCode == 91 || keyCode == 92) {
	                pressedKeys.OSKey = true;
	            } else if (pressedKeys.OSKey) {
	                if (e.timeStamp - pressedKeys.lastT > 200 && pressedKeys.count == 1)
	                    resetPressedKeys();
	            }
	            if (pressedKeys[keyCode] == 1)
	                pressedKeys.count++;
	            pressedKeys.lastT = e.timeStamp;
	            var result = normalizeCommandKeys(callback, e, keyCode);
	            lastDefaultPrevented = e.defaultPrevented;
	            return result;
	        });

	        addListener(el, "keypress", function(e) {
	            if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
	                exports.stopEvent(e);
	                lastDefaultPrevented = null;
	            }
	        });

	        addListener(el, "keyup", function(e) {
	            var keyCode = e.keyCode;
	            if (!pressedKeys[keyCode]) {
	                resetPressedKeys();
	            } else {
	                pressedKeys.count = Math.max(pressedKeys.count - 1, 0);
	            }
	            if (keyCode == 91 || keyCode == 92) {
	                pressedKeys.OSKey = false;
	            }
	            pressedKeys[keyCode] = null;
	        });

	        if (!pressedKeys) {
	            resetPressedKeys();
	            addListener(window, "focus", resetPressedKeys);
	        }
	    }
	};
	function resetPressedKeys() {
	    pressedKeys = Object.create(null);
	    pressedKeys.count = 0;
	    pressedKeys.lastT = 0;
	}

	if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
	    var postMessageId = 1;
	    exports.nextTick = function(callback, win) {
	        win = win || window;
	        var messageName = "zero-timeout-message-" + postMessageId;
	        exports.addListener(win, "message", function listener(e) {
	            if (e.data == messageName) {
	                exports.stopPropagation(e);
	                exports.removeListener(win, "message", listener);
	                callback();
	            }
	        });
	        win.postMessage(messageName, "*");
	    };
	}


	exports.nextFrame = typeof window == "object" && (window.requestAnimationFrame
	    || window.mozRequestAnimationFrame
	    || window.webkitRequestAnimationFrame
	    || window.msRequestAnimationFrame
	    || window.oRequestAnimationFrame);

	if (exports.nextFrame)
	    exports.nextFrame = exports.nextFrame.bind(window);
	else
	    exports.nextFrame = function(callback) {
	        setTimeout(callback, 17);
	    };
	});

	ace.define("ace/lib/lang",["require","exports","module"], function(acequire, exports, module) {
	"use strict";

	exports.last = function(a) {
	    return a[a.length - 1];
	};

	exports.stringReverse = function(string) {
	    return string.split("").reverse().join("");
	};

	exports.stringRepeat = function (string, count) {
	    var result = '';
	    while (count > 0) {
	        if (count & 1)
	            result += string;

	        if (count >>= 1)
	            string += string;
	    }
	    return result;
	};

	var trimBeginRegexp = /^\s\s*/;
	var trimEndRegexp = /\s\s*$/;

	exports.stringTrimLeft = function (string) {
	    return string.replace(trimBeginRegexp, '');
	};

	exports.stringTrimRight = function (string) {
	    return string.replace(trimEndRegexp, '');
	};

	exports.copyObject = function(obj) {
	    var copy = {};
	    for (var key in obj) {
	        copy[key] = obj[key];
	    }
	    return copy;
	};

	exports.copyArray = function(array){
	    var copy = [];
	    for (var i=0, l=array.length; i<l; i++) {
	        if (array[i] && typeof array[i] == "object")
	            copy[i] = this.copyObject( array[i] );
	        else 
	            copy[i] = array[i];
	    }
	    return copy;
	};

	exports.deepCopy = function deepCopy(obj) {
	    if (typeof obj !== "object" || !obj)
	        return obj;
	    var copy;
	    if (Array.isArray(obj)) {
	        copy = [];
	        for (var key = 0; key < obj.length; key++) {
	            copy[key] = deepCopy(obj[key]);
	        }
	        return copy;
	    }
	    var cons = obj.constructor;
	    if (cons === RegExp)
	        return obj;
	    
	    copy = cons();
	    for (var key in obj) {
	        copy[key] = deepCopy(obj[key]);
	    }
	    return copy;
	};

	exports.arrayToMap = function(arr) {
	    var map = {};
	    for (var i=0; i<arr.length; i++) {
	        map[arr[i]] = 1;
	    }
	    return map;

	};

	exports.createMap = function(props) {
	    var map = Object.create(null);
	    for (var i in props) {
	        map[i] = props[i];
	    }
	    return map;
	};
	exports.arrayRemove = function(array, value) {
	  for (var i = 0; i <= array.length; i++) {
	    if (value === array[i]) {
	      array.splice(i, 1);
	    }
	  }
	};

	exports.escapeRegExp = function(str) {
	    return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
	};

	exports.escapeHTML = function(str) {
	    return str.replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
	};

	exports.getMatchOffsets = function(string, regExp) {
	    var matches = [];

	    string.replace(regExp, function(str) {
	        matches.push({
	            offset: arguments[arguments.length-2],
	            length: str.length
	        });
	    });

	    return matches;
	};
	exports.deferredCall = function(fcn) {
	    var timer = null;
	    var callback = function() {
	        timer = null;
	        fcn();
	    };

	    var deferred = function(timeout) {
	        deferred.cancel();
	        timer = setTimeout(callback, timeout || 0);
	        return deferred;
	    };

	    deferred.schedule = deferred;

	    deferred.call = function() {
	        this.cancel();
	        fcn();
	        return deferred;
	    };

	    deferred.cancel = function() {
	        clearTimeout(timer);
	        timer = null;
	        return deferred;
	    };
	    
	    deferred.isPending = function() {
	        return timer;
	    };

	    return deferred;
	};


	exports.delayedCall = function(fcn, defaultTimeout) {
	    var timer = null;
	    var callback = function() {
	        timer = null;
	        fcn();
	    };

	    var _self = function(timeout) {
	        if (timer == null)
	            timer = setTimeout(callback, timeout || defaultTimeout);
	    };

	    _self.delay = function(timeout) {
	        timer && clearTimeout(timer);
	        timer = setTimeout(callback, timeout || defaultTimeout);
	    };
	    _self.schedule = _self;

	    _self.call = function() {
	        this.cancel();
	        fcn();
	    };

	    _self.cancel = function() {
	        timer && clearTimeout(timer);
	        timer = null;
	    };

	    _self.isPending = function() {
	        return timer;
	    };

	    return _self;
	};
	});

	ace.define("ace/keyboard/textinput",["require","exports","module","ace/lib/event","ace/lib/useragent","ace/lib/dom","ace/lib/lang"], function(acequire, exports, module) {
	"use strict";

	var event = acequire("../lib/event");
	var useragent = acequire("../lib/useragent");
	var dom = acequire("../lib/dom");
	var lang = acequire("../lib/lang");
	var BROKEN_SETDATA = useragent.isChrome < 18;
	var USE_IE_MIME_TYPE =  useragent.isIE;

	var TextInput = function(parentNode, host) {
	    var text = dom.createElement("textarea");
	    text.className = "ace_text-input";

	    if (useragent.isTouchPad)
	        text.setAttribute("x-palm-disable-auto-cap", true);

	    text.setAttribute("wrap", "off");
	    text.setAttribute("autocorrect", "off");
	    text.setAttribute("autocapitalize", "off");
	    text.setAttribute("spellcheck", false);

	    text.style.opacity = "0";
	    if (useragent.isOldIE) text.style.top = "-1000px";
	    parentNode.insertBefore(text, parentNode.firstChild);

	    var PLACEHOLDER = "\x01\x01";

	    var copied = false;
	    var pasted = false;
	    var inComposition = false;
	    var tempStyle = '';
	    var isSelectionEmpty = true;
	    try { var isFocused = document.activeElement === text; } catch(e) {}
	    
	    event.addListener(text, "blur", function(e) {
	        host.onBlur(e);
	        isFocused = false;
	    });
	    event.addListener(text, "focus", function(e) {
	        isFocused = true;
	        host.onFocus(e);
	        resetSelection();
	    });
	    this.focus = function() {
	        if (tempStyle) return text.focus();
	        var top = text.style.top;
	        text.style.position = "fixed";
	        text.style.top = "0px";
	        text.focus();
	        setTimeout(function() {
	            text.style.position = "";
	            if (text.style.top == "0px")
	                text.style.top = top;
	        }, 0);
	    };
	    this.blur = function() {
	        text.blur();
	    };
	    this.isFocused = function() {
	        return isFocused;
	    };
	    var syncSelection = lang.delayedCall(function() {
	        isFocused && resetSelection(isSelectionEmpty);
	    });
	    var syncValue = lang.delayedCall(function() {
	         if (!inComposition) {
	            text.value = PLACEHOLDER;
	            isFocused && resetSelection();
	         }
	    });

	    function resetSelection(isEmpty) {
	        if (inComposition)
	            return;
	        inComposition = true;
	        
	        if (inputHandler) {
	            selectionStart = 0;
	            selectionEnd = isEmpty ? 0 : text.value.length - 1;
	        } else {
	            var selectionStart = isEmpty ? 2 : 1;
	            var selectionEnd = 2;
	        }
	        try {
	            text.setSelectionRange(selectionStart, selectionEnd);
	        } catch(e){}
	        
	        inComposition = false;
	    }

	    function resetValue() {
	        if (inComposition)
	            return;
	        text.value = PLACEHOLDER;
	        if (useragent.isWebKit)
	            syncValue.schedule();
	    }

	    useragent.isWebKit || host.addEventListener('changeSelection', function() {
	        if (host.selection.isEmpty() != isSelectionEmpty) {
	            isSelectionEmpty = !isSelectionEmpty;
	            syncSelection.schedule();
	        }
	    });

	    resetValue();
	    if (isFocused)
	        host.onFocus();


	    var isAllSelected = function(text) {
	        return text.selectionStart === 0 && text.selectionEnd === text.value.length;
	    };
	    if (!text.setSelectionRange && text.createTextRange) {
	        text.setSelectionRange = function(selectionStart, selectionEnd) {
	            var range = this.createTextRange();
	            range.collapse(true);
	            range.moveStart('character', selectionStart);
	            range.moveEnd('character', selectionEnd);
	            range.select();
	        };
	        isAllSelected = function(text) {
	            try {
	                var range = text.ownerDocument.selection.createRange();
	            }catch(e) {}
	            if (!range || range.parentElement() != text) return false;
	                return range.text == text.value;
	        }
	    }
	    if (useragent.isOldIE) {
	        var inPropertyChange = false;
	        var onPropertyChange = function(e){
	            if (inPropertyChange)
	                return;
	            var data = text.value;
	            if (inComposition || !data || data == PLACEHOLDER)
	                return;
	            if (e && data == PLACEHOLDER[0])
	                return syncProperty.schedule();

	            sendText(data);
	            inPropertyChange = true;
	            resetValue();
	            inPropertyChange = false;
	        };
	        var syncProperty = lang.delayedCall(onPropertyChange);
	        event.addListener(text, "propertychange", onPropertyChange);

	        var keytable = { 13:1, 27:1 };
	        event.addListener(text, "keyup", function (e) {
	            if (inComposition && (!text.value || keytable[e.keyCode]))
	                setTimeout(onCompositionEnd, 0);
	            if ((text.value.charCodeAt(0)||0) < 129) {
	                return syncProperty.call();
	            }
	            inComposition ? onCompositionUpdate() : onCompositionStart();
	        });
	        event.addListener(text, "keydown", function (e) {
	            syncProperty.schedule(50);
	        });
	    }

	    var onSelect = function(e) {
	        if (copied) {
	            copied = false;
	        } else if (isAllSelected(text)) {
	            host.selectAll();
	            resetSelection();
	        } else if (inputHandler) {
	            resetSelection(host.selection.isEmpty());
	        }
	    };

	    var inputHandler = null;
	    this.setInputHandler = function(cb) {inputHandler = cb};
	    this.getInputHandler = function() {return inputHandler};
	    var afterContextMenu = false;
	    
	    var sendText = function(data) {
	        if (inputHandler) {
	            data = inputHandler(data);
	            inputHandler = null;
	        }
	        if (pasted) {
	            resetSelection();
	            if (data)
	                host.onPaste(data);
	            pasted = false;
	        } else if (data == PLACEHOLDER.charAt(0)) {
	            if (afterContextMenu)
	                host.execCommand("del", {source: "ace"});
	            else // some versions of android do not fire keydown when pressing backspace
	                host.execCommand("backspace", {source: "ace"});
	        } else {
	            if (data.substring(0, 2) == PLACEHOLDER)
	                data = data.substr(2);
	            else if (data.charAt(0) == PLACEHOLDER.charAt(0))
	                data = data.substr(1);
	            else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
	                data = data.slice(0, -1);
	            if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
	                data = data.slice(0, -1);
	            
	            if (data)
	                host.onTextInput(data);
	        }
	        if (afterContextMenu)
	            afterContextMenu = false;
	    };
	    var onInput = function(e) {
	        if (inComposition)
	            return;
	        var data = text.value;
	        sendText(data);
	        resetValue();
	    };
	    
	    var handleClipboardData = function(e, data) {
	        var clipboardData = e.clipboardData || window.clipboardData;
	        if (!clipboardData || BROKEN_SETDATA)
	            return;
	        var mime = USE_IE_MIME_TYPE ? "Text" : "text/plain";
	        if (data) {
	            return clipboardData.setData(mime, data) !== false;
	        } else {
	            return clipboardData.getData(mime);
	        }
	    };

	    var doCopy = function(e, isCut) {
	        var data = host.getCopyText();
	        if (!data)
	            return event.preventDefault(e);

	        if (handleClipboardData(e, data)) {
	            isCut ? host.onCut() : host.onCopy();
	            event.preventDefault(e);
	        } else {
	            copied = true;
	            text.value = data;
	            text.select();
	            setTimeout(function(){
	                copied = false;
	                resetValue();
	                resetSelection();
	                isCut ? host.onCut() : host.onCopy();
	            });
	        }
	    };
	    
	    var onCut = function(e) {
	        doCopy(e, true);
	    };
	    
	    var onCopy = function(e) {
	        doCopy(e, false);
	    };
	    
	    var onPaste = function(e) {
	        var data = handleClipboardData(e);
	        if (typeof data == "string") {
	            if (data)
	                host.onPaste(data, e);
	            if (useragent.isIE)
	                setTimeout(resetSelection);
	            event.preventDefault(e);
	        }
	        else {
	            text.value = "";
	            pasted = true;
	        }
	    };

	    event.addCommandKeyListener(text, host.onCommandKey.bind(host));

	    event.addListener(text, "select", onSelect);

	    event.addListener(text, "input", onInput);

	    event.addListener(text, "cut", onCut);
	    event.addListener(text, "copy", onCopy);
	    event.addListener(text, "paste", onPaste);
	    if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)){
	        event.addListener(parentNode, "keydown", function(e) {
	            if ((useragent.isMac && !e.metaKey) || !e.ctrlKey)
	                return;

	            switch (e.keyCode) {
	                case 67:
	                    onCopy(e);
	                    break;
	                case 86:
	                    onPaste(e);
	                    break;
	                case 88:
	                    onCut(e);
	                    break;
	            }
	        });
	    }
	    var onCompositionStart = function(e) {
	        if (inComposition || !host.onCompositionStart || host.$readOnly) 
	            return;
	        inComposition = {};
	        host.onCompositionStart();
	        setTimeout(onCompositionUpdate, 0);
	        host.on("mousedown", onCompositionEnd);
	        if (!host.selection.isEmpty()) {
	            host.insert("");
	            host.session.markUndoGroup();
	            host.selection.clearSelection();
	        }
	        host.session.markUndoGroup();
	    };

	    var onCompositionUpdate = function() {
	        if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
	            return;
	        var val = text.value.replace(/\x01/g, "");
	        if (inComposition.lastValue === val) return;
	        
	        host.onCompositionUpdate(val);
	        if (inComposition.lastValue)
	            host.undo();
	        inComposition.lastValue = val;
	        if (inComposition.lastValue) {
	            var r = host.selection.getRange();
	            host.insert(inComposition.lastValue);
	            host.session.markUndoGroup();
	            inComposition.range = host.selection.getRange();
	            host.selection.setRange(r);
	            host.selection.clearSelection();
	        }
	    };

	    var onCompositionEnd = function(e) {
	        if (!host.onCompositionEnd || host.$readOnly) return;
	        var c = inComposition;
	        inComposition = false;
	        var timer = setTimeout(function() {
	            timer = null;
	            var str = text.value.replace(/\x01/g, "");
	            if (inComposition)
	                return;
	            else if (str == c.lastValue)
	                resetValue();
	            else if (!c.lastValue && str) {
	                resetValue();
	                sendText(str);
	            }
	        });
	        inputHandler = function compositionInputHandler(str) {
	            if (timer)
	                clearTimeout(timer);
	            str = str.replace(/\x01/g, "");
	            if (str == c.lastValue)
	                return "";
	            if (c.lastValue && timer)
	                host.undo();
	            return str;
	        };
	        host.onCompositionEnd();
	        host.removeListener("mousedown", onCompositionEnd);
	        if (e.type == "compositionend" && c.range) {
	            host.selection.setRange(c.range);
	        }
	    };
	    
	    

	    var syncComposition = lang.delayedCall(onCompositionUpdate, 50);

	    event.addListener(text, "compositionstart", onCompositionStart);
	    if (useragent.isGecko) {
	        event.addListener(text, "text", function(){syncComposition.schedule()});
	    } else {
	        event.addListener(text, "keyup", function(){syncComposition.schedule()});
	        event.addListener(text, "keydown", function(){syncComposition.schedule()});
	    }
	    event.addListener(text, "compositionend", onCompositionEnd);

	    this.getElement = function() {
	        return text;
	    };

	    this.setReadOnly = function(readOnly) {
	       text.readOnly = readOnly;
	    };

	    this.onContextMenu = function(e) {
	        afterContextMenu = true;
	        resetSelection(host.selection.isEmpty());
	        host._emit("nativecontextmenu", {target: host, domEvent: e});
	        this.moveToMouse(e, true);
	    };
	    
	    this.moveToMouse = function(e, bringToFront) {
	        if (!bringToFront && useragent.isOldIE)
	            return;
	        if (!tempStyle)
	            tempStyle = text.style.cssText;
	        text.style.cssText = (bringToFront ? "z-index:100000;" : "")
	            + "height:" + text.style.height + ";"
	            + (useragent.isIE ? "opacity:0.1;" : "");

	        var rect = host.container.getBoundingClientRect();
	        var style = dom.computedStyle(host.container);
	        var top = rect.top + (parseInt(style.borderTopWidth) || 0);
	        var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
	        var maxTop = rect.bottom - top - text.clientHeight -2;
	        var move = function(e) {
	            text.style.left = e.clientX - left - 2 + "px";
	            text.style.top = Math.min(e.clientY - top - 2, maxTop) + "px";
	        }; 
	        move(e);

	        if (e.type != "mousedown")
	            return;

	        if (host.renderer.$keepTextAreaAtCursor)
	            host.renderer.$keepTextAreaAtCursor = null;

	        clearTimeout(closeTimeout);
	        if (useragent.isWin && !useragent.isOldIE)
	            event.capture(host.container, move, onContextMenuClose);
	    };

	    this.onContextMenuClose = onContextMenuClose;
	    var closeTimeout;
	    function onContextMenuClose() {
	        clearTimeout(closeTimeout);
	        closeTimeout = setTimeout(function () {
	            if (tempStyle) {
	                text.style.cssText = tempStyle;
	                tempStyle = '';
	            }
	            if (host.renderer.$keepTextAreaAtCursor == null) {
	                host.renderer.$keepTextAreaAtCursor = true;
	                host.renderer.$moveTextAreaToCursor();
	            }
	        }, useragent.isOldIE ? 200 : 0);
	    }

	    var onContextMenu = function(e) {
	        host.textInput.onContextMenu(e);
	        onContextMenuClose();
	    };
	    event.addListener(text, "mouseup", onContextMenu);
	    event.addListener(text, "mousedown", function(e) {
	        e.preventDefault();
	        onContextMenuClose();
	    });
	    event.addListener(host.renderer.scroller, "contextmenu", onContextMenu);
	    event.addListener(text, "contextmenu", onContextMenu);
	};

	exports.TextInput = TextInput;
	});

	ace.define("ace/mouse/default_handlers",["require","exports","module","ace/lib/dom","ace/lib/event","ace/lib/useragent"], function(acequire, exports, module) {
	"use strict";

	var dom = acequire("../lib/dom");
	var event = acequire("../lib/event");
	var useragent = acequire("../lib/useragent");

	var DRAG_OFFSET = 0; // pixels

	function DefaultHandlers(mouseHandler) {
	    mouseHandler.$clickSelection = null;

	    var editor = mouseHandler.editor;
	    editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
	    editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
	    editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
	    editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
	    editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));
	    editor.setDefaultHandler("touchmove", this.onTouchMove.bind(mouseHandler));

	    var exports = ["select", "startSelect", "selectEnd", "selectAllEnd", "selectByWordsEnd",
	        "selectByLinesEnd", "dragWait", "dragWaitEnd", "focusWait"];

	    exports.forEach(function(x) {
	        mouseHandler[x] = this[x];
	    }, this);

	    mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
	    mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
	}

	(function() {

	    this.onMouseDown = function(ev) {
	        var inSelection = ev.inSelection();
	        var pos = ev.getDocumentPosition();
	        this.mousedownEvent = ev;
	        var editor = this.editor;

	        var button = ev.getButton();
	        if (button !== 0) {
	            var selectionRange = editor.getSelectionRange();
	            var selectionEmpty = selectionRange.isEmpty();
	            editor.$blockScrolling++;
	            if (selectionEmpty || button == 1)
	                editor.selection.moveToPosition(pos);
	            editor.$blockScrolling--;
	            if (button == 2)
	                editor.textInput.onContextMenu(ev.domEvent);
	            return; // stopping event here breaks contextmenu on ff mac
	        }

	        this.mousedownEvent.time = Date.now();
	        if (inSelection && !editor.isFocused()) {
	            editor.focus();
	            if (this.$focusTimout && !this.$clickSelection && !editor.inMultiSelectMode) {
	                this.setState("focusWait");
	                this.captureMouse(ev);
	                return;
	            }
	        }

	        this.captureMouse(ev);
	        this.startSelect(pos, ev.domEvent._clicks > 1);
	        return ev.preventDefault();
	    };

	    this.startSelect = function(pos, waitForClickSelection) {
	        pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
	        var editor = this.editor;
	        editor.$blockScrolling++;
	        if (this.mousedownEvent.getShiftKey())
	            editor.selection.selectToPosition(pos);
	        else if (!waitForClickSelection)
	            editor.selection.moveToPosition(pos);
	        if (!waitForClickSelection)
	            this.select();
	        if (editor.renderer.scroller.setCapture) {
	            editor.renderer.scroller.setCapture();
	        }
	        editor.setStyle("ace_selecting");
	        this.setState("select");
	        editor.$blockScrolling--;
	    };

	    this.select = function() {
	        var anchor, editor = this.editor;
	        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
	        editor.$blockScrolling++;
	        if (this.$clickSelection) {
	            var cmp = this.$clickSelection.comparePoint(cursor);

	            if (cmp == -1) {
	                anchor = this.$clickSelection.end;
	            } else if (cmp == 1) {
	                anchor = this.$clickSelection.start;
	            } else {
	                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
	                cursor = orientedRange.cursor;
	                anchor = orientedRange.anchor;
	            }
	            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
	        }
	        editor.selection.selectToPosition(cursor);
	        editor.$blockScrolling--;
	        editor.renderer.scrollCursorIntoView();
	    };

	    this.extendSelectionBy = function(unitName) {
	        var anchor, editor = this.editor;
	        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
	        var range = editor.selection[unitName](cursor.row, cursor.column);
	        editor.$blockScrolling++;
	        if (this.$clickSelection) {
	            var cmpStart = this.$clickSelection.comparePoint(range.start);
	            var cmpEnd = this.$clickSelection.comparePoint(range.end);

	            if (cmpStart == -1 && cmpEnd <= 0) {
	                anchor = this.$clickSelection.end;
	                if (range.end.row != cursor.row || range.end.column != cursor.column)
	                    cursor = range.start;
	            } else if (cmpEnd == 1 && cmpStart >= 0) {
	                anchor = this.$clickSelection.start;
	                if (range.start.row != cursor.row || range.start.column != cursor.column)
	                    cursor = range.end;
	            } else if (cmpStart == -1 && cmpEnd == 1) {
	                cursor = range.end;
	                anchor = range.start;
	            } else {
	                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
	                cursor = orientedRange.cursor;
	                anchor = orientedRange.anchor;
	            }
	            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
	        }
	        editor.selection.selectToPosition(cursor);
	        editor.$blockScrolling--;
	        editor.renderer.scrollCursorIntoView();
	    };

	    this.selectEnd =
	    this.selectAllEnd =
	    this.selectByWordsEnd =
	    this.selectByLinesEnd = function() {
	        this.$clickSelection = null;
	        this.editor.unsetStyle("ace_selecting");
	        if (this.editor.renderer.scroller.releaseCapture) {
	            this.editor.renderer.scroller.releaseCapture();
	        }
	    };

	    this.focusWait = function() {
	        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
	        var time = Date.now();

	        if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimout)
	            this.startSelect(this.mousedownEvent.getDocumentPosition());
	    };

	    this.onDoubleClick = function(ev) {
	        var pos = ev.getDocumentPosition();
	        var editor = this.editor;
	        var session = editor.session;

	        var range = session.getBracketRange(pos);
	        if (range) {
	            if (range.isEmpty()) {
	                range.start.column--;
	                range.end.column++;
	            }
	            this.setState("select");
	        } else {
	            range = editor.selection.getWordRange(pos.row, pos.column);
	            this.setState("selectByWords");
	        }
	        this.$clickSelection = range;
	        this.select();
	    };

	    this.onTripleClick = function(ev) {
	        var pos = ev.getDocumentPosition();
	        var editor = this.editor;

	        this.setState("selectByLines");
	        var range = editor.getSelectionRange();
	        if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
	            this.$clickSelection = editor.selection.getLineRange(range.start.row);
	            this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
	        } else {
	            this.$clickSelection = editor.selection.getLineRange(pos.row);
	        }
	        this.select();
	    };

	    this.onQuadClick = function(ev) {
	        var editor = this.editor;

	        editor.selectAll();
	        this.$clickSelection = editor.getSelectionRange();
	        this.setState("selectAll");
	    };

	    this.onMouseWheel = function(ev) {
	        if (ev.getAccelKey())
	            return;
	        if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
	            ev.wheelX = ev.wheelY;
	            ev.wheelY = 0;
	        }

	        var t = ev.domEvent.timeStamp;
	        var dt = t - (this.$lastScrollTime||0);
	        
	        var editor = this.editor;
	        var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
	        if (isScrolable || dt < 200) {
	            this.$lastScrollTime = t;
	            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
	            return ev.stop();
	        }
	    };
	    
	    this.onTouchMove = function (ev) {
	        var t = ev.domEvent.timeStamp;
	        var dt = t - (this.$lastScrollTime || 0);

	        var editor = this.editor;
	        var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
	        if (isScrolable || dt < 200) {
	            this.$lastScrollTime = t;
	            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
	            return ev.stop();
	        }
	    };

	}).call(DefaultHandlers.prototype);

	exports.DefaultHandlers = DefaultHandlers;

	function calcDistance(ax, ay, bx, by) {
	    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
	}

	function calcRangeOrientation(range, cursor) {
	    if (range.start.row == range.end.row)
	        var cmp = 2 * cursor.column - range.start.column - range.end.column;
	    else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)
	        var cmp = cursor.column - 4;
	    else
	        var cmp = 2 * cursor.row - range.start.row - range.end.row;

	    if (cmp < 0)
	        return {cursor: range.start, anchor: range.end};
	    else
	        return {cursor: range.end, anchor: range.start};
	}

	});

	ace.define("ace/tooltip",["require","exports","module","ace/lib/oop","ace/lib/dom"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("./lib/oop");
	var dom = acequire("./lib/dom");
	function Tooltip (parentNode) {
	    this.isOpen = false;
	    this.$element = null;
	    this.$parentNode = parentNode;
	}

	(function() {
	    this.$init = function() {
	        this.$element = dom.createElement("div");
	        this.$element.className = "ace_tooltip";
	        this.$element.style.display = "none";
	        this.$parentNode.appendChild(this.$element);
	        return this.$element;
	    };
	    this.getElement = function() {
	        return this.$element || this.$init();
	    };
	    this.setText = function(text) {
	        dom.setInnerText(this.getElement(), text);
	    };
	    this.setHtml = function(html) {
	        this.getElement().innerHTML = html;
	    };
	    this.setPosition = function(x, y) {
	        this.getElement().style.left = x + "px";
	        this.getElement().style.top = y + "px";
	    };
	    this.setClassName = function(className) {
	        dom.addCssClass(this.getElement(), className);
	    };
	    this.show = function(text, x, y) {
	        if (text != null)
	            this.setText(text);
	        if (x != null && y != null)
	            this.setPosition(x, y);
	        if (!this.isOpen) {
	            this.getElement().style.display = "block";
	            this.isOpen = true;
	        }
	    };

	    this.hide = function() {
	        if (this.isOpen) {
	            this.getElement().style.display = "none";
	            this.isOpen = false;
	        }
	    };
	    this.getHeight = function() {
	        return this.getElement().offsetHeight;
	    };
	    this.getWidth = function() {
	        return this.getElement().offsetWidth;
	    };

	}).call(Tooltip.prototype);

	exports.Tooltip = Tooltip;
	});

	ace.define("ace/mouse/default_gutter_handler",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/event","ace/tooltip"], function(acequire, exports, module) {
	"use strict";
	var dom = acequire("../lib/dom");
	var oop = acequire("../lib/oop");
	var event = acequire("../lib/event");
	var Tooltip = acequire("../tooltip").Tooltip;

	function GutterHandler(mouseHandler) {
	    var editor = mouseHandler.editor;
	    var gutter = editor.renderer.$gutterLayer;
	    var tooltip = new GutterTooltip(editor.container);

	    mouseHandler.editor.setDefaultHandler("guttermousedown", function(e) {
	        if (!editor.isFocused() || e.getButton() != 0)
	            return;
	        var gutterRegion = gutter.getRegion(e);

	        if (gutterRegion == "foldWidgets")
	            return;

	        var row = e.getDocumentPosition().row;
	        var selection = editor.session.selection;

	        if (e.getShiftKey())
	            selection.selectTo(row, 0);
	        else {
	            if (e.domEvent.detail == 2) {
	                editor.selectAll();
	                return e.preventDefault();
	            }
	            mouseHandler.$clickSelection = editor.selection.getLineRange(row);
	        }
	        mouseHandler.setState("selectByLines");
	        mouseHandler.captureMouse(e);
	        return e.preventDefault();
	    });


	    var tooltipTimeout, mouseEvent, tooltipAnnotation;

	    function showTooltip() {
	        var row = mouseEvent.getDocumentPosition().row;
	        var annotation = gutter.$annotations[row];
	        if (!annotation)
	            return hideTooltip();

	        var maxRow = editor.session.getLength();
	        if (row == maxRow) {
	            var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
	            var pos = mouseEvent.$pos;
	            if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))
	                return hideTooltip();
	        }

	        if (tooltipAnnotation == annotation)
	            return;
	        tooltipAnnotation = annotation.text.join("<br/>");

	        tooltip.setHtml(tooltipAnnotation);
	        tooltip.show();
	        editor.on("mousewheel", hideTooltip);

	        if (mouseHandler.$tooltipFollowsMouse) {
	            moveTooltip(mouseEvent);
	        } else {
	            var gutterElement = mouseEvent.domEvent.target;
	            var rect = gutterElement.getBoundingClientRect();
	            var style = tooltip.getElement().style;
	            style.left = rect.right + "px";
	            style.top = rect.bottom + "px";
	        }
	    }

	    function hideTooltip() {
	        if (tooltipTimeout)
	            tooltipTimeout = clearTimeout(tooltipTimeout);
	        if (tooltipAnnotation) {
	            tooltip.hide();
	            tooltipAnnotation = null;
	            editor.removeEventListener("mousewheel", hideTooltip);
	        }
	    }

	    function moveTooltip(e) {
	        tooltip.setPosition(e.x, e.y);
	    }

	    mouseHandler.editor.setDefaultHandler("guttermousemove", function(e) {
	        var target = e.domEvent.target || e.domEvent.srcElement;
	        if (dom.hasCssClass(target, "ace_fold-widget"))
	            return hideTooltip();

	        if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse)
	            moveTooltip(e);

	        mouseEvent = e;
	        if (tooltipTimeout)
	            return;
	        tooltipTimeout = setTimeout(function() {
	            tooltipTimeout = null;
	            if (mouseEvent && !mouseHandler.isMousePressed)
	                showTooltip();
	            else
	                hideTooltip();
	        }, 50);
	    });

	    event.addListener(editor.renderer.$gutter, "mouseout", function(e) {
	        mouseEvent = null;
	        if (!tooltipAnnotation || tooltipTimeout)
	            return;

	        tooltipTimeout = setTimeout(function() {
	            tooltipTimeout = null;
	            hideTooltip();
	        }, 50);
	    });
	    
	    editor.on("changeSession", hideTooltip);
	}

	function GutterTooltip(parentNode) {
	    Tooltip.call(this, parentNode);
	}

	oop.inherits(GutterTooltip, Tooltip);

	(function(){
	    this.setPosition = function(x, y) {
	        var windowWidth = window.innerWidth || document.documentElement.clientWidth;
	        var windowHeight = window.innerHeight || document.documentElement.clientHeight;
	        var width = this.getWidth();
	        var height = this.getHeight();
	        x += 15;
	        y += 15;
	        if (x + width > windowWidth) {
	            x -= (x + width) - windowWidth;
	        }
	        if (y + height > windowHeight) {
	            y -= 20 + height;
	        }
	        Tooltip.prototype.setPosition.call(this, x, y);
	    };

	}).call(GutterTooltip.prototype);



	exports.GutterHandler = GutterHandler;

	});

	ace.define("ace/mouse/mouse_event",["require","exports","module","ace/lib/event","ace/lib/useragent"], function(acequire, exports, module) {
	"use strict";

	var event = acequire("../lib/event");
	var useragent = acequire("../lib/useragent");
	var MouseEvent = exports.MouseEvent = function(domEvent, editor) {
	    this.domEvent = domEvent;
	    this.editor = editor;
	    
	    this.x = this.clientX = domEvent.clientX;
	    this.y = this.clientY = domEvent.clientY;

	    this.$pos = null;
	    this.$inSelection = null;
	    
	    this.propagationStopped = false;
	    this.defaultPrevented = false;
	};

	(function() {  
	    
	    this.stopPropagation = function() {
	        event.stopPropagation(this.domEvent);
	        this.propagationStopped = true;
	    };
	    
	    this.preventDefault = function() {
	        event.preventDefault(this.domEvent);
	        this.defaultPrevented = true;
	    };
	    
	    this.stop = function() {
	        this.stopPropagation();
	        this.preventDefault();
	    };
	    this.getDocumentPosition = function() {
	        if (this.$pos)
	            return this.$pos;
	        
	        this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
	        return this.$pos;
	    };
	    this.inSelection = function() {
	        if (this.$inSelection !== null)
	            return this.$inSelection;
	            
	        var editor = this.editor;
	        

	        var selectionRange = editor.getSelectionRange();
	        if (selectionRange.isEmpty())
	            this.$inSelection = false;
	        else {
	            var pos = this.getDocumentPosition();
	            this.$inSelection = selectionRange.contains(pos.row, pos.column);
	        }

	        return this.$inSelection;
	    };
	    this.getButton = function() {
	        return event.getButton(this.domEvent);
	    };
	    this.getShiftKey = function() {
	        return this.domEvent.shiftKey;
	    };
	    
	    this.getAccelKey = useragent.isMac
	        ? function() { return this.domEvent.metaKey; }
	        : function() { return this.domEvent.ctrlKey; };
	    
	}).call(MouseEvent.prototype);

	});

	ace.define("ace/mouse/dragdrop_handler",["require","exports","module","ace/lib/dom","ace/lib/event","ace/lib/useragent"], function(acequire, exports, module) {
	"use strict";

	var dom = acequire("../lib/dom");
	var event = acequire("../lib/event");
	var useragent = acequire("../lib/useragent");

	var AUTOSCROLL_DELAY = 200;
	var SCROLL_CURSOR_DELAY = 200;
	var SCROLL_CURSOR_HYSTERESIS = 5;

	function DragdropHandler(mouseHandler) {

	    var editor = mouseHandler.editor;

	    var blankImage = dom.createElement("img");
	    blankImage.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
	    if (useragent.isOpera)
	        blankImage.style.cssText = "width:1px;height:1px;position:fixed;top:0;left:0;z-index:2147483647;opacity:0;";

	    var exports = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];

	     exports.forEach(function(x) {
	         mouseHandler[x] = this[x];
	    }, this);
	    editor.addEventListener("mousedown", this.onMouseDown.bind(mouseHandler));


	    var mouseTarget = editor.container;
	    var dragSelectionMarker, x, y;
	    var timerId, range;
	    var dragCursor, counter = 0;
	    var dragOperation;
	    var isInternal;
	    var autoScrollStartTime;
	    var cursorMovedTime;
	    var cursorPointOnCaretMoved;

	    this.onDragStart = function(e) {
	        if (this.cancelDrag || !mouseTarget.draggable) {
	            var self = this;
	            setTimeout(function(){
	                self.startSelect();
	                self.captureMouse(e);
	            }, 0);
	            return e.preventDefault();
	        }
	        range = editor.getSelectionRange();

	        var dataTransfer = e.dataTransfer;
	        dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
	        if (useragent.isOpera) {
	            editor.container.appendChild(blankImage);
	            blankImage.scrollTop = 0;
	        }
	        dataTransfer.setDragImage && dataTransfer.setDragImage(blankImage, 0, 0);
	        if (useragent.isOpera) {
	            editor.container.removeChild(blankImage);
	        }
	        dataTransfer.clearData();
	        dataTransfer.setData("Text", editor.session.getTextRange());

	        isInternal = true;
	        this.setState("drag");
	    };

	    this.onDragEnd = function(e) {
	        mouseTarget.draggable = false;
	        isInternal = false;
	        this.setState(null);
	        if (!editor.getReadOnly()) {
	            var dropEffect = e.dataTransfer.dropEffect;
	            if (!dragOperation && dropEffect == "move")
	                editor.session.remove(editor.getSelectionRange());
	            editor.renderer.$cursorLayer.setBlinking(true);
	        }
	        this.editor.unsetStyle("ace_dragging");
	        this.editor.renderer.setCursorStyle("");
	    };

	    this.onDragEnter = function(e) {
	        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
	            return;
	        x = e.clientX;
	        y = e.clientY;
	        if (!dragSelectionMarker)
	            addDragMarker();
	        counter++;
	        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
	        return event.preventDefault(e);
	    };

	    this.onDragOver = function(e) {
	        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
	            return;
	        x = e.clientX;
	        y = e.clientY;
	        if (!dragSelectionMarker) {
	            addDragMarker();
	            counter++;
	        }
	        if (onMouseMoveTimer !== null)
	            onMouseMoveTimer = null;

	        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
	        return event.preventDefault(e);
	    };

	    this.onDragLeave = function(e) {
	        counter--;
	        if (counter <= 0 && dragSelectionMarker) {
	            clearDragMarker();
	            dragOperation = null;
	            return event.preventDefault(e);
	        }
	    };

	    this.onDrop = function(e) {
	        if (!dragCursor)
	            return;
	        var dataTransfer = e.dataTransfer;
	        if (isInternal) {
	            switch (dragOperation) {
	                case "move":
	                    if (range.contains(dragCursor.row, dragCursor.column)) {
	                        range = {
	                            start: dragCursor,
	                            end: dragCursor
	                        };
	                    } else {
	                        range = editor.moveText(range, dragCursor);
	                    }
	                    break;
	                case "copy":
	                    range = editor.moveText(range, dragCursor, true);
	                    break;
	            }
	        } else {
	            var dropData = dataTransfer.getData('Text');
	            range = {
	                start: dragCursor,
	                end: editor.session.insert(dragCursor, dropData)
	            };
	            editor.focus();
	            dragOperation = null;
	        }
	        clearDragMarker();
	        return event.preventDefault(e);
	    };

	    event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler));
	    event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler));
	    event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler));
	    event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler));
	    event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler));
	    event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler));

	    function scrollCursorIntoView(cursor, prevCursor) {
	        var now = Date.now();
	        var vMovement = !prevCursor || cursor.row != prevCursor.row;
	        var hMovement = !prevCursor || cursor.column != prevCursor.column;
	        if (!cursorMovedTime || vMovement || hMovement) {
	            editor.$blockScrolling += 1;
	            editor.moveCursorToPosition(cursor);
	            editor.$blockScrolling -= 1;
	            cursorMovedTime = now;
	            cursorPointOnCaretMoved = {x: x, y: y};
	        } else {
	            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
	            if (distance > SCROLL_CURSOR_HYSTERESIS) {
	                cursorMovedTime = null;
	            } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
	                editor.renderer.scrollCursorIntoView();
	                cursorMovedTime = null;
	            }
	        }
	    }

	    function autoScroll(cursor, prevCursor) {
	        var now = Date.now();
	        var lineHeight = editor.renderer.layerConfig.lineHeight;
	        var characterWidth = editor.renderer.layerConfig.characterWidth;
	        var editorRect = editor.renderer.scroller.getBoundingClientRect();
	        var offsets = {
	           x: {
	               left: x - editorRect.left,
	               right: editorRect.right - x
	           },
	           y: {
	               top: y - editorRect.top,
	               bottom: editorRect.bottom - y
	           }
	        };
	        var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
	        var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
	        var scrollCursor = {row: cursor.row, column: cursor.column};
	        if (nearestXOffset / characterWidth <= 2) {
	            scrollCursor.column += (offsets.x.left < offsets.x.right ? -3 : +2);
	        }
	        if (nearestYOffset / lineHeight <= 1) {
	            scrollCursor.row += (offsets.y.top < offsets.y.bottom ? -1 : +1);
	        }
	        var vScroll = cursor.row != scrollCursor.row;
	        var hScroll = cursor.column != scrollCursor.column;
	        var vMovement = !prevCursor || cursor.row != prevCursor.row;
	        if (vScroll || (hScroll && !vMovement)) {
	            if (!autoScrollStartTime)
	                autoScrollStartTime = now;
	            else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)
	                editor.renderer.scrollCursorIntoView(scrollCursor);
	        } else {
	            autoScrollStartTime = null;
	        }
	    }

	    function onDragInterval() {
	        var prevCursor = dragCursor;
	        dragCursor = editor.renderer.screenToTextCoordinates(x, y);
	        scrollCursorIntoView(dragCursor, prevCursor);
	        autoScroll(dragCursor, prevCursor);
	    }

	    function addDragMarker() {
	        range = editor.selection.toOrientedRange();
	        dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
	        editor.clearSelection();
	        if (editor.isFocused())
	            editor.renderer.$cursorLayer.setBlinking(false);
	        clearInterval(timerId);
	        onDragInterval();
	        timerId = setInterval(onDragInterval, 20);
	        counter = 0;
	        event.addListener(document, "mousemove", onMouseMove);
	    }

	    function clearDragMarker() {
	        clearInterval(timerId);
	        editor.session.removeMarker(dragSelectionMarker);
	        dragSelectionMarker = null;
	        editor.$blockScrolling += 1;
	        editor.selection.fromOrientedRange(range);
	        editor.$blockScrolling -= 1;
	        if (editor.isFocused() && !isInternal)
	            editor.renderer.$cursorLayer.setBlinking(!editor.getReadOnly());
	        range = null;
	        dragCursor = null;
	        counter = 0;
	        autoScrollStartTime = null;
	        cursorMovedTime = null;
	        event.removeListener(document, "mousemove", onMouseMove);
	    }
	    var onMouseMoveTimer = null;
	    function onMouseMove() {
	        if (onMouseMoveTimer == null) {
	            onMouseMoveTimer = setTimeout(function() {
	                if (onMouseMoveTimer != null && dragSelectionMarker)
	                    clearDragMarker();
	            }, 20);
	        }
	    }

	    function canAccept(dataTransfer) {
	        var types = dataTransfer.types;
	        return !types || Array.prototype.some.call(types, function(type) {
	            return type == 'text/plain' || type == 'Text';
	        });
	    }

	    function getDropEffect(e) {
	        var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];
	        var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];

	        var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
	        var effectAllowed = "uninitialized";
	        try {
	            effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
	        } catch (e) {}
	        var dropEffect = "none";

	        if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)
	            dropEffect = "copy";
	        else if (moveAllowed.indexOf(effectAllowed) >= 0)
	            dropEffect = "move";
	        else if (copyAllowed.indexOf(effectAllowed) >= 0)
	            dropEffect = "copy";

	        return dropEffect;
	    }
	}

	(function() {

	    this.dragWait = function() {
	        var interval = Date.now() - this.mousedownEvent.time;
	        if (interval > this.editor.getDragDelay())
	            this.startDrag();
	    };

	    this.dragWaitEnd = function() {
	        var target = this.editor.container;
	        target.draggable = false;
	        this.startSelect(this.mousedownEvent.getDocumentPosition());
	        this.selectEnd();
	    };

	    this.dragReadyEnd = function(e) {
	        this.editor.renderer.$cursorLayer.setBlinking(!this.editor.getReadOnly());
	        this.editor.unsetStyle("ace_dragging");
	        this.editor.renderer.setCursorStyle("");
	        this.dragWaitEnd();
	    };

	    this.startDrag = function(){
	        this.cancelDrag = false;
	        var editor = this.editor;
	        var target = editor.container;
	        target.draggable = true;
	        editor.renderer.$cursorLayer.setBlinking(false);
	        editor.setStyle("ace_dragging");
	        var cursorStyle = useragent.isWin ? "default" : "move";
	        editor.renderer.setCursorStyle(cursorStyle);
	        this.setState("dragReady");
	    };

	    this.onMouseDrag = function(e) {
	        var target = this.editor.container;
	        if (useragent.isIE && this.state == "dragReady") {
	            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
	            if (distance > 3)
	                target.dragDrop();
	        }
	        if (this.state === "dragWait") {
	            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
	            if (distance > 0) {
	                target.draggable = false;
	                this.startSelect(this.mousedownEvent.getDocumentPosition());
	            }
	        }
	    };

	    this.onMouseDown = function(e) {
	        if (!this.$dragEnabled)
	            return;
	        this.mousedownEvent = e;
	        var editor = this.editor;

	        var inSelection = e.inSelection();
	        var button = e.getButton();
	        var clickCount = e.domEvent.detail || 1;
	        if (clickCount === 1 && button === 0 && inSelection) {
	            if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))
	                return;
	            this.mousedownEvent.time = Date.now();
	            var eventTarget = e.domEvent.target || e.domEvent.srcElement;
	            if ("unselectable" in eventTarget)
	                eventTarget.unselectable = "on";
	            if (editor.getDragDelay()) {
	                if (useragent.isWebKit) {
	                    this.cancelDrag = true;
	                    var mouseTarget = editor.container;
	                    mouseTarget.draggable = true;
	                }
	                this.setState("dragWait");
	            } else {
	                this.startDrag();
	            }
	            this.captureMouse(e, this.onMouseDrag.bind(this));
	            e.defaultPrevented = true;
	        }
	    };

	}).call(DragdropHandler.prototype);


	function calcDistance(ax, ay, bx, by) {
	    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
	}

	exports.DragdropHandler = DragdropHandler;

	});

	ace.define("ace/lib/net",["require","exports","module","ace/lib/dom"], function(acequire, exports, module) {
	"use strict";
	var dom = acequire("./dom");

	exports.get = function (url, callback) {
	    var xhr = new XMLHttpRequest();
	    xhr.open('GET', url, true);
	    xhr.onreadystatechange = function () {
	        if (xhr.readyState === 4) {
	            callback(xhr.responseText);
	        }
	    };
	    xhr.send(null);
	};

	exports.loadScript = function(path, callback) {
	    var head = dom.getDocumentHead();
	    var s = document.createElement('script');

	    s.src = path;
	    head.appendChild(s);

	    s.onload = s.onreadystatechange = function(_, isAbort) {
	        if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
	            s = s.onload = s.onreadystatechange = null;
	            if (!isAbort)
	                callback();
	        }
	    };
	};
	exports.qualifyURL = function(url) {
	    var a = document.createElement('a');
	    a.href = url;
	    return a.href;
	}

	});

	ace.define("ace/lib/event_emitter",["require","exports","module"], function(acequire, exports, module) {
	"use strict";

	var EventEmitter = {};
	var stopPropagation = function() { this.propagationStopped = true; };
	var preventDefault = function() { this.defaultPrevented = true; };

	EventEmitter._emit =
	EventEmitter._dispatchEvent = function(eventName, e) {
	    this._eventRegistry || (this._eventRegistry = {});
	    this._defaultHandlers || (this._defaultHandlers = {});

	    var listeners = this._eventRegistry[eventName] || [];
	    var defaultHandler = this._defaultHandlers[eventName];
	    if (!listeners.length && !defaultHandler)
	        return;

	    if (typeof e != "object" || !e)
	        e = {};

	    if (!e.type)
	        e.type = eventName;
	    if (!e.stopPropagation)
	        e.stopPropagation = stopPropagation;
	    if (!e.preventDefault)
	        e.preventDefault = preventDefault;

	    listeners = listeners.slice();
	    for (var i=0; i<listeners.length; i++) {
	        listeners[i](e, this);
	        if (e.propagationStopped)
	            break;
	    }
	    
	    if (defaultHandler && !e.defaultPrevented)
	        return defaultHandler(e, this);
	};


	EventEmitter._signal = function(eventName, e) {
	    var listeners = (this._eventRegistry || {})[eventName];
	    if (!listeners)
	        return;
	    listeners = listeners.slice();
	    for (var i=0; i<listeners.length; i++)
	        listeners[i](e, this);
	};

	EventEmitter.once = function(eventName, callback) {
	    var _self = this;
	    callback && this.addEventListener(eventName, function newCallback() {
	        _self.removeEventListener(eventName, newCallback);
	        callback.apply(null, arguments);
	    });
	};


	EventEmitter.setDefaultHandler = function(eventName, callback) {
	    var handlers = this._defaultHandlers
	    if (!handlers)
	        handlers = this._defaultHandlers = {_disabled_: {}};
	    
	    if (handlers[eventName]) {
	        var old = handlers[eventName];
	        var disabled = handlers._disabled_[eventName];
	        if (!disabled)
	            handlers._disabled_[eventName] = disabled = [];
	        disabled.push(old);
	        var i = disabled.indexOf(callback);
	        if (i != -1) 
	            disabled.splice(i, 1);
	    }
	    handlers[eventName] = callback;
	};
	EventEmitter.removeDefaultHandler = function(eventName, callback) {
	    var handlers = this._defaultHandlers
	    if (!handlers)
	        return;
	    var disabled = handlers._disabled_[eventName];
	    
	    if (handlers[eventName] == callback) {
	        var old = handlers[eventName];
	        if (disabled)
	            this.setDefaultHandler(eventName, disabled.pop());
	    } else if (disabled) {
	        var i = disabled.indexOf(callback);
	        if (i != -1)
	            disabled.splice(i, 1);
	    }
	};

	EventEmitter.on =
	EventEmitter.addEventListener = function(eventName, callback, capturing) {
	    this._eventRegistry = this._eventRegistry || {};

	    var listeners = this._eventRegistry[eventName];
	    if (!listeners)
	        listeners = this._eventRegistry[eventName] = [];

	    if (listeners.indexOf(callback) == -1)
	        listeners[capturing ? "unshift" : "push"](callback);
	    return callback;
	};

	EventEmitter.off =
	EventEmitter.removeListener =
	EventEmitter.removeEventListener = function(eventName, callback) {
	    this._eventRegistry = this._eventRegistry || {};

	    var listeners = this._eventRegistry[eventName];
	    if (!listeners)
	        return;

	    var index = listeners.indexOf(callback);
	    if (index !== -1)
	        listeners.splice(index, 1);
	};

	EventEmitter.removeAllListeners = function(eventName) {
	    if (this._eventRegistry) this._eventRegistry[eventName] = [];
	};

	exports.EventEmitter = EventEmitter;

	});

	ace.define("ace/lib/app_config",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(acequire, exports, module) {
	"no use strict";

	var oop = acequire("./oop");
	var EventEmitter = acequire("./event_emitter").EventEmitter;

	var optionsProvider = {
	    setOptions: function(optList) {
	        Object.keys(optList).forEach(function(key) {
	            this.setOption(key, optList[key]);
	        }, this);
	    },
	    getOptions: function(optionNames) {
	        var result = {};
	        if (!optionNames) {
	            optionNames = Object.keys(this.$options);
	        } else if (!Array.isArray(optionNames)) {
	            result = optionNames;
	            optionNames = Object.keys(result);
	        }
	        optionNames.forEach(function(key) {
	            result[key] = this.getOption(key);
	        }, this);
	        return result;
	    },
	    setOption: function(name, value) {
	        if (this["$" + name] === value)
	            return;
	        var opt = this.$options[name];
	        if (!opt) {
	            return warn('misspelled option "' + name + '"');
	        }
	        if (opt.forwardTo)
	            return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);

	        if (!opt.handlesSet)
	            this["$" + name] = value;
	        if (opt && opt.set)
	            opt.set.call(this, value);
	    },
	    getOption: function(name) {
	        var opt = this.$options[name];
	        if (!opt) {
	            return warn('misspelled option "' + name + '"');
	        }
	        if (opt.forwardTo)
	            return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
	        return opt && opt.get ? opt.get.call(this) : this["$" + name];
	    }
	};

	function warn(message) {
	    if (typeof console != "undefined" && console.warn)
	        console.warn.apply(console, arguments);
	}

	function reportError(msg, data) {
	    var e = new Error(msg);
	    e.data = data;
	    if (typeof console == "object" && console.error)
	        console.error(e);
	    setTimeout(function() { throw e; });
	}

	var AppConfig = function() {
	    this.$defaultOptions = {};
	};

	(function() {
	    oop.implement(this, EventEmitter);
	    this.defineOptions = function(obj, path, options) {
	        if (!obj.$options)
	            this.$defaultOptions[path] = obj.$options = {};

	        Object.keys(options).forEach(function(key) {
	            var opt = options[key];
	            if (typeof opt == "string")
	                opt = {forwardTo: opt};

	            opt.name || (opt.name = key);
	            obj.$options[opt.name] = opt;
	            if ("initialValue" in opt)
	                obj["$" + opt.name] = opt.initialValue;
	        });
	        oop.implement(obj, optionsProvider);

	        return this;
	    };

	    this.resetOptions = function(obj) {
	        Object.keys(obj.$options).forEach(function(key) {
	            var opt = obj.$options[key];
	            if ("value" in opt)
	                obj.setOption(key, opt.value);
	        });
	    };

	    this.setDefaultValue = function(path, name, value) {
	        var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
	        if (opts[name]) {
	            if (opts.forwardTo)
	                this.setDefaultValue(opts.forwardTo, name, value);
	            else
	                opts[name].value = value;
	        }
	    };

	    this.setDefaultValues = function(path, optionHash) {
	        Object.keys(optionHash).forEach(function(key) {
	            this.setDefaultValue(path, key, optionHash[key]);
	        }, this);
	    };
	    
	    this.warn = warn;
	    this.reportError = reportError;
	    
	}).call(AppConfig.prototype);

	exports.AppConfig = AppConfig;

	});

	ace.define("ace/config",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/lib/net","ace/lib/app_config"], function(acequire, exports, module) {
	"no use strict";

	var lang = acequire("./lib/lang");
	var oop = acequire("./lib/oop");
	var net = acequire("./lib/net");
	var AppConfig = acequire("./lib/app_config").AppConfig;

	module.exports = exports = new AppConfig();

	var global = (function() {
	    return this || typeof window != "undefined" && window;
	})();

	var options = {
	    packaged: false,
	    workerPath: null,
	    modePath: null,
	    themePath: null,
	    basePath: "",
	    suffix: ".js",
	    $moduleUrls: {}
	};

	exports.get = function(key) {
	    if (!options.hasOwnProperty(key))
	        throw new Error("Unknown config key: " + key);

	    return options[key];
	};

	exports.set = function(key, value) {
	    if (!options.hasOwnProperty(key))
	        throw new Error("Unknown config key: " + key);

	    options[key] = value;
	};

	exports.all = function() {
	    return lang.copyObject(options);
	};
	exports.moduleUrl = function(name, component) {
	    if (options.$moduleUrls[name])
	        return options.$moduleUrls[name];

	    var parts = name.split("/");
	    component = component || parts[parts.length - 2] || "";
	    var sep = component == "snippets" ? "/" : "-";
	    var base = parts[parts.length - 1];
	    if (component == "worker" && sep == "-") {
	        var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
	        base = base.replace(re, "");
	    }

	    if ((!base || base == component) && parts.length > 1)
	        base = parts[parts.length - 2];
	    var path = options[component + "Path"];
	    if (path == null) {
	        path = options.basePath;
	    } else if (sep == "/") {
	        component = sep = "";
	    }
	    if (path && path.slice(-1) != "/")
	        path += "/";
	    return path + component + sep + base + this.get("suffix");
	};

	exports.setModuleUrl = function(name, subst) {
	    return options.$moduleUrls[name] = subst;
	};

	exports.$loading = {};
	exports.loadModule = function(moduleName, onLoad) {
	    var module, moduleType;
	    if (Array.isArray(moduleName)) {
	        moduleType = moduleName[0];
	        moduleName = moduleName[1];
	    }

	    try {
	        module = acequire(moduleName);
	    } catch (e) {}
	    if (module && !exports.$loading[moduleName])
	        return onLoad && onLoad(module);

	    if (!exports.$loading[moduleName])
	        exports.$loading[moduleName] = [];

	    exports.$loading[moduleName].push(onLoad);

	    if (exports.$loading[moduleName].length > 1)
	        return;

	    var afterLoad = function() {
	        acequire([moduleName], function(module) {
	            exports._emit("load.module", {name: moduleName, module: module});
	            var listeners = exports.$loading[moduleName];
	            exports.$loading[moduleName] = null;
	            listeners.forEach(function(onLoad) {
	                onLoad && onLoad(module);
	            });
	        });
	    };

	    if (!exports.get("packaged"))
	        return afterLoad();
	    net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);
	};
	init(true);function init(packaged) {

	    if (!global || !global.document)
	        return;
	    
	    options.packaged = packaged || acequire.packaged || module.packaged || (global.define && __webpack_require__(96).packaged);

	    var scriptOptions = {};
	    var scriptUrl = "";
	    var currentScript = (document.currentScript || document._currentScript ); // native or polyfill
	    var currentDocument = currentScript && currentScript.ownerDocument || document;
	    
	    var scripts = currentDocument.getElementsByTagName("script");
	    for (var i=0; i<scripts.length; i++) {
	        var script = scripts[i];

	        var src = script.src || script.getAttribute("src");
	        if (!src)
	            continue;

	        var attributes = script.attributes;
	        for (var j=0, l=attributes.length; j < l; j++) {
	            var attr = attributes[j];
	            if (attr.name.indexOf("data-ace-") === 0) {
	                scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
	            }
	        }

	        var m = src.match(/^(.*)\/ace(\-\w+)?\.js(\?|$)/);
	        if (m)
	            scriptUrl = m[1];
	    }

	    if (scriptUrl) {
	        scriptOptions.base = scriptOptions.base || scriptUrl;
	        scriptOptions.packaged = true;
	    }

	    scriptOptions.basePath = scriptOptions.base;
	    scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
	    scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
	    scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
	    delete scriptOptions.base;

	    for (var key in scriptOptions)
	        if (typeof scriptOptions[key] !== "undefined")
	            exports.set(key, scriptOptions[key]);
	}

	exports.init = init;

	function deHyphenate(str) {
	    return str.replace(/-(.)/g, function(m, m1) { return m1.toUpperCase(); });
	}

	});

	ace.define("ace/mouse/mouse_handler",["require","exports","module","ace/lib/event","ace/lib/useragent","ace/mouse/default_handlers","ace/mouse/default_gutter_handler","ace/mouse/mouse_event","ace/mouse/dragdrop_handler","ace/config"], function(acequire, exports, module) {
	"use strict";

	var event = acequire("../lib/event");
	var useragent = acequire("../lib/useragent");
	var DefaultHandlers = acequire("./default_handlers").DefaultHandlers;
	var DefaultGutterHandler = acequire("./default_gutter_handler").GutterHandler;
	var MouseEvent = acequire("./mouse_event").MouseEvent;
	var DragdropHandler = acequire("./dragdrop_handler").DragdropHandler;
	var config = acequire("../config");

	var MouseHandler = function(editor) {
	    var _self = this;
	    this.editor = editor;

	    new DefaultHandlers(this);
	    new DefaultGutterHandler(this);
	    new DragdropHandler(this);

	    var focusEditor = function(e) {
	        var windowBlurred = !document.hasFocus || !document.hasFocus()
	            || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement())
	        if (windowBlurred)
	            window.focus();
	        editor.focus();
	    };

	    var mouseTarget = editor.renderer.getMouseEventTarget();
	    event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"));
	    event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"));
	    event.addMultiMouseDownListener([
	        mouseTarget,
	        editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner,
	        editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner,
	        editor.textInput && editor.textInput.getElement()
	    ].filter(Boolean), [400, 300, 250], this, "onMouseEvent");
	    event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"));
	    event.addTouchMoveListener(editor.container, this.onTouchMove.bind(this, "touchmove"));

	    var gutterEl = editor.renderer.$gutter;
	    event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"));
	    event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"));
	    event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"));
	    event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"));

	    event.addListener(mouseTarget, "mousedown", focusEditor);
	    event.addListener(gutterEl, "mousedown", focusEditor);
	    if (useragent.isIE && editor.renderer.scrollBarV) {
	        event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor);
	        event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor);
	    }

	    editor.on("mousemove", function(e){
	        if (_self.state || _self.$dragDelay || !_self.$dragEnabled)
	            return;

	        var character = editor.renderer.screenToTextCoordinates(e.x, e.y);
	        var range = editor.session.selection.getRange();
	        var renderer = editor.renderer;

	        if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
	            renderer.setCursorStyle("default");
	        } else {
	            renderer.setCursorStyle("");
	        }
	    });
	};

	(function() {
	    this.onMouseEvent = function(name, e) {
	        this.editor._emit(name, new MouseEvent(e, this.editor));
	    };

	    this.onMouseMove = function(name, e) {
	        var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
	        if (!listeners || !listeners.length)
	            return;

	        this.editor._emit(name, new MouseEvent(e, this.editor));
	    };

	    this.onMouseWheel = function(name, e) {
	        var mouseEvent = new MouseEvent(e, this.editor);
	        mouseEvent.speed = this.$scrollSpeed * 2;
	        mouseEvent.wheelX = e.wheelX;
	        mouseEvent.wheelY = e.wheelY;

	        this.editor._emit(name, mouseEvent);
	    };
	    
	    this.onTouchMove = function (name, e) {
	        var mouseEvent = new MouseEvent(e, this.editor);
	        mouseEvent.speed = 1;//this.$scrollSpeed * 2;
	        mouseEvent.wheelX = e.wheelX;
	        mouseEvent.wheelY = e.wheelY;
	        this.editor._emit(name, mouseEvent);
	    };

	    this.setState = function(state) {
	        this.state = state;
	    };

	    this.captureMouse = function(ev, mouseMoveHandler) {
	        this.x = ev.x;
	        this.y = ev.y;

	        this.isMousePressed = true;
	        var renderer = this.editor.renderer;
	        if (renderer.$keepTextAreaAtCursor)
	            renderer.$keepTextAreaAtCursor = null;

	        var self = this;
	        var onMouseMove = function(e) {
	            if (!e) return;
	            if (useragent.isWebKit && !e.which && self.releaseMouse)
	                return self.releaseMouse();

	            self.x = e.clientX;
	            self.y = e.clientY;
	            mouseMoveHandler && mouseMoveHandler(e);
	            self.mouseEvent = new MouseEvent(e, self.editor);
	            self.$mouseMoved = true;
	        };

	        var onCaptureEnd = function(e) {
	            clearInterval(timerId);
	            onCaptureInterval();
	            self[self.state + "End"] && self[self.state + "End"](e);
	            self.state = "";
	            if (renderer.$keepTextAreaAtCursor == null) {
	                renderer.$keepTextAreaAtCursor = true;
	                renderer.$moveTextAreaToCursor();
	            }
	            self.isMousePressed = false;
	            self.$onCaptureMouseMove = self.releaseMouse = null;
	            e && self.onMouseEvent("mouseup", e);
	        };

	        var onCaptureInterval = function() {
	            self[self.state] && self[self.state]();
	            self.$mouseMoved = false;
	        };

	        if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
	            return setTimeout(function() {onCaptureEnd(ev);});
	        }

	        self.$onCaptureMouseMove = onMouseMove;
	        self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
	        var timerId = setInterval(onCaptureInterval, 20);
	    };
	    this.releaseMouse = null;
	    this.cancelContextMenu = function() {
	        var stop = function(e) {
	            if (e && e.domEvent && e.domEvent.type != "contextmenu")
	                return;
	            this.editor.off("nativecontextmenu", stop);
	            if (e && e.domEvent)
	                event.stopEvent(e.domEvent);
	        }.bind(this);
	        setTimeout(stop, 10);
	        this.editor.on("nativecontextmenu", stop);
	    };
	}).call(MouseHandler.prototype);

	config.defineOptions(MouseHandler.prototype, "mouseHandler", {
	    scrollSpeed: {initialValue: 2},
	    dragDelay: {initialValue: (useragent.isMac ? 150 : 0)},
	    dragEnabled: {initialValue: true},
	    focusTimout: {initialValue: 0},
	    tooltipFollowsMouse: {initialValue: true}
	});


	exports.MouseHandler = MouseHandler;
	});

	ace.define("ace/mouse/fold_handler",["require","exports","module"], function(acequire, exports, module) {
	"use strict";

	function FoldHandler(editor) {

	    editor.on("click", function(e) {
	        var position = e.getDocumentPosition();
	        var session = editor.session;
	        var fold = session.getFoldAt(position.row, position.column, 1);
	        if (fold) {
	            if (e.getAccelKey())
	                session.removeFold(fold);
	            else
	                session.expandFold(fold);

	            e.stop();
	        }
	    });

	    editor.on("gutterclick", function(e) {
	        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

	        if (gutterRegion == "foldWidgets") {
	            var row = e.getDocumentPosition().row;
	            var session = editor.session;
	            if (session.foldWidgets && session.foldWidgets[row])
	                editor.session.onFoldWidgetClick(row, e);
	            if (!editor.isFocused())
	                editor.focus();
	            e.stop();
	        }
	    });

	    editor.on("gutterdblclick", function(e) {
	        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

	        if (gutterRegion == "foldWidgets") {
	            var row = e.getDocumentPosition().row;
	            var session = editor.session;
	            var data = session.getParentFoldRangeData(row, true);
	            var range = data.range || data.firstRange;

	            if (range) {
	                row = range.start.row;
	                var fold = session.getFoldAt(row, session.getLine(row).length, 1);

	                if (fold) {
	                    session.removeFold(fold);
	                } else {
	                    session.addFold("...", range);
	                    editor.renderer.scrollCursorIntoView({row: range.start.row, column: 0});
	                }
	            }
	            e.stop();
	        }
	    });
	}

	exports.FoldHandler = FoldHandler;

	});

	ace.define("ace/keyboard/keybinding",["require","exports","module","ace/lib/keys","ace/lib/event"], function(acequire, exports, module) {
	"use strict";

	var keyUtil  = acequire("../lib/keys");
	var event = acequire("../lib/event");

	var KeyBinding = function(editor) {
	    this.$editor = editor;
	    this.$data = {editor: editor};
	    this.$handlers = [];
	    this.setDefaultHandler(editor.commands);
	};

	(function() {
	    this.setDefaultHandler = function(kb) {
	        this.removeKeyboardHandler(this.$defaultHandler);
	        this.$defaultHandler = kb;
	        this.addKeyboardHandler(kb, 0);
	    };

	    this.setKeyboardHandler = function(kb) {
	        var h = this.$handlers;
	        if (h[h.length - 1] == kb)
	            return;

	        while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)
	            this.removeKeyboardHandler(h[h.length - 1]);

	        this.addKeyboardHandler(kb, 1);
	    };

	    this.addKeyboardHandler = function(kb, pos) {
	        if (!kb)
	            return;
	        if (typeof kb == "function" && !kb.handleKeyboard)
	            kb.handleKeyboard = kb;
	        var i = this.$handlers.indexOf(kb);
	        if (i != -1)
	            this.$handlers.splice(i, 1);

	        if (pos == undefined)
	            this.$handlers.push(kb);
	        else
	            this.$handlers.splice(pos, 0, kb);

	        if (i == -1 && kb.attach)
	            kb.attach(this.$editor);
	    };

	    this.removeKeyboardHandler = function(kb) {
	        var i = this.$handlers.indexOf(kb);
	        if (i == -1)
	            return false;
	        this.$handlers.splice(i, 1);
	        kb.detach && kb.detach(this.$editor);
	        return true;
	    };

	    this.getKeyboardHandler = function() {
	        return this.$handlers[this.$handlers.length - 1];
	    };
	    
	    this.getStatusText = function() {
	        var data = this.$data;
	        var editor = data.editor;
	        return this.$handlers.map(function(h) {
	            return h.getStatusText && h.getStatusText(editor, data) || "";
	        }).filter(Boolean).join(" ");
	    };

	    this.$callKeyboardHandlers = function(hashId, keyString, keyCode, e) {
	        var toExecute;
	        var success = false;
	        var commands = this.$editor.commands;

	        for (var i = this.$handlers.length; i--;) {
	            toExecute = this.$handlers[i].handleKeyboard(
	                this.$data, hashId, keyString, keyCode, e
	            );
	            if (!toExecute || !toExecute.command)
	                continue;
	            if (toExecute.command == "null") {
	                success = true;
	            } else {
	                success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
	            }
	            if (success && e && hashId != -1 && 
	                toExecute.passEvent != true && toExecute.command.passEvent != true
	            ) {
	                event.stopEvent(e);
	            }
	            if (success)
	                break;
	        }
	        
	        if (!success && hashId == -1) {
	            toExecute = {command: "insertstring"};
	            success = commands.exec("insertstring", this.$editor, keyString);
	        }
	        
	        if (success)
	            this.$editor._signal("keyboardActivity", toExecute);
	        
	        return success;
	    };

	    this.onCommandKey = function(e, hashId, keyCode) {
	        var keyString = keyUtil.keyCodeToString(keyCode);
	        this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
	    };

	    this.onTextInput = function(text) {
	        this.$callKeyboardHandlers(-1, text);
	    };

	}).call(KeyBinding.prototype);

	exports.KeyBinding = KeyBinding;
	});

	ace.define("ace/range",["require","exports","module"], function(acequire, exports, module) {
	"use strict";
	var comparePoints = function(p1, p2) {
	    return p1.row - p2.row || p1.column - p2.column;
	};
	var Range = function(startRow, startColumn, endRow, endColumn) {
	    this.start = {
	        row: startRow,
	        column: startColumn
	    };

	    this.end = {
	        row: endRow,
	        column: endColumn
	    };
	};

	(function() {
	    this.isEqual = function(range) {
	        return this.start.row === range.start.row &&
	            this.end.row === range.end.row &&
	            this.start.column === range.start.column &&
	            this.end.column === range.end.column;
	    };
	    this.toString = function() {
	        return ("Range: [" + this.start.row + "/" + this.start.column +
	            "] -> [" + this.end.row + "/" + this.end.column + "]");
	    };

	    this.contains = function(row, column) {
	        return this.compare(row, column) == 0;
	    };
	    this.compareRange = function(range) {
	        var cmp,
	            end = range.end,
	            start = range.start;

	        cmp = this.compare(end.row, end.column);
	        if (cmp == 1) {
	            cmp = this.compare(start.row, start.column);
	            if (cmp == 1) {
	                return 2;
	            } else if (cmp == 0) {
	                return 1;
	            } else {
	                return 0;
	            }
	        } else if (cmp == -1) {
	            return -2;
	        } else {
	            cmp = this.compare(start.row, start.column);
	            if (cmp == -1) {
	                return -1;
	            } else if (cmp == 1) {
	                return 42;
	            } else {
	                return 0;
	            }
	        }
	    };
	    this.comparePoint = function(p) {
	        return this.compare(p.row, p.column);
	    };
	    this.containsRange = function(range) {
	        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
	    };
	    this.intersects = function(range) {
	        var cmp = this.compareRange(range);
	        return (cmp == -1 || cmp == 0 || cmp == 1);
	    };
	    this.isEnd = function(row, column) {
	        return this.end.row == row && this.end.column == column;
	    };
	    this.isStart = function(row, column) {
	        return this.start.row == row && this.start.column == column;
	    };
	    this.setStart = function(row, column) {
	        if (typeof row == "object") {
	            this.start.column = row.column;
	            this.start.row = row.row;
	        } else {
	            this.start.row = row;
	            this.start.column = column;
	        }
	    };
	    this.setEnd = function(row, column) {
	        if (typeof row == "object") {
	            this.end.column = row.column;
	            this.end.row = row.row;
	        } else {
	            this.end.row = row;
	            this.end.column = column;
	        }
	    };
	    this.inside = function(row, column) {
	        if (this.compare(row, column) == 0) {
	            if (this.isEnd(row, column) || this.isStart(row, column)) {
	                return false;
	            } else {
	                return true;
	            }
	        }
	        return false;
	    };
	    this.insideStart = function(row, column) {
	        if (this.compare(row, column) == 0) {
	            if (this.isEnd(row, column)) {
	                return false;
	            } else {
	                return true;
	            }
	        }
	        return false;
	    };
	    this.insideEnd = function(row, column) {
	        if (this.compare(row, column) == 0) {
	            if (this.isStart(row, column)) {
	                return false;
	            } else {
	                return true;
	            }
	        }
	        return false;
	    };
	    this.compare = function(row, column) {
	        if (!this.isMultiLine()) {
	            if (row === this.start.row) {
	                return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);
	            }
	        }

	        if (row < this.start.row)
	            return -1;

	        if (row > this.end.row)
	            return 1;

	        if (this.start.row === row)
	            return column >= this.start.column ? 0 : -1;

	        if (this.end.row === row)
	            return column <= this.end.column ? 0 : 1;

	        return 0;
	    };
	    this.compareStart = function(row, column) {
	        if (this.start.row == row && this.start.column == column) {
	            return -1;
	        } else {
	            return this.compare(row, column);
	        }
	    };
	    this.compareEnd = function(row, column) {
	        if (this.end.row == row && this.end.column == column) {
	            return 1;
	        } else {
	            return this.compare(row, column);
	        }
	    };
	    this.compareInside = function(row, column) {
	        if (this.end.row == row && this.end.column == column) {
	            return 1;
	        } else if (this.start.row == row && this.start.column == column) {
	            return -1;
	        } else {
	            return this.compare(row, column);
	        }
	    };
	    this.clipRows = function(firstRow, lastRow) {
	        if (this.end.row > lastRow)
	            var end = {row: lastRow + 1, column: 0};
	        else if (this.end.row < firstRow)
	            var end = {row: firstRow, column: 0};

	        if (this.start.row > lastRow)
	            var start = {row: lastRow + 1, column: 0};
	        else if (this.start.row < firstRow)
	            var start = {row: firstRow, column: 0};

	        return Range.fromPoints(start || this.start, end || this.end);
	    };
	    this.extend = function(row, column) {
	        var cmp = this.compare(row, column);

	        if (cmp == 0)
	            return this;
	        else if (cmp == -1)
	            var start = {row: row, column: column};
	        else
	            var end = {row: row, column: column};

	        return Range.fromPoints(start || this.start, end || this.end);
	    };

	    this.isEmpty = function() {
	        return (this.start.row === this.end.row && this.start.column === this.end.column);
	    };
	    this.isMultiLine = function() {
	        return (this.start.row !== this.end.row);
	    };
	    this.clone = function() {
	        return Range.fromPoints(this.start, this.end);
	    };
	    this.collapseRows = function() {
	        if (this.end.column == 0)
	            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row-1), 0)
	        else
	            return new Range(this.start.row, 0, this.end.row, 0)
	    };
	    this.toScreenRange = function(session) {
	        var screenPosStart = session.documentToScreenPosition(this.start);
	        var screenPosEnd = session.documentToScreenPosition(this.end);

	        return new Range(
	            screenPosStart.row, screenPosStart.column,
	            screenPosEnd.row, screenPosEnd.column
	        );
	    };
	    this.moveBy = function(row, column) {
	        this.start.row += row;
	        this.start.column += column;
	        this.end.row += row;
	        this.end.column += column;
	    };

	}).call(Range.prototype);
	Range.fromPoints = function(start, end) {
	    return new Range(start.row, start.column, end.row, end.column);
	};
	Range.comparePoints = comparePoints;

	Range.comparePoints = function(p1, p2) {
	    return p1.row - p2.row || p1.column - p2.column;
	};


	exports.Range = Range;
	});

	ace.define("ace/selection",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter","ace/range"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("./lib/oop");
	var lang = acequire("./lib/lang");
	var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
	var Range = acequire("./range").Range;
	var Selection = function(session) {
	    this.session = session;
	    this.doc = session.getDocument();

	    this.clearSelection();
	    this.lead = this.selectionLead = this.doc.createAnchor(0, 0);
	    this.anchor = this.selectionAnchor = this.doc.createAnchor(0, 0);

	    var self = this;
	    this.lead.on("change", function(e) {
	        self._emit("changeCursor");
	        if (!self.$isEmpty)
	            self._emit("changeSelection");
	        if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column)
	            self.$desiredColumn = null;
	    });

	    this.selectionAnchor.on("change", function() {
	        if (!self.$isEmpty)
	            self._emit("changeSelection");
	    });
	};

	(function() {

	    oop.implement(this, EventEmitter);
	    this.isEmpty = function() {
	        return (this.$isEmpty || (
	            this.anchor.row == this.lead.row &&
	            this.anchor.column == this.lead.column
	        ));
	    };
	    this.isMultiLine = function() {
	        if (this.isEmpty()) {
	            return false;
	        }

	        return this.getRange().isMultiLine();
	    };
	    this.getCursor = function() {
	        return this.lead.getPosition();
	    };
	    this.setSelectionAnchor = function(row, column) {
	        this.anchor.setPosition(row, column);

	        if (this.$isEmpty) {
	            this.$isEmpty = false;
	            this._emit("changeSelection");
	        }
	    };
	    this.getSelectionAnchor = function() {
	        if (this.$isEmpty)
	            return this.getSelectionLead();
	        else
	            return this.anchor.getPosition();
	    };
	    this.getSelectionLead = function() {
	        return this.lead.getPosition();
	    };
	    this.shiftSelection = function(columns) {
	        if (this.$isEmpty) {
	            this.moveCursorTo(this.lead.row, this.lead.column + columns);
	            return;
	        }

	        var anchor = this.getSelectionAnchor();
	        var lead = this.getSelectionLead();

	        var isBackwards = this.isBackwards();

	        if (!isBackwards || anchor.column !== 0)
	            this.setSelectionAnchor(anchor.row, anchor.column + columns);

	        if (isBackwards || lead.column !== 0) {
	            this.$moveSelection(function() {
	                this.moveCursorTo(lead.row, lead.column + columns);
	            });
	        }
	    };
	    this.isBackwards = function() {
	        var anchor = this.anchor;
	        var lead = this.lead;
	        return (anchor.row > lead.row || (anchor.row == lead.row && anchor.column > lead.column));
	    };
	    this.getRange = function() {
	        var anchor = this.anchor;
	        var lead = this.lead;

	        if (this.isEmpty())
	            return Range.fromPoints(lead, lead);

	        if (this.isBackwards()) {
	            return Range.fromPoints(lead, anchor);
	        }
	        else {
	            return Range.fromPoints(anchor, lead);
	        }
	    };
	    this.clearSelection = function() {
	        if (!this.$isEmpty) {
	            this.$isEmpty = true;
	            this._emit("changeSelection");
	        }
	    };
	    this.selectAll = function() {
	        var lastRow = this.doc.getLength() - 1;
	        this.setSelectionAnchor(0, 0);
	        this.moveCursorTo(lastRow, this.doc.getLine(lastRow).length);
	    };
	    this.setRange =
	    this.setSelectionRange = function(range, reverse) {
	        if (reverse) {
	            this.setSelectionAnchor(range.end.row, range.end.column);
	            this.selectTo(range.start.row, range.start.column);
	        } else {
	            this.setSelectionAnchor(range.start.row, range.start.column);
	            this.selectTo(range.end.row, range.end.column);
	        }
	        if (this.getRange().isEmpty())
	            this.$isEmpty = true;
	        this.$desiredColumn = null;
	    };

	    this.$moveSelection = function(mover) {
	        var lead = this.lead;
	        if (this.$isEmpty)
	            this.setSelectionAnchor(lead.row, lead.column);

	        mover.call(this);
	    };
	    this.selectTo = function(row, column) {
	        this.$moveSelection(function() {
	            this.moveCursorTo(row, column);
	        });
	    };
	    this.selectToPosition = function(pos) {
	        this.$moveSelection(function() {
	            this.moveCursorToPosition(pos);
	        });
	    };
	    this.moveTo = function(row, column) {
	        this.clearSelection();
	        this.moveCursorTo(row, column);
	    };
	    this.moveToPosition = function(pos) {
	        this.clearSelection();
	        this.moveCursorToPosition(pos);
	    };
	    this.selectUp = function() {
	        this.$moveSelection(this.moveCursorUp);
	    };
	    this.selectDown = function() {
	        this.$moveSelection(this.moveCursorDown);
	    };
	    this.selectRight = function() {
	        this.$moveSelection(this.moveCursorRight);
	    };
	    this.selectLeft = function() {
	        this.$moveSelection(this.moveCursorLeft);
	    };
	    this.selectLineStart = function() {
	        this.$moveSelection(this.moveCursorLineStart);
	    };
	    this.selectLineEnd = function() {
	        this.$moveSelection(this.moveCursorLineEnd);
	    };
	    this.selectFileEnd = function() {
	        this.$moveSelection(this.moveCursorFileEnd);
	    };
	    this.selectFileStart = function() {
	        this.$moveSelection(this.moveCursorFileStart);
	    };
	    this.selectWordRight = function() {
	        this.$moveSelection(this.moveCursorWordRight);
	    };
	    this.selectWordLeft = function() {
	        this.$moveSelection(this.moveCursorWordLeft);
	    };
	    this.getWordRange = function(row, column) {
	        if (typeof column == "undefined") {
	            var cursor = row || this.lead;
	            row = cursor.row;
	            column = cursor.column;
	        }
	        return this.session.getWordRange(row, column);
	    };
	    this.selectWord = function() {
	        this.setSelectionRange(this.getWordRange());
	    };
	    this.selectAWord = function() {
	        var cursor = this.getCursor();
	        var range = this.session.getAWordRange(cursor.row, cursor.column);
	        this.setSelectionRange(range);
	    };

	    this.getLineRange = function(row, excludeLastChar) {
	        var rowStart = typeof row == "number" ? row : this.lead.row;
	        var rowEnd;

	        var foldLine = this.session.getFoldLine(rowStart);
	        if (foldLine) {
	            rowStart = foldLine.start.row;
	            rowEnd = foldLine.end.row;
	        } else {
	            rowEnd = rowStart;
	        }
	        if (excludeLastChar === true)
	            return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
	        else
	            return new Range(rowStart, 0, rowEnd + 1, 0);
	    };
	    this.selectLine = function() {
	        this.setSelectionRange(this.getLineRange());
	    };
	    this.moveCursorUp = function() {
	        this.moveCursorBy(-1, 0);
	    };
	    this.moveCursorDown = function() {
	        this.moveCursorBy(1, 0);
	    };
	    this.moveCursorLeft = function() {
	        var cursor = this.lead.getPosition(),
	            fold;

	        if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
	            this.moveCursorTo(fold.start.row, fold.start.column);
	        } else if (cursor.column === 0) {
	            if (cursor.row > 0) {
	                this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
	            }
	        }
	        else {
	            var tabSize = this.session.getTabSize();
	            if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column-tabSize, cursor.column).split(" ").length-1 == tabSize)
	                this.moveCursorBy(0, -tabSize);
	            else
	                this.moveCursorBy(0, -1);
	        }
	    };
	    this.moveCursorRight = function() {
	        var cursor = this.lead.getPosition(),
	            fold;
	        if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
	            this.moveCursorTo(fold.end.row, fold.end.column);
	        }
	        else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
	            if (this.lead.row < this.doc.getLength() - 1) {
	                this.moveCursorTo(this.lead.row + 1, 0);
	            }
	        }
	        else {
	            var tabSize = this.session.getTabSize();
	            var cursor = this.lead;
	            if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column, cursor.column+tabSize).split(" ").length-1 == tabSize)
	                this.moveCursorBy(0, tabSize);
	            else
	                this.moveCursorBy(0, 1);
	        }
	    };
	    this.moveCursorLineStart = function() {
	        var row = this.lead.row;
	        var column = this.lead.column;
	        var screenRow = this.session.documentToScreenRow(row, column);
	        var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
	        var beforeCursor = this.session.getDisplayLine(
	            row, null, firstColumnPosition.row,
	            firstColumnPosition.column
	        );

	        var leadingSpace = beforeCursor.match(/^\s*/);
	        if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)
	            firstColumnPosition.column += leadingSpace[0].length;
	        this.moveCursorToPosition(firstColumnPosition);
	    };
	    this.moveCursorLineEnd = function() {
	        var lead = this.lead;
	        var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
	        if (this.lead.column == lineEnd.column) {
	            var line = this.session.getLine(lineEnd.row);
	            if (lineEnd.column == line.length) {
	                var textEnd = line.search(/\s+$/);
	                if (textEnd > 0)
	                    lineEnd.column = textEnd;
	            }
	        }

	        this.moveCursorTo(lineEnd.row, lineEnd.column);
	    };
	    this.moveCursorFileEnd = function() {
	        var row = this.doc.getLength() - 1;
	        var column = this.doc.getLine(row).length;
	        this.moveCursorTo(row, column);
	    };
	    this.moveCursorFileStart = function() {
	        this.moveCursorTo(0, 0);
	    };
	    this.moveCursorLongWordRight = function() {
	        var row = this.lead.row;
	        var column = this.lead.column;
	        var line = this.doc.getLine(row);
	        var rightOfCursor = line.substring(column);

	        var match;
	        this.session.nonTokenRe.lastIndex = 0;
	        this.session.tokenRe.lastIndex = 0;
	        var fold = this.session.getFoldAt(row, column, 1);
	        if (fold) {
	            this.moveCursorTo(fold.end.row, fold.end.column);
	            return;
	        }
	        if (match = this.session.nonTokenRe.exec(rightOfCursor)) {
	            column += this.session.nonTokenRe.lastIndex;
	            this.session.nonTokenRe.lastIndex = 0;
	            rightOfCursor = line.substring(column);
	        }
	        if (column >= line.length) {
	            this.moveCursorTo(row, line.length);
	            this.moveCursorRight();
	            if (row < this.doc.getLength() - 1)
	                this.moveCursorWordRight();
	            return;
	        }
	        if (match = this.session.tokenRe.exec(rightOfCursor)) {
	            column += this.session.tokenRe.lastIndex;
	            this.session.tokenRe.lastIndex = 0;
	        }

	        this.moveCursorTo(row, column);
	    };
	    this.moveCursorLongWordLeft = function() {
	        var row = this.lead.row;
	        var column = this.lead.column;
	        var fold;
	        if (fold = this.session.getFoldAt(row, column, -1)) {
	            this.moveCursorTo(fold.start.row, fold.start.column);
	            return;
	        }

	        var str = this.session.getFoldStringAt(row, column, -1);
	        if (str == null) {
	            str = this.doc.getLine(row).substring(0, column);
	        }

	        var leftOfCursor = lang.stringReverse(str);
	        var match;
	        this.session.nonTokenRe.lastIndex = 0;
	        this.session.tokenRe.lastIndex = 0;
	        if (match = this.session.nonTokenRe.exec(leftOfCursor)) {
	            column -= this.session.nonTokenRe.lastIndex;
	            leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
	            this.session.nonTokenRe.lastIndex = 0;
	        }
	        if (column <= 0) {
	            this.moveCursorTo(row, 0);
	            this.moveCursorLeft();
	            if (row > 0)
	                this.moveCursorWordLeft();
	            return;
	        }
	        if (match = this.session.tokenRe.exec(leftOfCursor)) {
	            column -= this.session.tokenRe.lastIndex;
	            this.session.tokenRe.lastIndex = 0;
	        }

	        this.moveCursorTo(row, column);
	    };

	    this.$shortWordEndIndex = function(rightOfCursor) {
	        var match, index = 0, ch;
	        var whitespaceRe = /\s/;
	        var tokenRe = this.session.tokenRe;

	        tokenRe.lastIndex = 0;
	        if (match = this.session.tokenRe.exec(rightOfCursor)) {
	            index = this.session.tokenRe.lastIndex;
	        } else {
	            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
	                index ++;

	            if (index < 1) {
	                tokenRe.lastIndex = 0;
	                 while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
	                    tokenRe.lastIndex = 0;
	                    index ++;
	                    if (whitespaceRe.test(ch)) {
	                        if (index > 2) {
	                            index--;
	                            break;
	                        } else {
	                            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
	                                index ++;
	                            if (index > 2)
	                                break;
	                        }
	                    }
	                }
	            }
	        }
	        tokenRe.lastIndex = 0;

	        return index;
	    };

	    this.moveCursorShortWordRight = function() {
	        var row = this.lead.row;
	        var column = this.lead.column;
	        var line = this.doc.getLine(row);
	        var rightOfCursor = line.substring(column);

	        var fold = this.session.getFoldAt(row, column, 1);
	        if (fold)
	            return this.moveCursorTo(fold.end.row, fold.end.column);

	        if (column == line.length) {
	            var l = this.doc.getLength();
	            do {
	                row++;
	                rightOfCursor = this.doc.getLine(row);
	            } while (row < l && /^\s*$/.test(rightOfCursor));

	            if (!/^\s+/.test(rightOfCursor))
	                rightOfCursor = "";
	            column = 0;
	        }

	        var index = this.$shortWordEndIndex(rightOfCursor);

	        this.moveCursorTo(row, column + index);
	    };

	    this.moveCursorShortWordLeft = function() {
	        var row = this.lead.row;
	        var column = this.lead.column;

	        var fold;
	        if (fold = this.session.getFoldAt(row, column, -1))
	            return this.moveCursorTo(fold.start.row, fold.start.column);

	        var line = this.session.getLine(row).substring(0, column);
	        if (column === 0) {
	            do {
	                row--;
	                line = this.doc.getLine(row);
	            } while (row > 0 && /^\s*$/.test(line));

	            column = line.length;
	            if (!/\s+$/.test(line))
	                line = "";
	        }

	        var leftOfCursor = lang.stringReverse(line);
	        var index = this.$shortWordEndIndex(leftOfCursor);

	        return this.moveCursorTo(row, column - index);
	    };

	    this.moveCursorWordRight = function() {
	        if (this.session.$selectLongWords)
	            this.moveCursorLongWordRight();
	        else
	            this.moveCursorShortWordRight();
	    };

	    this.moveCursorWordLeft = function() {
	        if (this.session.$selectLongWords)
	            this.moveCursorLongWordLeft();
	        else
	            this.moveCursorShortWordLeft();
	    };
	    this.moveCursorBy = function(rows, chars) {
	        var screenPos = this.session.documentToScreenPosition(
	            this.lead.row,
	            this.lead.column
	        );

	        if (chars === 0) {
	            if (this.$desiredColumn)
	                screenPos.column = this.$desiredColumn;
	            else
	                this.$desiredColumn = screenPos.column;
	        }

	        var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column);
	        
	        if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {
	            if (this.session.lineWidgets && this.session.lineWidgets[docPos.row]) {
	                if (docPos.row > 0 || rows > 0)
	                    docPos.row++;
	            }
	        }
	        this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
	    };
	    this.moveCursorToPosition = function(position) {
	        this.moveCursorTo(position.row, position.column);
	    };
	    this.moveCursorTo = function(row, column, keepDesiredColumn) {
	        var fold = this.session.getFoldAt(row, column, 1);
	        if (fold) {
	            row = fold.start.row;
	            column = fold.start.column;
	        }

	        this.$keepDesiredColumnOnChange = true;
	        this.lead.setPosition(row, column);
	        this.$keepDesiredColumnOnChange = false;

	        if (!keepDesiredColumn)
	            this.$desiredColumn = null;
	    };
	    this.moveCursorToScreen = function(row, column, keepDesiredColumn) {
	        var pos = this.session.screenToDocumentPosition(row, column);
	        this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
	    };
	    this.detach = function() {
	        this.lead.detach();
	        this.anchor.detach();
	        this.session = this.doc = null;
	    };

	    this.fromOrientedRange = function(range) {
	        this.setSelectionRange(range, range.cursor == range.start);
	        this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
	    };

	    this.toOrientedRange = function(range) {
	        var r = this.getRange();
	        if (range) {
	            range.start.column = r.start.column;
	            range.start.row = r.start.row;
	            range.end.column = r.end.column;
	            range.end.row = r.end.row;
	        } else {
	            range = r;
	        }

	        range.cursor = this.isBackwards() ? range.start : range.end;
	        range.desiredColumn = this.$desiredColumn;
	        return range;
	    };
	    this.getRangeOfMovements = function(func) {
	        var start = this.getCursor();
	        try {
	            func(this);
	            var end = this.getCursor();
	            return Range.fromPoints(start,end);
	        } catch(e) {
	            return Range.fromPoints(start,start);
	        } finally {
	            this.moveCursorToPosition(start);
	        }
	    };

	    this.toJSON = function() {
	        if (this.rangeCount) {
	            var data = this.ranges.map(function(r) {
	                var r1 = r.clone();
	                r1.isBackwards = r.cursor == r.start;
	                return r1;
	            });
	        } else {
	            var data = this.getRange();
	            data.isBackwards = this.isBackwards();
	        }
	        return data;
	    };

	    this.fromJSON = function(data) {
	        if (data.start == undefined) {
	            if (this.rangeList) {
	                this.toSingleRange(data[0]);
	                for (var i = data.length; i--; ) {
	                    var r = Range.fromPoints(data[i].start, data[i].end);
	                    if (data[i].isBackwards)
	                        r.cursor = r.start;
	                    this.addRange(r, true);
	                }
	                return;
	            } else
	                data = data[0];
	        }
	        if (this.rangeList)
	            this.toSingleRange(data);
	        this.setSelectionRange(data, data.isBackwards);
	    };

	    this.isEqual = function(data) {
	        if ((data.length || this.rangeCount) && data.length != this.rangeCount)
	            return false;
	        if (!data.length || !this.ranges)
	            return this.getRange().isEqual(data);

	        for (var i = this.ranges.length; i--; ) {
	            if (!this.ranges[i].isEqual(data[i]))
	                return false;
	        }
	        return true;
	    };

	}).call(Selection.prototype);

	exports.Selection = Selection;
	});

	ace.define("ace/tokenizer",["require","exports","module","ace/config"], function(acequire, exports, module) {
	"use strict";

	var config = acequire("./config");
	var MAX_TOKEN_COUNT = 2000;
	var Tokenizer = function(rules) {
	    this.states = rules;

	    this.regExps = {};
	    this.matchMappings = {};
	    for (var key in this.states) {
	        var state = this.states[key];
	        var ruleRegExps = [];
	        var matchTotal = 0;
	        var mapping = this.matchMappings[key] = {defaultToken: "text"};
	        var flag = "g";

	        var splitterRurles = [];
	        for (var i = 0; i < state.length; i++) {
	            var rule = state[i];
	            if (rule.defaultToken)
	                mapping.defaultToken = rule.defaultToken;
	            if (rule.caseInsensitive)
	                flag = "gi";
	            if (rule.regex == null)
	                continue;

	            if (rule.regex instanceof RegExp)
	                rule.regex = rule.regex.toString().slice(1, -1);
	            var adjustedregex = rule.regex;
	            var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
	            if (Array.isArray(rule.token)) {
	                if (rule.token.length == 1 || matchcount == 1) {
	                    rule.token = rule.token[0];
	                } else if (matchcount - 1 != rule.token.length) {
	                    this.reportError("number of classes and regexp groups doesn't match", { 
	                        rule: rule,
	                        groupCount: matchcount - 1
	                    });
	                    rule.token = rule.token[0];
	                } else {
	                    rule.tokenArray = rule.token;
	                    rule.token = null;
	                    rule.onMatch = this.$arrayTokens;
	                }
	            } else if (typeof rule.token == "function" && !rule.onMatch) {
	                if (matchcount > 1)
	                    rule.onMatch = this.$applyToken;
	                else
	                    rule.onMatch = rule.token;
	            }

	            if (matchcount > 1) {
	                if (/\\\d/.test(rule.regex)) {
	                    adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match, digit) {
	                        return "\\" + (parseInt(digit, 10) + matchTotal + 1);
	                    });
	                } else {
	                    matchcount = 1;
	                    adjustedregex = this.removeCapturingGroups(rule.regex);
	                }
	                if (!rule.splitRegex && typeof rule.token != "string")
	                    splitterRurles.push(rule); // flag will be known only at the very end
	            }

	            mapping[matchTotal] = i;
	            matchTotal += matchcount;

	            ruleRegExps.push(adjustedregex);
	            if (!rule.onMatch)
	                rule.onMatch = null;
	        }
	        
	        if (!ruleRegExps.length) {
	            mapping[0] = 0;
	            ruleRegExps.push("$");
	        }
	        
	        splitterRurles.forEach(function(rule) {
	            rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
	        }, this);

	        this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
	    }
	};

	(function() {
	    this.$setMaxTokenCount = function(m) {
	        MAX_TOKEN_COUNT = m | 0;
	    };
	    
	    this.$applyToken = function(str) {
	        var values = this.splitRegex.exec(str).slice(1);
	        var types = this.token.apply(this, values);
	        if (typeof types === "string")
	            return [{type: types, value: str}];

	        var tokens = [];
	        for (var i = 0, l = types.length; i < l; i++) {
	            if (values[i])
	                tokens[tokens.length] = {
	                    type: types[i],
	                    value: values[i]
	                };
	        }
	        return tokens;
	    };

	    this.$arrayTokens = function(str) {
	        if (!str)
	            return [];
	        var values = this.splitRegex.exec(str);
	        if (!values)
	            return "text";
	        var tokens = [];
	        var types = this.tokenArray;
	        for (var i = 0, l = types.length; i < l; i++) {
	            if (values[i + 1])
	                tokens[tokens.length] = {
	                    type: types[i],
	                    value: values[i + 1]
	                };
	        }
	        return tokens;
	    };

	    this.removeCapturingGroups = function(src) {
	        var r = src.replace(
	            /\[(?:\\.|[^\]])*?\]|\\.|\(\?[:=!]|(\()/g,
	            function(x, y) {return y ? "(?:" : x;}
	        );
	        return r;
	    };

	    this.createSplitterRegexp = function(src, flag) {
	        if (src.indexOf("(?=") != -1) {
	            var stack = 0;
	            var inChClass = false;
	            var lastCapture = {};
	            src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(
	                m, esc, parenOpen, parenClose, square, index
	            ) {
	                if (inChClass) {
	                    inChClass = square != "]";
	                } else if (square) {
	                    inChClass = true;
	                } else if (parenClose) {
	                    if (stack == lastCapture.stack) {
	                        lastCapture.end = index+1;
	                        lastCapture.stack = -1;
	                    }
	                    stack--;
	                } else if (parenOpen) {
	                    stack++;
	                    if (parenOpen.length != 1) {
	                        lastCapture.stack = stack
	                        lastCapture.start = index;
	                    }
	                }
	                return m;
	            });

	            if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
	                src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
	        }
	        if (src.charAt(0) != "^") src = "^" + src;
	        if (src.charAt(src.length - 1) != "$") src += "$";
	        
	        return new RegExp(src, (flag||"").replace("g", ""));
	    };
	    this.getLineTokens = function(line, startState) {
	        if (startState && typeof startState != "string") {
	            var stack = startState.slice(0);
	            startState = stack[0];
	            if (startState === "#tmp") {
	                stack.shift()
	                startState = stack.shift()
	            }
	        } else
	            var stack = [];

	        var currentState = startState || "start";
	        var state = this.states[currentState];
	        if (!state) {
	            currentState = "start";
	            state = this.states[currentState];
	        }
	        var mapping = this.matchMappings[currentState];
	        var re = this.regExps[currentState];
	        re.lastIndex = 0;

	        var match, tokens = [];
	        var lastIndex = 0;
	        var matchAttempts = 0;

	        var token = {type: null, value: ""};

	        while (match = re.exec(line)) {
	            var type = mapping.defaultToken;
	            var rule = null;
	            var value = match[0];
	            var index = re.lastIndex;

	            if (index - value.length > lastIndex) {
	                var skipped = line.substring(lastIndex, index - value.length);
	                if (token.type == type) {
	                    token.value += skipped;
	                } else {
	                    if (token.type)
	                        tokens.push(token);
	                    token = {type: type, value: skipped};
	                }
	            }

	            for (var i = 0; i < match.length-2; i++) {
	                if (match[i + 1] === undefined)
	                    continue;

	                rule = state[mapping[i]];

	                if (rule.onMatch)
	                    type = rule.onMatch(value, currentState, stack);
	                else
	                    type = rule.token;

	                if (rule.next) {
	                    if (typeof rule.next == "string") {
	                        currentState = rule.next;
	                    } else {
	                        currentState = rule.next(currentState, stack);
	                    }
	                    
	                    state = this.states[currentState];
	                    if (!state) {
	                        this.reportError("state doesn't exist", currentState);
	                        currentState = "start";
	                        state = this.states[currentState];
	                    }
	                    mapping = this.matchMappings[currentState];
	                    lastIndex = index;
	                    re = this.regExps[currentState];
	                    re.lastIndex = index;
	                }
	                break;
	            }

	            if (value) {
	                if (typeof type === "string") {
	                    if ((!rule || rule.merge !== false) && token.type === type) {
	                        token.value += value;
	                    } else {
	                        if (token.type)
	                            tokens.push(token);
	                        token = {type: type, value: value};
	                    }
	                } else if (type) {
	                    if (token.type)
	                        tokens.push(token);
	                    token = {type: null, value: ""};
	                    for (var i = 0; i < type.length; i++)
	                        tokens.push(type[i]);
	                }
	            }

	            if (lastIndex == line.length)
	                break;

	            lastIndex = index;

	            if (matchAttempts++ > MAX_TOKEN_COUNT) {
	                if (matchAttempts > 2 * line.length) {
	                    this.reportError("infinite loop with in ace tokenizer", {
	                        startState: startState,
	                        line: line
	                    });
	                }
	                while (lastIndex < line.length) {
	                    if (token.type)
	                        tokens.push(token);
	                    token = {
	                        value: line.substring(lastIndex, lastIndex += 2000),
	                        type: "overflow"
	                    };
	                }
	                currentState = "start";
	                stack = [];
	                break;
	            }
	        }

	        if (token.type)
	            tokens.push(token);
	        
	        if (stack.length > 1) {
	            if (stack[0] !== currentState)
	                stack.unshift("#tmp", currentState);
	        }
	        return {
	            tokens : tokens,
	            state : stack.length ? stack : currentState
	        };
	    };
	    
	    this.reportError = config.reportError;
	    
	}).call(Tokenizer.prototype);

	exports.Tokenizer = Tokenizer;
	});

	ace.define("ace/mode/text_highlight_rules",["require","exports","module","ace/lib/lang"], function(acequire, exports, module) {
	"use strict";

	var lang = acequire("../lib/lang");

	var TextHighlightRules = function() {

	    this.$rules = {
	        "start" : [{
	            token : "empty_line",
	            regex : '^$'
	        }, {
	            defaultToken : "text"
	        }]
	    };
	};

	(function() {

	    this.addRules = function(rules, prefix) {
	        if (!prefix) {
	            for (var key in rules)
	                this.$rules[key] = rules[key];
	            return;
	        }
	        for (var key in rules) {
	            var state = rules[key];
	            for (var i = 0; i < state.length; i++) {
	                var rule = state[i];
	                if (rule.next || rule.onMatch) {
	                    if (typeof rule.next == "string") {
	                        if (rule.next.indexOf(prefix) !== 0)
	                            rule.next = prefix + rule.next;
	                    }
	                    if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)
	                        rule.nextState = prefix + rule.nextState;
	                }
	            }
	            this.$rules[prefix + key] = state;
	        }
	    };

	    this.getRules = function() {
	        return this.$rules;
	    };

	    this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {
	        var embedRules = typeof HighlightRules == "function"
	            ? new HighlightRules().getRules()
	            : HighlightRules;
	        if (states) {
	            for (var i = 0; i < states.length; i++)
	                states[i] = prefix + states[i];
	        } else {
	            states = [];
	            for (var key in embedRules)
	                states.push(prefix + key);
	        }

	        this.addRules(embedRules, prefix);

	        if (escapeRules) {
	            var addRules = Array.prototype[append ? "push" : "unshift"];
	            for (var i = 0; i < states.length; i++)
	                addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));
	        }

	        if (!this.$embeds)
	            this.$embeds = [];
	        this.$embeds.push(prefix);
	    };

	    this.getEmbeds = function() {
	        return this.$embeds;
	    };

	    var pushState = function(currentState, stack) {
	        if (currentState != "start" || stack.length)
	            stack.unshift(this.nextState, currentState);
	        return this.nextState;
	    };
	    var popState = function(currentState, stack) {
	        stack.shift();
	        return stack.shift() || "start";
	    };

	    this.normalizeRules = function() {
	        var id = 0;
	        var rules = this.$rules;
	        function processState(key) {
	            var state = rules[key];
	            state.processed = true;
	            for (var i = 0; i < state.length; i++) {
	                var rule = state[i];
	                if (!rule.regex && rule.start) {
	                    rule.regex = rule.start;
	                    if (!rule.next)
	                        rule.next = [];
	                    rule.next.push({
	                        defaultToken: rule.token
	                    }, {
	                        token: rule.token + ".end",
	                        regex: rule.end || rule.start,
	                        next: "pop"
	                    });
	                    rule.token = rule.token + ".start";
	                    rule.push = true;
	                }
	                var next = rule.next || rule.push;
	                if (next && Array.isArray(next)) {
	                    var stateName = rule.stateName;
	                    if (!stateName)  {
	                        stateName = rule.token;
	                        if (typeof stateName != "string")
	                            stateName = stateName[0] || "";
	                        if (rules[stateName])
	                            stateName += id++;
	                    }
	                    rules[stateName] = next;
	                    rule.next = stateName;
	                    processState(stateName);
	                } else if (next == "pop") {
	                    rule.next = popState;
	                }

	                if (rule.push) {
	                    rule.nextState = rule.next || rule.push;
	                    rule.next = pushState;
	                    delete rule.push;
	                }

	                if (rule.rules) {
	                    for (var r in rule.rules) {
	                        if (rules[r]) {
	                            if (rules[r].push)
	                                rules[r].push.apply(rules[r], rule.rules[r]);
	                        } else {
	                            rules[r] = rule.rules[r];
	                        }
	                    }
	                }
	                if (rule.include || typeof rule == "string") {
	                    var includeName = rule.include || rule;
	                    var toInsert = rules[includeName];
	                } else if (Array.isArray(rule))
	                    toInsert = rule;

	                if (toInsert) {
	                    var args = [i, 1].concat(toInsert);
	                    if (rule.noEscape)
	                        args = args.filter(function(x) {return !x.next;});
	                    state.splice.apply(state, args);
	                    i--;
	                    toInsert = null;
	                }
	                
	                if (rule.keywordMap) {
	                    rule.token = this.createKeywordMapper(
	                        rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive
	                    );
	                    delete rule.defaultToken;
	                }
	            }
	        }
	        Object.keys(rules).forEach(processState, this);
	    };

	    this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {
	        var keywords = Object.create(null);
	        Object.keys(map).forEach(function(className) {
	            var a = map[className];
	            if (ignoreCase)
	                a = a.toLowerCase();
	            var list = a.split(splitChar || "|");
	            for (var i = list.length; i--; )
	                keywords[list[i]] = className;
	        });
	        if (Object.getPrototypeOf(keywords)) {
	            keywords.__proto__ = null;
	        }
	        this.$keywordList = Object.keys(keywords);
	        map = null;
	        return ignoreCase
	            ? function(value) {return keywords[value.toLowerCase()] || defaultToken }
	            : function(value) {return keywords[value] || defaultToken };
	    };

	    this.getKeywords = function() {
	        return this.$keywords;
	    };

	}).call(TextHighlightRules.prototype);

	exports.TextHighlightRules = TextHighlightRules;
	});

	ace.define("ace/mode/behaviour",["require","exports","module"], function(acequire, exports, module) {
	"use strict";

	var Behaviour = function() {
	   this.$behaviours = {};
	};

	(function () {

	    this.add = function (name, action, callback) {
	        switch (undefined) {
	          case this.$behaviours:
	              this.$behaviours = {};
	          case this.$behaviours[name]:
	              this.$behaviours[name] = {};
	        }
	        this.$behaviours[name][action] = callback;
	    }
	    
	    this.addBehaviours = function (behaviours) {
	        for (var key in behaviours) {
	            for (var action in behaviours[key]) {
	                this.add(key, action, behaviours[key][action]);
	            }
	        }
	    }
	    
	    this.remove = function (name) {
	        if (this.$behaviours && this.$behaviours[name]) {
	            delete this.$behaviours[name];
	        }
	    }
	    
	    this.inherit = function (mode, filter) {
	        if (typeof mode === "function") {
	            var behaviours = new mode().getBehaviours(filter);
	        } else {
	            var behaviours = mode.getBehaviours(filter);
	        }
	        this.addBehaviours(behaviours);
	    }
	    
	    this.getBehaviours = function (filter) {
	        if (!filter) {
	            return this.$behaviours;
	        } else {
	            var ret = {}
	            for (var i = 0; i < filter.length; i++) {
	                if (this.$behaviours[filter[i]]) {
	                    ret[filter[i]] = this.$behaviours[filter[i]];
	                }
	            }
	            return ret;
	        }
	    }

	}).call(Behaviour.prototype);

	exports.Behaviour = Behaviour;
	});

	ace.define("ace/unicode",["require","exports","module"], function(acequire, exports, module) {
	"use strict";
	exports.packages = {};

	addUnicodePackage({
	    L:  "0041-005A0061-007A00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D03860388-038A038C038E-03A103A3-03F503F7-0481048A-05250531-055605590561-058705D0-05EA05F0-05F20621-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280904-0939093D09500958-0961097109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510D0-10FA10FC1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209421022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2D00-2D252D30-2D652D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A65FA662-A66EA67F-A697A6A0-A6E5A717-A71FA722-A788A78BA78CA7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
	    Ll: "0061-007A00AA00B500BA00DF-00F600F8-00FF01010103010501070109010B010D010F01110113011501170119011B011D011F01210123012501270129012B012D012F01310133013501370138013A013C013E014001420144014601480149014B014D014F01510153015501570159015B015D015F01610163016501670169016B016D016F0171017301750177017A017C017E-0180018301850188018C018D019201950199-019B019E01A101A301A501A801AA01AB01AD01B001B401B601B901BA01BD-01BF01C601C901CC01CE01D001D201D401D601D801DA01DC01DD01DF01E101E301E501E701E901EB01ED01EF01F001F301F501F901FB01FD01FF02010203020502070209020B020D020F02110213021502170219021B021D021F02210223022502270229022B022D022F02310233-0239023C023F0240024202470249024B024D024F-02930295-02AF037103730377037B-037D039003AC-03CE03D003D103D5-03D703D903DB03DD03DF03E103E303E503E703E903EB03ED03EF-03F303F503F803FB03FC0430-045F04610463046504670469046B046D046F04710473047504770479047B047D047F0481048B048D048F04910493049504970499049B049D049F04A104A304A504A704A904AB04AD04AF04B104B304B504B704B904BB04BD04BF04C204C404C604C804CA04CC04CE04CF04D104D304D504D704D904DB04DD04DF04E104E304E504E704E904EB04ED04EF04F104F304F504F704F904FB04FD04FF05010503050505070509050B050D050F05110513051505170519051B051D051F0521052305250561-05871D00-1D2B1D62-1D771D79-1D9A1E011E031E051E071E091E0B1E0D1E0F1E111E131E151E171E191E1B1E1D1E1F1E211E231E251E271E291E2B1E2D1E2F1E311E331E351E371E391E3B1E3D1E3F1E411E431E451E471E491E4B1E4D1E4F1E511E531E551E571E591E5B1E5D1E5F1E611E631E651E671E691E6B1E6D1E6F1E711E731E751E771E791E7B1E7D1E7F1E811E831E851E871E891E8B1E8D1E8F1E911E931E95-1E9D1E9F1EA11EA31EA51EA71EA91EAB1EAD1EAF1EB11EB31EB51EB71EB91EBB1EBD1EBF1EC11EC31EC51EC71EC91ECB1ECD1ECF1ED11ED31ED51ED71ED91EDB1EDD1EDF1EE11EE31EE51EE71EE91EEB1EED1EEF1EF11EF31EF51EF71EF91EFB1EFD1EFF-1F071F10-1F151F20-1F271F30-1F371F40-1F451F50-1F571F60-1F671F70-1F7D1F80-1F871F90-1F971FA0-1FA71FB0-1FB41FB61FB71FBE1FC2-1FC41FC61FC71FD0-1FD31FD61FD71FE0-1FE71FF2-1FF41FF61FF7210A210E210F2113212F21342139213C213D2146-2149214E21842C30-2C5E2C612C652C662C682C6A2C6C2C712C732C742C76-2C7C2C812C832C852C872C892C8B2C8D2C8F2C912C932C952C972C992C9B2C9D2C9F2CA12CA32CA52CA72CA92CAB2CAD2CAF2CB12CB32CB52CB72CB92CBB2CBD2CBF2CC12CC32CC52CC72CC92CCB2CCD2CCF2CD12CD32CD52CD72CD92CDB2CDD2CDF2CE12CE32CE42CEC2CEE2D00-2D25A641A643A645A647A649A64BA64DA64FA651A653A655A657A659A65BA65DA65FA663A665A667A669A66BA66DA681A683A685A687A689A68BA68DA68FA691A693A695A697A723A725A727A729A72BA72DA72F-A731A733A735A737A739A73BA73DA73FA741A743A745A747A749A74BA74DA74FA751A753A755A757A759A75BA75DA75FA761A763A765A767A769A76BA76DA76FA771-A778A77AA77CA77FA781A783A785A787A78CFB00-FB06FB13-FB17FF41-FF5A",
	    Lu: "0041-005A00C0-00D600D8-00DE01000102010401060108010A010C010E01100112011401160118011A011C011E01200122012401260128012A012C012E01300132013401360139013B013D013F0141014301450147014A014C014E01500152015401560158015A015C015E01600162016401660168016A016C016E017001720174017601780179017B017D018101820184018601870189-018B018E-0191019301940196-0198019C019D019F01A001A201A401A601A701A901AC01AE01AF01B1-01B301B501B701B801BC01C401C701CA01CD01CF01D101D301D501D701D901DB01DE01E001E201E401E601E801EA01EC01EE01F101F401F6-01F801FA01FC01FE02000202020402060208020A020C020E02100212021402160218021A021C021E02200222022402260228022A022C022E02300232023A023B023D023E02410243-02460248024A024C024E03700372037603860388-038A038C038E038F0391-03A103A3-03AB03CF03D2-03D403D803DA03DC03DE03E003E203E403E603E803EA03EC03EE03F403F703F903FA03FD-042F04600462046404660468046A046C046E04700472047404760478047A047C047E0480048A048C048E04900492049404960498049A049C049E04A004A204A404A604A804AA04AC04AE04B004B204B404B604B804BA04BC04BE04C004C104C304C504C704C904CB04CD04D004D204D404D604D804DA04DC04DE04E004E204E404E604E804EA04EC04EE04F004F204F404F604F804FA04FC04FE05000502050405060508050A050C050E05100512051405160518051A051C051E0520052205240531-055610A0-10C51E001E021E041E061E081E0A1E0C1E0E1E101E121E141E161E181E1A1E1C1E1E1E201E221E241E261E281E2A1E2C1E2E1E301E321E341E361E381E3A1E3C1E3E1E401E421E441E461E481E4A1E4C1E4E1E501E521E541E561E581E5A1E5C1E5E1E601E621E641E661E681E6A1E6C1E6E1E701E721E741E761E781E7A1E7C1E7E1E801E821E841E861E881E8A1E8C1E8E1E901E921E941E9E1EA01EA21EA41EA61EA81EAA1EAC1EAE1EB01EB21EB41EB61EB81EBA1EBC1EBE1EC01EC21EC41EC61EC81ECA1ECC1ECE1ED01ED21ED41ED61ED81EDA1EDC1EDE1EE01EE21EE41EE61EE81EEA1EEC1EEE1EF01EF21EF41EF61EF81EFA1EFC1EFE1F08-1F0F1F18-1F1D1F28-1F2F1F38-1F3F1F48-1F4D1F591F5B1F5D1F5F1F68-1F6F1FB8-1FBB1FC8-1FCB1FD8-1FDB1FE8-1FEC1FF8-1FFB21022107210B-210D2110-211221152119-211D212421262128212A-212D2130-2133213E213F214521832C00-2C2E2C602C62-2C642C672C692C6B2C6D-2C702C722C752C7E-2C802C822C842C862C882C8A2C8C2C8E2C902C922C942C962C982C9A2C9C2C9E2CA02CA22CA42CA62CA82CAA2CAC2CAE2CB02CB22CB42CB62CB82CBA2CBC2CBE2CC02CC22CC42CC62CC82CCA2CCC2CCE2CD02CD22CD42CD62CD82CDA2CDC2CDE2CE02CE22CEB2CEDA640A642A644A646A648A64AA64CA64EA650A652A654A656A658A65AA65CA65EA662A664A666A668A66AA66CA680A682A684A686A688A68AA68CA68EA690A692A694A696A722A724A726A728A72AA72CA72EA732A734A736A738A73AA73CA73EA740A742A744A746A748A74AA74CA74EA750A752A754A756A758A75AA75CA75EA760A762A764A766A768A76AA76CA76EA779A77BA77DA77EA780A782A784A786A78BFF21-FF3A",
	    Lt: "01C501C801CB01F21F88-1F8F1F98-1F9F1FA8-1FAF1FBC1FCC1FFC",
	    Lm: "02B0-02C102C6-02D102E0-02E402EC02EE0374037A0559064006E506E607F407F507FA081A0824082809710E460EC610FC17D718431AA71C78-1C7D1D2C-1D611D781D9B-1DBF2071207F2090-20942C7D2D6F2E2F30053031-3035303B309D309E30FC-30FEA015A4F8-A4FDA60CA67FA717-A71FA770A788A9CFAA70AADDFF70FF9EFF9F",
	    Lo: "01BB01C0-01C3029405D0-05EA05F0-05F20621-063F0641-064A066E066F0671-06D306D506EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA0800-08150904-0939093D09500958-096109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E450E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10D0-10FA1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317DC1820-18421844-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C771CE9-1CEC1CEE-1CF12135-21382D30-2D652D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE3006303C3041-3096309F30A1-30FA30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A014A016-A48CA4D0-A4F7A500-A60BA610-A61FA62AA62BA66EA6A0-A6E5A7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2AA00-AA28AA40-AA42AA44-AA4BAA60-AA6FAA71-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADBAADCABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF66-FF6FFF71-FF9DFFA0-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
	    M:  "0300-036F0483-04890591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DE-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0903093C093E-094E0951-0955096209630981-098309BC09BE-09C409C709C809CB-09CD09D709E209E30A01-0A030A3C0A3E-0A420A470A480A4B-0A4D0A510A700A710A750A81-0A830ABC0ABE-0AC50AC7-0AC90ACB-0ACD0AE20AE30B01-0B030B3C0B3E-0B440B470B480B4B-0B4D0B560B570B620B630B820BBE-0BC20BC6-0BC80BCA-0BCD0BD70C01-0C030C3E-0C440C46-0C480C4A-0C4D0C550C560C620C630C820C830CBC0CBE-0CC40CC6-0CC80CCA-0CCD0CD50CD60CE20CE30D020D030D3E-0D440D46-0D480D4A-0D4D0D570D620D630D820D830DCA0DCF-0DD40DD60DD8-0DDF0DF20DF30E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F3E0F3F0F71-0F840F860F870F90-0F970F99-0FBC0FC6102B-103E1056-1059105E-10601062-10641067-106D1071-10741082-108D108F109A-109D135F1712-17141732-1734175217531772177317B6-17D317DD180B-180D18A91920-192B1930-193B19B0-19C019C819C91A17-1A1B1A55-1A5E1A60-1A7C1A7F1B00-1B041B34-1B441B6B-1B731B80-1B821BA1-1BAA1C24-1C371CD0-1CD21CD4-1CE81CED1CF21DC0-1DE61DFD-1DFF20D0-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66F-A672A67CA67DA6F0A6F1A802A806A80BA823-A827A880A881A8B4-A8C4A8E0-A8F1A926-A92DA947-A953A980-A983A9B3-A9C0AA29-AA36AA43AA4CAA4DAA7BAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE3-ABEAABECABEDFB1EFE00-FE0FFE20-FE26",
	    Mn: "0300-036F0483-04870591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DF-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0902093C0941-0948094D0951-095509620963098109BC09C1-09C409CD09E209E30A010A020A3C0A410A420A470A480A4B-0A4D0A510A700A710A750A810A820ABC0AC1-0AC50AC70AC80ACD0AE20AE30B010B3C0B3F0B41-0B440B4D0B560B620B630B820BC00BCD0C3E-0C400C46-0C480C4A-0C4D0C550C560C620C630CBC0CBF0CC60CCC0CCD0CE20CE30D41-0D440D4D0D620D630DCA0DD2-0DD40DD60E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F71-0F7E0F80-0F840F860F870F90-0F970F99-0FBC0FC6102D-10301032-10371039103A103D103E10581059105E-10601071-1074108210851086108D109D135F1712-17141732-1734175217531772177317B7-17BD17C617C9-17D317DD180B-180D18A91920-19221927192819321939-193B1A171A181A561A58-1A5E1A601A621A65-1A6C1A73-1A7C1A7F1B00-1B031B341B36-1B3A1B3C1B421B6B-1B731B801B811BA2-1BA51BA81BA91C2C-1C331C361C371CD0-1CD21CD4-1CE01CE2-1CE81CED1DC0-1DE61DFD-1DFF20D0-20DC20E120E5-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66FA67CA67DA6F0A6F1A802A806A80BA825A826A8C4A8E0-A8F1A926-A92DA947-A951A980-A982A9B3A9B6-A9B9A9BCAA29-AA2EAA31AA32AA35AA36AA43AA4CAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE5ABE8ABEDFB1EFE00-FE0FFE20-FE26",
	    Mc: "0903093E-09400949-094C094E0982098309BE-09C009C709C809CB09CC09D70A030A3E-0A400A830ABE-0AC00AC90ACB0ACC0B020B030B3E0B400B470B480B4B0B4C0B570BBE0BBF0BC10BC20BC6-0BC80BCA-0BCC0BD70C01-0C030C41-0C440C820C830CBE0CC0-0CC40CC70CC80CCA0CCB0CD50CD60D020D030D3E-0D400D46-0D480D4A-0D4C0D570D820D830DCF-0DD10DD8-0DDF0DF20DF30F3E0F3F0F7F102B102C10311038103B103C105610571062-10641067-106D108310841087-108C108F109A-109C17B617BE-17C517C717C81923-19261929-192B193019311933-193819B0-19C019C819C91A19-1A1B1A551A571A611A631A641A6D-1A721B041B351B3B1B3D-1B411B431B441B821BA11BA61BA71BAA1C24-1C2B1C341C351CE11CF2A823A824A827A880A881A8B4-A8C3A952A953A983A9B4A9B5A9BAA9BBA9BD-A9C0AA2FAA30AA33AA34AA4DAA7BABE3ABE4ABE6ABE7ABE9ABEAABEC",
	    Me: "0488048906DE20DD-20E020E2-20E4A670-A672",
	    N:  "0030-003900B200B300B900BC-00BE0660-066906F0-06F907C0-07C90966-096F09E6-09EF09F4-09F90A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BF20C66-0C6F0C78-0C7E0CE6-0CEF0D66-0D750E50-0E590ED0-0ED90F20-0F331040-10491090-10991369-137C16EE-16F017E0-17E917F0-17F91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C5920702074-20792080-20892150-21822185-21892460-249B24EA-24FF2776-27932CFD30073021-30293038-303A3192-31953220-32293251-325F3280-328932B1-32BFA620-A629A6E6-A6EFA830-A835A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
	    Nd: "0030-00390660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
	    Nl: "16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF",
	    No: "00B200B300B900BC-00BE09F4-09F90BF0-0BF20C78-0C7E0D70-0D750F2A-0F331369-137C17F0-17F920702074-20792080-20892150-215F21892460-249B24EA-24FF2776-27932CFD3192-31953220-32293251-325F3280-328932B1-32BFA830-A835",
	    P:  "0021-00230025-002A002C-002F003A003B003F0040005B-005D005F007B007D00A100AB00B700BB00BF037E0387055A-055F0589058A05BE05C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F3A-0F3D0F850FD0-0FD4104A-104F10FB1361-13681400166D166E169B169C16EB-16ED1735173617D4-17D617D8-17DA1800-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD32010-20272030-20432045-20512053-205E207D207E208D208E2329232A2768-277527C527C627E6-27EF2983-299829D8-29DB29FC29FD2CF9-2CFC2CFE2CFF2E00-2E2E2E302E313001-30033008-30113014-301F3030303D30A030FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFD3EFD3FFE10-FE19FE30-FE52FE54-FE61FE63FE68FE6AFE6BFF01-FF03FF05-FF0AFF0C-FF0FFF1AFF1BFF1FFF20FF3B-FF3DFF3FFF5BFF5DFF5F-FF65",
	    Pd: "002D058A05BE140018062010-20152E172E1A301C303030A0FE31FE32FE58FE63FF0D",
	    Ps: "0028005B007B0F3A0F3C169B201A201E2045207D208D23292768276A276C276E27702772277427C527E627E827EA27EC27EE2983298529872989298B298D298F299129932995299729D829DA29FC2E222E242E262E283008300A300C300E3010301430163018301A301DFD3EFE17FE35FE37FE39FE3BFE3DFE3FFE41FE43FE47FE59FE5BFE5DFF08FF3BFF5BFF5FFF62",
	    Pe: "0029005D007D0F3B0F3D169C2046207E208E232A2769276B276D276F27712773277527C627E727E927EB27ED27EF298429862988298A298C298E2990299229942996299829D929DB29FD2E232E252E272E293009300B300D300F3011301530173019301B301E301FFD3FFE18FE36FE38FE3AFE3CFE3EFE40FE42FE44FE48FE5AFE5CFE5EFF09FF3DFF5DFF60FF63",
	    Pi: "00AB2018201B201C201F20392E022E042E092E0C2E1C2E20",
	    Pf: "00BB2019201D203A2E032E052E0A2E0D2E1D2E21",
	    Pc: "005F203F20402054FE33FE34FE4D-FE4FFF3F",
	    Po: "0021-00230025-0027002A002C002E002F003A003B003F0040005C00A100B700BF037E0387055A-055F058905C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F850FD0-0FD4104A-104F10FB1361-1368166D166E16EB-16ED1735173617D4-17D617D8-17DA1800-18051807-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD3201620172020-20272030-2038203B-203E2041-20432047-205120532055-205E2CF9-2CFC2CFE2CFF2E002E012E06-2E082E0B2E0E-2E162E182E192E1B2E1E2E1F2E2A-2E2E2E302E313001-3003303D30FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFE10-FE16FE19FE30FE45FE46FE49-FE4CFE50-FE52FE54-FE57FE5F-FE61FE68FE6AFE6BFF01-FF03FF05-FF07FF0AFF0CFF0EFF0FFF1AFF1BFF1FFF20FF3CFF61FF64FF65",
	    S:  "0024002B003C-003E005E0060007C007E00A2-00A900AC00AE-00B100B400B600B800D700F702C2-02C502D2-02DF02E5-02EB02ED02EF-02FF03750384038503F604820606-0608060B060E060F06E906FD06FE07F609F209F309FA09FB0AF10B700BF3-0BFA0C7F0CF10CF20D790E3F0F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-139917DB194019E0-19FF1B61-1B6A1B74-1B7C1FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE20442052207A-207C208A-208C20A0-20B8210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B2140-2144214A-214D214F2190-2328232B-23E82400-24262440-244A249C-24E92500-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE27C0-27C427C7-27CA27CC27D0-27E527F0-29822999-29D729DC-29FB29FE-2B4C2B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F309B309C319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A700-A716A720A721A789A78AA828-A82BA836-A839AA77-AA79FB29FDFCFDFDFE62FE64-FE66FE69FF04FF0BFF1C-FF1EFF3EFF40FF5CFF5EFFE0-FFE6FFE8-FFEEFFFCFFFD",
	    Sm: "002B003C-003E007C007E00AC00B100D700F703F60606-060820442052207A-207C208A-208C2140-2144214B2190-2194219A219B21A021A321A621AE21CE21CF21D221D421F4-22FF2308-230B23202321237C239B-23B323DC-23E125B725C125F8-25FF266F27C0-27C427C7-27CA27CC27D0-27E527F0-27FF2900-29822999-29D729DC-29FB29FE-2AFF2B30-2B442B47-2B4CFB29FE62FE64-FE66FF0BFF1C-FF1EFF5CFF5EFFE2FFE9-FFEC",
	    Sc: "002400A2-00A5060B09F209F309FB0AF10BF90E3F17DB20A0-20B8A838FDFCFE69FF04FFE0FFE1FFE5FFE6",
	    Sk: "005E006000A800AF00B400B802C2-02C502D2-02DF02E5-02EB02ED02EF-02FF0375038403851FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE309B309CA700-A716A720A721A789A78AFF3EFF40FFE3",
	    So: "00A600A700A900AE00B000B60482060E060F06E906FD06FE07F609FA0B700BF3-0BF80BFA0C7F0CF10CF20D790F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-1399194019E0-19FF1B61-1B6A1B74-1B7C210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B214A214C214D214F2195-2199219C-219F21A121A221A421A521A7-21AD21AF-21CD21D021D121D321D5-21F32300-2307230C-231F2322-2328232B-237B237D-239A23B4-23DB23E2-23E82400-24262440-244A249C-24E92500-25B625B8-25C025C2-25F72600-266E2670-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE2800-28FF2B00-2B2F2B452B462B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A828-A82BA836A837A839AA77-AA79FDFDFFE4FFE8FFEDFFEEFFFCFFFD",
	    Z:  "002000A01680180E2000-200A20282029202F205F3000",
	    Zs: "002000A01680180E2000-200A202F205F3000",
	    Zl: "2028",
	    Zp: "2029",
	    C:  "0000-001F007F-009F00AD03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-0605061C061D0620065F06DD070E070F074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17B417B517DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF200B-200F202A-202E2060-206F20722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-F8FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFD-FF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFFBFFFEFFFF",
	    Cc: "0000-001F007F-009F",
	    Cf: "00AD0600-060306DD070F17B417B5200B-200F202A-202E2060-2064206A-206FFEFFFFF9-FFFB",
	    Co: "E000-F8FF",
	    Cs: "D800-DFFF",
	    Cn: "03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-05FF06040605061C061D0620065F070E074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF2065-206920722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-D7FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFDFEFEFF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFF8FFFEFFFF"
	});

	function addUnicodePackage (pack) {
	    var codePoint = /\w{4}/g;
	    for (var name in pack)
	        exports.packages[name] = pack[name].replace(codePoint, "\\u$&");
	}

	});

	ace.define("ace/token_iterator",["require","exports","module"], function(acequire, exports, module) {
	"use strict";
	var TokenIterator = function(session, initialRow, initialColumn) {
	    this.$session = session;
	    this.$row = initialRow;
	    this.$rowTokens = session.getTokens(initialRow);

	    var token = session.getTokenAt(initialRow, initialColumn);
	    this.$tokenIndex = token ? token.index : -1;
	};

	(function() { 
	    this.stepBackward = function() {
	        this.$tokenIndex -= 1;
	        
	        while (this.$tokenIndex < 0) {
	            this.$row -= 1;
	            if (this.$row < 0) {
	                this.$row = 0;
	                return null;
	            }
	                
	            this.$rowTokens = this.$session.getTokens(this.$row);
	            this.$tokenIndex = this.$rowTokens.length - 1;
	        }
	            
	        return this.$rowTokens[this.$tokenIndex];
	    };   
	    this.stepForward = function() {
	        this.$tokenIndex += 1;
	        var rowCount;
	        while (this.$tokenIndex >= this.$rowTokens.length) {
	            this.$row += 1;
	            if (!rowCount)
	                rowCount = this.$session.getLength();
	            if (this.$row >= rowCount) {
	                this.$row = rowCount - 1;
	                return null;
	            }

	            this.$rowTokens = this.$session.getTokens(this.$row);
	            this.$tokenIndex = 0;
	        }
	            
	        return this.$rowTokens[this.$tokenIndex];
	    };      
	    this.getCurrentToken = function () {
	        return this.$rowTokens[this.$tokenIndex];
	    };      
	    this.getCurrentTokenRow = function () {
	        return this.$row;
	    };     
	    this.getCurrentTokenColumn = function() {
	        var rowTokens = this.$rowTokens;
	        var tokenIndex = this.$tokenIndex;
	        var column = rowTokens[tokenIndex].start;
	        if (column !== undefined)
	            return column;
	            
	        column = 0;
	        while (tokenIndex > 0) {
	            tokenIndex -= 1;
	            column += rowTokens[tokenIndex].value.length;
	        }
	        
	        return column;  
	    };
	    this.getCurrentTokenPosition = function() {
	        return {row: this.$row, column: this.getCurrentTokenColumn()};
	    };
	            
	}).call(TokenIterator.prototype);

	exports.TokenIterator = TokenIterator;
	});

	ace.define("ace/mode/text",["require","exports","module","ace/tokenizer","ace/mode/text_highlight_rules","ace/mode/behaviour","ace/unicode","ace/lib/lang","ace/token_iterator","ace/range"], function(acequire, exports, module) {
	"use strict";

	var Tokenizer = acequire("../tokenizer").Tokenizer;
	var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;
	var Behaviour = acequire("./behaviour").Behaviour;
	var unicode = acequire("../unicode");
	var lang = acequire("../lib/lang");
	var TokenIterator = acequire("../token_iterator").TokenIterator;
	var Range = acequire("../range").Range;

	var Mode = function() {
	    this.HighlightRules = TextHighlightRules;
	    this.$behaviour = new Behaviour();
	};

	(function() {

	    this.tokenRe = new RegExp("^["
	        + unicode.packages.L
	        + unicode.packages.Mn + unicode.packages.Mc
	        + unicode.packages.Nd
	        + unicode.packages.Pc + "\\$_]+", "g"
	    );

	    this.nonTokenRe = new RegExp("^(?:[^"
	        + unicode.packages.L
	        + unicode.packages.Mn + unicode.packages.Mc
	        + unicode.packages.Nd
	        + unicode.packages.Pc + "\\$_]|\\s])+", "g"
	    );

	    this.getTokenizer = function() {
	        if (!this.$tokenizer) {
	            this.$highlightRules = this.$highlightRules || new this.HighlightRules();
	            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
	        }
	        return this.$tokenizer;
	    };

	    this.lineCommentStart = "";
	    this.blockComment = "";

	    this.toggleCommentLines = function(state, session, startRow, endRow) {
	        var doc = session.doc;

	        var ignoreBlankLines = true;
	        var shouldRemove = true;
	        var minIndent = Infinity;
	        var tabSize = session.getTabSize();
	        var insertAtTabStop = false;

	        if (!this.lineCommentStart) {
	            if (!this.blockComment)
	                return false;
	            var lineCommentStart = this.blockComment.start;
	            var lineCommentEnd = this.blockComment.end;
	            var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
	            var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");

	            var comment = function(line, i) {
	                if (testRemove(line, i))
	                    return;
	                if (!ignoreBlankLines || /\S/.test(line)) {
	                    doc.insertInLine({row: i, column: line.length}, lineCommentEnd);
	                    doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
	                }
	            };

	            var uncomment = function(line, i) {
	                var m;
	                if (m = line.match(regexpEnd))
	                    doc.removeInLine(i, line.length - m[0].length, line.length);
	                if (m = line.match(regexpStart))
	                    doc.removeInLine(i, m[1].length, m[0].length);
	            };

	            var testRemove = function(line, row) {
	                if (regexpStart.test(line))
	                    return true;
	                var tokens = session.getTokens(row);
	                for (var i = 0; i < tokens.length; i++) {
	                    if (tokens[i].type === "comment")
	                        return true;
	                }
	            };
	        } else {
	            if (Array.isArray(this.lineCommentStart)) {
	                var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
	                var lineCommentStart = this.lineCommentStart[0];
	            } else {
	                var regexpStart = lang.escapeRegExp(this.lineCommentStart);
	                var lineCommentStart = this.lineCommentStart;
	            }
	            regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");
	            
	            insertAtTabStop = session.getUseSoftTabs();

	            var uncomment = function(line, i) {
	                var m = line.match(regexpStart);
	                if (!m) return;
	                var start = m[1].length, end = m[0].length;
	                if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ")
	                    end--;
	                doc.removeInLine(i, start, end);
	            };
	            var commentWithSpace = lineCommentStart + " ";
	            var comment = function(line, i) {
	                if (!ignoreBlankLines || /\S/.test(line)) {
	                    if (shouldInsertSpace(line, minIndent, minIndent))
	                        doc.insertInLine({row: i, column: minIndent}, commentWithSpace);
	                    else
	                        doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
	                }
	            };
	            var testRemove = function(line, i) {
	                return regexpStart.test(line);
	            };
	            
	            var shouldInsertSpace = function(line, before, after) {
	                var spaces = 0;
	                while (before-- && line.charAt(before) == " ")
	                    spaces++;
	                if (spaces % tabSize != 0)
	                    return false;
	                var spaces = 0;
	                while (line.charAt(after++) == " ")
	                    spaces++;
	                if (tabSize > 2)
	                    return spaces % tabSize != tabSize - 1;
	                else
	                    return spaces % tabSize == 0;
	                return true;
	            };
	        }

	        function iter(fun) {
	            for (var i = startRow; i <= endRow; i++)
	                fun(doc.getLine(i), i);
	        }


	        var minEmptyLength = Infinity;
	        iter(function(line, i) {
	            var indent = line.search(/\S/);
	            if (indent !== -1) {
	                if (indent < minIndent)
	                    minIndent = indent;
	                if (shouldRemove && !testRemove(line, i))
	                    shouldRemove = false;
	            } else if (minEmptyLength > line.length) {
	                minEmptyLength = line.length;
	            }
	        });

	        if (minIndent == Infinity) {
	            minIndent = minEmptyLength;
	            ignoreBlankLines = false;
	            shouldRemove = false;
	        }

	        if (insertAtTabStop && minIndent % tabSize != 0)
	            minIndent = Math.floor(minIndent / tabSize) * tabSize;

	        iter(shouldRemove ? uncomment : comment);
	    };

	    this.toggleBlockComment = function(state, session, range, cursor) {
	        var comment = this.blockComment;
	        if (!comment)
	            return;
	        if (!comment.start && comment[0])
	            comment = comment[0];

	        var iterator = new TokenIterator(session, cursor.row, cursor.column);
	        var token = iterator.getCurrentToken();

	        var sel = session.selection;
	        var initialRange = session.selection.toOrientedRange();
	        var startRow, colDiff;

	        if (token && /comment/.test(token.type)) {
	            var startRange, endRange;
	            while (token && /comment/.test(token.type)) {
	                var i = token.value.indexOf(comment.start);
	                if (i != -1) {
	                    var row = iterator.getCurrentTokenRow();
	                    var column = iterator.getCurrentTokenColumn() + i;
	                    startRange = new Range(row, column, row, column + comment.start.length);
	                    break;
	                }
	                token = iterator.stepBackward();
	            }

	            var iterator = new TokenIterator(session, cursor.row, cursor.column);
	            var token = iterator.getCurrentToken();
	            while (token && /comment/.test(token.type)) {
	                var i = token.value.indexOf(comment.end);
	                if (i != -1) {
	                    var row = iterator.getCurrentTokenRow();
	                    var column = iterator.getCurrentTokenColumn() + i;
	                    endRange = new Range(row, column, row, column + comment.end.length);
	                    break;
	                }
	                token = iterator.stepForward();
	            }
	            if (endRange)
	                session.remove(endRange);
	            if (startRange) {
	                session.remove(startRange);
	                startRow = startRange.start.row;
	                colDiff = -comment.start.length;
	            }
	        } else {
	            colDiff = comment.start.length;
	            startRow = range.start.row;
	            session.insert(range.end, comment.end);
	            session.insert(range.start, comment.start);
	        }
	        if (initialRange.start.row == startRow)
	            initialRange.start.column += colDiff;
	        if (initialRange.end.row == startRow)
	            initialRange.end.column += colDiff;
	        session.selection.fromOrientedRange(initialRange);
	    };

	    this.getNextLineIndent = function(state, line, tab) {
	        return this.$getIndent(line);
	    };

	    this.checkOutdent = function(state, line, input) {
	        return false;
	    };

	    this.autoOutdent = function(state, doc, row) {
	    };

	    this.$getIndent = function(line) {
	        return line.match(/^\s*/)[0];
	    };

	    this.createWorker = function(session) {
	        return null;
	    };

	    this.createModeDelegates = function (mapping) {
	        this.$embeds = [];
	        this.$modes = {};
	        for (var i in mapping) {
	            if (mapping[i]) {
	                this.$embeds.push(i);
	                this.$modes[i] = new mapping[i]();
	            }
	        }

	        var delegations = ["toggleBlockComment", "toggleCommentLines", "getNextLineIndent", 
	            "checkOutdent", "autoOutdent", "transformAction", "getCompletions"];

	        for (var i = 0; i < delegations.length; i++) {
	            (function(scope) {
	              var functionName = delegations[i];
	              var defaultHandler = scope[functionName];
	              scope[delegations[i]] = function() {
	                  return this.$delegator(functionName, arguments, defaultHandler);
	              };
	            }(this));
	        }
	    };

	    this.$delegator = function(method, args, defaultHandler) {
	        var state = args[0];
	        if (typeof state != "string")
	            state = state[0];
	        for (var i = 0; i < this.$embeds.length; i++) {
	            if (!this.$modes[this.$embeds[i]]) continue;

	            var split = state.split(this.$embeds[i]);
	            if (!split[0] && split[1]) {
	                args[0] = split[1];
	                var mode = this.$modes[this.$embeds[i]];
	                return mode[method].apply(mode, args);
	            }
	        }
	        var ret = defaultHandler.apply(this, args);
	        return defaultHandler ? ret : undefined;
	    };

	    this.transformAction = function(state, action, editor, session, param) {
	        if (this.$behaviour) {
	            var behaviours = this.$behaviour.getBehaviours();
	            for (var key in behaviours) {
	                if (behaviours[key][action]) {
	                    var ret = behaviours[key][action].apply(this, arguments);
	                    if (ret) {
	                        return ret;
	                    }
	                }
	            }
	        }
	    };
	    
	    this.getKeywords = function(append) {
	        if (!this.completionKeywords) {
	            var rules = this.$tokenizer.rules;
	            var completionKeywords = [];
	            for (var rule in rules) {
	                var ruleItr = rules[rule];
	                for (var r = 0, l = ruleItr.length; r < l; r++) {
	                    if (typeof ruleItr[r].token === "string") {
	                        if (/keyword|support|storage/.test(ruleItr[r].token))
	                            completionKeywords.push(ruleItr[r].regex);
	                    }
	                    else if (typeof ruleItr[r].token === "object") {
	                        for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {    
	                            if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
	                                var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
	                                completionKeywords.push(rule.substr(1, rule.length - 2));
	                            }
	                        }
	                    }
	                }
	            }
	            this.completionKeywords = completionKeywords;
	        }
	        if (!append)
	            return this.$keywordList;
	        return completionKeywords.concat(this.$keywordList || []);
	    };
	    
	    this.$createKeywordList = function() {
	        if (!this.$highlightRules)
	            this.getTokenizer();
	        return this.$keywordList = this.$highlightRules.$keywordList || [];
	    };

	    this.getCompletions = function(state, session, pos, prefix) {
	        var keywords = this.$keywordList || this.$createKeywordList();
	        return keywords.map(function(word) {
	            return {
	                name: word,
	                value: word,
	                score: 0,
	                meta: "keyword"
	            };
	        });
	    };

	    this.$id = "ace/mode/text";
	}).call(Mode.prototype);

	exports.Mode = Mode;
	});

	ace.define("ace/apply_delta",["require","exports","module"], function(acequire, exports, module) {
	"use strict";

	function throwDeltaError(delta, errorText){
	    console.log("Invalid Delta:", delta);
	    throw "Invalid Delta: " + errorText;
	}

	function positionInDocument(docLines, position) {
	    return position.row    >= 0 && position.row    <  docLines.length &&
	           position.column >= 0 && position.column <= docLines[position.row].length;
	}

	function validateDelta(docLines, delta) {
	    if (delta.action != "insert" && delta.action != "remove")
	        throwDeltaError(delta, "delta.action must be 'insert' or 'remove'");
	    if (!(delta.lines instanceof Array))
	        throwDeltaError(delta, "delta.lines must be an Array");
	    if (!delta.start || !delta.end)
	       throwDeltaError(delta, "delta.start/end must be an present");
	    var start = delta.start;
	    if (!positionInDocument(docLines, delta.start))
	        throwDeltaError(delta, "delta.start must be contained in document");
	    var end = delta.end;
	    if (delta.action == "remove" && !positionInDocument(docLines, end))
	        throwDeltaError(delta, "delta.end must contained in document for 'remove' actions");
	    var numRangeRows = end.row - start.row;
	    var numRangeLastLineChars = (end.column - (numRangeRows == 0 ? start.column : 0));
	    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars)
	        throwDeltaError(delta, "delta.range must match delta lines");
	}

	exports.applyDelta = function(docLines, delta, doNotValidate) {
	    
	    var row = delta.start.row;
	    var startColumn = delta.start.column;
	    var line = docLines[row] || "";
	    switch (delta.action) {
	        case "insert":
	            var lines = delta.lines;
	            if (lines.length === 1) {
	                docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
	            } else {
	                var args = [row, 1].concat(delta.lines);
	                docLines.splice.apply(docLines, args);
	                docLines[row] = line.substring(0, startColumn) + docLines[row];
	                docLines[row + delta.lines.length - 1] += line.substring(startColumn);
	            }
	            break;
	        case "remove":
	            var endColumn = delta.end.column;
	            var endRow = delta.end.row;
	            if (row === endRow) {
	                docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
	            } else {
	                docLines.splice(
	                    row, endRow - row + 1,
	                    line.substring(0, startColumn) + docLines[endRow].substring(endColumn)
	                );
	            }
	            break;
	    }
	}
	});

	ace.define("ace/anchor",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("./lib/oop");
	var EventEmitter = acequire("./lib/event_emitter").EventEmitter;

	var Anchor = exports.Anchor = function(doc, row, column) {
	    this.$onChange = this.onChange.bind(this);
	    this.attach(doc);
	    
	    if (typeof column == "undefined")
	        this.setPosition(row.row, row.column);
	    else
	        this.setPosition(row, column);
	};

	(function() {

	    oop.implement(this, EventEmitter);
	    this.getPosition = function() {
	        return this.$clipPositionToDocument(this.row, this.column);
	    };
	    this.getDocument = function() {
	        return this.document;
	    };
	    this.$insertRight = false;
	    this.onChange = function(delta) {
	        if (delta.start.row == delta.end.row && delta.start.row != this.row)
	            return;

	        if (delta.start.row > this.row)
	            return;
	            
	        var point = $getTransformedPoint(delta, {row: this.row, column: this.column}, this.$insertRight);
	        this.setPosition(point.row, point.column, true);
	    };
	    
	    function $pointsInOrder(point1, point2, equalPointsInOrder) {
	        var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
	        return (point1.row < point2.row) || (point1.row == point2.row && bColIsAfter);
	    }
	            
	    function $getTransformedPoint(delta, point, moveIfEqual) {
	        var deltaIsInsert = delta.action == "insert";
	        var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row    - delta.start.row);
	        var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
	        var deltaStart = delta.start;
	        var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.
	        if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
	            return {
	                row: point.row,
	                column: point.column
	            };
	        }
	        if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
	            return {
	                row: point.row + deltaRowShift,
	                column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
	            };
	        }
	        
	        return {
	            row: deltaStart.row,
	            column: deltaStart.column
	        };
	    }
	    this.setPosition = function(row, column, noClip) {
	        var pos;
	        if (noClip) {
	            pos = {
	                row: row,
	                column: column
	            };
	        } else {
	            pos = this.$clipPositionToDocument(row, column);
	        }

	        if (this.row == pos.row && this.column == pos.column)
	            return;

	        var old = {
	            row: this.row,
	            column: this.column
	        };

	        this.row = pos.row;
	        this.column = pos.column;
	        this._signal("change", {
	            old: old,
	            value: pos
	        });
	    };
	    this.detach = function() {
	        this.document.removeEventListener("change", this.$onChange);
	    };
	    this.attach = function(doc) {
	        this.document = doc || this.document;
	        this.document.on("change", this.$onChange);
	    };
	    this.$clipPositionToDocument = function(row, column) {
	        var pos = {};

	        if (row >= this.document.getLength()) {
	            pos.row = Math.max(0, this.document.getLength() - 1);
	            pos.column = this.document.getLine(pos.row).length;
	        }
	        else if (row < 0) {
	            pos.row = 0;
	            pos.column = 0;
	        }
	        else {
	            pos.row = row;
	            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
	        }

	        if (column < 0)
	            pos.column = 0;

	        return pos;
	    };

	}).call(Anchor.prototype);

	});

	ace.define("ace/document",["require","exports","module","ace/lib/oop","ace/apply_delta","ace/lib/event_emitter","ace/range","ace/anchor"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("./lib/oop");
	var applyDelta = acequire("./apply_delta").applyDelta;
	var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
	var Range = acequire("./range").Range;
	var Anchor = acequire("./anchor").Anchor;

	var Document = function(textOrLines) {
	    this.$lines = [""];
	    if (textOrLines.length === 0) {
	        this.$lines = [""];
	    } else if (Array.isArray(textOrLines)) {
	        this.insertMergedLines({row: 0, column: 0}, textOrLines);
	    } else {
	        this.insert({row: 0, column:0}, textOrLines);
	    }
	};

	(function() {

	    oop.implement(this, EventEmitter);
	    this.setValue = function(text) {
	        var len = this.getLength() - 1;
	        this.remove(new Range(0, 0, len, this.getLine(len).length));
	        this.insert({row: 0, column: 0}, text);
	    };
	    this.getValue = function() {
	        return this.getAllLines().join(this.getNewLineCharacter());
	    };
	    this.createAnchor = function(row, column) {
	        return new Anchor(this, row, column);
	    };
	    if ("aaa".split(/a/).length === 0) {
	        this.$split = function(text) {
	            return text.replace(/\r\n|\r/g, "\n").split("\n");
	        };
	    } else {
	        this.$split = function(text) {
	            return text.split(/\r\n|\r|\n/);
	        };
	    }


	    this.$detectNewLine = function(text) {
	        var match = text.match(/^.*?(\r\n|\r|\n)/m);
	        this.$autoNewLine = match ? match[1] : "\n";
	        this._signal("changeNewLineMode");
	    };
	    this.getNewLineCharacter = function() {
	        switch (this.$newLineMode) {
	          case "windows":
	            return "\r\n";
	          case "unix":
	            return "\n";
	          default:
	            return this.$autoNewLine || "\n";
	        }
	    };

	    this.$autoNewLine = "";
	    this.$newLineMode = "auto";
	    this.setNewLineMode = function(newLineMode) {
	        if (this.$newLineMode === newLineMode)
	            return;

	        this.$newLineMode = newLineMode;
	        this._signal("changeNewLineMode");
	    };
	    this.getNewLineMode = function() {
	        return this.$newLineMode;
	    };
	    this.isNewLine = function(text) {
	        return (text == "\r\n" || text == "\r" || text == "\n");
	    };
	    this.getLine = function(row) {
	        return this.$lines[row] || "";
	    };
	    this.getLines = function(firstRow, lastRow) {
	        return this.$lines.slice(firstRow, lastRow + 1);
	    };
	    this.getAllLines = function() {
	        return this.getLines(0, this.getLength());
	    };
	    this.getLength = function() {
	        return this.$lines.length;
	    };
	    this.getTextRange = function(range) {
	        return this.getLinesForRange(range).join(this.getNewLineCharacter());
	    };
	    this.getLinesForRange = function(range) {
	        var lines;
	        if (range.start.row === range.end.row) {
	            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
	        } else {
	            lines = this.getLines(range.start.row, range.end.row);
	            lines[0] = (lines[0] || "").substring(range.start.column);
	            var l = lines.length - 1;
	            if (range.end.row - range.start.row == l)
	                lines[l] = lines[l].substring(0, range.end.column);
	        }
	        return lines;
	    };
	    this.insertLines = function(row, lines) {
	        console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
	        return this.insertFullLines(row, lines);
	    };
	    this.removeLines = function(firstRow, lastRow) {
	        console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
	        return this.removeFullLines(firstRow, lastRow);
	    };
	    this.insertNewLine = function(position) {
	        console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, [\'\', \'\']) instead.");
	        return this.insertMergedLines(position, ["", ""]);
	    };
	    this.insert = function(position, text) {
	        if (this.getLength() <= 1)
	            this.$detectNewLine(text);
	        
	        return this.insertMergedLines(position, this.$split(text));
	    };
	    this.insertInLine = function(position, text) {
	        var start = this.clippedPos(position.row, position.column);
	        var end = this.pos(position.row, position.column + text.length);
	        
	        this.applyDelta({
	            start: start,
	            end: end,
	            action: "insert",
	            lines: [text]
	        }, true);
	        
	        return this.clonePos(end);
	    };
	    
	    this.clippedPos = function(row, column) {
	        var length = this.getLength();
	        if (row === undefined) {
	            row = length;
	        } else if (row < 0) {
	            row = 0;
	        } else if (row >= length) {
	            row = length - 1;
	            column = undefined;
	        }
	        var line = this.getLine(row);
	        if (column == undefined)
	            column = line.length;
	        column = Math.min(Math.max(column, 0), line.length);
	        return {row: row, column: column};
	    };
	    
	    this.clonePos = function(pos) {
	        return {row: pos.row, column: pos.column};
	    };
	    
	    this.pos = function(row, column) {
	        return {row: row, column: column};
	    };
	    
	    this.$clipPosition = function(position) {
	        var length = this.getLength();
	        if (position.row >= length) {
	            position.row = Math.max(0, length - 1);
	            position.column = this.getLine(length - 1).length;
	        } else {
	            position.row = Math.max(0, position.row);
	            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
	        }
	        return position;
	    };
	    this.insertFullLines = function(row, lines) {
	        row = Math.min(Math.max(row, 0), this.getLength());
	        var column = 0;
	        if (row < this.getLength()) {
	            lines = lines.concat([""]);
	            column = 0;
	        } else {
	            lines = [""].concat(lines);
	            row--;
	            column = this.$lines[row].length;
	        }
	        this.insertMergedLines({row: row, column: column}, lines);
	    };    
	    this.insertMergedLines = function(position, lines) {
	        var start = this.clippedPos(position.row, position.column);
	        var end = {
	            row: start.row + lines.length - 1,
	            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
	        };
	        
	        this.applyDelta({
	            start: start,
	            end: end,
	            action: "insert",
	            lines: lines
	        });
	        
	        return this.clonePos(end);
	    };
	    this.remove = function(range) {
	        var start = this.clippedPos(range.start.row, range.start.column);
	        var end = this.clippedPos(range.end.row, range.end.column);
	        this.applyDelta({
	            start: start,
	            end: end,
	            action: "remove",
	            lines: this.getLinesForRange({start: start, end: end})
	        });
	        return this.clonePos(start);
	    };
	    this.removeInLine = function(row, startColumn, endColumn) {
	        var start = this.clippedPos(row, startColumn);
	        var end = this.clippedPos(row, endColumn);
	        
	        this.applyDelta({
	            start: start,
	            end: end,
	            action: "remove",
	            lines: this.getLinesForRange({start: start, end: end})
	        }, true);
	        
	        return this.clonePos(start);
	    };
	    this.removeFullLines = function(firstRow, lastRow) {
	        firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
	        lastRow  = Math.min(Math.max(0, lastRow ), this.getLength() - 1);
	        var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
	        var deleteLastNewLine  = lastRow  < this.getLength() - 1;
	        var startRow = ( deleteFirstNewLine ? firstRow - 1                  : firstRow                    );
	        var startCol = ( deleteFirstNewLine ? this.getLine(startRow).length : 0                           );
	        var endRow   = ( deleteLastNewLine  ? lastRow + 1                   : lastRow                     );
	        var endCol   = ( deleteLastNewLine  ? 0                             : this.getLine(endRow).length ); 
	        var range = new Range(startRow, startCol, endRow, endCol);
	        var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
	        
	        this.applyDelta({
	            start: range.start,
	            end: range.end,
	            action: "remove",
	            lines: this.getLinesForRange(range)
	        });
	        return deletedLines;
	    };
	    this.removeNewLine = function(row) {
	        if (row < this.getLength() - 1 && row >= 0) {
	            this.applyDelta({
	                start: this.pos(row, this.getLine(row).length),
	                end: this.pos(row + 1, 0),
	                action: "remove",
	                lines: ["", ""]
	            });
	        }
	    };
	    this.replace = function(range, text) {
	        if (!(range instanceof Range))
	            range = Range.fromPoints(range.start, range.end);
	        if (text.length === 0 && range.isEmpty())
	            return range.start;
	        if (text == this.getTextRange(range))
	            return range.end;

	        this.remove(range);
	        var end;
	        if (text) {
	            end = this.insert(range.start, text);
	        }
	        else {
	            end = range.start;
	        }
	        
	        return end;
	    };
	    this.applyDeltas = function(deltas) {
	        for (var i=0; i<deltas.length; i++) {
	            this.applyDelta(deltas[i]);
	        }
	    };
	    this.revertDeltas = function(deltas) {
	        for (var i=deltas.length-1; i>=0; i--) {
	            this.revertDelta(deltas[i]);
	        }
	    };
	    this.applyDelta = function(delta, doNotValidate) {
	        var isInsert = delta.action == "insert";
	        if (isInsert ? delta.lines.length <= 1 && !delta.lines[0]
	            : !Range.comparePoints(delta.start, delta.end)) {
	            return;
	        }
	        
	        if (isInsert && delta.lines.length > 20000)
	            this.$splitAndapplyLargeDelta(delta, 20000);
	        applyDelta(this.$lines, delta, doNotValidate);
	        this._signal("change", delta);
	    };
	    
	    this.$splitAndapplyLargeDelta = function(delta, MAX) {
	        var lines = delta.lines;
	        var l = lines.length;
	        var row = delta.start.row; 
	        var column = delta.start.column;
	        var from = 0, to = 0;
	        do {
	            from = to;
	            to += MAX - 1;
	            var chunk = lines.slice(from, to);
	            if (to > l) {
	                delta.lines = chunk;
	                delta.start.row = row + from;
	                delta.start.column = column;
	                break;
	            }
	            chunk.push("");
	            this.applyDelta({
	                start: this.pos(row + from, column),
	                end: this.pos(row + to, column = 0),
	                action: delta.action,
	                lines: chunk
	            }, true);
	        } while(true);
	    };
	    this.revertDelta = function(delta) {
	        this.applyDelta({
	            start: this.clonePos(delta.start),
	            end: this.clonePos(delta.end),
	            action: (delta.action == "insert" ? "remove" : "insert"),
	            lines: delta.lines.slice()
	        });
	    };
	    this.indexToPosition = function(index, startRow) {
	        var lines = this.$lines || this.getAllLines();
	        var newlineLength = this.getNewLineCharacter().length;
	        for (var i = startRow || 0, l = lines.length; i < l; i++) {
	            index -= lines[i].length + newlineLength;
	            if (index < 0)
	                return {row: i, column: index + lines[i].length + newlineLength};
	        }
	        return {row: l-1, column: lines[l-1].length};
	    };
	    this.positionToIndex = function(pos, startRow) {
	        var lines = this.$lines || this.getAllLines();
	        var newlineLength = this.getNewLineCharacter().length;
	        var index = 0;
	        var row = Math.min(pos.row, lines.length);
	        for (var i = startRow || 0; i < row; ++i)
	            index += lines[i].length + newlineLength;

	        return index + pos.column;
	    };

	}).call(Document.prototype);

	exports.Document = Document;
	});

	ace.define("ace/background_tokenizer",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("./lib/oop");
	var EventEmitter = acequire("./lib/event_emitter").EventEmitter;

	var BackgroundTokenizer = function(tokenizer, editor) {
	    this.running = false;
	    this.lines = [];
	    this.states = [];
	    this.currentLine = 0;
	    this.tokenizer = tokenizer;

	    var self = this;

	    this.$worker = function() {
	        if (!self.running) { return; }

	        var workerStart = new Date();
	        var currentLine = self.currentLine;
	        var endLine = -1;
	        var doc = self.doc;

	        var startLine = currentLine;
	        while (self.lines[currentLine])
	            currentLine++;
	        
	        var len = doc.getLength();
	        var processedLines = 0;
	        self.running = false;
	        while (currentLine < len) {
	            self.$tokenizeRow(currentLine);
	            endLine = currentLine;
	            do {
	                currentLine++;
	            } while (self.lines[currentLine]);
	            processedLines ++;
	            if ((processedLines % 5 === 0) && (new Date() - workerStart) > 20) {                
	                self.running = setTimeout(self.$worker, 20);
	                break;
	            }
	        }
	        self.currentLine = currentLine;
	        
	        if (startLine <= endLine)
	            self.fireUpdateEvent(startLine, endLine);
	    };
	};

	(function(){

	    oop.implement(this, EventEmitter);
	    this.setTokenizer = function(tokenizer) {
	        this.tokenizer = tokenizer;
	        this.lines = [];
	        this.states = [];

	        this.start(0);
	    };
	    this.setDocument = function(doc) {
	        this.doc = doc;
	        this.lines = [];
	        this.states = [];

	        this.stop();
	    };
	    this.fireUpdateEvent = function(firstRow, lastRow) {
	        var data = {
	            first: firstRow,
	            last: lastRow
	        };
	        this._signal("update", {data: data});
	    };
	    this.start = function(startRow) {
	        this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
	        this.lines.splice(this.currentLine, this.lines.length);
	        this.states.splice(this.currentLine, this.states.length);

	        this.stop();
	        this.running = setTimeout(this.$worker, 700);
	    };
	    
	    this.scheduleStart = function() {
	        if (!this.running)
	            this.running = setTimeout(this.$worker, 700);
	    }

	    this.$updateOnChange = function(delta) {
	        var startRow = delta.start.row;
	        var len = delta.end.row - startRow;

	        if (len === 0) {
	            this.lines[startRow] = null;
	        } else if (delta.action == "remove") {
	            this.lines.splice(startRow, len + 1, null);
	            this.states.splice(startRow, len + 1, null);
	        } else {
	            var args = Array(len + 1);
	            args.unshift(startRow, 1);
	            this.lines.splice.apply(this.lines, args);
	            this.states.splice.apply(this.states, args);
	        }

	        this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());

	        this.stop();
	    };
	    this.stop = function() {
	        if (this.running)
	            clearTimeout(this.running);
	        this.running = false;
	    };
	    this.getTokens = function(row) {
	        return this.lines[row] || this.$tokenizeRow(row);
	    };
	    this.getState = function(row) {
	        if (this.currentLine == row)
	            this.$tokenizeRow(row);
	        return this.states[row] || "start";
	    };

	    this.$tokenizeRow = function(row) {
	        var line = this.doc.getLine(row);
	        var state = this.states[row - 1];

	        var data = this.tokenizer.getLineTokens(line, state, row);

	        if (this.states[row] + "" !== data.state + "") {
	            this.states[row] = data.state;
	            this.lines[row + 1] = null;
	            if (this.currentLine > row + 1)
	                this.currentLine = row + 1;
	        } else if (this.currentLine == row) {
	            this.currentLine = row + 1;
	        }

	        return this.lines[row] = data.tokens;
	    };

	}).call(BackgroundTokenizer.prototype);

	exports.BackgroundTokenizer = BackgroundTokenizer;
	});

	ace.define("ace/search_highlight",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/range"], function(acequire, exports, module) {
	"use strict";

	var lang = acequire("./lib/lang");
	var oop = acequire("./lib/oop");
	var Range = acequire("./range").Range;

	var SearchHighlight = function(regExp, clazz, type) {
	    this.setRegexp(regExp);
	    this.clazz = clazz;
	    this.type = type || "text";
	};

	(function() {
	    this.MAX_RANGES = 500;
	    
	    this.setRegexp = function(regExp) {
	        if (this.regExp+"" == regExp+"")
	            return;
	        this.regExp = regExp;
	        this.cache = [];
	    };

	    this.update = function(html, markerLayer, session, config) {
	        if (!this.regExp)
	            return;
	        var start = config.firstRow, end = config.lastRow;

	        for (var i = start; i <= end; i++) {
	            var ranges = this.cache[i];
	            if (ranges == null) {
	                ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
	                if (ranges.length > this.MAX_RANGES)
	                    ranges = ranges.slice(0, this.MAX_RANGES);
	                ranges = ranges.map(function(match) {
	                    return new Range(i, match.offset, i, match.offset + match.length);
	                });
	                this.cache[i] = ranges.length ? ranges : "";
	            }

	            for (var j = ranges.length; j --; ) {
	                markerLayer.drawSingleLineMarker(
	                    html, ranges[j].toScreenRange(session), this.clazz, config);
	            }
	        }
	    };

	}).call(SearchHighlight.prototype);

	exports.SearchHighlight = SearchHighlight;
	});

	ace.define("ace/edit_session/fold_line",["require","exports","module","ace/range"], function(acequire, exports, module) {
	"use strict";

	var Range = acequire("../range").Range;
	function FoldLine(foldData, folds) {
	    this.foldData = foldData;
	    if (Array.isArray(folds)) {
	        this.folds = folds;
	    } else {
	        folds = this.folds = [ folds ];
	    }

	    var last = folds[folds.length - 1];
	    this.range = new Range(folds[0].start.row, folds[0].start.column,
	                           last.end.row, last.end.column);
	    this.start = this.range.start;
	    this.end   = this.range.end;

	    this.folds.forEach(function(fold) {
	        fold.setFoldLine(this);
	    }, this);
	}

	(function() {
	    this.shiftRow = function(shift) {
	        this.start.row += shift;
	        this.end.row += shift;
	        this.folds.forEach(function(fold) {
	            fold.start.row += shift;
	            fold.end.row += shift;
	        });
	    };

	    this.addFold = function(fold) {
	        if (fold.sameRow) {
	            if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
	                throw new Error("Can't add a fold to this FoldLine as it has no connection");
	            }
	            this.folds.push(fold);
	            this.folds.sort(function(a, b) {
	                return -a.range.compareEnd(b.start.row, b.start.column);
	            });
	            if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
	                this.end.row = fold.end.row;
	                this.end.column =  fold.end.column;
	            } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
	                this.start.row = fold.start.row;
	                this.start.column = fold.start.column;
	            }
	        } else if (fold.start.row == this.end.row) {
	            this.folds.push(fold);
	            this.end.row = fold.end.row;
	            this.end.column = fold.end.column;
	        } else if (fold.end.row == this.start.row) {
	            this.folds.unshift(fold);
	            this.start.row = fold.start.row;
	            this.start.column = fold.start.column;
	        } else {
	            throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
	        }
	        fold.foldLine = this;
	    };

	    this.containsRow = function(row) {
	        return row >= this.start.row && row <= this.end.row;
	    };

	    this.walk = function(callback, endRow, endColumn) {
	        var lastEnd = 0,
	            folds = this.folds,
	            fold,
	            cmp, stop, isNewRow = true;

	        if (endRow == null) {
	            endRow = this.end.row;
	            endColumn = this.end.column;
	        }

	        for (var i = 0; i < folds.length; i++) {
	            fold = folds[i];

	            cmp = fold.range.compareStart(endRow, endColumn);
	            if (cmp == -1) {
	                callback(null, endRow, endColumn, lastEnd, isNewRow);
	                return;
	            }

	            stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
	            stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
	            if (stop || cmp === 0) {
	                return;
	            }
	            isNewRow = !fold.sameRow;
	            lastEnd = fold.end.column;
	        }
	        callback(null, endRow, endColumn, lastEnd, isNewRow);
	    };

	    this.getNextFoldTo = function(row, column) {
	        var fold, cmp;
	        for (var i = 0; i < this.folds.length; i++) {
	            fold = this.folds[i];
	            cmp = fold.range.compareEnd(row, column);
	            if (cmp == -1) {
	                return {
	                    fold: fold,
	                    kind: "after"
	                };
	            } else if (cmp === 0) {
	                return {
	                    fold: fold,
	                    kind: "inside"
	                };
	            }
	        }
	        return null;
	    };

	    this.addRemoveChars = function(row, column, len) {
	        var ret = this.getNextFoldTo(row, column),
	            fold, folds;
	        if (ret) {
	            fold = ret.fold;
	            if (ret.kind == "inside"
	                && fold.start.column != column
	                && fold.start.row != row)
	            {
	                window.console && window.console.log(row, column, fold);
	            } else if (fold.start.row == row) {
	                folds = this.folds;
	                var i = folds.indexOf(fold);
	                if (i === 0) {
	                    this.start.column += len;
	                }
	                for (i; i < folds.length; i++) {
	                    fold = folds[i];
	                    fold.start.column += len;
	                    if (!fold.sameRow) {
	                        return;
	                    }
	                    fold.end.column += len;
	                }
	                this.end.column += len;
	            }
	        }
	    };

	    this.split = function(row, column) {
	        var pos = this.getNextFoldTo(row, column);
	        
	        if (!pos || pos.kind == "inside")
	            return null;
	            
	        var fold = pos.fold;
	        var folds = this.folds;
	        var foldData = this.foldData;
	        
	        var i = folds.indexOf(fold);
	        var foldBefore = folds[i - 1];
	        this.end.row = foldBefore.end.row;
	        this.end.column = foldBefore.end.column;
	        folds = folds.splice(i, folds.length - i);

	        var newFoldLine = new FoldLine(foldData, folds);
	        foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
	        return newFoldLine;
	    };

	    this.merge = function(foldLineNext) {
	        var folds = foldLineNext.folds;
	        for (var i = 0; i < folds.length; i++) {
	            this.addFold(folds[i]);
	        }
	        var foldData = this.foldData;
	        foldData.splice(foldData.indexOf(foldLineNext), 1);
	    };

	    this.toString = function() {
	        var ret = [this.range.toString() + ": [" ];

	        this.folds.forEach(function(fold) {
	            ret.push("  " + fold.toString());
	        });
	        ret.push("]");
	        return ret.join("\n");
	    };

	    this.idxToPosition = function(idx) {
	        var lastFoldEndColumn = 0;

	        for (var i = 0; i < this.folds.length; i++) {
	            var fold = this.folds[i];

	            idx -= fold.start.column - lastFoldEndColumn;
	            if (idx < 0) {
	                return {
	                    row: fold.start.row,
	                    column: fold.start.column + idx
	                };
	            }

	            idx -= fold.placeholder.length;
	            if (idx < 0) {
	                return fold.start;
	            }

	            lastFoldEndColumn = fold.end.column;
	        }

	        return {
	            row: this.end.row,
	            column: this.end.column + idx
	        };
	    };
	}).call(FoldLine.prototype);

	exports.FoldLine = FoldLine;
	});

	ace.define("ace/range_list",["require","exports","module","ace/range"], function(acequire, exports, module) {
	"use strict";
	var Range = acequire("./range").Range;
	var comparePoints = Range.comparePoints;

	var RangeList = function() {
	    this.ranges = [];
	};

	(function() {
	    this.comparePoints = comparePoints;

	    this.pointIndex = function(pos, excludeEdges, startIndex) {
	        var list = this.ranges;

	        for (var i = startIndex || 0; i < list.length; i++) {
	            var range = list[i];
	            var cmpEnd = comparePoints(pos, range.end);
	            if (cmpEnd > 0)
	                continue;
	            var cmpStart = comparePoints(pos, range.start);
	            if (cmpEnd === 0)
	                return excludeEdges && cmpStart !== 0 ? -i-2 : i;
	            if (cmpStart > 0 || (cmpStart === 0 && !excludeEdges))
	                return i;

	            return -i-1;
	        }
	        return -i - 1;
	    };

	    this.add = function(range) {
	        var excludeEdges = !range.isEmpty();
	        var startIndex = this.pointIndex(range.start, excludeEdges);
	        if (startIndex < 0)
	            startIndex = -startIndex - 1;

	        var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);

	        if (endIndex < 0)
	            endIndex = -endIndex - 1;
	        else
	            endIndex++;
	        return this.ranges.splice(startIndex, endIndex - startIndex, range);
	    };

	    this.addList = function(list) {
	        var removed = [];
	        for (var i = list.length; i--; ) {
	            removed.push.apply(removed, this.add(list[i]));
	        }
	        return removed;
	    };

	    this.substractPoint = function(pos) {
	        var i = this.pointIndex(pos);

	        if (i >= 0)
	            return this.ranges.splice(i, 1);
	    };
	    this.merge = function() {
	        var removed = [];
	        var list = this.ranges;
	        
	        list = list.sort(function(a, b) {
	            return comparePoints(a.start, b.start);
	        });
	        
	        var next = list[0], range;
	        for (var i = 1; i < list.length; i++) {
	            range = next;
	            next = list[i];
	            var cmp = comparePoints(range.end, next.start);
	            if (cmp < 0)
	                continue;

	            if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
	                continue;

	            if (comparePoints(range.end, next.end) < 0) {
	                range.end.row = next.end.row;
	                range.end.column = next.end.column;
	            }

	            list.splice(i, 1);
	            removed.push(next);
	            next = range;
	            i--;
	        }
	        
	        this.ranges = list;

	        return removed;
	    };

	    this.contains = function(row, column) {
	        return this.pointIndex({row: row, column: column}) >= 0;
	    };

	    this.containsPoint = function(pos) {
	        return this.pointIndex(pos) >= 0;
	    };

	    this.rangeAtPoint = function(pos) {
	        var i = this.pointIndex(pos);
	        if (i >= 0)
	            return this.ranges[i];
	    };


	    this.clipRows = function(startRow, endRow) {
	        var list = this.ranges;
	        if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)
	            return [];

	        var startIndex = this.pointIndex({row: startRow, column: 0});
	        if (startIndex < 0)
	            startIndex = -startIndex - 1;
	        var endIndex = this.pointIndex({row: endRow, column: 0}, startIndex);
	        if (endIndex < 0)
	            endIndex = -endIndex - 1;

	        var clipped = [];
	        for (var i = startIndex; i < endIndex; i++) {
	            clipped.push(list[i]);
	        }
	        return clipped;
	    };

	    this.removeAll = function() {
	        return this.ranges.splice(0, this.ranges.length);
	    };

	    this.attach = function(session) {
	        if (this.session)
	            this.detach();

	        this.session = session;
	        this.onChange = this.$onChange.bind(this);

	        this.session.on('change', this.onChange);
	    };

	    this.detach = function() {
	        if (!this.session)
	            return;
	        this.session.removeListener('change', this.onChange);
	        this.session = null;
	    };

	    this.$onChange = function(delta) {
	        if (delta.action == "insert"){
	            var start = delta.start;
	            var end = delta.end;
	        } else {
	            var end = delta.start;
	            var start = delta.end;
	        }
	        var startRow = start.row;
	        var endRow = end.row;
	        var lineDif = endRow - startRow;

	        var colDiff = -start.column + end.column;
	        var ranges = this.ranges;

	        for (var i = 0, n = ranges.length; i < n; i++) {
	            var r = ranges[i];
	            if (r.end.row < startRow)
	                continue;
	            if (r.start.row > startRow)
	                break;

	            if (r.start.row == startRow && r.start.column >= start.column ) {
	                if (r.start.column == start.column && this.$insertRight) {
	                } else {
	                    r.start.column += colDiff;
	                    r.start.row += lineDif;
	                }
	            }
	            if (r.end.row == startRow && r.end.column >= start.column) {
	                if (r.end.column == start.column && this.$insertRight) {
	                    continue;
	                }
	                if (r.end.column == start.column && colDiff > 0 && i < n - 1) {                
	                    if (r.end.column > r.start.column && r.end.column == ranges[i+1].start.column)
	                        r.end.column -= colDiff;
	                }
	                r.end.column += colDiff;
	                r.end.row += lineDif;
	            }
	        }

	        if (lineDif != 0 && i < n) {
	            for (; i < n; i++) {
	                var r = ranges[i];
	                r.start.row += lineDif;
	                r.end.row += lineDif;
	            }
	        }
	    };

	}).call(RangeList.prototype);

	exports.RangeList = RangeList;
	});

	ace.define("ace/edit_session/fold",["require","exports","module","ace/range","ace/range_list","ace/lib/oop"], function(acequire, exports, module) {
	"use strict";

	var Range = acequire("../range").Range;
	var RangeList = acequire("../range_list").RangeList;
	var oop = acequire("../lib/oop")
	var Fold = exports.Fold = function(range, placeholder) {
	    this.foldLine = null;
	    this.placeholder = placeholder;
	    this.range = range;
	    this.start = range.start;
	    this.end = range.end;

	    this.sameRow = range.start.row == range.end.row;
	    this.subFolds = this.ranges = [];
	};

	oop.inherits(Fold, RangeList);

	(function() {

	    this.toString = function() {
	        return '"' + this.placeholder + '" ' + this.range.toString();
	    };

	    this.setFoldLine = function(foldLine) {
	        this.foldLine = foldLine;
	        this.subFolds.forEach(function(fold) {
	            fold.setFoldLine(foldLine);
	        });
	    };

	    this.clone = function() {
	        var range = this.range.clone();
	        var fold = new Fold(range, this.placeholder);
	        this.subFolds.forEach(function(subFold) {
	            fold.subFolds.push(subFold.clone());
	        });
	        fold.collapseChildren = this.collapseChildren;
	        return fold;
	    };

	    this.addSubFold = function(fold) {
	        if (this.range.isEqual(fold))
	            return;

	        if (!this.range.containsRange(fold))
	            throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);
	        consumeRange(fold, this.start);

	        var row = fold.start.row, column = fold.start.column;
	        for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
	            cmp = this.subFolds[i].range.compare(row, column);
	            if (cmp != 1)
	                break;
	        }
	        var afterStart = this.subFolds[i];

	        if (cmp == 0)
	            return afterStart.addSubFold(fold);
	        var row = fold.range.end.row, column = fold.range.end.column;
	        for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
	            cmp = this.subFolds[j].range.compare(row, column);
	            if (cmp != 1)
	                break;
	        }
	        var afterEnd = this.subFolds[j];

	        if (cmp == 0)
	            throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);

	        var consumedFolds = this.subFolds.splice(i, j - i, fold);
	        fold.setFoldLine(this.foldLine);

	        return fold;
	    };
	    
	    this.restoreRange = function(range) {
	        return restoreRange(range, this.start);
	    };

	}).call(Fold.prototype);

	function consumePoint(point, anchor) {
	    point.row -= anchor.row;
	    if (point.row == 0)
	        point.column -= anchor.column;
	}
	function consumeRange(range, anchor) {
	    consumePoint(range.start, anchor);
	    consumePoint(range.end, anchor);
	}
	function restorePoint(point, anchor) {
	    if (point.row == 0)
	        point.column += anchor.column;
	    point.row += anchor.row;
	}
	function restoreRange(range, anchor) {
	    restorePoint(range.start, anchor);
	    restorePoint(range.end, anchor);
	}

	});

	ace.define("ace/edit_session/folding",["require","exports","module","ace/range","ace/edit_session/fold_line","ace/edit_session/fold","ace/token_iterator"], function(acequire, exports, module) {
	"use strict";

	var Range = acequire("../range").Range;
	var FoldLine = acequire("./fold_line").FoldLine;
	var Fold = acequire("./fold").Fold;
	var TokenIterator = acequire("../token_iterator").TokenIterator;

	function Folding() {
	    this.getFoldAt = function(row, column, side) {
	        var foldLine = this.getFoldLine(row);
	        if (!foldLine)
	            return null;

	        var folds = foldLine.folds;
	        for (var i = 0; i < folds.length; i++) {
	            var fold = folds[i];
	            if (fold.range.contains(row, column)) {
	                if (side == 1 && fold.range.isEnd(row, column)) {
	                    continue;
	                } else if (side == -1 && fold.range.isStart(row, column)) {
	                    continue;
	                }
	                return fold;
	            }
	        }
	    };
	    this.getFoldsInRange = function(range) {
	        var start = range.start;
	        var end = range.end;
	        var foldLines = this.$foldData;
	        var foundFolds = [];

	        start.column += 1;
	        end.column -= 1;

	        for (var i = 0; i < foldLines.length; i++) {
	            var cmp = foldLines[i].range.compareRange(range);
	            if (cmp == 2) {
	                continue;
	            }
	            else if (cmp == -2) {
	                break;
	            }

	            var folds = foldLines[i].folds;
	            for (var j = 0; j < folds.length; j++) {
	                var fold = folds[j];
	                cmp = fold.range.compareRange(range);
	                if (cmp == -2) {
	                    break;
	                } else if (cmp == 2) {
	                    continue;
	                } else
	                if (cmp == 42) {
	                    break;
	                }
	                foundFolds.push(fold);
	            }
	        }
	        start.column -= 1;
	        end.column += 1;

	        return foundFolds;
	    };

	    this.getFoldsInRangeList = function(ranges) {
	        if (Array.isArray(ranges)) {
	            var folds = [];
	            ranges.forEach(function(range) {
	                folds = folds.concat(this.getFoldsInRange(range));
	            }, this);
	        } else {
	            var folds = this.getFoldsInRange(ranges);
	        }
	        return folds;
	    };
	    this.getAllFolds = function() {
	        var folds = [];
	        var foldLines = this.$foldData;
	        
	        for (var i = 0; i < foldLines.length; i++)
	            for (var j = 0; j < foldLines[i].folds.length; j++)
	                folds.push(foldLines[i].folds[j]);

	        return folds;
	    };
	    this.getFoldStringAt = function(row, column, trim, foldLine) {
	        foldLine = foldLine || this.getFoldLine(row);
	        if (!foldLine)
	            return null;

	        var lastFold = {
	            end: { column: 0 }
	        };
	        var str, fold;
	        for (var i = 0; i < foldLine.folds.length; i++) {
	            fold = foldLine.folds[i];
	            var cmp = fold.range.compareEnd(row, column);
	            if (cmp == -1) {
	                str = this
	                    .getLine(fold.start.row)
	                    .substring(lastFold.end.column, fold.start.column);
	                break;
	            }
	            else if (cmp === 0) {
	                return null;
	            }
	            lastFold = fold;
	        }
	        if (!str)
	            str = this.getLine(fold.start.row).substring(lastFold.end.column);

	        if (trim == -1)
	            return str.substring(0, column - lastFold.end.column);
	        else if (trim == 1)
	            return str.substring(column - lastFold.end.column);
	        else
	            return str;
	    };

	    this.getFoldLine = function(docRow, startFoldLine) {
	        var foldData = this.$foldData;
	        var i = 0;
	        if (startFoldLine)
	            i = foldData.indexOf(startFoldLine);
	        if (i == -1)
	            i = 0;
	        for (i; i < foldData.length; i++) {
	            var foldLine = foldData[i];
	            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
	                return foldLine;
	            } else if (foldLine.end.row > docRow) {
	                return null;
	            }
	        }
	        return null;
	    };
	    this.getNextFoldLine = function(docRow, startFoldLine) {
	        var foldData = this.$foldData;
	        var i = 0;
	        if (startFoldLine)
	            i = foldData.indexOf(startFoldLine);
	        if (i == -1)
	            i = 0;
	        for (i; i < foldData.length; i++) {
	            var foldLine = foldData[i];
	            if (foldLine.end.row >= docRow) {
	                return foldLine;
	            }
	        }
	        return null;
	    };

	    this.getFoldedRowCount = function(first, last) {
	        var foldData = this.$foldData, rowCount = last-first+1;
	        for (var i = 0; i < foldData.length; i++) {
	            var foldLine = foldData[i],
	                end = foldLine.end.row,
	                start = foldLine.start.row;
	            if (end >= last) {
	                if (start < last) {
	                    if (start >= first)
	                        rowCount -= last-start;
	                    else
	                        rowCount = 0; // in one fold
	                }
	                break;
	            } else if (end >= first){
	                if (start >= first) // fold inside range
	                    rowCount -=  end-start;
	                else
	                    rowCount -=  end-first+1;
	            }
	        }
	        return rowCount;
	    };

	    this.$addFoldLine = function(foldLine) {
	        this.$foldData.push(foldLine);
	        this.$foldData.sort(function(a, b) {
	            return a.start.row - b.start.row;
	        });
	        return foldLine;
	    };
	    this.addFold = function(placeholder, range) {
	        var foldData = this.$foldData;
	        var added = false;
	        var fold;
	        
	        if (placeholder instanceof Fold)
	            fold = placeholder;
	        else {
	            fold = new Fold(range, placeholder);
	            fold.collapseChildren = range.collapseChildren;
	        }
	        this.$clipRangeToDocument(fold.range);

	        var startRow = fold.start.row;
	        var startColumn = fold.start.column;
	        var endRow = fold.end.row;
	        var endColumn = fold.end.column;
	        if (!(startRow < endRow || 
	            startRow == endRow && startColumn <= endColumn - 2))
	            throw new Error("The range has to be at least 2 characters width");

	        var startFold = this.getFoldAt(startRow, startColumn, 1);
	        var endFold = this.getFoldAt(endRow, endColumn, -1);
	        if (startFold && endFold == startFold)
	            return startFold.addSubFold(fold);

	        if (startFold && !startFold.range.isStart(startRow, startColumn))
	            this.removeFold(startFold);
	        
	        if (endFold && !endFold.range.isEnd(endRow, endColumn))
	            this.removeFold(endFold);
	        var folds = this.getFoldsInRange(fold.range);
	        if (folds.length > 0) {
	            this.removeFolds(folds);
	            folds.forEach(function(subFold) {
	                fold.addSubFold(subFold);
	            });
	        }

	        for (var i = 0; i < foldData.length; i++) {
	            var foldLine = foldData[i];
	            if (endRow == foldLine.start.row) {
	                foldLine.addFold(fold);
	                added = true;
	                break;
	            } else if (startRow == foldLine.end.row) {
	                foldLine.addFold(fold);
	                added = true;
	                if (!fold.sameRow) {
	                    var foldLineNext = foldData[i + 1];
	                    if (foldLineNext && foldLineNext.start.row == endRow) {
	                        foldLine.merge(foldLineNext);
	                        break;
	                    }
	                }
	                break;
	            } else if (endRow <= foldLine.start.row) {
	                break;
	            }
	        }

	        if (!added)
	            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));

	        if (this.$useWrapMode)
	            this.$updateWrapData(foldLine.start.row, foldLine.start.row);
	        else
	            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
	        this.$modified = true;
	        this._signal("changeFold", { data: fold, action: "add" });

	        return fold;
	    };

	    this.addFolds = function(folds) {
	        folds.forEach(function(fold) {
	            this.addFold(fold);
	        }, this);
	    };

	    this.removeFold = function(fold) {
	        var foldLine = fold.foldLine;
	        var startRow = foldLine.start.row;
	        var endRow = foldLine.end.row;

	        var foldLines = this.$foldData;
	        var folds = foldLine.folds;
	        if (folds.length == 1) {
	            foldLines.splice(foldLines.indexOf(foldLine), 1);
	        } else
	        if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
	            folds.pop();
	            foldLine.end.row = folds[folds.length - 1].end.row;
	            foldLine.end.column = folds[folds.length - 1].end.column;
	        } else
	        if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
	            folds.shift();
	            foldLine.start.row = folds[0].start.row;
	            foldLine.start.column = folds[0].start.column;
	        } else
	        if (fold.sameRow) {
	            folds.splice(folds.indexOf(fold), 1);
	        } else
	        {
	            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
	            folds = newFoldLine.folds;
	            folds.shift();
	            newFoldLine.start.row = folds[0].start.row;
	            newFoldLine.start.column = folds[0].start.column;
	        }

	        if (!this.$updating) {
	            if (this.$useWrapMode)
	                this.$updateWrapData(startRow, endRow);
	            else
	                this.$updateRowLengthCache(startRow, endRow);
	        }
	        this.$modified = true;
	        this._signal("changeFold", { data: fold, action: "remove" });
	    };

	    this.removeFolds = function(folds) {
	        var cloneFolds = [];
	        for (var i = 0; i < folds.length; i++) {
	            cloneFolds.push(folds[i]);
	        }

	        cloneFolds.forEach(function(fold) {
	            this.removeFold(fold);
	        }, this);
	        this.$modified = true;
	    };

	    this.expandFold = function(fold) {
	        this.removeFold(fold);
	        fold.subFolds.forEach(function(subFold) {
	            fold.restoreRange(subFold);
	            this.addFold(subFold);
	        }, this);
	        if (fold.collapseChildren > 0) {
	            this.foldAll(fold.start.row+1, fold.end.row, fold.collapseChildren-1);
	        }
	        fold.subFolds = [];
	    };

	    this.expandFolds = function(folds) {
	        folds.forEach(function(fold) {
	            this.expandFold(fold);
	        }, this);
	    };

	    this.unfold = function(location, expandInner) {
	        var range, folds;
	        if (location == null) {
	            range = new Range(0, 0, this.getLength(), 0);
	            expandInner = true;
	        } else if (typeof location == "number")
	            range = new Range(location, 0, location, this.getLine(location).length);
	        else if ("row" in location)
	            range = Range.fromPoints(location, location);
	        else
	            range = location;
	        
	        folds = this.getFoldsInRangeList(range);
	        if (expandInner) {
	            this.removeFolds(folds);
	        } else {
	            var subFolds = folds;
	            while (subFolds.length) {
	                this.expandFolds(subFolds);
	                subFolds = this.getFoldsInRangeList(range);
	            }
	        }
	        if (folds.length)
	            return folds;
	    };
	    this.isRowFolded = function(docRow, startFoldRow) {
	        return !!this.getFoldLine(docRow, startFoldRow);
	    };

	    this.getRowFoldEnd = function(docRow, startFoldRow) {
	        var foldLine = this.getFoldLine(docRow, startFoldRow);
	        return foldLine ? foldLine.end.row : docRow;
	    };

	    this.getRowFoldStart = function(docRow, startFoldRow) {
	        var foldLine = this.getFoldLine(docRow, startFoldRow);
	        return foldLine ? foldLine.start.row : docRow;
	    };

	    this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {
	        if (startRow == null)
	            startRow = foldLine.start.row;
	        if (startColumn == null)
	            startColumn = 0;
	        if (endRow == null)
	            endRow = foldLine.end.row;
	        if (endColumn == null)
	            endColumn = this.getLine(endRow).length;
	        var doc = this.doc;
	        var textLine = "";

	        foldLine.walk(function(placeholder, row, column, lastColumn) {
	            if (row < startRow)
	                return;
	            if (row == startRow) {
	                if (column < startColumn)
	                    return;
	                lastColumn = Math.max(startColumn, lastColumn);
	            }

	            if (placeholder != null) {
	                textLine += placeholder;
	            } else {
	                textLine += doc.getLine(row).substring(lastColumn, column);
	            }
	        }, endRow, endColumn);
	        return textLine;
	    };

	    this.getDisplayLine = function(row, endColumn, startRow, startColumn) {
	        var foldLine = this.getFoldLine(row);

	        if (!foldLine) {
	            var line;
	            line = this.doc.getLine(row);
	            return line.substring(startColumn || 0, endColumn || line.length);
	        } else {
	            return this.getFoldDisplayLine(
	                foldLine, row, endColumn, startRow, startColumn);
	        }
	    };

	    this.$cloneFoldData = function() {
	        var fd = [];
	        fd = this.$foldData.map(function(foldLine) {
	            var folds = foldLine.folds.map(function(fold) {
	                return fold.clone();
	            });
	            return new FoldLine(fd, folds);
	        });

	        return fd;
	    };

	    this.toggleFold = function(tryToUnfold) {
	        var selection = this.selection;
	        var range = selection.getRange();
	        var fold;
	        var bracketPos;

	        if (range.isEmpty()) {
	            var cursor = range.start;
	            fold = this.getFoldAt(cursor.row, cursor.column);

	            if (fold) {
	                this.expandFold(fold);
	                return;
	            } else if (bracketPos = this.findMatchingBracket(cursor)) {
	                if (range.comparePoint(bracketPos) == 1) {
	                    range.end = bracketPos;
	                } else {
	                    range.start = bracketPos;
	                    range.start.column++;
	                    range.end.column--;
	                }
	            } else if (bracketPos = this.findMatchingBracket({row: cursor.row, column: cursor.column + 1})) {
	                if (range.comparePoint(bracketPos) == 1)
	                    range.end = bracketPos;
	                else
	                    range.start = bracketPos;

	                range.start.column++;
	            } else {
	                range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
	            }
	        } else {
	            var folds = this.getFoldsInRange(range);
	            if (tryToUnfold && folds.length) {
	                this.expandFolds(folds);
	                return;
	            } else if (folds.length == 1 ) {
	                fold = folds[0];
	            }
	        }

	        if (!fold)
	            fold = this.getFoldAt(range.start.row, range.start.column);

	        if (fold && fold.range.toString() == range.toString()) {
	            this.expandFold(fold);
	            return;
	        }

	        var placeholder = "...";
	        if (!range.isMultiLine()) {
	            placeholder = this.getTextRange(range);
	            if (placeholder.length < 4)
	                return;
	            placeholder = placeholder.trim().substring(0, 2) + "..";
	        }

	        this.addFold(placeholder, range);
	    };

	    this.getCommentFoldRange = function(row, column, dir) {
	        var iterator = new TokenIterator(this, row, column);
	        var token = iterator.getCurrentToken();
	        if (token && /^comment|string/.test(token.type)) {
	            var range = new Range();
	            var re = new RegExp(token.type.replace(/\..*/, "\\."));
	            if (dir != 1) {
	                do {
	                    token = iterator.stepBackward();
	                } while (token && re.test(token.type));
	                iterator.stepForward();
	            }
	            
	            range.start.row = iterator.getCurrentTokenRow();
	            range.start.column = iterator.getCurrentTokenColumn() + 2;

	            iterator = new TokenIterator(this, row, column);
	            
	            if (dir != -1) {
	                do {
	                    token = iterator.stepForward();
	                } while (token && re.test(token.type));
	                token = iterator.stepBackward();
	            } else
	                token = iterator.getCurrentToken();

	            range.end.row = iterator.getCurrentTokenRow();
	            range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;
	            return range;
	        }
	    };

	    this.foldAll = function(startRow, endRow, depth) {
	        if (depth == undefined)
	            depth = 100000; // JSON.stringify doesn't hanle Infinity
	        var foldWidgets = this.foldWidgets;
	        if (!foldWidgets)
	            return; // mode doesn't support folding
	        endRow = endRow || this.getLength();
	        startRow = startRow || 0;
	        for (var row = startRow; row < endRow; row++) {
	            if (foldWidgets[row] == null)
	                foldWidgets[row] = this.getFoldWidget(row);
	            if (foldWidgets[row] != "start")
	                continue;

	            var range = this.getFoldWidgetRange(row);
	            if (range && range.isMultiLine()
	                && range.end.row <= endRow
	                && range.start.row >= startRow
	            ) {
	                row = range.end.row;
	                try {
	                    var fold = this.addFold("...", range);
	                    if (fold)
	                        fold.collapseChildren = depth;
	                } catch(e) {}
	            }
	        }
	    };
	    this.$foldStyles = {
	        "manual": 1,
	        "markbegin": 1,
	        "markbeginend": 1
	    };
	    this.$foldStyle = "markbegin";
	    this.setFoldStyle = function(style) {
	        if (!this.$foldStyles[style])
	            throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
	        
	        if (this.$foldStyle == style)
	            return;

	        this.$foldStyle = style;
	        
	        if (style == "manual")
	            this.unfold();
	        var mode = this.$foldMode;
	        this.$setFolding(null);
	        this.$setFolding(mode);
	    };

	    this.$setFolding = function(foldMode) {
	        if (this.$foldMode == foldMode)
	            return;
	            
	        this.$foldMode = foldMode;
	        
	        this.off('change', this.$updateFoldWidgets);
	        this.off('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
	        this._signal("changeAnnotation");
	        
	        if (!foldMode || this.$foldStyle == "manual") {
	            this.foldWidgets = null;
	            return;
	        }
	        
	        this.foldWidgets = [];
	        this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
	        this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
	        
	        this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
	        this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
	        this.on('change', this.$updateFoldWidgets);
	        this.on('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
	    };

	    this.getParentFoldRangeData = function (row, ignoreCurrent) {
	        var fw = this.foldWidgets;
	        if (!fw || (ignoreCurrent && fw[row]))
	            return {};

	        var i = row - 1, firstRange;
	        while (i >= 0) {
	            var c = fw[i];
	            if (c == null)
	                c = fw[i] = this.getFoldWidget(i);

	            if (c == "start") {
	                var range = this.getFoldWidgetRange(i);
	                if (!firstRange)
	                    firstRange = range;
	                if (range && range.end.row >= row)
	                    break;
	            }
	            i--;
	        }

	        return {
	            range: i !== -1 && range,
	            firstRange: firstRange
	        };
	    };

	    this.onFoldWidgetClick = function(row, e) {
	        e = e.domEvent;
	        var options = {
	            children: e.shiftKey,
	            all: e.ctrlKey || e.metaKey,
	            siblings: e.altKey
	        };
	        
	        var range = this.$toggleFoldWidget(row, options);
	        if (!range) {
	            var el = (e.target || e.srcElement);
	            if (el && /ace_fold-widget/.test(el.className))
	                el.className += " ace_invalid";
	        }
	    };
	    
	    this.$toggleFoldWidget = function(row, options) {
	        if (!this.getFoldWidget)
	            return;
	        var type = this.getFoldWidget(row);
	        var line = this.getLine(row);

	        var dir = type === "end" ? -1 : 1;
	        var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);

	        if (fold) {
	            if (options.children || options.all)
	                this.removeFold(fold);
	            else
	                this.expandFold(fold);
	            return;
	        }

	        var range = this.getFoldWidgetRange(row, true);
	        if (range && !range.isMultiLine()) {
	            fold = this.getFoldAt(range.start.row, range.start.column, 1);
	            if (fold && range.isEqual(fold.range)) {
	                this.removeFold(fold);
	                return;
	            }
	        }
	        
	        if (options.siblings) {
	            var data = this.getParentFoldRangeData(row);
	            if (data.range) {
	                var startRow = data.range.start.row + 1;
	                var endRow = data.range.end.row;
	            }
	            this.foldAll(startRow, endRow, options.all ? 10000 : 0);
	        } else if (options.children) {
	            endRow = range ? range.end.row : this.getLength();
	            this.foldAll(row + 1, endRow, options.all ? 10000 : 0);
	        } else if (range) {
	            if (options.all) 
	                range.collapseChildren = 10000;
	            this.addFold("...", range);
	        }
	        
	        return range;
	    };
	    
	    
	    
	    this.toggleFoldWidget = function(toggleParent) {
	        var row = this.selection.getCursor().row;
	        row = this.getRowFoldStart(row);
	        var range = this.$toggleFoldWidget(row, {});
	        
	        if (range)
	            return;
	        var data = this.getParentFoldRangeData(row, true);
	        range = data.range || data.firstRange;
	        
	        if (range) {
	            row = range.start.row;
	            var fold = this.getFoldAt(row, this.getLine(row).length, 1);

	            if (fold) {
	                this.removeFold(fold);
	            } else {
	                this.addFold("...", range);
	            }
	        }
	    };

	    this.updateFoldWidgets = function(delta) {
	        var firstRow = delta.start.row;
	        var len = delta.end.row - firstRow;

	        if (len === 0) {
	            this.foldWidgets[firstRow] = null;
	        } else if (delta.action == 'remove') {
	            this.foldWidgets.splice(firstRow, len + 1, null);
	        } else {
	            var args = Array(len + 1);
	            args.unshift(firstRow, 1);
	            this.foldWidgets.splice.apply(this.foldWidgets, args);
	        }
	    };
	    this.tokenizerUpdateFoldWidgets = function(e) {
	        var rows = e.data;
	        if (rows.first != rows.last) {
	            if (this.foldWidgets.length > rows.first)
	                this.foldWidgets.splice(rows.first, this.foldWidgets.length);
	        }
	    };
	}

	exports.Folding = Folding;

	});

	ace.define("ace/edit_session/bracket_match",["require","exports","module","ace/token_iterator","ace/range"], function(acequire, exports, module) {
	"use strict";

	var TokenIterator = acequire("../token_iterator").TokenIterator;
	var Range = acequire("../range").Range;


	function BracketMatch() {

	    this.findMatchingBracket = function(position, chr) {
	        if (position.column == 0) return null;

	        var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column-1);
	        if (charBeforeCursor == "") return null;

	        var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
	        if (!match)
	            return null;

	        if (match[1])
	            return this.$findClosingBracket(match[1], position);
	        else
	            return this.$findOpeningBracket(match[2], position);
	    };
	    
	    this.getBracketRange = function(pos) {
	        var line = this.getLine(pos.row);
	        var before = true, range;

	        var chr = line.charAt(pos.column-1);
	        var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
	        if (!match) {
	            chr = line.charAt(pos.column);
	            pos = {row: pos.row, column: pos.column + 1};
	            match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
	            before = false;
	        }
	        if (!match)
	            return null;

	        if (match[1]) {
	            var bracketPos = this.$findClosingBracket(match[1], pos);
	            if (!bracketPos)
	                return null;
	            range = Range.fromPoints(pos, bracketPos);
	            if (!before) {
	                range.end.column++;
	                range.start.column--;
	            }
	            range.cursor = range.end;
	        } else {
	            var bracketPos = this.$findOpeningBracket(match[2], pos);
	            if (!bracketPos)
	                return null;
	            range = Range.fromPoints(bracketPos, pos);
	            if (!before) {
	                range.start.column++;
	                range.end.column--;
	            }
	            range.cursor = range.start;
	        }
	        
	        return range;
	    };

	    this.$brackets = {
	        ")": "(",
	        "(": ")",
	        "]": "[",
	        "[": "]",
	        "{": "}",
	        "}": "{"
	    };

	    this.$findOpeningBracket = function(bracket, position, typeRe) {
	        var openBracket = this.$brackets[bracket];
	        var depth = 1;

	        var iterator = new TokenIterator(this, position.row, position.column);
	        var token = iterator.getCurrentToken();
	        if (!token)
	            token = iterator.stepForward();
	        if (!token)
	            return;
	        
	         if (!typeRe){
	            typeRe = new RegExp(
	                "(\\.?" +
	                token.type.replace(".", "\\.").replace("rparen", ".paren")
	                    .replace(/\b(?:end)\b/, "(?:start|begin|end)")
	                + ")+"
	            );
	        }
	        var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
	        var value = token.value;
	        
	        while (true) {
	        
	            while (valueIndex >= 0) {
	                var chr = value.charAt(valueIndex);
	                if (chr == openBracket) {
	                    depth -= 1;
	                    if (depth == 0) {
	                        return {row: iterator.getCurrentTokenRow(),
	                            column: valueIndex + iterator.getCurrentTokenColumn()};
	                    }
	                }
	                else if (chr == bracket) {
	                    depth += 1;
	                }
	                valueIndex -= 1;
	            }
	            do {
	                token = iterator.stepBackward();
	            } while (token && !typeRe.test(token.type));

	            if (token == null)
	                break;
	                
	            value = token.value;
	            valueIndex = value.length - 1;
	        }
	        
	        return null;
	    };

	    this.$findClosingBracket = function(bracket, position, typeRe) {
	        var closingBracket = this.$brackets[bracket];
	        var depth = 1;

	        var iterator = new TokenIterator(this, position.row, position.column);
	        var token = iterator.getCurrentToken();
	        if (!token)
	            token = iterator.stepForward();
	        if (!token)
	            return;

	        if (!typeRe){
	            typeRe = new RegExp(
	                "(\\.?" +
	                token.type.replace(".", "\\.").replace("lparen", ".paren")
	                    .replace(/\b(?:start|begin)\b/, "(?:start|begin|end)")
	                + ")+"
	            );
	        }
	        var valueIndex = position.column - iterator.getCurrentTokenColumn();

	        while (true) {

	            var value = token.value;
	            var valueLength = value.length;
	            while (valueIndex < valueLength) {
	                var chr = value.charAt(valueIndex);
	                if (chr == closingBracket) {
	                    depth -= 1;
	                    if (depth == 0) {
	                        return {row: iterator.getCurrentTokenRow(),
	                            column: valueIndex + iterator.getCurrentTokenColumn()};
	                    }
	                }
	                else if (chr == bracket) {
	                    depth += 1;
	                }
	                valueIndex += 1;
	            }
	            do {
	                token = iterator.stepForward();
	            } while (token && !typeRe.test(token.type));

	            if (token == null)
	                break;

	            valueIndex = 0;
	        }
	        
	        return null;
	    };
	}
	exports.BracketMatch = BracketMatch;

	});

	ace.define("ace/edit_session",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/config","ace/lib/event_emitter","ace/selection","ace/mode/text","ace/range","ace/document","ace/background_tokenizer","ace/search_highlight","ace/edit_session/folding","ace/edit_session/bracket_match"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("./lib/oop");
	var lang = acequire("./lib/lang");
	var config = acequire("./config");
	var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
	var Selection = acequire("./selection").Selection;
	var TextMode = acequire("./mode/text").Mode;
	var Range = acequire("./range").Range;
	var Document = acequire("./document").Document;
	var BackgroundTokenizer = acequire("./background_tokenizer").BackgroundTokenizer;
	var SearchHighlight = acequire("./search_highlight").SearchHighlight;

	var EditSession = function(text, mode) {
	    this.$breakpoints = [];
	    this.$decorations = [];
	    this.$frontMarkers = {};
	    this.$backMarkers = {};
	    this.$markerId = 1;
	    this.$undoSelect = true;

	    this.$foldData = [];
	    this.$foldData.toString = function() {
	        return this.join("\n");
	    };
	    this.on("changeFold", this.onChangeFold.bind(this));
	    this.$onChange = this.onChange.bind(this);

	    if (typeof text != "object" || !text.getLine)
	        text = new Document(text);

	    this.setDocument(text);
	    this.selection = new Selection(this);

	    config.resetOptions(this);
	    this.setMode(mode);
	    config._signal("session", this);
	};


	(function() {

	    oop.implement(this, EventEmitter);
	    this.setDocument = function(doc) {
	        if (this.doc)
	            this.doc.removeListener("change", this.$onChange);

	        this.doc = doc;
	        doc.on("change", this.$onChange);

	        if (this.bgTokenizer)
	            this.bgTokenizer.setDocument(this.getDocument());

	        this.resetCaches();
	    };
	    this.getDocument = function() {
	        return this.doc;
	    };
	    this.$resetRowCache = function(docRow) {
	        if (!docRow) {
	            this.$docRowCache = [];
	            this.$screenRowCache = [];
	            return;
	        }
	        var l = this.$docRowCache.length;
	        var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
	        if (l > i) {
	            this.$docRowCache.splice(i, l);
	            this.$screenRowCache.splice(i, l);
	        }
	    };

	    this.$getRowCacheIndex = function(cacheArray, val) {
	        var low = 0;
	        var hi = cacheArray.length - 1;

	        while (low <= hi) {
	            var mid = (low + hi) >> 1;
	            var c = cacheArray[mid];

	            if (val > c)
	                low = mid + 1;
	            else if (val < c)
	                hi = mid - 1;
	            else
	                return mid;
	        }

	        return low -1;
	    };

	    this.resetCaches = function() {
	        this.$modified = true;
	        this.$wrapData = [];
	        this.$rowLengthCache = [];
	        this.$resetRowCache(0);
	        if (this.bgTokenizer)
	            this.bgTokenizer.start(0);
	    };

	    this.onChangeFold = function(e) {
	        var fold = e.data;
	        this.$resetRowCache(fold.start.row);
	    };

	    this.onChange = function(delta) {
	        this.$modified = true;

	        this.$resetRowCache(delta.start.row);

	        var removedFolds = this.$updateInternalDataOnChange(delta);
	        if (!this.$fromUndo && this.$undoManager && !delta.ignore) {
	            this.$deltasDoc.push(delta);
	            if (removedFolds && removedFolds.length != 0) {
	                this.$deltasFold.push({
	                    action: "removeFolds",
	                    folds:  removedFolds
	                });
	            }

	            this.$informUndoManager.schedule();
	        }

	        this.bgTokenizer && this.bgTokenizer.$updateOnChange(delta);
	        this._signal("change", delta);
	    };
	    this.setValue = function(text) {
	        this.doc.setValue(text);
	        this.selection.moveTo(0, 0);

	        this.$resetRowCache(0);
	        this.$deltas = [];
	        this.$deltasDoc = [];
	        this.$deltasFold = [];
	        this.setUndoManager(this.$undoManager);
	        this.getUndoManager().reset();
	    };
	    this.getValue =
	    this.toString = function() {
	        return this.doc.getValue();
	    };
	    this.getSelection = function() {
	        return this.selection;
	    };
	    this.getState = function(row) {
	        return this.bgTokenizer.getState(row);
	    };
	    this.getTokens = function(row) {
	        return this.bgTokenizer.getTokens(row);
	    };
	    this.getTokenAt = function(row, column) {
	        var tokens = this.bgTokenizer.getTokens(row);
	        var token, c = 0;
	        if (column == null) {
	            i = tokens.length - 1;
	            c = this.getLine(row).length;
	        } else {
	            for (var i = 0; i < tokens.length; i++) {
	                c += tokens[i].value.length;
	                if (c >= column)
	                    break;
	            }
	        }
	        token = tokens[i];
	        if (!token)
	            return null;
	        token.index = i;
	        token.start = c - token.value.length;
	        return token;
	    };
	    this.setUndoManager = function(undoManager) {
	        this.$undoManager = undoManager;
	        this.$deltas = [];
	        this.$deltasDoc = [];
	        this.$deltasFold = [];

	        if (this.$informUndoManager)
	            this.$informUndoManager.cancel();

	        if (undoManager) {
	            var self = this;

	            this.$syncInformUndoManager = function() {
	                self.$informUndoManager.cancel();

	                if (self.$deltasFold.length) {
	                    self.$deltas.push({
	                        group: "fold",
	                        deltas: self.$deltasFold
	                    });
	                    self.$deltasFold = [];
	                }

	                if (self.$deltasDoc.length) {
	                    self.$deltas.push({
	                        group: "doc",
	                        deltas: self.$deltasDoc
	                    });
	                    self.$deltasDoc = [];
	                }

	                if (self.$deltas.length > 0) {
	                    undoManager.execute({
	                        action: "aceupdate",
	                        args: [self.$deltas, self],
	                        merge: self.mergeUndoDeltas
	                    });
	                }
	                self.mergeUndoDeltas = false;
	                self.$deltas = [];
	            };
	            this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
	        }
	    };
	    this.markUndoGroup = function() {
	        if (this.$syncInformUndoManager)
	            this.$syncInformUndoManager();
	    };
	    
	    this.$defaultUndoManager = {
	        undo: function() {},
	        redo: function() {},
	        reset: function() {}
	    };
	    this.getUndoManager = function() {
	        return this.$undoManager || this.$defaultUndoManager;
	    };
	    this.getTabString = function() {
	        if (this.getUseSoftTabs()) {
	            return lang.stringRepeat(" ", this.getTabSize());
	        } else {
	            return "\t";
	        }
	    };
	    this.setUseSoftTabs = function(val) {
	        this.setOption("useSoftTabs", val);
	    };
	    this.getUseSoftTabs = function() {
	        return this.$useSoftTabs && !this.$mode.$indentWithTabs;
	    };
	    this.setTabSize = function(tabSize) {
	        this.setOption("tabSize", tabSize);
	    };
	    this.getTabSize = function() {
	        return this.$tabSize;
	    };
	    this.isTabStop = function(position) {
	        return this.$useSoftTabs && (position.column % this.$tabSize === 0);
	    };

	    this.$overwrite = false;
	    this.setOverwrite = function(overwrite) {
	        this.setOption("overwrite", overwrite);
	    };
	    this.getOverwrite = function() {
	        return this.$overwrite;
	    };
	    this.toggleOverwrite = function() {
	        this.setOverwrite(!this.$overwrite);
	    };
	    this.addGutterDecoration = function(row, className) {
	        if (!this.$decorations[row])
	            this.$decorations[row] = "";
	        this.$decorations[row] += " " + className;
	        this._signal("changeBreakpoint", {});
	    };
	    this.removeGutterDecoration = function(row, className) {
	        this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
	        this._signal("changeBreakpoint", {});
	    };
	    this.getBreakpoints = function() {
	        return this.$breakpoints;
	    };
	    this.setBreakpoints = function(rows) {
	        this.$breakpoints = [];
	        for (var i=0; i<rows.length; i++) {
	            this.$breakpoints[rows[i]] = "ace_breakpoint";
	        }
	        this._signal("changeBreakpoint", {});
	    };
	    this.clearBreakpoints = function() {
	        this.$breakpoints = [];
	        this._signal("changeBreakpoint", {});
	    };
	    this.setBreakpoint = function(row, className) {
	        if (className === undefined)
	            className = "ace_breakpoint";
	        if (className)
	            this.$breakpoints[row] = className;
	        else
	            delete this.$breakpoints[row];
	        this._signal("changeBreakpoint", {});
	    };
	    this.clearBreakpoint = function(row) {
	        delete this.$breakpoints[row];
	        this._signal("changeBreakpoint", {});
	    };
	    this.addMarker = function(range, clazz, type, inFront) {
	        var id = this.$markerId++;

	        var marker = {
	            range : range,
	            type : type || "line",
	            renderer: typeof type == "function" ? type : null,
	            clazz : clazz,
	            inFront: !!inFront,
	            id: id
	        };

	        if (inFront) {
	            this.$frontMarkers[id] = marker;
	            this._signal("changeFrontMarker");
	        } else {
	            this.$backMarkers[id] = marker;
	            this._signal("changeBackMarker");
	        }

	        return id;
	    };
	    this.addDynamicMarker = function(marker, inFront) {
	        if (!marker.update)
	            return;
	        var id = this.$markerId++;
	        marker.id = id;
	        marker.inFront = !!inFront;

	        if (inFront) {
	            this.$frontMarkers[id] = marker;
	            this._signal("changeFrontMarker");
	        } else {
	            this.$backMarkers[id] = marker;
	            this._signal("changeBackMarker");
	        }

	        return marker;
	    };
	    this.removeMarker = function(markerId) {
	        var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
	        if (!marker)
	            return;

	        var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
	        if (marker) {
	            delete (markers[markerId]);
	            this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
	        }
	    };
	    this.getMarkers = function(inFront) {
	        return inFront ? this.$frontMarkers : this.$backMarkers;
	    };

	    this.highlight = function(re) {
	        if (!this.$searchHighlight) {
	            var highlight = new SearchHighlight(null, "ace_selected-word", "text");
	            this.$searchHighlight = this.addDynamicMarker(highlight);
	        }
	        this.$searchHighlight.setRegexp(re);
	    };
	    this.highlightLines = function(startRow, endRow, clazz, inFront) {
	        if (typeof endRow != "number") {
	            clazz = endRow;
	            endRow = startRow;
	        }
	        if (!clazz)
	            clazz = "ace_step";

	        var range = new Range(startRow, 0, endRow, Infinity);
	        range.id = this.addMarker(range, clazz, "fullLine", inFront);
	        return range;
	    };
	    this.setAnnotations = function(annotations) {
	        this.$annotations = annotations;
	        this._signal("changeAnnotation", {});
	    };
	    this.getAnnotations = function() {
	        return this.$annotations || [];
	    };
	    this.clearAnnotations = function() {
	        this.setAnnotations([]);
	    };
	    this.$detectNewLine = function(text) {
	        var match = text.match(/^.*?(\r?\n)/m);
	        if (match) {
	            this.$autoNewLine = match[1];
	        } else {
	            this.$autoNewLine = "\n";
	        }
	    };
	    this.getWordRange = function(row, column) {
	        var line = this.getLine(row);

	        var inToken = false;
	        if (column > 0)
	            inToken = !!line.charAt(column - 1).match(this.tokenRe);

	        if (!inToken)
	            inToken = !!line.charAt(column).match(this.tokenRe);

	        if (inToken)
	            var re = this.tokenRe;
	        else if (/^\s+$/.test(line.slice(column-1, column+1)))
	            var re = /\s/;
	        else
	            var re = this.nonTokenRe;

	        var start = column;
	        if (start > 0) {
	            do {
	                start--;
	            }
	            while (start >= 0 && line.charAt(start).match(re));
	            start++;
	        }

	        var end = column;
	        while (end < line.length && line.charAt(end).match(re)) {
	            end++;
	        }

	        return new Range(row, start, row, end);
	    };
	    this.getAWordRange = function(row, column) {
	        var wordRange = this.getWordRange(row, column);
	        var line = this.getLine(wordRange.end.row);

	        while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
	            wordRange.end.column += 1;
	        }
	        return wordRange;
	    };
	    this.setNewLineMode = function(newLineMode) {
	        this.doc.setNewLineMode(newLineMode);
	    };
	    this.getNewLineMode = function() {
	        return this.doc.getNewLineMode();
	    };
	    this.setUseWorker = function(useWorker) { this.setOption("useWorker", useWorker); };
	    this.getUseWorker = function() { return this.$useWorker; };
	    this.onReloadTokenizer = function(e) {
	        var rows = e.data;
	        this.bgTokenizer.start(rows.first);
	        this._signal("tokenizerUpdate", e);
	    };

	    this.$modes = {};
	    this.$mode = null;
	    this.$modeId = null;
	    this.setMode = function(mode, cb) {
	        if (mode && typeof mode === "object") {
	            if (mode.getTokenizer)
	                return this.$onChangeMode(mode);
	            var options = mode;
	            var path = options.path;
	        } else {
	            path = mode || "ace/mode/text";
	        }
	        if (!this.$modes["ace/mode/text"])
	            this.$modes["ace/mode/text"] = new TextMode();

	        if (this.$modes[path] && !options) {
	            this.$onChangeMode(this.$modes[path]);
	            cb && cb();
	            return;
	        }
	        this.$modeId = path;
	        config.loadModule(["mode", path], function(m) {
	            if (this.$modeId !== path)
	                return cb && cb();
	            if (this.$modes[path] && !options) {
	                this.$onChangeMode(this.$modes[path]);
	            } else if (m && m.Mode) {
	                m = new m.Mode(options);
	                if (!options) {
	                    this.$modes[path] = m;
	                    m.$id = path;
	                }
	                this.$onChangeMode(m);
	            }
	            cb && cb();
	        }.bind(this));
	        if (!this.$mode)
	            this.$onChangeMode(this.$modes["ace/mode/text"], true);
	    };

	    this.$onChangeMode = function(mode, $isPlaceholder) {
	        if (!$isPlaceholder)
	            this.$modeId = mode.$id;
	        if (this.$mode === mode) 
	            return;

	        this.$mode = mode;

	        this.$stopWorker();

	        if (this.$useWorker)
	            this.$startWorker();

	        var tokenizer = mode.getTokenizer();

	        if(tokenizer.addEventListener !== undefined) {
	            var onReloadTokenizer = this.onReloadTokenizer.bind(this);
	            tokenizer.addEventListener("update", onReloadTokenizer);
	        }

	        if (!this.bgTokenizer) {
	            this.bgTokenizer = new BackgroundTokenizer(tokenizer);
	            var _self = this;
	            this.bgTokenizer.addEventListener("update", function(e) {
	                _self._signal("tokenizerUpdate", e);
	            });
	        } else {
	            this.bgTokenizer.setTokenizer(tokenizer);
	        }

	        this.bgTokenizer.setDocument(this.getDocument());

	        this.tokenRe = mode.tokenRe;
	        this.nonTokenRe = mode.nonTokenRe;

	        
	        if (!$isPlaceholder) {
	            if (mode.attachToSession)
	                mode.attachToSession(this);
	            this.$options.wrapMethod.set.call(this, this.$wrapMethod);
	            this.$setFolding(mode.foldingRules);
	            this.bgTokenizer.start(0);
	            this._emit("changeMode");
	        }
	    };

	    this.$stopWorker = function() {
	        if (this.$worker) {
	            this.$worker.terminate();
	            this.$worker = null;
	        }
	    };

	    this.$startWorker = function() {
	        try {
	            this.$worker = this.$mode.createWorker(this);
	        } catch (e) {
	            config.warn("Could not load worker", e);
	            this.$worker = null;
	        }
	    };
	    this.getMode = function() {
	        return this.$mode;
	    };

	    this.$scrollTop = 0;
	    this.setScrollTop = function(scrollTop) {
	        if (this.$scrollTop === scrollTop || isNaN(scrollTop))
	            return;

	        this.$scrollTop = scrollTop;
	        this._signal("changeScrollTop", scrollTop);
	    };
	    this.getScrollTop = function() {
	        return this.$scrollTop;
	    };

	    this.$scrollLeft = 0;
	    this.setScrollLeft = function(scrollLeft) {
	        if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
	            return;

	        this.$scrollLeft = scrollLeft;
	        this._signal("changeScrollLeft", scrollLeft);
	    };
	    this.getScrollLeft = function() {
	        return this.$scrollLeft;
	    };
	    this.getScreenWidth = function() {
	        this.$computeWidth();
	        if (this.lineWidgets) 
	            return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
	        return this.screenWidth;
	    };
	    
	    this.getLineWidgetMaxWidth = function() {
	        if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth;
	        var width = 0;
	        this.lineWidgets.forEach(function(w) {
	            if (w && w.screenWidth > width)
	                width = w.screenWidth;
	        });
	        return this.lineWidgetWidth = width;
	    };

	    this.$computeWidth = function(force) {
	        if (this.$modified || force) {
	            this.$modified = false;

	            if (this.$useWrapMode)
	                return this.screenWidth = this.$wrapLimit;

	            var lines = this.doc.getAllLines();
	            var cache = this.$rowLengthCache;
	            var longestScreenLine = 0;
	            var foldIndex = 0;
	            var foldLine = this.$foldData[foldIndex];
	            var foldStart = foldLine ? foldLine.start.row : Infinity;
	            var len = lines.length;

	            for (var i = 0; i < len; i++) {
	                if (i > foldStart) {
	                    i = foldLine.end.row + 1;
	                    if (i >= len)
	                        break;
	                    foldLine = this.$foldData[foldIndex++];
	                    foldStart = foldLine ? foldLine.start.row : Infinity;
	                }

	                if (cache[i] == null)
	                    cache[i] = this.$getStringScreenWidth(lines[i])[0];

	                if (cache[i] > longestScreenLine)
	                    longestScreenLine = cache[i];
	            }
	            this.screenWidth = longestScreenLine;
	        }
	    };
	    this.getLine = function(row) {
	        return this.doc.getLine(row);
	    };
	    this.getLines = function(firstRow, lastRow) {
	        return this.doc.getLines(firstRow, lastRow);
	    };
	    this.getLength = function() {
	        return this.doc.getLength();
	    };
	    this.getTextRange = function(range) {
	        return this.doc.getTextRange(range || this.selection.getRange());
	    };
	    this.insert = function(position, text) {
	        return this.doc.insert(position, text);
	    };
	    this.remove = function(range) {
	        return this.doc.remove(range);
	    };
	    this.removeFullLines = function(firstRow, lastRow){
	        return this.doc.removeFullLines(firstRow, lastRow);
	    };
	    this.undoChanges = function(deltas, dontSelect) {
	        if (!deltas.length)
	            return;

	        this.$fromUndo = true;
	        var lastUndoRange = null;
	        for (var i = deltas.length - 1; i != -1; i--) {
	            var delta = deltas[i];
	            if (delta.group == "doc") {
	                this.doc.revertDeltas(delta.deltas);
	                lastUndoRange =
	                    this.$getUndoSelection(delta.deltas, true, lastUndoRange);
	            } else {
	                delta.deltas.forEach(function(foldDelta) {
	                    this.addFolds(foldDelta.folds);
	                }, this);
	            }
	        }
	        this.$fromUndo = false;
	        lastUndoRange &&
	            this.$undoSelect &&
	            !dontSelect &&
	            this.selection.setSelectionRange(lastUndoRange);
	        return lastUndoRange;
	    };
	    this.redoChanges = function(deltas, dontSelect) {
	        if (!deltas.length)
	            return;

	        this.$fromUndo = true;
	        var lastUndoRange = null;
	        for (var i = 0; i < deltas.length; i++) {
	            var delta = deltas[i];
	            if (delta.group == "doc") {
	                this.doc.applyDeltas(delta.deltas);
	                lastUndoRange =
	                    this.$getUndoSelection(delta.deltas, false, lastUndoRange);
	            }
	        }
	        this.$fromUndo = false;
	        lastUndoRange &&
	            this.$undoSelect &&
	            !dontSelect &&
	            this.selection.setSelectionRange(lastUndoRange);
	        return lastUndoRange;
	    };
	    this.setUndoSelect = function(enable) {
	        this.$undoSelect = enable;
	    };

	    this.$getUndoSelection = function(deltas, isUndo, lastUndoRange) {
	        function isInsert(delta) {
	            return isUndo ? delta.action !== "insert" : delta.action === "insert";
	        }

	        var delta = deltas[0];
	        var range, point;
	        var lastDeltaIsInsert = false;
	        if (isInsert(delta)) {
	            range = Range.fromPoints(delta.start, delta.end);
	            lastDeltaIsInsert = true;
	        } else {
	            range = Range.fromPoints(delta.start, delta.start);
	            lastDeltaIsInsert = false;
	        }

	        for (var i = 1; i < deltas.length; i++) {
	            delta = deltas[i];
	            if (isInsert(delta)) {
	                point = delta.start;
	                if (range.compare(point.row, point.column) == -1) {
	                    range.setStart(point);
	                }
	                point = delta.end;
	                if (range.compare(point.row, point.column) == 1) {
	                    range.setEnd(point);
	                }
	                lastDeltaIsInsert = true;
	            } else {
	                point = delta.start;
	                if (range.compare(point.row, point.column) == -1) {
	                    range = Range.fromPoints(delta.start, delta.start);
	                }
	                lastDeltaIsInsert = false;
	            }
	        }
	        if (lastUndoRange != null) {
	            if (Range.comparePoints(lastUndoRange.start, range.start) === 0) {
	                lastUndoRange.start.column += range.end.column - range.start.column;
	                lastUndoRange.end.column += range.end.column - range.start.column;
	            }

	            var cmp = lastUndoRange.compareRange(range);
	            if (cmp == 1) {
	                range.setStart(lastUndoRange.start);
	            } else if (cmp == -1) {
	                range.setEnd(lastUndoRange.end);
	            }
	        }

	        return range;
	    };
	    this.replace = function(range, text) {
	        return this.doc.replace(range, text);
	    };
	    this.moveText = function(fromRange, toPosition, copy) {
	        var text = this.getTextRange(fromRange);
	        var folds = this.getFoldsInRange(fromRange);

	        var toRange = Range.fromPoints(toPosition, toPosition);
	        if (!copy) {
	            this.remove(fromRange);
	            var rowDiff = fromRange.start.row - fromRange.end.row;
	            var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
	            if (collDiff) {
	                if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)
	                    toRange.start.column += collDiff;
	                if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)
	                    toRange.end.column += collDiff;
	            }
	            if (rowDiff && toRange.start.row >= fromRange.end.row) {
	                toRange.start.row += rowDiff;
	                toRange.end.row += rowDiff;
	            }
	        }

	        toRange.end = this.insert(toRange.start, text);
	        if (folds.length) {
	            var oldStart = fromRange.start;
	            var newStart = toRange.start;
	            var rowDiff = newStart.row - oldStart.row;
	            var collDiff = newStart.column - oldStart.column;
	            this.addFolds(folds.map(function(x) {
	                x = x.clone();
	                if (x.start.row == oldStart.row)
	                    x.start.column += collDiff;
	                if (x.end.row == oldStart.row)
	                    x.end.column += collDiff;
	                x.start.row += rowDiff;
	                x.end.row += rowDiff;
	                return x;
	            }));
	        }

	        return toRange;
	    };
	    this.indentRows = function(startRow, endRow, indentString) {
	        indentString = indentString.replace(/\t/g, this.getTabString());
	        for (var row=startRow; row<=endRow; row++)
	            this.doc.insertInLine({row: row, column: 0}, indentString);
	    };
	    this.outdentRows = function (range) {
	        var rowRange = range.collapseRows();
	        var deleteRange = new Range(0, 0, 0, 0);
	        var size = this.getTabSize();

	        for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
	            var line = this.getLine(i);

	            deleteRange.start.row = i;
	            deleteRange.end.row = i;
	            for (var j = 0; j < size; ++j)
	                if (line.charAt(j) != ' ')
	                    break;
	            if (j < size && line.charAt(j) == '\t') {
	                deleteRange.start.column = j;
	                deleteRange.end.column = j + 1;
	            } else {
	                deleteRange.start.column = 0;
	                deleteRange.end.column = j;
	            }
	            this.remove(deleteRange);
	        }
	    };

	    this.$moveLines = function(firstRow, lastRow, dir) {
	        firstRow = this.getRowFoldStart(firstRow);
	        lastRow = this.getRowFoldEnd(lastRow);
	        if (dir < 0) {
	            var row = this.getRowFoldStart(firstRow + dir);
	            if (row < 0) return 0;
	            var diff = row-firstRow;
	        } else if (dir > 0) {
	            var row = this.getRowFoldEnd(lastRow + dir);
	            if (row > this.doc.getLength()-1) return 0;
	            var diff = row-lastRow;
	        } else {
	            firstRow = this.$clipRowToDocument(firstRow);
	            lastRow = this.$clipRowToDocument(lastRow);
	            var diff = lastRow - firstRow + 1;
	        }

	        var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
	        var folds = this.getFoldsInRange(range).map(function(x){
	            x = x.clone();
	            x.start.row += diff;
	            x.end.row += diff;
	            return x;
	        });
	        
	        var lines = dir == 0
	            ? this.doc.getLines(firstRow, lastRow)
	            : this.doc.removeFullLines(firstRow, lastRow);
	        this.doc.insertFullLines(firstRow+diff, lines);
	        folds.length && this.addFolds(folds);
	        return diff;
	    };
	    this.moveLinesUp = function(firstRow, lastRow) {
	        return this.$moveLines(firstRow, lastRow, -1);
	    };
	    this.moveLinesDown = function(firstRow, lastRow) {
	        return this.$moveLines(firstRow, lastRow, 1);
	    };
	    this.duplicateLines = function(firstRow, lastRow) {
	        return this.$moveLines(firstRow, lastRow, 0);
	    };


	    this.$clipRowToDocument = function(row) {
	        return Math.max(0, Math.min(row, this.doc.getLength()-1));
	    };

	    this.$clipColumnToRow = function(row, column) {
	        if (column < 0)
	            return 0;
	        return Math.min(this.doc.getLine(row).length, column);
	    };


	    this.$clipPositionToDocument = function(row, column) {
	        column = Math.max(0, column);

	        if (row < 0) {
	            row = 0;
	            column = 0;
	        } else {
	            var len = this.doc.getLength();
	            if (row >= len) {
	                row = len - 1;
	                column = this.doc.getLine(len-1).length;
	            } else {
	                column = Math.min(this.doc.getLine(row).length, column);
	            }
	        }

	        return {
	            row: row,
	            column: column
	        };
	    };

	    this.$clipRangeToDocument = function(range) {
	        if (range.start.row < 0) {
	            range.start.row = 0;
	            range.start.column = 0;
	        } else {
	            range.start.column = this.$clipColumnToRow(
	                range.start.row,
	                range.start.column
	            );
	        }

	        var len = this.doc.getLength() - 1;
	        if (range.end.row > len) {
	            range.end.row = len;
	            range.end.column = this.doc.getLine(len).length;
	        } else {
	            range.end.column = this.$clipColumnToRow(
	                range.end.row,
	                range.end.column
	            );
	        }
	        return range;
	    };
	    this.$wrapLimit = 80;
	    this.$useWrapMode = false;
	    this.$wrapLimitRange = {
	        min : null,
	        max : null
	    };
	    this.setUseWrapMode = function(useWrapMode) {
	        if (useWrapMode != this.$useWrapMode) {
	            this.$useWrapMode = useWrapMode;
	            this.$modified = true;
	            this.$resetRowCache(0);
	            if (useWrapMode) {
	                var len = this.getLength();
	                this.$wrapData = Array(len);
	                this.$updateWrapData(0, len - 1);
	            }

	            this._signal("changeWrapMode");
	        }
	    };
	    this.getUseWrapMode = function() {
	        return this.$useWrapMode;
	    };
	    this.setWrapLimitRange = function(min, max) {
	        if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
	            this.$wrapLimitRange = { min: min, max: max };
	            this.$modified = true;
	            if (this.$useWrapMode)
	                this._signal("changeWrapMode");
	        }
	    };
	    this.adjustWrapLimit = function(desiredLimit, $printMargin) {
	        var limits = this.$wrapLimitRange;
	        if (limits.max < 0)
	            limits = {min: $printMargin, max: $printMargin};
	        var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
	        if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
	            this.$wrapLimit = wrapLimit;
	            this.$modified = true;
	            if (this.$useWrapMode) {
	                this.$updateWrapData(0, this.getLength() - 1);
	                this.$resetRowCache(0);
	                this._signal("changeWrapLimit");
	            }
	            return true;
	        }
	        return false;
	    };

	    this.$constrainWrapLimit = function(wrapLimit, min, max) {
	        if (min)
	            wrapLimit = Math.max(min, wrapLimit);

	        if (max)
	            wrapLimit = Math.min(max, wrapLimit);

	        return wrapLimit;
	    };
	    this.getWrapLimit = function() {
	        return this.$wrapLimit;
	    };
	    this.setWrapLimit = function (limit) {
	        this.setWrapLimitRange(limit, limit);
	    };
	    this.getWrapLimitRange = function() {
	        return {
	            min : this.$wrapLimitRange.min,
	            max : this.$wrapLimitRange.max
	        };
	    };

	    this.$updateInternalDataOnChange = function(delta) {
	        var useWrapMode = this.$useWrapMode;
	        var action = delta.action;
	        var start = delta.start;
	        var end = delta.end;
	        var firstRow = start.row;
	        var lastRow = end.row;
	        var len = lastRow - firstRow;
	        var removedFolds = null;
	        
	        this.$updating = true;
	        if (len != 0) {
	            if (action === "remove") {
	                this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);

	                var foldLines = this.$foldData;
	                removedFolds = this.getFoldsInRange(delta);
	                this.removeFolds(removedFolds);

	                var foldLine = this.getFoldLine(end.row);
	                var idx = 0;
	                if (foldLine) {
	                    foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
	                    foldLine.shiftRow(-len);

	                    var foldLineBefore = this.getFoldLine(firstRow);
	                    if (foldLineBefore && foldLineBefore !== foldLine) {
	                        foldLineBefore.merge(foldLine);
	                        foldLine = foldLineBefore;
	                    }
	                    idx = foldLines.indexOf(foldLine) + 1;
	                }

	                for (idx; idx < foldLines.length; idx++) {
	                    var foldLine = foldLines[idx];
	                    if (foldLine.start.row >= end.row) {
	                        foldLine.shiftRow(-len);
	                    }
	                }

	                lastRow = firstRow;
	            } else {
	                var args = Array(len);
	                args.unshift(firstRow, 0);
	                var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache
	                arr.splice.apply(arr, args);
	                var foldLines = this.$foldData;
	                var foldLine = this.getFoldLine(firstRow);
	                var idx = 0;
	                if (foldLine) {
	                    var cmp = foldLine.range.compareInside(start.row, start.column);
	                    if (cmp == 0) {
	                        foldLine = foldLine.split(start.row, start.column);
	                        if (foldLine) {
	                            foldLine.shiftRow(len);
	                            foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
	                        }
	                    } else
	                    if (cmp == -1) {
	                        foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
	                        foldLine.shiftRow(len);
	                    }
	                    idx = foldLines.indexOf(foldLine) + 1;
	                }

	                for (idx; idx < foldLines.length; idx++) {
	                    var foldLine = foldLines[idx];
	                    if (foldLine.start.row >= firstRow) {
	                        foldLine.shiftRow(len);
	                    }
	                }
	            }
	        } else {
	            len = Math.abs(delta.start.column - delta.end.column);
	            if (action === "remove") {
	                removedFolds = this.getFoldsInRange(delta);
	                this.removeFolds(removedFolds);

	                len = -len;
	            }
	            var foldLine = this.getFoldLine(firstRow);
	            if (foldLine) {
	                foldLine.addRemoveChars(firstRow, start.column, len);
	            }
	        }

	        if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
	            console.error("doc.getLength() and $wrapData.length have to be the same!");
	        }
	        this.$updating = false;

	        if (useWrapMode)
	            this.$updateWrapData(firstRow, lastRow);
	        else
	            this.$updateRowLengthCache(firstRow, lastRow);

	        return removedFolds;
	    };

	    this.$updateRowLengthCache = function(firstRow, lastRow, b) {
	        this.$rowLengthCache[firstRow] = null;
	        this.$rowLengthCache[lastRow] = null;
	    };

	    this.$updateWrapData = function(firstRow, lastRow) {
	        var lines = this.doc.getAllLines();
	        var tabSize = this.getTabSize();
	        var wrapData = this.$wrapData;
	        var wrapLimit = this.$wrapLimit;
	        var tokens;
	        var foldLine;

	        var row = firstRow;
	        lastRow = Math.min(lastRow, lines.length - 1);
	        while (row <= lastRow) {
	            foldLine = this.getFoldLine(row, foldLine);
	            if (!foldLine) {
	                tokens = this.$getDisplayTokens(lines[row]);
	                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
	                row ++;
	            } else {
	                tokens = [];
	                foldLine.walk(function(placeholder, row, column, lastColumn) {
	                        var walkTokens;
	                        if (placeholder != null) {
	                            walkTokens = this.$getDisplayTokens(
	                                            placeholder, tokens.length);
	                            walkTokens[0] = PLACEHOLDER_START;
	                            for (var i = 1; i < walkTokens.length; i++) {
	                                walkTokens[i] = PLACEHOLDER_BODY;
	                            }
	                        } else {
	                            walkTokens = this.$getDisplayTokens(
	                                lines[row].substring(lastColumn, column),
	                                tokens.length);
	                        }
	                        tokens = tokens.concat(walkTokens);
	                    }.bind(this),
	                    foldLine.end.row,
	                    lines[foldLine.end.row].length + 1
	                );

	                wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
	                row = foldLine.end.row + 1;
	            }
	        }
	    };
	    var CHAR = 1,
	        CHAR_EXT = 2,
	        PLACEHOLDER_START = 3,
	        PLACEHOLDER_BODY =  4,
	        PUNCTUATION = 9,
	        SPACE = 10,
	        TAB = 11,
	        TAB_SPACE = 12;


	    this.$computeWrapSplits = function(tokens, wrapLimit, tabSize) {
	        if (tokens.length == 0) {
	            return [];
	        }

	        var splits = [];
	        var displayLength = tokens.length;
	        var lastSplit = 0, lastDocSplit = 0;

	        var isCode = this.$wrapAsCode;

	        var indentedSoftWrap = this.$indentedSoftWrap;
	        var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8)
	            || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);

	        function getWrapIndent() {
	            var indentation = 0;
	            if (maxIndent === 0)
	                return indentation;
	            if (indentedSoftWrap) {
	                for (var i = 0; i < tokens.length; i++) {
	                    var token = tokens[i];
	                    if (token == SPACE)
	                        indentation += 1;
	                    else if (token == TAB)
	                        indentation += tabSize;
	                    else if (token == TAB_SPACE)
	                        continue;
	                    else
	                        break;
	                }
	            }
	            if (isCode && indentedSoftWrap !== false)
	                indentation += tabSize;
	            return Math.min(indentation, maxIndent);
	        }
	        function addSplit(screenPos) {
	            var displayed = tokens.slice(lastSplit, screenPos);
	            var len = displayed.length;
	            displayed.join("")
	                .replace(/12/g, function() {
	                    len -= 1;
	                })
	                .replace(/2/g, function() {
	                    len -= 1;
	                });

	            if (!splits.length) {
	                indent = getWrapIndent();
	                splits.indent = indent;
	            }
	            lastDocSplit += len;
	            splits.push(lastDocSplit);
	            lastSplit = screenPos;
	        }
	        var indent = 0;
	        while (displayLength - lastSplit > wrapLimit - indent) {
	            var split = lastSplit + wrapLimit - indent;
	            if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
	                addSplit(split);
	                continue;
	            }
	            if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
	                for (split; split != lastSplit - 1; split--) {
	                    if (tokens[split] == PLACEHOLDER_START) {
	                        break;
	                    }
	                }
	                if (split > lastSplit) {
	                    addSplit(split);
	                    continue;
	                }
	                split = lastSplit + wrapLimit;
	                for (split; split < tokens.length; split++) {
	                    if (tokens[split] != PLACEHOLDER_BODY) {
	                        break;
	                    }
	                }
	                if (split == tokens.length) {
	                    break;  // Breaks the while-loop.
	                }
	                addSplit(split);
	                continue;
	            }
	            var minSplit = Math.max(split - (wrapLimit -(wrapLimit>>2)), lastSplit - 1);
	            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
	                split --;
	            }
	            if (isCode) {
	                while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
	                    split --;
	                }
	                while (split > minSplit && tokens[split] == PUNCTUATION) {
	                    split --;
	                }
	            } else {
	                while (split > minSplit && tokens[split] < SPACE) {
	                    split --;
	                }
	            }
	            if (split > minSplit) {
	                addSplit(++split);
	                continue;
	            }
	            split = lastSplit + wrapLimit;
	            if (tokens[split] == CHAR_EXT)
	                split--;
	            addSplit(split - indent);
	        }
	        return splits;
	    };
	    this.$getDisplayTokens = function(str, offset) {
	        var arr = [];
	        var tabSize;
	        offset = offset || 0;

	        for (var i = 0; i < str.length; i++) {
	            var c = str.charCodeAt(i);
	            if (c == 9) {
	                tabSize = this.getScreenTabSize(arr.length + offset);
	                arr.push(TAB);
	                for (var n = 1; n < tabSize; n++) {
	                    arr.push(TAB_SPACE);
	                }
	            }
	            else if (c == 32) {
	                arr.push(SPACE);
	            } else if((c > 39 && c < 48) || (c > 57 && c < 64)) {
	                arr.push(PUNCTUATION);
	            }
	            else if (c >= 0x1100 && isFullWidth(c)) {
	                arr.push(CHAR, CHAR_EXT);
	            } else {
	                arr.push(CHAR);
	            }
	        }
	        return arr;
	    };
	    this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
	        if (maxScreenColumn == 0)
	            return [0, 0];
	        if (maxScreenColumn == null)
	            maxScreenColumn = Infinity;
	        screenColumn = screenColumn || 0;

	        var c, column;
	        for (column = 0; column < str.length; column++) {
	            c = str.charCodeAt(column);
	            if (c == 9) {
	                screenColumn += this.getScreenTabSize(screenColumn);
	            }
	            else if (c >= 0x1100 && isFullWidth(c)) {
	                screenColumn += 2;
	            } else {
	                screenColumn += 1;
	            }
	            if (screenColumn > maxScreenColumn) {
	                break;
	            }
	        }

	        return [screenColumn, column];
	    };

	    this.lineWidgets = null;
	    this.getRowLength = function(row) {
	        if (this.lineWidgets)
	            var h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
	        else 
	            h = 0
	        if (!this.$useWrapMode || !this.$wrapData[row]) {
	            return 1 + h;
	        } else {
	            return this.$wrapData[row].length + 1 + h;
	        }
	    };
	    this.getRowLineCount = function(row) {
	        if (!this.$useWrapMode || !this.$wrapData[row]) {
	            return 1;
	        } else {
	            return this.$wrapData[row].length + 1;
	        }
	    };

	    this.getRowWrapIndent = function(screenRow) {
	        if (this.$useWrapMode) {
	            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
	            var splits = this.$wrapData[pos.row];
	            return splits.length && splits[0] < pos.column ? splits.indent : 0;
	        } else {
	            return 0;
	        }
	    }
	    this.getScreenLastRowColumn = function(screenRow) {
	        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
	        return this.documentToScreenColumn(pos.row, pos.column);
	    };
	    this.getDocumentLastRowColumn = function(docRow, docColumn) {
	        var screenRow = this.documentToScreenRow(docRow, docColumn);
	        return this.getScreenLastRowColumn(screenRow);
	    };
	    this.getDocumentLastRowColumnPosition = function(docRow, docColumn) {
	        var screenRow = this.documentToScreenRow(docRow, docColumn);
	        return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
	    };
	    this.getRowSplitData = function(row) {
	        if (!this.$useWrapMode) {
	            return undefined;
	        } else {
	            return this.$wrapData[row];
	        }
	    };
	    this.getScreenTabSize = function(screenColumn) {
	        return this.$tabSize - screenColumn % this.$tabSize;
	    };


	    this.screenToDocumentRow = function(screenRow, screenColumn) {
	        return this.screenToDocumentPosition(screenRow, screenColumn).row;
	    };


	    this.screenToDocumentColumn = function(screenRow, screenColumn) {
	        return this.screenToDocumentPosition(screenRow, screenColumn).column;
	    };
	    this.screenToDocumentPosition = function(screenRow, screenColumn) {
	        if (screenRow < 0)
	            return {row: 0, column: 0};

	        var line;
	        var docRow = 0;
	        var docColumn = 0;
	        var column;
	        var row = 0;
	        var rowLength = 0;

	        var rowCache = this.$screenRowCache;
	        var i = this.$getRowCacheIndex(rowCache, screenRow);
	        var l = rowCache.length;
	        if (l && i >= 0) {
	            var row = rowCache[i];
	            var docRow = this.$docRowCache[i];
	            var doCache = screenRow > rowCache[l - 1];
	        } else {
	            var doCache = !l;
	        }

	        var maxRow = this.getLength() - 1;
	        var foldLine = this.getNextFoldLine(docRow);
	        var foldStart = foldLine ? foldLine.start.row : Infinity;

	        while (row <= screenRow) {
	            rowLength = this.getRowLength(docRow);
	            if (row + rowLength > screenRow || docRow >= maxRow) {
	                break;
	            } else {
	                row += rowLength;
	                docRow++;
	                if (docRow > foldStart) {
	                    docRow = foldLine.end.row+1;
	                    foldLine = this.getNextFoldLine(docRow, foldLine);
	                    foldStart = foldLine ? foldLine.start.row : Infinity;
	                }
	            }

	            if (doCache) {
	                this.$docRowCache.push(docRow);
	                this.$screenRowCache.push(row);
	            }
	        }

	        if (foldLine && foldLine.start.row <= docRow) {
	            line = this.getFoldDisplayLine(foldLine);
	            docRow = foldLine.start.row;
	        } else if (row + rowLength <= screenRow || docRow > maxRow) {
	            return {
	                row: maxRow,
	                column: this.getLine(maxRow).length
	            };
	        } else {
	            line = this.getLine(docRow);
	            foldLine = null;
	        }
	        var wrapIndent = 0;
	        if (this.$useWrapMode) {
	            var splits = this.$wrapData[docRow];
	            if (splits) {
	                var splitIndex = Math.floor(screenRow - row);
	                column = splits[splitIndex];
	                if(splitIndex > 0 && splits.length) {
	                    wrapIndent = splits.indent;
	                    docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
	                    line = line.substring(docColumn);
	                }
	            }
	        }

	        docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];
	        if (this.$useWrapMode && docColumn >= column)
	            docColumn = column - 1;

	        if (foldLine)
	            return foldLine.idxToPosition(docColumn);

	        return {row: docRow, column: docColumn};
	    };
	    this.documentToScreenPosition = function(docRow, docColumn) {
	        if (typeof docColumn === "undefined")
	            var pos = this.$clipPositionToDocument(docRow.row, docRow.column);
	        else
	            pos = this.$clipPositionToDocument(docRow, docColumn);

	        docRow = pos.row;
	        docColumn = pos.column;

	        var screenRow = 0;
	        var foldStartRow = null;
	        var fold = null;
	        fold = this.getFoldAt(docRow, docColumn, 1);
	        if (fold) {
	            docRow = fold.start.row;
	            docColumn = fold.start.column;
	        }

	        var rowEnd, row = 0;


	        var rowCache = this.$docRowCache;
	        var i = this.$getRowCacheIndex(rowCache, docRow);
	        var l = rowCache.length;
	        if (l && i >= 0) {
	            var row = rowCache[i];
	            var screenRow = this.$screenRowCache[i];
	            var doCache = docRow > rowCache[l - 1];
	        } else {
	            var doCache = !l;
	        }

	        var foldLine = this.getNextFoldLine(row);
	        var foldStart = foldLine ?foldLine.start.row :Infinity;

	        while (row < docRow) {
	            if (row >= foldStart) {
	                rowEnd = foldLine.end.row + 1;
	                if (rowEnd > docRow)
	                    break;
	                foldLine = this.getNextFoldLine(rowEnd, foldLine);
	                foldStart = foldLine ?foldLine.start.row :Infinity;
	            }
	            else {
	                rowEnd = row + 1;
	            }

	            screenRow += this.getRowLength(row);
	            row = rowEnd;

	            if (doCache) {
	                this.$docRowCache.push(row);
	                this.$screenRowCache.push(screenRow);
	            }
	        }
	        var textLine = "";
	        if (foldLine && row >= foldStart) {
	            textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
	            foldStartRow = foldLine.start.row;
	        } else {
	            textLine = this.getLine(docRow).substring(0, docColumn);
	            foldStartRow = docRow;
	        }
	        var wrapIndent = 0;
	        if (this.$useWrapMode) {
	            var wrapRow = this.$wrapData[foldStartRow];
	            if (wrapRow) {
	                var screenRowOffset = 0;
	                while (textLine.length >= wrapRow[screenRowOffset]) {
	                    screenRow ++;
	                    screenRowOffset++;
	                }
	                textLine = textLine.substring(
	                    wrapRow[screenRowOffset - 1] || 0, textLine.length
	                );
	                wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
	            }
	        }

	        return {
	            row: screenRow,
	            column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
	        };
	    };
	    this.documentToScreenColumn = function(row, docColumn) {
	        return this.documentToScreenPosition(row, docColumn).column;
	    };
	    this.documentToScreenRow = function(docRow, docColumn) {
	        return this.documentToScreenPosition(docRow, docColumn).row;
	    };
	    this.getScreenLength = function() {
	        var screenRows = 0;
	        var fold = null;
	        if (!this.$useWrapMode) {
	            screenRows = this.getLength();
	            var foldData = this.$foldData;
	            for (var i = 0; i < foldData.length; i++) {
	                fold = foldData[i];
	                screenRows -= fold.end.row - fold.start.row;
	            }
	        } else {
	            var lastRow = this.$wrapData.length;
	            var row = 0, i = 0;
	            var fold = this.$foldData[i++];
	            var foldStart = fold ? fold.start.row :Infinity;

	            while (row < lastRow) {
	                var splits = this.$wrapData[row];
	                screenRows += splits ? splits.length + 1 : 1;
	                row ++;
	                if (row > foldStart) {
	                    row = fold.end.row+1;
	                    fold = this.$foldData[i++];
	                    foldStart = fold ?fold.start.row :Infinity;
	                }
	            }
	        }
	        if (this.lineWidgets)
	            screenRows += this.$getWidgetScreenLength();

	        return screenRows;
	    };
	    this.$setFontMetrics = function(fm) {
	        if (!this.$enableVarChar) return;
	        this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
	            if (maxScreenColumn === 0)
	                return [0, 0];
	            if (!maxScreenColumn)
	                maxScreenColumn = Infinity;
	            screenColumn = screenColumn || 0;
	            
	            var c, column;
	            for (column = 0; column < str.length; column++) {
	                c = str.charAt(column);
	                if (c === "\t") {
	                    screenColumn += this.getScreenTabSize(screenColumn);
	                } else {
	                    screenColumn += fm.getCharacterWidth(c);
	                }
	                if (screenColumn > maxScreenColumn) {
	                    break;
	                }
	            }
	            
	            return [screenColumn, column];
	        };
	    };
	    
	    this.destroy = function() {
	        if (this.bgTokenizer) {
	            this.bgTokenizer.setDocument(null);
	            this.bgTokenizer = null;
	        }
	        this.$stopWorker();
	    };
	    function isFullWidth(c) {
	        if (c < 0x1100)
	            return false;
	        return c >= 0x1100 && c <= 0x115F ||
	               c >= 0x11A3 && c <= 0x11A7 ||
	               c >= 0x11FA && c <= 0x11FF ||
	               c >= 0x2329 && c <= 0x232A ||
	               c >= 0x2E80 && c <= 0x2E99 ||
	               c >= 0x2E9B && c <= 0x2EF3 ||
	               c >= 0x2F00 && c <= 0x2FD5 ||
	               c >= 0x2FF0 && c <= 0x2FFB ||
	               c >= 0x3000 && c <= 0x303E ||
	               c >= 0x3041 && c <= 0x3096 ||
	               c >= 0x3099 && c <= 0x30FF ||
	               c >= 0x3105 && c <= 0x312D ||
	               c >= 0x3131 && c <= 0x318E ||
	               c >= 0x3190 && c <= 0x31BA ||
	               c >= 0x31C0 && c <= 0x31E3 ||
	               c >= 0x31F0 && c <= 0x321E ||
	               c >= 0x3220 && c <= 0x3247 ||
	               c >= 0x3250 && c <= 0x32FE ||
	               c >= 0x3300 && c <= 0x4DBF ||
	               c >= 0x4E00 && c <= 0xA48C ||
	               c >= 0xA490 && c <= 0xA4C6 ||
	               c >= 0xA960 && c <= 0xA97C ||
	               c >= 0xAC00 && c <= 0xD7A3 ||
	               c >= 0xD7B0 && c <= 0xD7C6 ||
	               c >= 0xD7CB && c <= 0xD7FB ||
	               c >= 0xF900 && c <= 0xFAFF ||
	               c >= 0xFE10 && c <= 0xFE19 ||
	               c >= 0xFE30 && c <= 0xFE52 ||
	               c >= 0xFE54 && c <= 0xFE66 ||
	               c >= 0xFE68 && c <= 0xFE6B ||
	               c >= 0xFF01 && c <= 0xFF60 ||
	               c >= 0xFFE0 && c <= 0xFFE6;
	    }

	}).call(EditSession.prototype);

	acequire("./edit_session/folding").Folding.call(EditSession.prototype);
	acequire("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);


	config.defineOptions(EditSession.prototype, "session", {
	    wrap: {
	        set: function(value) {
	            if (!value || value == "off")
	                value = false;
	            else if (value == "free")
	                value = true;
	            else if (value == "printMargin")
	                value = -1;
	            else if (typeof value == "string")
	                value = parseInt(value, 10) || false;

	            if (this.$wrap == value)
	                return;
	            this.$wrap = value;
	            if (!value) {
	                this.setUseWrapMode(false);
	            } else {
	                var col = typeof value == "number" ? value : null;
	                this.setWrapLimitRange(col, col);
	                this.setUseWrapMode(true);
	            }
	        },
	        get: function() {
	            if (this.getUseWrapMode()) {
	                if (this.$wrap == -1)
	                    return "printMargin";
	                if (!this.getWrapLimitRange().min)
	                    return "free";
	                return this.$wrap;
	            }
	            return "off";
	        },
	        handlesSet: true
	    },    
	    wrapMethod: {
	        set: function(val) {
	            val = val == "auto"
	                ? this.$mode.type != "text"
	                : val != "text";
	            if (val != this.$wrapAsCode) {
	                this.$wrapAsCode = val;
	                if (this.$useWrapMode) {
	                    this.$modified = true;
	                    this.$resetRowCache(0);
	                    this.$updateWrapData(0, this.getLength() - 1);
	                }
	            }
	        },
	        initialValue: "auto"
	    },
	    indentedSoftWrap: { initialValue: true },
	    firstLineNumber: {
	        set: function() {this._signal("changeBreakpoint");},
	        initialValue: 1
	    },
	    useWorker: {
	        set: function(useWorker) {
	            this.$useWorker = useWorker;

	            this.$stopWorker();
	            if (useWorker)
	                this.$startWorker();
	        },
	        initialValue: true
	    },
	    useSoftTabs: {initialValue: true},
	    tabSize: {
	        set: function(tabSize) {
	            if (isNaN(tabSize) || this.$tabSize === tabSize) return;

	            this.$modified = true;
	            this.$rowLengthCache = [];
	            this.$tabSize = tabSize;
	            this._signal("changeTabSize");
	        },
	        initialValue: 4,
	        handlesSet: true
	    },
	    overwrite: {
	        set: function(val) {this._signal("changeOverwrite");},
	        initialValue: false
	    },
	    newLineMode: {
	        set: function(val) {this.doc.setNewLineMode(val)},
	        get: function() {return this.doc.getNewLineMode()},
	        handlesSet: true
	    },
	    mode: {
	        set: function(val) { this.setMode(val) },
	        get: function() { return this.$modeId }
	    }
	});

	exports.EditSession = EditSession;
	});

	ace.define("ace/search",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/range"], function(acequire, exports, module) {
	"use strict";

	var lang = acequire("./lib/lang");
	var oop = acequire("./lib/oop");
	var Range = acequire("./range").Range;

	var Search = function() {
	    this.$options = {};
	};

	(function() {
	    this.set = function(options) {
	        oop.mixin(this.$options, options);
	        return this;
	    };
	    this.getOptions = function() {
	        return lang.copyObject(this.$options);
	    };
	    this.setOptions = function(options) {
	        this.$options = options;
	    };
	    this.find = function(session) {
	        var options = this.$options;
	        var iterator = this.$matchIterator(session, options);
	        if (!iterator)
	            return false;

	        var firstRange = null;
	        iterator.forEach(function(range, row, offset) {
	            if (!range.start) {
	                var column = range.offset + (offset || 0);
	                firstRange = new Range(row, column, row, column + range.length);
	                if (!range.length && options.start && options.start.start
	                    && options.skipCurrent != false && firstRange.isEqual(options.start)
	                ) {
	                    firstRange = null;
	                    return false;
	                }
	            } else
	                firstRange = range;
	            return true;
	        });

	        return firstRange;
	    };
	    this.findAll = function(session) {
	        var options = this.$options;
	        if (!options.needle)
	            return [];
	        this.$assembleRegExp(options);

	        var range = options.range;
	        var lines = range
	            ? session.getLines(range.start.row, range.end.row)
	            : session.doc.getAllLines();

	        var ranges = [];
	        var re = options.re;
	        if (options.$isMultiLine) {
	            var len = re.length;
	            var maxRow = lines.length - len;
	            var prevRange;
	            outer: for (var row = re.offset || 0; row <= maxRow; row++) {
	                for (var j = 0; j < len; j++)
	                    if (lines[row + j].search(re[j]) == -1)
	                        continue outer;
	                
	                var startLine = lines[row];
	                var line = lines[row + len - 1];
	                var startIndex = startLine.length - startLine.match(re[0])[0].length;
	                var endIndex = line.match(re[len - 1])[0].length;
	                
	                if (prevRange && prevRange.end.row === row &&
	                    prevRange.end.column > startIndex
	                ) {
	                    continue;
	                }
	                ranges.push(prevRange = new Range(
	                    row, startIndex, row + len - 1, endIndex
	                ));
	                if (len > 2)
	                    row = row + len - 2;
	            }
	        } else {
	            for (var i = 0; i < lines.length; i++) {
	                var matches = lang.getMatchOffsets(lines[i], re);
	                for (var j = 0; j < matches.length; j++) {
	                    var match = matches[j];
	                    ranges.push(new Range(i, match.offset, i, match.offset + match.length));
	                }
	            }
	        }

	        if (range) {
	            var startColumn = range.start.column;
	            var endColumn = range.start.column;
	            var i = 0, j = ranges.length - 1;
	            while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row)
	                i++;

	            while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row)
	                j--;
	            
	            ranges = ranges.slice(i, j + 1);
	            for (i = 0, j = ranges.length; i < j; i++) {
	                ranges[i].start.row += range.start.row;
	                ranges[i].end.row += range.start.row;
	            }
	        }

	        return ranges;
	    };
	    this.replace = function(input, replacement) {
	        var options = this.$options;

	        var re = this.$assembleRegExp(options);
	        if (options.$isMultiLine)
	            return replacement;

	        if (!re)
	            return;

	        var match = re.exec(input);
	        if (!match || match[0].length != input.length)
	            return null;
	        
	        replacement = input.replace(re, replacement);
	        if (options.preserveCase) {
	            replacement = replacement.split("");
	            for (var i = Math.min(input.length, input.length); i--; ) {
	                var ch = input[i];
	                if (ch && ch.toLowerCase() != ch)
	                    replacement[i] = replacement[i].toUpperCase();
	                else
	                    replacement[i] = replacement[i].toLowerCase();
	            }
	            replacement = replacement.join("");
	        }
	        
	        return replacement;
	    };

	    this.$matchIterator = function(session, options) {
	        var re = this.$assembleRegExp(options);
	        if (!re)
	            return false;

	        var callback;
	        if (options.$isMultiLine) {
	            var len = re.length;
	            var matchIterator = function(line, row, offset) {
	                var startIndex = line.search(re[0]);
	                if (startIndex == -1)
	                    return;
	                for (var i = 1; i < len; i++) {
	                    line = session.getLine(row + i);
	                    if (line.search(re[i]) == -1)
	                        return;
	                }

	                var endIndex = line.match(re[len - 1])[0].length;

	                var range = new Range(row, startIndex, row + len - 1, endIndex);
	                if (re.offset == 1) {
	                    range.start.row--;
	                    range.start.column = Number.MAX_VALUE;
	                } else if (offset)
	                    range.start.column += offset;

	                if (callback(range))
	                    return true;
	            };
	        } else if (options.backwards) {
	            var matchIterator = function(line, row, startIndex) {
	                var matches = lang.getMatchOffsets(line, re);
	                for (var i = matches.length-1; i >= 0; i--)
	                    if (callback(matches[i], row, startIndex))
	                        return true;
	            };
	        } else {
	            var matchIterator = function(line, row, startIndex) {
	                var matches = lang.getMatchOffsets(line, re);
	                for (var i = 0; i < matches.length; i++)
	                    if (callback(matches[i], row, startIndex))
	                        return true;
	            };
	        }
	        
	        var lineIterator = this.$lineIterator(session, options);

	        return {
	            forEach: function(_callback) {
	                callback = _callback;
	                lineIterator.forEach(matchIterator);
	            }
	        };
	    };

	    this.$assembleRegExp = function(options, $disableFakeMultiline) {
	        if (options.needle instanceof RegExp)
	            return options.re = options.needle;

	        var needle = options.needle;

	        if (!options.needle)
	            return options.re = false;

	        if (!options.regExp)
	            needle = lang.escapeRegExp(needle);

	        if (options.wholeWord)
	            needle = "\\b" + needle + "\\b";

	        var modifier = options.caseSensitive ? "gm" : "gmi";

	        options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
	        if (options.$isMultiLine)
	            return options.re = this.$assembleMultilineRegExp(needle, modifier);

	        try {
	            var re = new RegExp(needle, modifier);
	        } catch(e) {
	            re = false;
	        }
	        return options.re = re;
	    };

	    this.$assembleMultilineRegExp = function(needle, modifier) {
	        var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
	        var re = [];
	        for (var i = 0; i < parts.length; i++) try {
	            re.push(new RegExp(parts[i], modifier));
	        } catch(e) {
	            return false;
	        }
	        if (parts[0] == "") {
	            re.shift();
	            re.offset = 1;
	        } else {
	            re.offset = 0;
	        }
	        return re;
	    };

	    this.$lineIterator = function(session, options) {
	        var backwards = options.backwards == true;
	        var skipCurrent = options.skipCurrent != false;

	        var range = options.range;
	        var start = options.start;
	        if (!start)
	            start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();
	         
	        if (start.start)
	            start = start[skipCurrent != backwards ? "end" : "start"];

	        var firstRow = range ? range.start.row : 0;
	        var lastRow = range ? range.end.row : session.getLength() - 1;

	        var forEach = backwards ? function(callback) {
	                var row = start.row;

	                var line = session.getLine(row).substring(0, start.column);
	                if (callback(line, row))
	                    return;

	                for (row--; row >= firstRow; row--)
	                    if (callback(session.getLine(row), row))
	                        return;

	                if (options.wrap == false)
	                    return;

	                for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
	                    if (callback(session.getLine(row), row))
	                        return;
	            } : function(callback) {
	                var row = start.row;

	                var line = session.getLine(row).substr(start.column);
	                if (callback(line, row, start.column))
	                    return;

	                for (row = row+1; row <= lastRow; row++)
	                    if (callback(session.getLine(row), row))
	                        return;

	                if (options.wrap == false)
	                    return;

	                for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
	                    if (callback(session.getLine(row), row))
	                        return;
	            };
	        
	        return {forEach: forEach};
	    };

	}).call(Search.prototype);

	exports.Search = Search;
	});

	ace.define("ace/keyboard/hash_handler",["require","exports","module","ace/lib/keys","ace/lib/useragent"], function(acequire, exports, module) {
	"use strict";

	var keyUtil = acequire("../lib/keys");
	var useragent = acequire("../lib/useragent");
	var KEY_MODS = keyUtil.KEY_MODS;

	function HashHandler(config, platform) {
	    this.platform = platform || (useragent.isMac ? "mac" : "win");
	    this.commands = {};
	    this.commandKeyBinding = {};
	    this.addCommands(config);
	    this.$singleCommand = true;
	}

	function MultiHashHandler(config, platform) {
	    HashHandler.call(this, config, platform);
	    this.$singleCommand = false;
	}

	MultiHashHandler.prototype = HashHandler.prototype;

	(function() {
	    

	    this.addCommand = function(command) {
	        if (this.commands[command.name])
	            this.removeCommand(command);

	        this.commands[command.name] = command;

	        if (command.bindKey)
	            this._buildKeyHash(command);
	    };

	    this.removeCommand = function(command, keepCommand) {
	        var name = command && (typeof command === 'string' ? command : command.name);
	        command = this.commands[name];
	        if (!keepCommand)
	            delete this.commands[name];
	        var ckb = this.commandKeyBinding;
	        for (var keyId in ckb) {
	            var cmdGroup = ckb[keyId];
	            if (cmdGroup == command) {
	                delete ckb[keyId];
	            } else if (Array.isArray(cmdGroup)) {
	                var i = cmdGroup.indexOf(command);
	                if (i != -1) {
	                    cmdGroup.splice(i, 1);
	                    if (cmdGroup.length == 1)
	                        ckb[keyId] = cmdGroup[0];
	                }
	            }
	        }
	    };

	    this.bindKey = function(key, command, position) {
	        if (typeof key == "object" && key) {
	            if (position == undefined)
	                position = key.position;
	            key = key[this.platform];
	        }
	        if (!key)
	            return;
	        if (typeof command == "function")
	            return this.addCommand({exec: command, bindKey: key, name: command.name || key});
	        
	        key.split("|").forEach(function(keyPart) {
	            var chain = "";
	            if (keyPart.indexOf(" ") != -1) {
	                var parts = keyPart.split(/\s+/);
	                keyPart = parts.pop();
	                parts.forEach(function(keyPart) {
	                    var binding = this.parseKeys(keyPart);
	                    var id = KEY_MODS[binding.hashId] + binding.key;
	                    chain += (chain ? " " : "") + id;
	                    this._addCommandToBinding(chain, "chainKeys");
	                }, this);
	                chain += " ";
	            }
	            var binding = this.parseKeys(keyPart);
	            var id = KEY_MODS[binding.hashId] + binding.key;
	            this._addCommandToBinding(chain + id, command, position);
	        }, this);
	    };
	    
	    function getPosition(command) {
	        return typeof command == "object" && command.bindKey
	            && command.bindKey.position || 0;
	    }
	    this._addCommandToBinding = function(keyId, command, position) {
	        var ckb = this.commandKeyBinding, i;
	        if (!command) {
	            delete ckb[keyId];
	        } else if (!ckb[keyId] || this.$singleCommand) {
	            ckb[keyId] = command;
	        } else {
	            if (!Array.isArray(ckb[keyId])) {
	                ckb[keyId] = [ckb[keyId]];
	            } else if ((i = ckb[keyId].indexOf(command)) != -1) {
	                ckb[keyId].splice(i, 1);
	            }

	            if (typeof position != "number") {
	                if (position || command.isDefault)
	                    position = -100;
	                else
	                   position = getPosition(command);
	            }
	            var commands = ckb[keyId];
	            for (i = 0; i < commands.length; i++) {
	                var other = commands[i];
	                var otherPos = getPosition(other);
	                if (otherPos > position)
	                    break;
	            }
	            commands.splice(i, 0, command);
	        }
	    };

	    this.addCommands = function(commands) {
	        commands && Object.keys(commands).forEach(function(name) {
	            var command = commands[name];
	            if (!command)
	                return;
	            
	            if (typeof command === "string")
	                return this.bindKey(command, name);

	            if (typeof command === "function")
	                command = { exec: command };

	            if (typeof command !== "object")
	                return;

	            if (!command.name)
	                command.name = name;

	            this.addCommand(command);
	        }, this);
	    };

	    this.removeCommands = function(commands) {
	        Object.keys(commands).forEach(function(name) {
	            this.removeCommand(commands[name]);
	        }, this);
	    };

	    this.bindKeys = function(keyList) {
	        Object.keys(keyList).forEach(function(key) {
	            this.bindKey(key, keyList[key]);
	        }, this);
	    };

	    this._buildKeyHash = function(command) {
	        this.bindKey(command.bindKey, command);
	    };
	    this.parseKeys = function(keys) {
	        var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x){return x});
	        var key = parts.pop();

	        var keyCode = keyUtil[key];
	        if (keyUtil.FUNCTION_KEYS[keyCode])
	            key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
	        else if (!parts.length)
	            return {key: key, hashId: -1};
	        else if (parts.length == 1 && parts[0] == "shift")
	            return {key: key.toUpperCase(), hashId: -1};

	        var hashId = 0;
	        for (var i = parts.length; i--;) {
	            var modifier = keyUtil.KEY_MODS[parts[i]];
	            if (modifier == null) {
	                if (typeof console != "undefined")
	                    console.error("invalid modifier " + parts[i] + " in " + keys);
	                return false;
	            }
	            hashId |= modifier;
	        }
	        return {key: key, hashId: hashId};
	    };

	    this.findKeyCommand = function findKeyCommand(hashId, keyString) {
	        var key = KEY_MODS[hashId] + keyString;
	        return this.commandKeyBinding[key];
	    };

	    this.handleKeyboard = function(data, hashId, keyString, keyCode) {
	        if (keyCode < 0) return;
	        var key = KEY_MODS[hashId] + keyString;
	        var command = this.commandKeyBinding[key];
	        if (data.$keyChain) {
	            data.$keyChain += " " + key;
	            command = this.commandKeyBinding[data.$keyChain] || command;
	        }
	        
	        if (command) {
	            if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
	                data.$keyChain = data.$keyChain || key;
	                return {command: "null"};
	            }
	        }
	        
	        if (data.$keyChain) {
	            if ((!hashId || hashId == 4) && keyString.length == 1)
	                data.$keyChain = data.$keyChain.slice(0, -key.length - 1); // wait for input
	            else if (hashId == -1 || keyCode > 0)
	                data.$keyChain = ""; // reset keyChain
	        }
	        return {command: command};
	    };
	    
	    this.getStatusText = function(editor, data) {
	        return data.$keyChain || "";
	    };

	}).call(HashHandler.prototype);

	exports.HashHandler = HashHandler;
	exports.MultiHashHandler = MultiHashHandler;
	});

	ace.define("ace/commands/command_manager",["require","exports","module","ace/lib/oop","ace/keyboard/hash_handler","ace/lib/event_emitter"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../lib/oop");
	var MultiHashHandler = acequire("../keyboard/hash_handler").MultiHashHandler;
	var EventEmitter = acequire("../lib/event_emitter").EventEmitter;

	var CommandManager = function(platform, commands) {
	    MultiHashHandler.call(this, commands, platform);
	    this.byName = this.commands;
	    this.setDefaultHandler("exec", function(e) {
	        return e.command.exec(e.editor, e.args || {});
	    });
	};

	oop.inherits(CommandManager, MultiHashHandler);

	(function() {

	    oop.implement(this, EventEmitter);

	    this.exec = function(command, editor, args) {
	        if (Array.isArray(command)) {
	            for (var i = command.length; i--; ) {
	                if (this.exec(command[i], editor, args)) return true;
	            }
	            return false;
	        }
	        
	        if (typeof command === "string")
	            command = this.commands[command];

	        if (!command)
	            return false;

	        if (editor && editor.$readOnly && !command.readOnly)
	            return false;

	        var e = {editor: editor, command: command, args: args};
	        e.returnValue = this._emit("exec", e);
	        this._signal("afterExec", e);

	        return e.returnValue === false ? false : true;
	    };

	    this.toggleRecording = function(editor) {
	        if (this.$inReplay)
	            return;

	        editor && editor._emit("changeStatus");
	        if (this.recording) {
	            this.macro.pop();
	            this.removeEventListener("exec", this.$addCommandToMacro);

	            if (!this.macro.length)
	                this.macro = this.oldMacro;

	            return this.recording = false;
	        }
	        if (!this.$addCommandToMacro) {
	            this.$addCommandToMacro = function(e) {
	                this.macro.push([e.command, e.args]);
	            }.bind(this);
	        }

	        this.oldMacro = this.macro;
	        this.macro = [];
	        this.on("exec", this.$addCommandToMacro);
	        return this.recording = true;
	    };

	    this.replay = function(editor) {
	        if (this.$inReplay || !this.macro)
	            return;

	        if (this.recording)
	            return this.toggleRecording(editor);

	        try {
	            this.$inReplay = true;
	            this.macro.forEach(function(x) {
	                if (typeof x == "string")
	                    this.exec(x, editor);
	                else
	                    this.exec(x[0], editor, x[1]);
	            }, this);
	        } finally {
	            this.$inReplay = false;
	        }
	    };

	    this.trimMacro = function(m) {
	        return m.map(function(x){
	            if (typeof x[0] != "string")
	                x[0] = x[0].name;
	            if (!x[1])
	                x = x[0];
	            return x;
	        });
	    };

	}).call(CommandManager.prototype);

	exports.CommandManager = CommandManager;

	});

	ace.define("ace/commands/default_commands",["require","exports","module","ace/lib/lang","ace/config","ace/range"], function(acequire, exports, module) {
	"use strict";

	var lang = acequire("../lib/lang");
	var config = acequire("../config");
	var Range = acequire("../range").Range;

	function bindKey(win, mac) {
	    return {win: win, mac: mac};
	}
	exports.commands = [{
	    name: "showSettingsMenu",
	    bindKey: bindKey("Ctrl-,", "Command-,"),
	    exec: function(editor) {
	        config.loadModule("ace/ext/settings_menu", function(module) {
	            module.init(editor);
	            editor.showSettingsMenu();
	        });
	    },
	    readOnly: true
	}, {
	    name: "goToNextError",
	    bindKey: bindKey("Alt-E", "Ctrl-E"),
	    exec: function(editor) {
	        config.loadModule("ace/ext/error_marker", function(module) {
	            module.showErrorMarker(editor, 1);
	        });
	    },
	    scrollIntoView: "animate",
	    readOnly: true
	}, {
	    name: "goToPreviousError",
	    bindKey: bindKey("Alt-Shift-E", "Ctrl-Shift-E"),
	    exec: function(editor) {
	        config.loadModule("ace/ext/error_marker", function(module) {
	            module.showErrorMarker(editor, -1);
	        });
	    },
	    scrollIntoView: "animate",
	    readOnly: true
	}, {
	    name: "selectall",
	    bindKey: bindKey("Ctrl-A", "Command-A"),
	    exec: function(editor) { editor.selectAll(); },
	    readOnly: true
	}, {
	    name: "centerselection",
	    bindKey: bindKey(null, "Ctrl-L"),
	    exec: function(editor) { editor.centerSelection(); },
	    readOnly: true
	}, {
	    name: "gotoline",
	    bindKey: bindKey("Ctrl-L", "Command-L"),
	    exec: function(editor) {
	        var line = parseInt(prompt("Enter line number:"), 10);
	        if (!isNaN(line)) {
	            editor.gotoLine(line);
	        }
	    },
	    readOnly: true
	}, {
	    name: "fold",
	    bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
	    exec: function(editor) { editor.session.toggleFold(false); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "center",
	    readOnly: true
	}, {
	    name: "unfold",
	    bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
	    exec: function(editor) { editor.session.toggleFold(true); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "center",
	    readOnly: true
	}, {
	    name: "toggleFoldWidget",
	    bindKey: bindKey("F2", "F2"),
	    exec: function(editor) { editor.session.toggleFoldWidget(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "center",
	    readOnly: true
	}, {
	    name: "toggleParentFoldWidget",
	    bindKey: bindKey("Alt-F2", "Alt-F2"),
	    exec: function(editor) { editor.session.toggleFoldWidget(true); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "center",
	    readOnly: true
	}, {
	    name: "foldall",
	    bindKey: bindKey(null, "Ctrl-Command-Option-0"),
	    exec: function(editor) { editor.session.foldAll(); },
	    scrollIntoView: "center",
	    readOnly: true
	}, {
	    name: "foldOther",
	    bindKey: bindKey("Alt-0", "Command-Option-0"),
	    exec: function(editor) { 
	        editor.session.foldAll();
	        editor.session.unfold(editor.selection.getAllRanges());
	    },
	    scrollIntoView: "center",
	    readOnly: true
	}, {
	    name: "unfoldall",
	    bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
	    exec: function(editor) { editor.session.unfold(); },
	    scrollIntoView: "center",
	    readOnly: true
	}, {
	    name: "findnext",
	    bindKey: bindKey("Ctrl-K", "Command-G"),
	    exec: function(editor) { editor.findNext(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "center",
	    readOnly: true
	}, {
	    name: "findprevious",
	    bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
	    exec: function(editor) { editor.findPrevious(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "center",
	    readOnly: true
	}, {
	    name: "selectOrFindNext",
	    bindKey: bindKey("Alt-K", "Ctrl-G"),
	    exec: function(editor) {
	        if (editor.selection.isEmpty())
	            editor.selection.selectWord();
	        else
	            editor.findNext(); 
	    },
	    readOnly: true
	}, {
	    name: "selectOrFindPrevious",
	    bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
	    exec: function(editor) { 
	        if (editor.selection.isEmpty())
	            editor.selection.selectWord();
	        else
	            editor.findPrevious();
	    },
	    readOnly: true
	}, {
	    name: "find",
	    bindKey: bindKey("Ctrl-F", "Command-F"),
	    exec: function(editor) {
	        config.loadModule("ace/ext/searchbox", function(e) {e.Search(editor)});
	    },
	    readOnly: true
	}, {
	    name: "overwrite",
	    bindKey: "Insert",
	    exec: function(editor) { editor.toggleOverwrite(); },
	    readOnly: true
	}, {
	    name: "selecttostart",
	    bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Up"),
	    exec: function(editor) { editor.getSelection().selectFileStart(); },
	    multiSelectAction: "forEach",
	    readOnly: true,
	    scrollIntoView: "animate",
	    aceCommandGroup: "fileJump"
	}, {
	    name: "gotostart",
	    bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
	    exec: function(editor) { editor.navigateFileStart(); },
	    multiSelectAction: "forEach",
	    readOnly: true,
	    scrollIntoView: "animate",
	    aceCommandGroup: "fileJump"
	}, {
	    name: "selectup",
	    bindKey: bindKey("Shift-Up", "Shift-Up"),
	    exec: function(editor) { editor.getSelection().selectUp(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "golineup",
	    bindKey: bindKey("Up", "Up|Ctrl-P"),
	    exec: function(editor, args) { editor.navigateUp(args.times); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selecttoend",
	    bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-Down"),
	    exec: function(editor) { editor.getSelection().selectFileEnd(); },
	    multiSelectAction: "forEach",
	    readOnly: true,
	    scrollIntoView: "animate",
	    aceCommandGroup: "fileJump"
	}, {
	    name: "gotoend",
	    bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
	    exec: function(editor) { editor.navigateFileEnd(); },
	    multiSelectAction: "forEach",
	    readOnly: true,
	    scrollIntoView: "animate",
	    aceCommandGroup: "fileJump"
	}, {
	    name: "selectdown",
	    bindKey: bindKey("Shift-Down", "Shift-Down"),
	    exec: function(editor) { editor.getSelection().selectDown(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "golinedown",
	    bindKey: bindKey("Down", "Down|Ctrl-N"),
	    exec: function(editor, args) { editor.navigateDown(args.times); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selectwordleft",
	    bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
	    exec: function(editor) { editor.getSelection().selectWordLeft(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "gotowordleft",
	    bindKey: bindKey("Ctrl-Left", "Option-Left"),
	    exec: function(editor) { editor.navigateWordLeft(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selecttolinestart",
	    bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left"),
	    exec: function(editor) { editor.getSelection().selectLineStart(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "gotolinestart",
	    bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
	    exec: function(editor) { editor.navigateLineStart(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selectleft",
	    bindKey: bindKey("Shift-Left", "Shift-Left"),
	    exec: function(editor) { editor.getSelection().selectLeft(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "gotoleft",
	    bindKey: bindKey("Left", "Left|Ctrl-B"),
	    exec: function(editor, args) { editor.navigateLeft(args.times); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selectwordright",
	    bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
	    exec: function(editor) { editor.getSelection().selectWordRight(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "gotowordright",
	    bindKey: bindKey("Ctrl-Right", "Option-Right"),
	    exec: function(editor) { editor.navigateWordRight(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selecttolineend",
	    bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right"),
	    exec: function(editor) { editor.getSelection().selectLineEnd(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "gotolineend",
	    bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
	    exec: function(editor) { editor.navigateLineEnd(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selectright",
	    bindKey: bindKey("Shift-Right", "Shift-Right"),
	    exec: function(editor) { editor.getSelection().selectRight(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "gotoright",
	    bindKey: bindKey("Right", "Right|Ctrl-F"),
	    exec: function(editor, args) { editor.navigateRight(args.times); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selectpagedown",
	    bindKey: "Shift-PageDown",
	    exec: function(editor) { editor.selectPageDown(); },
	    readOnly: true
	}, {
	    name: "pagedown",
	    bindKey: bindKey(null, "Option-PageDown"),
	    exec: function(editor) { editor.scrollPageDown(); },
	    readOnly: true
	}, {
	    name: "gotopagedown",
	    bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
	    exec: function(editor) { editor.gotoPageDown(); },
	    readOnly: true
	}, {
	    name: "selectpageup",
	    bindKey: "Shift-PageUp",
	    exec: function(editor) { editor.selectPageUp(); },
	    readOnly: true
	}, {
	    name: "pageup",
	    bindKey: bindKey(null, "Option-PageUp"),
	    exec: function(editor) { editor.scrollPageUp(); },
	    readOnly: true
	}, {
	    name: "gotopageup",
	    bindKey: "PageUp",
	    exec: function(editor) { editor.gotoPageUp(); },
	    readOnly: true
	}, {
	    name: "scrollup",
	    bindKey: bindKey("Ctrl-Up", null),
	    exec: function(e) { e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight); },
	    readOnly: true
	}, {
	    name: "scrolldown",
	    bindKey: bindKey("Ctrl-Down", null),
	    exec: function(e) { e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight); },
	    readOnly: true
	}, {
	    name: "selectlinestart",
	    bindKey: "Shift-Home",
	    exec: function(editor) { editor.getSelection().selectLineStart(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selectlineend",
	    bindKey: "Shift-End",
	    exec: function(editor) { editor.getSelection().selectLineEnd(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "togglerecording",
	    bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
	    exec: function(editor) { editor.commands.toggleRecording(editor); },
	    readOnly: true
	}, {
	    name: "replaymacro",
	    bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
	    exec: function(editor) { editor.commands.replay(editor); },
	    readOnly: true
	}, {
	    name: "jumptomatching",
	    bindKey: bindKey("Ctrl-P", "Ctrl-P"),
	    exec: function(editor) { editor.jumpToMatching(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "animate",
	    readOnly: true
	}, {
	    name: "selecttomatching",
	    bindKey: bindKey("Ctrl-Shift-P", "Ctrl-Shift-P"),
	    exec: function(editor) { editor.jumpToMatching(true); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "animate",
	    readOnly: true
	}, {
	    name: "expandToMatching",
	    bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
	    exec: function(editor) { editor.jumpToMatching(true, true); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "animate",
	    readOnly: true
	}, {
	    name: "passKeysToBrowser",
	    bindKey: bindKey(null, null),
	    exec: function() {},
	    passEvent: true,
	    readOnly: true
	}, {
	    name: "copy",
	    exec: function(editor) {
	    },
	    readOnly: true
	},
	{
	    name: "cut",
	    exec: function(editor) {
	        var range = editor.getSelectionRange();
	        editor._emit("cut", range);

	        if (!editor.selection.isEmpty()) {
	            editor.session.remove(range);
	            editor.clearSelection();
	        }
	    },
	    scrollIntoView: "cursor",
	    multiSelectAction: "forEach"
	}, {
	    name: "paste",
	    exec: function(editor, args) {
	        editor.$handlePaste(args);
	    },
	    scrollIntoView: "cursor"
	}, {
	    name: "removeline",
	    bindKey: bindKey("Ctrl-D", "Command-D"),
	    exec: function(editor) { editor.removeLines(); },
	    scrollIntoView: "cursor",
	    multiSelectAction: "forEachLine"
	}, {
	    name: "duplicateSelection",
	    bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
	    exec: function(editor) { editor.duplicateSelection(); },
	    scrollIntoView: "cursor",
	    multiSelectAction: "forEach"
	}, {
	    name: "sortlines",
	    bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
	    exec: function(editor) { editor.sortLines(); },
	    scrollIntoView: "selection",
	    multiSelectAction: "forEachLine"
	}, {
	    name: "togglecomment",
	    bindKey: bindKey("Ctrl-/", "Command-/"),
	    exec: function(editor) { editor.toggleCommentLines(); },
	    multiSelectAction: "forEachLine",
	    scrollIntoView: "selectionPart"
	}, {
	    name: "toggleBlockComment",
	    bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
	    exec: function(editor) { editor.toggleBlockComment(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "selectionPart"
	}, {
	    name: "modifyNumberUp",
	    bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
	    exec: function(editor) { editor.modifyNumber(1); },
	    scrollIntoView: "cursor",
	    multiSelectAction: "forEach"
	}, {
	    name: "modifyNumberDown",
	    bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
	    exec: function(editor) { editor.modifyNumber(-1); },
	    scrollIntoView: "cursor",
	    multiSelectAction: "forEach"
	}, {
	    name: "replace",
	    bindKey: bindKey("Ctrl-H", "Command-Option-F"),
	    exec: function(editor) {
	        config.loadModule("ace/ext/searchbox", function(e) {e.Search(editor, true)});
	    }
	}, {
	    name: "undo",
	    bindKey: bindKey("Ctrl-Z", "Command-Z"),
	    exec: function(editor) { editor.undo(); }
	}, {
	    name: "redo",
	    bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
	    exec: function(editor) { editor.redo(); }
	}, {
	    name: "copylinesup",
	    bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
	    exec: function(editor) { editor.copyLinesUp(); },
	    scrollIntoView: "cursor"
	}, {
	    name: "movelinesup",
	    bindKey: bindKey("Alt-Up", "Option-Up"),
	    exec: function(editor) { editor.moveLinesUp(); },
	    scrollIntoView: "cursor"
	}, {
	    name: "copylinesdown",
	    bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
	    exec: function(editor) { editor.copyLinesDown(); },
	    scrollIntoView: "cursor"
	}, {
	    name: "movelinesdown",
	    bindKey: bindKey("Alt-Down", "Option-Down"),
	    exec: function(editor) { editor.moveLinesDown(); },
	    scrollIntoView: "cursor"
	}, {
	    name: "del",
	    bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
	    exec: function(editor) { editor.remove("right"); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "backspace",
	    bindKey: bindKey(
	        "Shift-Backspace|Backspace",
	        "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"
	    ),
	    exec: function(editor) { editor.remove("left"); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "cut_or_delete",
	    bindKey: bindKey("Shift-Delete", null),
	    exec: function(editor) { 
	        if (editor.selection.isEmpty()) {
	            editor.remove("left");
	        } else {
	            return false;
	        }
	    },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "removetolinestart",
	    bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
	    exec: function(editor) { editor.removeToLineStart(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "removetolineend",
	    bindKey: bindKey("Alt-Delete", "Ctrl-K"),
	    exec: function(editor) { editor.removeToLineEnd(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "removewordleft",
	    bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
	    exec: function(editor) { editor.removeWordLeft(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "removewordright",
	    bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
	    exec: function(editor) { editor.removeWordRight(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "outdent",
	    bindKey: bindKey("Shift-Tab", "Shift-Tab"),
	    exec: function(editor) { editor.blockOutdent(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "selectionPart"
	}, {
	    name: "indent",
	    bindKey: bindKey("Tab", "Tab"),
	    exec: function(editor) { editor.indent(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "selectionPart"
	}, {
	    name: "blockoutdent",
	    bindKey: bindKey("Ctrl-[", "Ctrl-["),
	    exec: function(editor) { editor.blockOutdent(); },
	    multiSelectAction: "forEachLine",
	    scrollIntoView: "selectionPart"
	}, {
	    name: "blockindent",
	    bindKey: bindKey("Ctrl-]", "Ctrl-]"),
	    exec: function(editor) { editor.blockIndent(); },
	    multiSelectAction: "forEachLine",
	    scrollIntoView: "selectionPart"
	}, {
	    name: "insertstring",
	    exec: function(editor, str) { editor.insert(str); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "inserttext",
	    exec: function(editor, args) {
	        editor.insert(lang.stringRepeat(args.text  || "", args.times || 1));
	    },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "splitline",
	    bindKey: bindKey(null, "Ctrl-O"),
	    exec: function(editor) { editor.splitLine(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "transposeletters",
	    bindKey: bindKey("Ctrl-T", "Ctrl-T"),
	    exec: function(editor) { editor.transposeLetters(); },
	    multiSelectAction: function(editor) {editor.transposeSelections(1); },
	    scrollIntoView: "cursor"
	}, {
	    name: "touppercase",
	    bindKey: bindKey("Ctrl-U", "Ctrl-U"),
	    exec: function(editor) { editor.toUpperCase(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "tolowercase",
	    bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
	    exec: function(editor) { editor.toLowerCase(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "expandtoline",
	    bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
	    exec: function(editor) {
	        var range = editor.selection.getRange();

	        range.start.column = range.end.column = 0;
	        range.end.row++;
	        editor.selection.setRange(range, false);
	    },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "joinlines",
	    bindKey: bindKey(null, null),
	    exec: function(editor) {
	        var isBackwards = editor.selection.isBackwards();
	        var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
	        var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
	        var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
	        var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
	        var selectedCount = selectedText.replace(/\n\s*/, " ").length;
	        var insertLine = editor.session.doc.getLine(selectionStart.row);

	        for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {
	            var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));
	            if (curLine.length !== 0) {
	                curLine = " " + curLine;
	            }
	            insertLine += curLine;
	        }

	        if (selectionEnd.row + 1 < (editor.session.doc.getLength() - 1)) {
	            insertLine += editor.session.doc.getNewLineCharacter();
	        }

	        editor.clearSelection();
	        editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);

	        if (selectedCount > 0) {
	            editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
	            editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
	        } else {
	            firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? (firstLineEndCol + 1) : firstLineEndCol;
	            editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
	        }
	    },
	    multiSelectAction: "forEach",
	    readOnly: true
	}, {
	    name: "invertSelection",
	    bindKey: bindKey(null, null),
	    exec: function(editor) {
	        var endRow = editor.session.doc.getLength() - 1;
	        var endCol = editor.session.doc.getLine(endRow).length;
	        var ranges = editor.selection.rangeList.ranges;
	        var newRanges = [];
	        if (ranges.length < 1) {
	            ranges = [editor.selection.getRange()];
	        }

	        for (var i = 0; i < ranges.length; i++) {
	            if (i == (ranges.length - 1)) {
	                if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {
	                    newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
	                }
	            }

	            if (i === 0) {
	                if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {
	                    newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));
	                }
	            } else {
	                newRanges.push(new Range(ranges[i-1].end.row, ranges[i-1].end.column, ranges[i].start.row, ranges[i].start.column));
	            }
	        }

	        editor.exitMultiSelectMode();
	        editor.clearSelection();

	        for(var i = 0; i < newRanges.length; i++) {
	            editor.selection.addRange(newRanges[i], false);
	        }
	    },
	    readOnly: true,
	    scrollIntoView: "none"
	}];

	});

	ace.define("ace/editor",["require","exports","module","ace/lib/fixoldbrowsers","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/useragent","ace/keyboard/textinput","ace/mouse/mouse_handler","ace/mouse/fold_handler","ace/keyboard/keybinding","ace/edit_session","ace/search","ace/range","ace/lib/event_emitter","ace/commands/command_manager","ace/commands/default_commands","ace/config","ace/token_iterator"], function(acequire, exports, module) {
	"use strict";

	acequire("./lib/fixoldbrowsers");

	var oop = acequire("./lib/oop");
	var dom = acequire("./lib/dom");
	var lang = acequire("./lib/lang");
	var useragent = acequire("./lib/useragent");
	var TextInput = acequire("./keyboard/textinput").TextInput;
	var MouseHandler = acequire("./mouse/mouse_handler").MouseHandler;
	var FoldHandler = acequire("./mouse/fold_handler").FoldHandler;
	var KeyBinding = acequire("./keyboard/keybinding").KeyBinding;
	var EditSession = acequire("./edit_session").EditSession;
	var Search = acequire("./search").Search;
	var Range = acequire("./range").Range;
	var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
	var CommandManager = acequire("./commands/command_manager").CommandManager;
	var defaultCommands = acequire("./commands/default_commands").commands;
	var config = acequire("./config");
	var TokenIterator = acequire("./token_iterator").TokenIterator;
	var Editor = function(renderer, session) {
	    var container = renderer.getContainerElement();
	    this.container = container;
	    this.renderer = renderer;

	    this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
	    this.textInput  = new TextInput(renderer.getTextAreaContainer(), this);
	    this.renderer.textarea = this.textInput.getElement();
	    this.keyBinding = new KeyBinding(this);
	    this.$mouseHandler = new MouseHandler(this);
	    new FoldHandler(this);

	    this.$blockScrolling = 0;
	    this.$search = new Search().set({
	        wrap: true
	    });

	    this.$historyTracker = this.$historyTracker.bind(this);
	    this.commands.on("exec", this.$historyTracker);

	    this.$initOperationListeners();
	    
	    this._$emitInputEvent = lang.delayedCall(function() {
	        this._signal("input", {});
	        if (this.session && this.session.bgTokenizer)
	            this.session.bgTokenizer.scheduleStart();
	    }.bind(this));
	    
	    this.on("change", function(_, _self) {
	        _self._$emitInputEvent.schedule(31);
	    });

	    this.setSession(session || new EditSession(""));
	    config.resetOptions(this);
	    config._signal("editor", this);
	};

	(function(){

	    oop.implement(this, EventEmitter);

	    this.$initOperationListeners = function() {
	        function last(a) {return a[a.length - 1]}

	        this.selections = [];
	        this.commands.on("exec", this.startOperation.bind(this), true);
	        this.commands.on("afterExec", this.endOperation.bind(this), true);

	        this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this));

	        this.on("change", function() {
	            this.curOp || this.startOperation();
	            this.curOp.docChanged = true;
	        }.bind(this), true);

	        this.on("changeSelection", function() {
	            this.curOp || this.startOperation();
	            this.curOp.selectionChanged = true;
	        }.bind(this), true);
	    };

	    this.curOp = null;
	    this.prevOp = {};
	    this.startOperation = function(commadEvent) {
	        if (this.curOp) {
	            if (!commadEvent || this.curOp.command)
	                return;
	            this.prevOp = this.curOp;
	        }
	        if (!commadEvent) {
	            this.previousCommand = null;
	            commadEvent = {};
	        }

	        this.$opResetTimer.schedule();
	        this.curOp = {
	            command: commadEvent.command || {},
	            args: commadEvent.args,
	            scrollTop: this.renderer.scrollTop
	        };
	        if (this.curOp.command.name && this.curOp.command.scrollIntoView !== undefined)
	            this.$blockScrolling++;
	    };

	    this.endOperation = function(e) {
	        if (this.curOp) {
	            if (e && e.returnValue === false)
	                return this.curOp = null;
	            this._signal("beforeEndOperation");
	            var command = this.curOp.command;
	            if (command.name && this.$blockScrolling > 0)
	                this.$blockScrolling--;
	            var scrollIntoView = command && command.scrollIntoView;
	            if (scrollIntoView) {
	                switch (scrollIntoView) {
	                    case "center-animate":
	                        scrollIntoView = "animate";
	                    case "center":
	                        this.renderer.scrollCursorIntoView(null, 0.5);
	                        break;
	                    case "animate":
	                    case "cursor":
	                        this.renderer.scrollCursorIntoView();
	                        break;
	                    case "selectionPart":
	                        var range = this.selection.getRange();
	                        var config = this.renderer.layerConfig;
	                        if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {
	                            this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
	                        }
	                        break;
	                    default:
	                        break;
	                }
	                if (scrollIntoView == "animate")
	                    this.renderer.animateScrolling(this.curOp.scrollTop);
	            }
	            
	            this.prevOp = this.curOp;
	            this.curOp = null;
	        }
	    };
	    this.$mergeableCommands = ["backspace", "del", "insertstring"];
	    this.$historyTracker = function(e) {
	        if (!this.$mergeUndoDeltas)
	            return;

	        var prev = this.prevOp;
	        var mergeableCommands = this.$mergeableCommands;
	        var shouldMerge = prev.command && (e.command.name == prev.command.name);
	        if (e.command.name == "insertstring") {
	            var text = e.args;
	            if (this.mergeNextCommand === undefined)
	                this.mergeNextCommand = true;

	            shouldMerge = shouldMerge
	                && this.mergeNextCommand // previous command allows to coalesce with
	                && (!/\s/.test(text) || /\s/.test(prev.args)); // previous insertion was of same type

	            this.mergeNextCommand = true;
	        } else {
	            shouldMerge = shouldMerge
	                && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable
	        }

	        if (
	            this.$mergeUndoDeltas != "always"
	            && Date.now() - this.sequenceStartTime > 2000
	        ) {
	            shouldMerge = false; // the sequence is too long
	        }

	        if (shouldMerge)
	            this.session.mergeUndoDeltas = true;
	        else if (mergeableCommands.indexOf(e.command.name) !== -1)
	            this.sequenceStartTime = Date.now();
	    };
	    this.setKeyboardHandler = function(keyboardHandler, cb) {
	        if (keyboardHandler && typeof keyboardHandler === "string") {
	            this.$keybindingId = keyboardHandler;
	            var _self = this;
	            config.loadModule(["keybinding", keyboardHandler], function(module) {
	                if (_self.$keybindingId == keyboardHandler)
	                    _self.keyBinding.setKeyboardHandler(module && module.handler);
	                cb && cb();
	            });
	        } else {
	            this.$keybindingId = null;
	            this.keyBinding.setKeyboardHandler(keyboardHandler);
	            cb && cb();
	        }
	    };
	    this.getKeyboardHandler = function() {
	        return this.keyBinding.getKeyboardHandler();
	    };
	    this.setSession = function(session) {
	        if (this.session == session)
	            return;
	        if (this.curOp) this.endOperation();
	        this.curOp = {};

	        var oldSession = this.session;
	        if (oldSession) {
	            this.session.off("change", this.$onDocumentChange);
	            this.session.off("changeMode", this.$onChangeMode);
	            this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
	            this.session.off("changeTabSize", this.$onChangeTabSize);
	            this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
	            this.session.off("changeWrapMode", this.$onChangeWrapMode);
	            this.session.off("changeFold", this.$onChangeFold);
	            this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
	            this.session.off("changeBackMarker", this.$onChangeBackMarker);
	            this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
	            this.session.off("changeAnnotation", this.$onChangeAnnotation);
	            this.session.off("changeOverwrite", this.$onCursorChange);
	            this.session.off("changeScrollTop", this.$onScrollTopChange);
	            this.session.off("changeScrollLeft", this.$onScrollLeftChange);

	            var selection = this.session.getSelection();
	            selection.off("changeCursor", this.$onCursorChange);
	            selection.off("changeSelection", this.$onSelectionChange);
	        }

	        this.session = session;
	        if (session) {
	            this.$onDocumentChange = this.onDocumentChange.bind(this);
	            session.on("change", this.$onDocumentChange);
	            this.renderer.setSession(session);
	    
	            this.$onChangeMode = this.onChangeMode.bind(this);
	            session.on("changeMode", this.$onChangeMode);
	    
	            this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
	            session.on("tokenizerUpdate", this.$onTokenizerUpdate);
	    
	            this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
	            session.on("changeTabSize", this.$onChangeTabSize);
	    
	            this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
	            session.on("changeWrapLimit", this.$onChangeWrapLimit);
	    
	            this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
	            session.on("changeWrapMode", this.$onChangeWrapMode);
	    
	            this.$onChangeFold = this.onChangeFold.bind(this);
	            session.on("changeFold", this.$onChangeFold);
	    
	            this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
	            this.session.on("changeFrontMarker", this.$onChangeFrontMarker);
	    
	            this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
	            this.session.on("changeBackMarker", this.$onChangeBackMarker);
	    
	            this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
	            this.session.on("changeBreakpoint", this.$onChangeBreakpoint);
	    
	            this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
	            this.session.on("changeAnnotation", this.$onChangeAnnotation);
	    
	            this.$onCursorChange = this.onCursorChange.bind(this);
	            this.session.on("changeOverwrite", this.$onCursorChange);
	    
	            this.$onScrollTopChange = this.onScrollTopChange.bind(this);
	            this.session.on("changeScrollTop", this.$onScrollTopChange);
	    
	            this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
	            this.session.on("changeScrollLeft", this.$onScrollLeftChange);
	    
	            this.selection = session.getSelection();
	            this.selection.on("changeCursor", this.$onCursorChange);
	    
	            this.$onSelectionChange = this.onSelectionChange.bind(this);
	            this.selection.on("changeSelection", this.$onSelectionChange);
	    
	            this.onChangeMode();
	    
	            this.$blockScrolling += 1;
	            this.onCursorChange();
	            this.$blockScrolling -= 1;
	    
	            this.onScrollTopChange();
	            this.onScrollLeftChange();
	            this.onSelectionChange();
	            this.onChangeFrontMarker();
	            this.onChangeBackMarker();
	            this.onChangeBreakpoint();
	            this.onChangeAnnotation();
	            this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
	            this.renderer.updateFull();
	        } else {
	            this.selection = null;
	            this.renderer.setSession(session);
	        }

	        this._signal("changeSession", {
	            session: session,
	            oldSession: oldSession
	        });
	        
	        this.curOp = null;
	        
	        oldSession && oldSession._signal("changeEditor", {oldEditor: this});
	        session && session._signal("changeEditor", {editor: this});
	    };
	    this.getSession = function() {
	        return this.session;
	    };
	    this.setValue = function(val, cursorPos) {
	        this.session.doc.setValue(val);

	        if (!cursorPos)
	            this.selectAll();
	        else if (cursorPos == 1)
	            this.navigateFileEnd();
	        else if (cursorPos == -1)
	            this.navigateFileStart();

	        return val;
	    };
	    this.getValue = function() {
	        return this.session.getValue();
	    };
	    this.getSelection = function() {
	        return this.selection;
	    };
	    this.resize = function(force) {
	        this.renderer.onResize(force);
	    };
	    this.setTheme = function(theme, cb) {
	        this.renderer.setTheme(theme, cb);
	    };
	    this.getTheme = function() {
	        return this.renderer.getTheme();
	    };
	    this.setStyle = function(style) {
	        this.renderer.setStyle(style);
	    };
	    this.unsetStyle = function(style) {
	        this.renderer.unsetStyle(style);
	    };
	    this.getFontSize = function () {
	        return this.getOption("fontSize") ||
	           dom.computedStyle(this.container, "fontSize");
	    };
	    this.setFontSize = function(size) {
	        this.setOption("fontSize", size);
	    };

	    this.$highlightBrackets = function() {
	        if (this.session.$bracketHighlight) {
	            this.session.removeMarker(this.session.$bracketHighlight);
	            this.session.$bracketHighlight = null;
	        }

	        if (this.$highlightPending) {
	            return;
	        }
	        var self = this;
	        this.$highlightPending = true;
	        setTimeout(function() {
	            self.$highlightPending = false;
	            var session = self.session;
	            if (!session || !session.bgTokenizer) return;
	            var pos = session.findMatchingBracket(self.getCursorPosition());
	            if (pos) {
	                var range = new Range(pos.row, pos.column, pos.row, pos.column + 1);
	            } else if (session.$mode.getMatching) {
	                var range = session.$mode.getMatching(self.session);
	            }
	            if (range)
	                session.$bracketHighlight = session.addMarker(range, "ace_bracket", "text");
	        }, 50);
	    };
	    this.$highlightTags = function() {
	        if (this.$highlightTagPending)
	            return;
	        var self = this;
	        this.$highlightTagPending = true;
	        setTimeout(function() {
	            self.$highlightTagPending = false;
	            
	            var session = self.session;
	            if (!session || !session.bgTokenizer) return;
	            
	            var pos = self.getCursorPosition();
	            var iterator = new TokenIterator(self.session, pos.row, pos.column);
	            var token = iterator.getCurrentToken();
	            
	            if (!token || !/\b(?:tag-open|tag-name)/.test(token.type)) {
	                session.removeMarker(session.$tagHighlight);
	                session.$tagHighlight = null;
	                return;
	            }
	            
	            if (token.type.indexOf("tag-open") != -1) {
	                token = iterator.stepForward();
	                if (!token)
	                    return;
	            }
	            
	            var tag = token.value;
	            var depth = 0;
	            var prevToken = iterator.stepBackward();
	            
	            if (prevToken.value == '<'){
	                do {
	                    prevToken = token;
	                    token = iterator.stepForward();
	                    
	                    if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
	                        if (prevToken.value === '<'){
	                            depth++;
	                        } else if (prevToken.value === '</'){
	                            depth--;
	                        }
	                    }
	                    
	                } while (token && depth >= 0);
	            } else {
	                do {
	                    token = prevToken;
	                    prevToken = iterator.stepBackward();
	                    
	                    if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
	                        if (prevToken.value === '<') {
	                            depth++;
	                        } else if (prevToken.value === '</') {
	                            depth--;
	                        }
	                    }
	                } while (prevToken && depth <= 0);
	                iterator.stepForward();
	            }
	            
	            if (!token) {
	                session.removeMarker(session.$tagHighlight);
	                session.$tagHighlight = null;
	                return;
	            }
	            
	            var row = iterator.getCurrentTokenRow();
	            var column = iterator.getCurrentTokenColumn();
	            var range = new Range(row, column, row, column+token.value.length);
	            if (session.$tagHighlight && range.compareRange(session.$backMarkers[session.$tagHighlight].range)!==0) {
	                session.removeMarker(session.$tagHighlight);
	                session.$tagHighlight = null;
	            }
	            
	            if (range && !session.$tagHighlight)
	                session.$tagHighlight = session.addMarker(range, "ace_bracket", "text");
	        }, 50);
	    };
	    this.focus = function() {
	        var _self = this;
	        setTimeout(function() {
	            _self.textInput.focus();
	        });
	        this.textInput.focus();
	    };
	    this.isFocused = function() {
	        return this.textInput.isFocused();
	    };
	    this.blur = function() {
	        this.textInput.blur();
	    };
	    this.onFocus = function(e) {
	        if (this.$isFocused)
	            return;
	        this.$isFocused = true;
	        this.renderer.showCursor();
	        this.renderer.visualizeFocus();
	        this._emit("focus", e);
	    };
	    this.onBlur = function(e) {
	        if (!this.$isFocused)
	            return;
	        this.$isFocused = false;
	        this.renderer.hideCursor();
	        this.renderer.visualizeBlur();
	        this._emit("blur", e);
	    };

	    this.$cursorChange = function() {
	        this.renderer.updateCursor();
	    };
	    this.onDocumentChange = function(delta) {
	        var wrap = this.session.$useWrapMode;
	        var lastRow = (delta.start.row == delta.end.row ? delta.end.row : Infinity);
	        this.renderer.updateLines(delta.start.row, lastRow, wrap);

	        this._signal("change", delta);
	        this.$cursorChange();
	        this.$updateHighlightActiveLine();
	    };

	    this.onTokenizerUpdate = function(e) {
	        var rows = e.data;
	        this.renderer.updateLines(rows.first, rows.last);
	    };


	    this.onScrollTopChange = function() {
	        this.renderer.scrollToY(this.session.getScrollTop());
	    };

	    this.onScrollLeftChange = function() {
	        this.renderer.scrollToX(this.session.getScrollLeft());
	    };
	    this.onCursorChange = function() {
	        this.$cursorChange();

	        if (!this.$blockScrolling) {
	            config.warn("Automatically scrolling cursor into view after selection change",
	                "this will be disabled in the next version",
	                "set editor.$blockScrolling = Infinity to disable this message"
	            );
	            this.renderer.scrollCursorIntoView();
	        }

	        this.$highlightBrackets();
	        this.$highlightTags();
	        this.$updateHighlightActiveLine();
	        this._signal("changeSelection");
	    };

	    this.$updateHighlightActiveLine = function() {
	        var session = this.getSession();

	        var highlight;
	        if (this.$highlightActiveLine) {
	            if ((this.$selectionStyle != "line" || !this.selection.isMultiLine()))
	                highlight = this.getCursorPosition();
	            if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))
	                highlight = false;
	        }

	        if (session.$highlightLineMarker && !highlight) {
	            session.removeMarker(session.$highlightLineMarker.id);
	            session.$highlightLineMarker = null;
	        } else if (!session.$highlightLineMarker && highlight) {
	            var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
	            range.id = session.addMarker(range, "ace_active-line", "screenLine");
	            session.$highlightLineMarker = range;
	        } else if (highlight) {
	            session.$highlightLineMarker.start.row = highlight.row;
	            session.$highlightLineMarker.end.row = highlight.row;
	            session.$highlightLineMarker.start.column = highlight.column;
	            session._signal("changeBackMarker");
	        }
	    };

	    this.onSelectionChange = function(e) {
	        var session = this.session;

	        if (session.$selectionMarker) {
	            session.removeMarker(session.$selectionMarker);
	        }
	        session.$selectionMarker = null;

	        if (!this.selection.isEmpty()) {
	            var range = this.selection.getRange();
	            var style = this.getSelectionStyle();
	            session.$selectionMarker = session.addMarker(range, "ace_selection", style);
	        } else {
	            this.$updateHighlightActiveLine();
	        }

	        var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
	        this.session.highlight(re);

	        this._signal("changeSelection");
	    };

	    this.$getSelectionHighLightRegexp = function() {
	        var session = this.session;

	        var selection = this.getSelectionRange();
	        if (selection.isEmpty() || selection.isMultiLine())
	            return;

	        var startOuter = selection.start.column - 1;
	        var endOuter = selection.end.column + 1;
	        var line = session.getLine(selection.start.row);
	        var lineCols = line.length;
	        var needle = line.substring(Math.max(startOuter, 0),
	                                    Math.min(endOuter, lineCols));
	        if ((startOuter >= 0 && /^[\w\d]/.test(needle)) ||
	            (endOuter <= lineCols && /[\w\d]$/.test(needle)))
	            return;

	        needle = line.substring(selection.start.column, selection.end.column);
	        if (!/^[\w\d]+$/.test(needle))
	            return;

	        var re = this.$search.$assembleRegExp({
	            wholeWord: true,
	            caseSensitive: true,
	            needle: needle
	        });

	        return re;
	    };


	    this.onChangeFrontMarker = function() {
	        this.renderer.updateFrontMarkers();
	    };

	    this.onChangeBackMarker = function() {
	        this.renderer.updateBackMarkers();
	    };


	    this.onChangeBreakpoint = function() {
	        this.renderer.updateBreakpoints();
	    };

	    this.onChangeAnnotation = function() {
	        this.renderer.setAnnotations(this.session.getAnnotations());
	    };


	    this.onChangeMode = function(e) {
	        this.renderer.updateText();
	        this._emit("changeMode", e);
	    };


	    this.onChangeWrapLimit = function() {
	        this.renderer.updateFull();
	    };

	    this.onChangeWrapMode = function() {
	        this.renderer.onResize(true);
	    };


	    this.onChangeFold = function() {
	        this.$updateHighlightActiveLine();
	        this.renderer.updateFull();
	    };
	    this.getSelectedText = function() {
	        return this.session.getTextRange(this.getSelectionRange());
	    };
	    this.getCopyText = function() {
	        var text = this.getSelectedText();
	        this._signal("copy", text);
	        return text;
	    };
	    this.onCopy = function() {
	        this.commands.exec("copy", this);
	    };
	    this.onCut = function() {
	        this.commands.exec("cut", this);
	    };
	    this.onPaste = function(text, event) {
	        var e = {text: text, event: event};
	        this.commands.exec("paste", this, e);
	    };
	    
	    this.$handlePaste = function(e) {
	        if (typeof e == "string") 
	            e = {text: e};
	        this._signal("paste", e);
	        var text = e.text;
	        if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
	            this.insert(text);
	        } else {
	            var lines = text.split(/\r\n|\r|\n/);
	            var ranges = this.selection.rangeList.ranges;
	    
	            if (lines.length > ranges.length || lines.length < 2 || !lines[1])
	                return this.commands.exec("insertstring", this, text);
	    
	            for (var i = ranges.length; i--;) {
	                var range = ranges[i];
	                if (!range.isEmpty())
	                    this.session.remove(range);
	    
	                this.session.insert(range.start, lines[i]);
	            }
	        }
	    };

	    this.execCommand = function(command, args) {
	        return this.commands.exec(command, this, args);
	    };
	    this.insert = function(text, pasted) {
	        var session = this.session;
	        var mode = session.getMode();
	        var cursor = this.getCursorPosition();

	        if (this.getBehavioursEnabled() && !pasted) {
	            var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);
	            if (transform) {
	                if (text !== transform.text) {
	                    this.session.mergeUndoDeltas = false;
	                    this.$mergeNextCommand = false;
	                }
	                text = transform.text;

	            }
	        }
	        
	        if (text == "\t")
	            text = this.session.getTabString();
	        if (!this.selection.isEmpty()) {
	            var range = this.getSelectionRange();
	            cursor = this.session.remove(range);
	            this.clearSelection();
	        }
	        else if (this.session.getOverwrite()) {
	            var range = new Range.fromPoints(cursor, cursor);
	            range.end.column += text.length;
	            this.session.remove(range);
	        }

	        if (text == "\n" || text == "\r\n") {
	            var line = session.getLine(cursor.row);
	            if (cursor.column > line.search(/\S|$/)) {
	                var d = line.substr(cursor.column).search(/\S|$/);
	                session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
	            }
	        }
	        this.clearSelection();

	        var start = cursor.column;
	        var lineState = session.getState(cursor.row);
	        var line = session.getLine(cursor.row);
	        var shouldOutdent = mode.checkOutdent(lineState, line, text);
	        var end = session.insert(cursor, text);

	        if (transform && transform.selection) {
	            if (transform.selection.length == 2) { // Transform relative to the current column
	                this.selection.setSelectionRange(
	                    new Range(cursor.row, start + transform.selection[0],
	                              cursor.row, start + transform.selection[1]));
	            } else { // Transform relative to the current row.
	                this.selection.setSelectionRange(
	                    new Range(cursor.row + transform.selection[0],
	                              transform.selection[1],
	                              cursor.row + transform.selection[2],
	                              transform.selection[3]));
	            }
	        }

	        if (session.getDocument().isNewLine(text)) {
	            var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());

	            session.insert({row: cursor.row+1, column: 0}, lineIndent);
	        }
	        if (shouldOutdent)
	            mode.autoOutdent(lineState, session, cursor.row);
	    };

	    this.onTextInput = function(text) {
	        this.keyBinding.onTextInput(text);
	    };

	    this.onCommandKey = function(e, hashId, keyCode) {
	        this.keyBinding.onCommandKey(e, hashId, keyCode);
	    };
	    this.setOverwrite = function(overwrite) {
	        this.session.setOverwrite(overwrite);
	    };
	    this.getOverwrite = function() {
	        return this.session.getOverwrite();
	    };
	    this.toggleOverwrite = function() {
	        this.session.toggleOverwrite();
	    };
	    this.setScrollSpeed = function(speed) {
	        this.setOption("scrollSpeed", speed);
	    };
	    this.getScrollSpeed = function() {
	        return this.getOption("scrollSpeed");
	    };
	    this.setDragDelay = function(dragDelay) {
	        this.setOption("dragDelay", dragDelay);
	    };
	    this.getDragDelay = function() {
	        return this.getOption("dragDelay");
	    };
	    this.setSelectionStyle = function(val) {
	        this.setOption("selectionStyle", val);
	    };
	    this.getSelectionStyle = function() {
	        return this.getOption("selectionStyle");
	    };
	    this.setHighlightActiveLine = function(shouldHighlight) {
	        this.setOption("highlightActiveLine", shouldHighlight);
	    };
	    this.getHighlightActiveLine = function() {
	        return this.getOption("highlightActiveLine");
	    };
	    this.setHighlightGutterLine = function(shouldHighlight) {
	        this.setOption("highlightGutterLine", shouldHighlight);
	    };

	    this.getHighlightGutterLine = function() {
	        return this.getOption("highlightGutterLine");
	    };
	    this.setHighlightSelectedWord = function(shouldHighlight) {
	        this.setOption("highlightSelectedWord", shouldHighlight);
	    };
	    this.getHighlightSelectedWord = function() {
	        return this.$highlightSelectedWord;
	    };

	    this.setAnimatedScroll = function(shouldAnimate){
	        this.renderer.setAnimatedScroll(shouldAnimate);
	    };

	    this.getAnimatedScroll = function(){
	        return this.renderer.getAnimatedScroll();
	    };
	    this.setShowInvisibles = function(showInvisibles) {
	        this.renderer.setShowInvisibles(showInvisibles);
	    };
	    this.getShowInvisibles = function() {
	        return this.renderer.getShowInvisibles();
	    };

	    this.setDisplayIndentGuides = function(display) {
	        this.renderer.setDisplayIndentGuides(display);
	    };

	    this.getDisplayIndentGuides = function() {
	        return this.renderer.getDisplayIndentGuides();
	    };
	    this.setShowPrintMargin = function(showPrintMargin) {
	        this.renderer.setShowPrintMargin(showPrintMargin);
	    };
	    this.getShowPrintMargin = function() {
	        return this.renderer.getShowPrintMargin();
	    };
	    this.setPrintMarginColumn = function(showPrintMargin) {
	        this.renderer.setPrintMarginColumn(showPrintMargin);
	    };
	    this.getPrintMarginColumn = function() {
	        return this.renderer.getPrintMarginColumn();
	    };
	    this.setReadOnly = function(readOnly) {
	        this.setOption("readOnly", readOnly);
	    };
	    this.getReadOnly = function() {
	        return this.getOption("readOnly");
	    };
	    this.setBehavioursEnabled = function (enabled) {
	        this.setOption("behavioursEnabled", enabled);
	    };
	    this.getBehavioursEnabled = function () {
	        return this.getOption("behavioursEnabled");
	    };
	    this.setWrapBehavioursEnabled = function (enabled) {
	        this.setOption("wrapBehavioursEnabled", enabled);
	    };
	    this.getWrapBehavioursEnabled = function () {
	        return this.getOption("wrapBehavioursEnabled");
	    };
	    this.setShowFoldWidgets = function(show) {
	        this.setOption("showFoldWidgets", show);

	    };
	    this.getShowFoldWidgets = function() {
	        return this.getOption("showFoldWidgets");
	    };

	    this.setFadeFoldWidgets = function(fade) {
	        this.setOption("fadeFoldWidgets", fade);
	    };

	    this.getFadeFoldWidgets = function() {
	        return this.getOption("fadeFoldWidgets");
	    };
	    this.remove = function(dir) {
	        if (this.selection.isEmpty()){
	            if (dir == "left")
	                this.selection.selectLeft();
	            else
	                this.selection.selectRight();
	        }

	        var range = this.getSelectionRange();
	        if (this.getBehavioursEnabled()) {
	            var session = this.session;
	            var state = session.getState(range.start.row);
	            var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);

	            if (range.end.column === 0) {
	                var text = session.getTextRange(range);
	                if (text[text.length - 1] == "\n") {
	                    var line = session.getLine(range.end.row);
	                    if (/^\s+$/.test(line)) {
	                        range.end.column = line.length;
	                    }
	                }
	            }
	            if (new_range)
	                range = new_range;
	        }

	        this.session.remove(range);
	        this.clearSelection();
	    };
	    this.removeWordRight = function() {
	        if (this.selection.isEmpty())
	            this.selection.selectWordRight();

	        this.session.remove(this.getSelectionRange());
	        this.clearSelection();
	    };
	    this.removeWordLeft = function() {
	        if (this.selection.isEmpty())
	            this.selection.selectWordLeft();

	        this.session.remove(this.getSelectionRange());
	        this.clearSelection();
	    };
	    this.removeToLineStart = function() {
	        if (this.selection.isEmpty())
	            this.selection.selectLineStart();

	        this.session.remove(this.getSelectionRange());
	        this.clearSelection();
	    };
	    this.removeToLineEnd = function() {
	        if (this.selection.isEmpty())
	            this.selection.selectLineEnd();

	        var range = this.getSelectionRange();
	        if (range.start.column == range.end.column && range.start.row == range.end.row) {
	            range.end.column = 0;
	            range.end.row++;
	        }

	        this.session.remove(range);
	        this.clearSelection();
	    };
	    this.splitLine = function() {
	        if (!this.selection.isEmpty()) {
	            this.session.remove(this.getSelectionRange());
	            this.clearSelection();
	        }

	        var cursor = this.getCursorPosition();
	        this.insert("\n");
	        this.moveCursorToPosition(cursor);
	    };
	    this.transposeLetters = function() {
	        if (!this.selection.isEmpty()) {
	            return;
	        }

	        var cursor = this.getCursorPosition();
	        var column = cursor.column;
	        if (column === 0)
	            return;

	        var line = this.session.getLine(cursor.row);
	        var swap, range;
	        if (column < line.length) {
	            swap = line.charAt(column) + line.charAt(column-1);
	            range = new Range(cursor.row, column-1, cursor.row, column+1);
	        }
	        else {
	            swap = line.charAt(column-1) + line.charAt(column-2);
	            range = new Range(cursor.row, column-2, cursor.row, column);
	        }
	        this.session.replace(range, swap);
	    };
	    this.toLowerCase = function() {
	        var originalRange = this.getSelectionRange();
	        if (this.selection.isEmpty()) {
	            this.selection.selectWord();
	        }

	        var range = this.getSelectionRange();
	        var text = this.session.getTextRange(range);
	        this.session.replace(range, text.toLowerCase());
	        this.selection.setSelectionRange(originalRange);
	    };
	    this.toUpperCase = function() {
	        var originalRange = this.getSelectionRange();
	        if (this.selection.isEmpty()) {
	            this.selection.selectWord();
	        }

	        var range = this.getSelectionRange();
	        var text = this.session.getTextRange(range);
	        this.session.replace(range, text.toUpperCase());
	        this.selection.setSelectionRange(originalRange);
	    };
	    this.indent = function() {
	        var session = this.session;
	        var range = this.getSelectionRange();

	        if (range.start.row < range.end.row) {
	            var rows = this.$getSelectedRows();
	            session.indentRows(rows.first, rows.last, "\t");
	            return;
	        } else if (range.start.column < range.end.column) {
	            var text = session.getTextRange(range);
	            if (!/^\s+$/.test(text)) {
	                var rows = this.$getSelectedRows();
	                session.indentRows(rows.first, rows.last, "\t");
	                return;
	            }
	        }
	        
	        var line = session.getLine(range.start.row);
	        var position = range.start;
	        var size = session.getTabSize();
	        var column = session.documentToScreenColumn(position.row, position.column);

	        if (this.session.getUseSoftTabs()) {
	            var count = (size - column % size);
	            var indentString = lang.stringRepeat(" ", count);
	        } else {
	            var count = column % size;
	            while (line[range.start.column] == " " && count) {
	                range.start.column--;
	                count--;
	            }
	            this.selection.setSelectionRange(range);
	            indentString = "\t";
	        }
	        return this.insert(indentString);
	    };
	    this.blockIndent = function() {
	        var rows = this.$getSelectedRows();
	        this.session.indentRows(rows.first, rows.last, "\t");
	    };
	    this.blockOutdent = function() {
	        var selection = this.session.getSelection();
	        this.session.outdentRows(selection.getRange());
	    };
	    this.sortLines = function() {
	        var rows = this.$getSelectedRows();
	        var session = this.session;

	        var lines = [];
	        for (i = rows.first; i <= rows.last; i++)
	            lines.push(session.getLine(i));

	        lines.sort(function(a, b) {
	            if (a.toLowerCase() < b.toLowerCase()) return -1;
	            if (a.toLowerCase() > b.toLowerCase()) return 1;
	            return 0;
	        });

	        var deleteRange = new Range(0, 0, 0, 0);
	        for (var i = rows.first; i <= rows.last; i++) {
	            var line = session.getLine(i);
	            deleteRange.start.row = i;
	            deleteRange.end.row = i;
	            deleteRange.end.column = line.length;
	            session.replace(deleteRange, lines[i-rows.first]);
	        }
	    };
	    this.toggleCommentLines = function() {
	        var state = this.session.getState(this.getCursorPosition().row);
	        var rows = this.$getSelectedRows();
	        this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
	    };

	    this.toggleBlockComment = function() {
	        var cursor = this.getCursorPosition();
	        var state = this.session.getState(cursor.row);
	        var range = this.getSelectionRange();
	        this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
	    };
	    this.getNumberAt = function(row, column) {
	        var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
	        _numberRx.lastIndex = 0;

	        var s = this.session.getLine(row);
	        while (_numberRx.lastIndex < column) {
	            var m = _numberRx.exec(s);
	            if(m.index <= column && m.index+m[0].length >= column){
	                var number = {
	                    value: m[0],
	                    start: m.index,
	                    end: m.index+m[0].length
	                };
	                return number;
	            }
	        }
	        return null;
	    };
	    this.modifyNumber = function(amount) {
	        var row = this.selection.getCursor().row;
	        var column = this.selection.getCursor().column;
	        var charRange = new Range(row, column-1, row, column);

	        var c = this.session.getTextRange(charRange);
	        if (!isNaN(parseFloat(c)) && isFinite(c)) {
	            var nr = this.getNumberAt(row, column);
	            if (nr) {
	                var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
	                var decimals = nr.start + nr.value.length - fp;

	                var t = parseFloat(nr.value);
	                t *= Math.pow(10, decimals);


	                if(fp !== nr.end && column < fp){
	                    amount *= Math.pow(10, nr.end - column - 1);
	                } else {
	                    amount *= Math.pow(10, nr.end - column);
	                }

	                t += amount;
	                t /= Math.pow(10, decimals);
	                var nnr = t.toFixed(decimals);
	                var replaceRange = new Range(row, nr.start, row, nr.end);
	                this.session.replace(replaceRange, nnr);
	                this.moveCursorTo(row, Math.max(nr.start +1, column + nnr.length - nr.value.length));

	            }
	        }
	    };
	    this.removeLines = function() {
	        var rows = this.$getSelectedRows();
	        this.session.removeFullLines(rows.first, rows.last);
	        this.clearSelection();
	    };

	    this.duplicateSelection = function() {
	        var sel = this.selection;
	        var doc = this.session;
	        var range = sel.getRange();
	        var reverse = sel.isBackwards();
	        if (range.isEmpty()) {
	            var row = range.start.row;
	            doc.duplicateLines(row, row);
	        } else {
	            var point = reverse ? range.start : range.end;
	            var endPoint = doc.insert(point, doc.getTextRange(range), false);
	            range.start = point;
	            range.end = endPoint;

	            sel.setSelectionRange(range, reverse);
	        }
	    };
	    this.moveLinesDown = function() {
	        this.$moveLines(1, false);
	    };
	    this.moveLinesUp = function() {
	        this.$moveLines(-1, false);
	    };
	    this.moveText = function(range, toPosition, copy) {
	        return this.session.moveText(range, toPosition, copy);
	    };
	    this.copyLinesUp = function() {
	        this.$moveLines(-1, true);
	    };
	    this.copyLinesDown = function() {
	        this.$moveLines(1, true);
	    };
	    this.$moveLines = function(dir, copy) {
	        var rows, moved;
	        var selection = this.selection;
	        if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
	            var range = selection.toOrientedRange();
	            rows = this.$getSelectedRows(range);
	            moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
	            if (copy && dir == -1) moved = 0;
	            range.moveBy(moved, 0);
	            selection.fromOrientedRange(range);
	        } else {
	            var ranges = selection.rangeList.ranges;
	            selection.rangeList.detach(this.session);
	            this.inVirtualSelectionMode = true;
	            
	            var diff = 0;
	            var totalDiff = 0;
	            var l = ranges.length;
	            for (var i = 0; i < l; i++) {
	                var rangeIndex = i;
	                ranges[i].moveBy(diff, 0);
	                rows = this.$getSelectedRows(ranges[i]);
	                var first = rows.first;
	                var last = rows.last;
	                while (++i < l) {
	                    if (totalDiff) ranges[i].moveBy(totalDiff, 0);
	                    var subRows = this.$getSelectedRows(ranges[i]);
	                    if (copy && subRows.first != last)
	                        break;
	                    else if (!copy && subRows.first > last + 1)
	                        break;
	                    last = subRows.last;
	                }
	                i--;
	                diff = this.session.$moveLines(first, last, copy ? 0 : dir);
	                if (copy && dir == -1) rangeIndex = i + 1;
	                while (rangeIndex <= i) {
	                    ranges[rangeIndex].moveBy(diff, 0);
	                    rangeIndex++;
	                }
	                if (!copy) diff = 0;
	                totalDiff += diff;
	            }
	            
	            selection.fromOrientedRange(selection.ranges[0]);
	            selection.rangeList.attach(this.session);
	            this.inVirtualSelectionMode = false;
	        }
	    };
	    this.$getSelectedRows = function(range) {
	        range = (range || this.getSelectionRange()).collapseRows();

	        return {
	            first: this.session.getRowFoldStart(range.start.row),
	            last: this.session.getRowFoldEnd(range.end.row)
	        };
	    };

	    this.onCompositionStart = function(text) {
	        this.renderer.showComposition(this.getCursorPosition());
	    };

	    this.onCompositionUpdate = function(text) {
	        this.renderer.setCompositionText(text);
	    };

	    this.onCompositionEnd = function() {
	        this.renderer.hideComposition();
	    };
	    this.getFirstVisibleRow = function() {
	        return this.renderer.getFirstVisibleRow();
	    };
	    this.getLastVisibleRow = function() {
	        return this.renderer.getLastVisibleRow();
	    };
	    this.isRowVisible = function(row) {
	        return (row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow());
	    };
	    this.isRowFullyVisible = function(row) {
	        return (row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow());
	    };
	    this.$getVisibleRowCount = function() {
	        return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
	    };

	    this.$moveByPage = function(dir, select) {
	        var renderer = this.renderer;
	        var config = this.renderer.layerConfig;
	        var rows = dir * Math.floor(config.height / config.lineHeight);

	        this.$blockScrolling++;
	        if (select === true) {
	            this.selection.$moveSelection(function(){
	                this.moveCursorBy(rows, 0);
	            });
	        } else if (select === false) {
	            this.selection.moveCursorBy(rows, 0);
	            this.selection.clearSelection();
	        }
	        this.$blockScrolling--;

	        var scrollTop = renderer.scrollTop;

	        renderer.scrollBy(0, rows * config.lineHeight);
	        if (select != null)
	            renderer.scrollCursorIntoView(null, 0.5);

	        renderer.animateScrolling(scrollTop);
	    };
	    this.selectPageDown = function() {
	        this.$moveByPage(1, true);
	    };
	    this.selectPageUp = function() {
	        this.$moveByPage(-1, true);
	    };
	    this.gotoPageDown = function() {
	       this.$moveByPage(1, false);
	    };
	    this.gotoPageUp = function() {
	        this.$moveByPage(-1, false);
	    };
	    this.scrollPageDown = function() {
	        this.$moveByPage(1);
	    };
	    this.scrollPageUp = function() {
	        this.$moveByPage(-1);
	    };
	    this.scrollToRow = function(row) {
	        this.renderer.scrollToRow(row);
	    };
	    this.scrollToLine = function(line, center, animate, callback) {
	        this.renderer.scrollToLine(line, center, animate, callback);
	    };
	    this.centerSelection = function() {
	        var range = this.getSelectionRange();
	        var pos = {
	            row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
	            column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
	        };
	        this.renderer.alignCursor(pos, 0.5);
	    };
	    this.getCursorPosition = function() {
	        return this.selection.getCursor();
	    };
	    this.getCursorPositionScreen = function() {
	        return this.session.documentToScreenPosition(this.getCursorPosition());
	    };
	    this.getSelectionRange = function() {
	        return this.selection.getRange();
	    };
	    this.selectAll = function() {
	        this.$blockScrolling += 1;
	        this.selection.selectAll();
	        this.$blockScrolling -= 1;
	    };
	    this.clearSelection = function() {
	        this.selection.clearSelection();
	    };
	    this.moveCursorTo = function(row, column) {
	        this.selection.moveCursorTo(row, column);
	    };
	    this.moveCursorToPosition = function(pos) {
	        this.selection.moveCursorToPosition(pos);
	    };
	    this.jumpToMatching = function(select, expand) {
	        var cursor = this.getCursorPosition();
	        var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
	        var prevToken = iterator.getCurrentToken();
	        var token = prevToken || iterator.stepForward();

	        if (!token) return;
	        var matchType;
	        var found = false;
	        var depth = {};
	        var i = cursor.column - token.start;
	        var bracketType;
	        var brackets = {
	            ")": "(",
	            "(": "(",
	            "]": "[",
	            "[": "[",
	            "{": "{",
	            "}": "{"
	        };
	        
	        do {
	            if (token.value.match(/[{}()\[\]]/g)) {
	                for (; i < token.value.length && !found; i++) {
	                    if (!brackets[token.value[i]]) {
	                        continue;
	                    }

	                    bracketType = brackets[token.value[i]] + '.' + token.type.replace("rparen", "lparen");

	                    if (isNaN(depth[bracketType])) {
	                        depth[bracketType] = 0;
	                    }

	                    switch (token.value[i]) {
	                        case '(':
	                        case '[':
	                        case '{':
	                            depth[bracketType]++;
	                            break;
	                        case ')':
	                        case ']':
	                        case '}':
	                            depth[bracketType]--;

	                            if (depth[bracketType] === -1) {
	                                matchType = 'bracket';
	                                found = true;
	                            }
	                        break;
	                    }
	                }
	            }
	            else if (token && token.type.indexOf('tag-name') !== -1) {
	                if (isNaN(depth[token.value])) {
	                    depth[token.value] = 0;
	                }
	                
	                if (prevToken.value === '<') {
	                    depth[token.value]++;
	                }
	                else if (prevToken.value === '</') {
	                    depth[token.value]--;
	                }
	                
	                if (depth[token.value] === -1) {
	                    matchType = 'tag';
	                    found = true;
	                }
	            }

	            if (!found) {
	                prevToken = token;
	                token = iterator.stepForward();
	                i = 0;
	            }
	        } while (token && !found);
	        if (!matchType)
	            return;

	        var range, pos;
	        if (matchType === 'bracket') {
	            range = this.session.getBracketRange(cursor);
	            if (!range) {
	                range = new Range(
	                    iterator.getCurrentTokenRow(),
	                    iterator.getCurrentTokenColumn() + i - 1,
	                    iterator.getCurrentTokenRow(),
	                    iterator.getCurrentTokenColumn() + i - 1
	                );
	                pos = range.start;
	                if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2)
	                    range = this.session.getBracketRange(pos);
	            }
	        }
	        else if (matchType === 'tag') {
	            if (token && token.type.indexOf('tag-name') !== -1) 
	                var tag = token.value;
	            else
	                return;

	            range = new Range(
	                iterator.getCurrentTokenRow(),
	                iterator.getCurrentTokenColumn() - 2,
	                iterator.getCurrentTokenRow(),
	                iterator.getCurrentTokenColumn() - 2
	            );
	            if (range.compare(cursor.row, cursor.column) === 0) {
	                found = false;
	                do {
	                    token = prevToken;
	                    prevToken = iterator.stepBackward();
	                    
	                    if (prevToken) {
	                        if (prevToken.type.indexOf('tag-close') !== -1) {
	                            range.setEnd(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
	                        }

	                        if (token.value === tag && token.type.indexOf('tag-name') !== -1) {
	                            if (prevToken.value === '<') {
	                                depth[tag]++;
	                            }
	                            else if (prevToken.value === '</') {
	                                depth[tag]--;
	                            }
	                            
	                            if (depth[tag] === 0)
	                                found = true;
	                        }
	                    }
	                } while (prevToken && !found);
	            }
	            if (token && token.type.indexOf('tag-name')) {
	                pos = range.start;
	                if (pos.row == cursor.row && Math.abs(pos.column - cursor.column) < 2)
	                    pos = range.end;
	            }
	        }

	        pos = range && range.cursor || pos;
	        if (pos) {
	            if (select) {
	                if (range && expand) {
	                    this.selection.setRange(range);
	                } else if (range && range.isEqual(this.getSelectionRange())) {
	                    this.clearSelection();
	                } else {
	                    this.selection.selectTo(pos.row, pos.column);
	                }
	            } else {
	                this.selection.moveTo(pos.row, pos.column);
	            }
	        }
	    };
	    this.gotoLine = function(lineNumber, column, animate) {
	        this.selection.clearSelection();
	        this.session.unfold({row: lineNumber - 1, column: column || 0});

	        this.$blockScrolling += 1;
	        this.exitMultiSelectMode && this.exitMultiSelectMode();
	        this.moveCursorTo(lineNumber - 1, column || 0);
	        this.$blockScrolling -= 1;

	        if (!this.isRowFullyVisible(lineNumber - 1))
	            this.scrollToLine(lineNumber - 1, true, animate);
	    };
	    this.navigateTo = function(row, column) {
	        this.selection.moveTo(row, column);
	    };
	    this.navigateUp = function(times) {
	        if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
	            var selectionStart = this.selection.anchor.getPosition();
	            return this.moveCursorToPosition(selectionStart);
	        }
	        this.selection.clearSelection();
	        this.selection.moveCursorBy(-times || -1, 0);
	    };
	    this.navigateDown = function(times) {
	        if (this.selection.isMultiLine() && this.selection.isBackwards()) {
	            var selectionEnd = this.selection.anchor.getPosition();
	            return this.moveCursorToPosition(selectionEnd);
	        }
	        this.selection.clearSelection();
	        this.selection.moveCursorBy(times || 1, 0);
	    };
	    this.navigateLeft = function(times) {
	        if (!this.selection.isEmpty()) {
	            var selectionStart = this.getSelectionRange().start;
	            this.moveCursorToPosition(selectionStart);
	        }
	        else {
	            times = times || 1;
	            while (times--) {
	                this.selection.moveCursorLeft();
	            }
	        }
	        this.clearSelection();
	    };
	    this.navigateRight = function(times) {
	        if (!this.selection.isEmpty()) {
	            var selectionEnd = this.getSelectionRange().end;
	            this.moveCursorToPosition(selectionEnd);
	        }
	        else {
	            times = times || 1;
	            while (times--) {
	                this.selection.moveCursorRight();
	            }
	        }
	        this.clearSelection();
	    };
	    this.navigateLineStart = function() {
	        this.selection.moveCursorLineStart();
	        this.clearSelection();
	    };
	    this.navigateLineEnd = function() {
	        this.selection.moveCursorLineEnd();
	        this.clearSelection();
	    };
	    this.navigateFileEnd = function() {
	        this.selection.moveCursorFileEnd();
	        this.clearSelection();
	    };
	    this.navigateFileStart = function() {
	        this.selection.moveCursorFileStart();
	        this.clearSelection();
	    };
	    this.navigateWordRight = function() {
	        this.selection.moveCursorWordRight();
	        this.clearSelection();
	    };
	    this.navigateWordLeft = function() {
	        this.selection.moveCursorWordLeft();
	        this.clearSelection();
	    };
	    this.replace = function(replacement, options) {
	        if (options)
	            this.$search.set(options);

	        var range = this.$search.find(this.session);
	        var replaced = 0;
	        if (!range)
	            return replaced;

	        if (this.$tryReplace(range, replacement)) {
	            replaced = 1;
	        }
	        if (range !== null) {
	            this.selection.setSelectionRange(range);
	            this.renderer.scrollSelectionIntoView(range.start, range.end);
	        }

	        return replaced;
	    };
	    this.replaceAll = function(replacement, options) {
	        if (options) {
	            this.$search.set(options);
	        }

	        var ranges = this.$search.findAll(this.session);
	        var replaced = 0;
	        if (!ranges.length)
	            return replaced;

	        this.$blockScrolling += 1;

	        var selection = this.getSelectionRange();
	        this.selection.moveTo(0, 0);

	        for (var i = ranges.length - 1; i >= 0; --i) {
	            if(this.$tryReplace(ranges[i], replacement)) {
	                replaced++;
	            }
	        }

	        this.selection.setSelectionRange(selection);
	        this.$blockScrolling -= 1;

	        return replaced;
	    };

	    this.$tryReplace = function(range, replacement) {
	        var input = this.session.getTextRange(range);
	        replacement = this.$search.replace(input, replacement);
	        if (replacement !== null) {
	            range.end = this.session.replace(range, replacement);
	            return range;
	        } else {
	            return null;
	        }
	    };
	    this.getLastSearchOptions = function() {
	        return this.$search.getOptions();
	    };
	    this.find = function(needle, options, animate) {
	        if (!options)
	            options = {};

	        if (typeof needle == "string" || needle instanceof RegExp)
	            options.needle = needle;
	        else if (typeof needle == "object")
	            oop.mixin(options, needle);

	        var range = this.selection.getRange();
	        if (options.needle == null) {
	            needle = this.session.getTextRange(range)
	                || this.$search.$options.needle;
	            if (!needle) {
	                range = this.session.getWordRange(range.start.row, range.start.column);
	                needle = this.session.getTextRange(range);
	            }
	            this.$search.set({needle: needle});
	        }

	        this.$search.set(options);
	        if (!options.start)
	            this.$search.set({start: range});

	        var newRange = this.$search.find(this.session);
	        if (options.preventScroll)
	            return newRange;
	        if (newRange) {
	            this.revealRange(newRange, animate);
	            return newRange;
	        }
	        if (options.backwards)
	            range.start = range.end;
	        else
	            range.end = range.start;
	        this.selection.setRange(range);
	    };
	    this.findNext = function(options, animate) {
	        this.find({skipCurrent: true, backwards: false}, options, animate);
	    };
	    this.findPrevious = function(options, animate) {
	        this.find(options, {skipCurrent: true, backwards: true}, animate);
	    };

	    this.revealRange = function(range, animate) {
	        this.$blockScrolling += 1;
	        this.session.unfold(range);
	        this.selection.setSelectionRange(range);
	        this.$blockScrolling -= 1;

	        var scrollTop = this.renderer.scrollTop;
	        this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
	        if (animate !== false)
	            this.renderer.animateScrolling(scrollTop);
	    };
	    this.undo = function() {
	        this.$blockScrolling++;
	        this.session.getUndoManager().undo();
	        this.$blockScrolling--;
	        this.renderer.scrollCursorIntoView(null, 0.5);
	    };
	    this.redo = function() {
	        this.$blockScrolling++;
	        this.session.getUndoManager().redo();
	        this.$blockScrolling--;
	        this.renderer.scrollCursorIntoView(null, 0.5);
	    };
	    this.destroy = function() {
	        this.renderer.destroy();
	        this._signal("destroy", this);
	        if (this.session) {
	            this.session.destroy();
	        }
	    };
	    this.setAutoScrollEditorIntoView = function(enable) {
	        if (!enable)
	            return;
	        var rect;
	        var self = this;
	        var shouldScroll = false;
	        if (!this.$scrollAnchor)
	            this.$scrollAnchor = document.createElement("div");
	        var scrollAnchor = this.$scrollAnchor;
	        scrollAnchor.style.cssText = "position:absolute";
	        this.container.insertBefore(scrollAnchor, this.container.firstChild);
	        var onChangeSelection = this.on("changeSelection", function() {
	            shouldScroll = true;
	        });
	        var onBeforeRender = this.renderer.on("beforeRender", function() {
	            if (shouldScroll)
	                rect = self.renderer.container.getBoundingClientRect();
	        });
	        var onAfterRender = this.renderer.on("afterRender", function() {
	            if (shouldScroll && rect && (self.isFocused()
	                || self.searchBox && self.searchBox.isFocused())
	            ) {
	                var renderer = self.renderer;
	                var pos = renderer.$cursorLayer.$pixelPos;
	                var config = renderer.layerConfig;
	                var top = pos.top - config.offset;
	                if (pos.top >= 0 && top + rect.top < 0) {
	                    shouldScroll = true;
	                } else if (pos.top < config.height &&
	                    pos.top + rect.top + config.lineHeight > window.innerHeight) {
	                    shouldScroll = false;
	                } else {
	                    shouldScroll = null;
	                }
	                if (shouldScroll != null) {
	                    scrollAnchor.style.top = top + "px";
	                    scrollAnchor.style.left = pos.left + "px";
	                    scrollAnchor.style.height = config.lineHeight + "px";
	                    scrollAnchor.scrollIntoView(shouldScroll);
	                }
	                shouldScroll = rect = null;
	            }
	        });
	        this.setAutoScrollEditorIntoView = function(enable) {
	            if (enable)
	                return;
	            delete this.setAutoScrollEditorIntoView;
	            this.off("changeSelection", onChangeSelection);
	            this.renderer.off("afterRender", onAfterRender);
	            this.renderer.off("beforeRender", onBeforeRender);
	        };
	    };


	    this.$resetCursorStyle = function() {
	        var style = this.$cursorStyle || "ace";
	        var cursorLayer = this.renderer.$cursorLayer;
	        if (!cursorLayer)
	            return;
	        cursorLayer.setSmoothBlinking(/smooth/.test(style));
	        cursorLayer.isBlinking = !this.$readOnly && style != "wide";
	        dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
	    };

	}).call(Editor.prototype);



	config.defineOptions(Editor.prototype, "editor", {
	    selectionStyle: {
	        set: function(style) {
	            this.onSelectionChange();
	            this._signal("changeSelectionStyle", {data: style});
	        },
	        initialValue: "line"
	    },
	    highlightActiveLine: {
	        set: function() {this.$updateHighlightActiveLine();},
	        initialValue: true
	    },
	    highlightSelectedWord: {
	        set: function(shouldHighlight) {this.$onSelectionChange();},
	        initialValue: true
	    },
	    readOnly: {
	        set: function(readOnly) {
	            this.$resetCursorStyle(); 
	        },
	        initialValue: false
	    },
	    cursorStyle: {
	        set: function(val) { this.$resetCursorStyle(); },
	        values: ["ace", "slim", "smooth", "wide"],
	        initialValue: "ace"
	    },
	    mergeUndoDeltas: {
	        values: [false, true, "always"],
	        initialValue: true
	    },
	    behavioursEnabled: {initialValue: true},
	    wrapBehavioursEnabled: {initialValue: true},
	    autoScrollEditorIntoView: {
	        set: function(val) {this.setAutoScrollEditorIntoView(val)}
	    },
	    keyboardHandler: {
	        set: function(val) { this.setKeyboardHandler(val); },
	        get: function() { return this.keybindingId; },
	        handlesSet: true
	    },

	    hScrollBarAlwaysVisible: "renderer",
	    vScrollBarAlwaysVisible: "renderer",
	    highlightGutterLine: "renderer",
	    animatedScroll: "renderer",
	    showInvisibles: "renderer",
	    showPrintMargin: "renderer",
	    printMarginColumn: "renderer",
	    printMargin: "renderer",
	    fadeFoldWidgets: "renderer",
	    showFoldWidgets: "renderer",
	    showLineNumbers: "renderer",
	    showGutter: "renderer",
	    displayIndentGuides: "renderer",
	    fontSize: "renderer",
	    fontFamily: "renderer",
	    maxLines: "renderer",
	    minLines: "renderer",
	    scrollPastEnd: "renderer",
	    fixedWidthGutter: "renderer",
	    theme: "renderer",

	    scrollSpeed: "$mouseHandler",
	    dragDelay: "$mouseHandler",
	    dragEnabled: "$mouseHandler",
	    focusTimout: "$mouseHandler",
	    tooltipFollowsMouse: "$mouseHandler",

	    firstLineNumber: "session",
	    overwrite: "session",
	    newLineMode: "session",
	    useWorker: "session",
	    useSoftTabs: "session",
	    tabSize: "session",
	    wrap: "session",
	    indentedSoftWrap: "session",
	    foldStyle: "session",
	    mode: "session"
	});

	exports.Editor = Editor;
	});

	ace.define("ace/undomanager",["require","exports","module"], function(acequire, exports, module) {
	"use strict";
	var UndoManager = function() {
	    this.reset();
	};

	(function() {
	    this.execute = function(options) {
	        var deltaSets = options.args[0];
	        this.$doc  = options.args[1];
	        if (options.merge && this.hasUndo()){
	            this.dirtyCounter--;
	            deltaSets = this.$undoStack.pop().concat(deltaSets);
	        }
	        this.$undoStack.push(deltaSets);
	        this.$redoStack = [];
	        if (this.dirtyCounter < 0) {
	            this.dirtyCounter = NaN;
	        }
	        this.dirtyCounter++;
	    };
	    this.undo = function(dontSelect) {
	        var deltaSets = this.$undoStack.pop();
	        var undoSelectionRange = null;
	        if (deltaSets) {
	            undoSelectionRange = this.$doc.undoChanges(deltaSets, dontSelect);
	            this.$redoStack.push(deltaSets);
	            this.dirtyCounter--;
	        }

	        return undoSelectionRange;
	    };
	    this.redo = function(dontSelect) {
	        var deltaSets = this.$redoStack.pop();
	        var redoSelectionRange = null;
	        if (deltaSets) {
	            redoSelectionRange =
	                this.$doc.redoChanges(this.$deserializeDeltas(deltaSets), dontSelect);
	            this.$undoStack.push(deltaSets);
	            this.dirtyCounter++;
	        }
	        return redoSelectionRange;
	    };
	    this.reset = function() {
	        this.$undoStack = [];
	        this.$redoStack = [];
	        this.dirtyCounter = 0;
	    };
	    this.hasUndo = function() {
	        return this.$undoStack.length > 0;
	    };
	    this.hasRedo = function() {
	        return this.$redoStack.length > 0;
	    };
	    this.markClean = function() {
	        this.dirtyCounter = 0;
	    };
	    this.isClean = function() {
	        return this.dirtyCounter === 0;
	    };
	    this.$serializeDeltas = function(deltaSets) {
	        return cloneDeltaSetsObj(deltaSets, $serializeDelta);
	    };
	    this.$deserializeDeltas = function(deltaSets) {
	        return cloneDeltaSetsObj(deltaSets, $deserializeDelta);
	    };
	    
	    function $serializeDelta(delta){
	        return {
	            action: delta.action,
	            start: delta.start,
	            end: delta.end,
	            lines: delta.lines.length == 1 ? null : delta.lines,
	            text: delta.lines.length == 1 ? delta.lines[0] : null
	        };
	    }
	        
	    function $deserializeDelta(delta) {
	        return {
	            action: delta.action,
	            start: delta.start,
	            end: delta.end,
	            lines: delta.lines || [delta.text]
	        };
	    }
	    
	    function cloneDeltaSetsObj(deltaSets_old, fnGetModifiedDelta) {
	        var deltaSets_new = new Array(deltaSets_old.length);
	        for (var i = 0; i < deltaSets_old.length; i++) {
	            var deltaSet_old = deltaSets_old[i];
	            var deltaSet_new = { group: deltaSet_old.group, deltas: new Array(deltaSet_old.length)};
	            
	            for (var j = 0; j < deltaSet_old.deltas.length; j++) {
	                var delta_old = deltaSet_old.deltas[j];
	                deltaSet_new.deltas[j] = fnGetModifiedDelta(delta_old);
	            }
	            
	            deltaSets_new[i] = deltaSet_new;
	        }
	        return deltaSets_new;
	    }
	    
	}).call(UndoManager.prototype);

	exports.UndoManager = UndoManager;
	});

	ace.define("ace/layer/gutter",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter"], function(acequire, exports, module) {
	"use strict";

	var dom = acequire("../lib/dom");
	var oop = acequire("../lib/oop");
	var lang = acequire("../lib/lang");
	var EventEmitter = acequire("../lib/event_emitter").EventEmitter;

	var Gutter = function(parentEl) {
	    this.element = dom.createElement("div");
	    this.element.className = "ace_layer ace_gutter-layer";
	    parentEl.appendChild(this.element);
	    this.setShowFoldWidgets(this.$showFoldWidgets);
	    
	    this.gutterWidth = 0;

	    this.$annotations = [];
	    this.$updateAnnotations = this.$updateAnnotations.bind(this);

	    this.$cells = [];
	};

	(function() {

	    oop.implement(this, EventEmitter);

	    this.setSession = function(session) {
	        if (this.session)
	            this.session.removeEventListener("change", this.$updateAnnotations);
	        this.session = session;
	        if (session)
	            session.on("change", this.$updateAnnotations);
	    };

	    this.addGutterDecoration = function(row, className){
	        if (window.console)
	            console.warn && console.warn("deprecated use session.addGutterDecoration");
	        this.session.addGutterDecoration(row, className);
	    };

	    this.removeGutterDecoration = function(row, className){
	        if (window.console)
	            console.warn && console.warn("deprecated use session.removeGutterDecoration");
	        this.session.removeGutterDecoration(row, className);
	    };

	    this.setAnnotations = function(annotations) {
	        this.$annotations = [];
	        for (var i = 0; i < annotations.length; i++) {
	            var annotation = annotations[i];
	            var row = annotation.row;
	            var rowInfo = this.$annotations[row];
	            if (!rowInfo)
	                rowInfo = this.$annotations[row] = {text: []};
	           
	            var annoText = annotation.text;
	            annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";

	            if (rowInfo.text.indexOf(annoText) === -1)
	                rowInfo.text.push(annoText);

	            var type = annotation.type;
	            if (type == "error")
	                rowInfo.className = " ace_error";
	            else if (type == "warning" && rowInfo.className != " ace_error")
	                rowInfo.className = " ace_warning";
	            else if (type == "info" && (!rowInfo.className))
	                rowInfo.className = " ace_info";
	        }
	    };

	    this.$updateAnnotations = function (delta) {
	        if (!this.$annotations.length)
	            return;
	        var firstRow = delta.start.row;
	        var len = delta.end.row - firstRow;
	        if (len === 0) {
	        } else if (delta.action == 'remove') {
	            this.$annotations.splice(firstRow, len + 1, null);
	        } else {
	            var args = new Array(len + 1);
	            args.unshift(firstRow, 1);
	            this.$annotations.splice.apply(this.$annotations, args);
	        }
	    };

	    this.update = function(config) {
	        var session = this.session;
	        var firstRow = config.firstRow;
	        var lastRow = Math.min(config.lastRow + config.gutterOffset,  // needed to compensate for hor scollbar
	            session.getLength() - 1);
	        var fold = session.getNextFoldLine(firstRow);
	        var foldStart = fold ? fold.start.row : Infinity;
	        var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
	        var breakpoints = session.$breakpoints;
	        var decorations = session.$decorations;
	        var firstLineNumber = session.$firstLineNumber;
	        var lastLineNumber = 0;
	        
	        var gutterRenderer = session.gutterRenderer || this.$renderer;

	        var cell = null;
	        var index = -1;
	        var row = firstRow;
	        while (true) {
	            if (row > foldStart) {
	                row = fold.end.row + 1;
	                fold = session.getNextFoldLine(row, fold);
	                foldStart = fold ? fold.start.row : Infinity;
	            }
	            if (row > lastRow) {
	                while (this.$cells.length > index + 1) {
	                    cell = this.$cells.pop();
	                    this.element.removeChild(cell.element);
	                }
	                break;
	            }

	            cell = this.$cells[++index];
	            if (!cell) {
	                cell = {element: null, textNode: null, foldWidget: null};
	                cell.element = dom.createElement("div");
	                cell.textNode = document.createTextNode('');
	                cell.element.appendChild(cell.textNode);
	                this.element.appendChild(cell.element);
	                this.$cells[index] = cell;
	            }

	            var className = "ace_gutter-cell ";
	            if (breakpoints[row])
	                className += breakpoints[row];
	            if (decorations[row])
	                className += decorations[row];
	            if (this.$annotations[row])
	                className += this.$annotations[row].className;
	            if (cell.element.className != className)
	                cell.element.className = className;

	            var height = session.getRowLength(row) * config.lineHeight + "px";
	            if (height != cell.element.style.height)
	                cell.element.style.height = height;

	            if (foldWidgets) {
	                var c = foldWidgets[row];
	                if (c == null)
	                    c = foldWidgets[row] = session.getFoldWidget(row);
	            }

	            if (c) {
	                if (!cell.foldWidget) {
	                    cell.foldWidget = dom.createElement("span");
	                    cell.element.appendChild(cell.foldWidget);
	                }
	                var className = "ace_fold-widget ace_" + c;
	                if (c == "start" && row == foldStart && row < fold.end.row)
	                    className += " ace_closed";
	                else
	                    className += " ace_open";
	                if (cell.foldWidget.className != className)
	                    cell.foldWidget.className = className;

	                var height = config.lineHeight + "px";
	                if (cell.foldWidget.style.height != height)
	                    cell.foldWidget.style.height = height;
	            } else {
	                if (cell.foldWidget) {
	                    cell.element.removeChild(cell.foldWidget);
	                    cell.foldWidget = null;
	                }
	            }
	            
	            var text = lastLineNumber = gutterRenderer
	                ? gutterRenderer.getText(session, row)
	                : row + firstLineNumber;
	            if (text != cell.textNode.data)
	                cell.textNode.data = text;

	            row++;
	        }

	        this.element.style.height = config.minHeight + "px";

	        if (this.$fixedWidth || session.$useWrapMode)
	            lastLineNumber = session.getLength() + firstLineNumber;

	        var gutterWidth = gutterRenderer 
	            ? gutterRenderer.getWidth(session, lastLineNumber, config)
	            : lastLineNumber.toString().length * config.characterWidth;
	        
	        var padding = this.$padding || this.$computePadding();
	        gutterWidth += padding.left + padding.right;
	        if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
	            this.gutterWidth = gutterWidth;
	            this.element.style.width = Math.ceil(this.gutterWidth) + "px";
	            this._emit("changeGutterWidth", gutterWidth);
	        }
	    };

	    this.$fixedWidth = false;
	    
	    this.$showLineNumbers = true;
	    this.$renderer = "";
	    this.setShowLineNumbers = function(show) {
	        this.$renderer = !show && {
	            getWidth: function() {return ""},
	            getText: function() {return ""}
	        };
	    };
	    
	    this.getShowLineNumbers = function() {
	        return this.$showLineNumbers;
	    };
	    
	    this.$showFoldWidgets = true;
	    this.setShowFoldWidgets = function(show) {
	        if (show)
	            dom.addCssClass(this.element, "ace_folding-enabled");
	        else
	            dom.removeCssClass(this.element, "ace_folding-enabled");

	        this.$showFoldWidgets = show;
	        this.$padding = null;
	    };
	    
	    this.getShowFoldWidgets = function() {
	        return this.$showFoldWidgets;
	    };

	    this.$computePadding = function() {
	        if (!this.element.firstChild)
	            return {left: 0, right: 0};
	        var style = dom.computedStyle(this.element.firstChild);
	        this.$padding = {};
	        this.$padding.left = parseInt(style.paddingLeft) + 1 || 0;
	        this.$padding.right = parseInt(style.paddingRight) || 0;
	        return this.$padding;
	    };

	    this.getRegion = function(point) {
	        var padding = this.$padding || this.$computePadding();
	        var rect = this.element.getBoundingClientRect();
	        if (point.x < padding.left + rect.left)
	            return "markers";
	        if (this.$showFoldWidgets && point.x > rect.right - padding.right)
	            return "foldWidgets";
	    };

	}).call(Gutter.prototype);

	exports.Gutter = Gutter;

	});

	ace.define("ace/layer/marker",["require","exports","module","ace/range","ace/lib/dom"], function(acequire, exports, module) {
	"use strict";

	var Range = acequire("../range").Range;
	var dom = acequire("../lib/dom");

	var Marker = function(parentEl) {
	    this.element = dom.createElement("div");
	    this.element.className = "ace_layer ace_marker-layer";
	    parentEl.appendChild(this.element);
	};

	(function() {

	    this.$padding = 0;

	    this.setPadding = function(padding) {
	        this.$padding = padding;
	    };
	    this.setSession = function(session) {
	        this.session = session;
	    };
	    
	    this.setMarkers = function(markers) {
	        this.markers = markers;
	    };

	    this.update = function(config) {
	        var config = config || this.config;
	        if (!config)
	            return;

	        this.config = config;


	        var html = [];
	        for (var key in this.markers) {
	            var marker = this.markers[key];

	            if (!marker.range) {
	                marker.update(html, this, this.session, config);
	                continue;
	            }

	            var range = marker.range.clipRows(config.firstRow, config.lastRow);
	            if (range.isEmpty()) continue;

	            range = range.toScreenRange(this.session);
	            if (marker.renderer) {
	                var top = this.$getTop(range.start.row, config);
	                var left = this.$padding + range.start.column * config.characterWidth;
	                marker.renderer(html, range, left, top, config);
	            } else if (marker.type == "fullLine") {
	                this.drawFullLineMarker(html, range, marker.clazz, config);
	            } else if (marker.type == "screenLine") {
	                this.drawScreenLineMarker(html, range, marker.clazz, config);
	            } else if (range.isMultiLine()) {
	                if (marker.type == "text")
	                    this.drawTextMarker(html, range, marker.clazz, config);
	                else
	                    this.drawMultiLineMarker(html, range, marker.clazz, config);
	            } else {
	                this.drawSingleLineMarker(html, range, marker.clazz + " ace_start" + " ace_br15", config);
	            }
	        }
	        this.element.innerHTML = html.join("");
	    };

	    this.$getTop = function(row, layerConfig) {
	        return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
	    };

	    function getBorderClass(tl, tr, br, bl) {
	        return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
	    }
	    this.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {
	        var session = this.session;
	        var start = range.start.row;
	        var end = range.end.row;
	        var row = start;
	        var prev = 0; 
	        var curr = 0;
	        var next = session.getScreenLastRowColumn(row);
	        var lineRange = new Range(row, range.start.column, row, curr);
	        for (; row <= end; row++) {
	            lineRange.start.row = lineRange.end.row = row;
	            lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
	            lineRange.end.column = next;
	            prev = curr;
	            curr = next;
	            next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
	            this.drawSingleLineMarker(stringBuilder, lineRange, 
	                clazz + (row == start  ? " ace_start" : "") + " ace_br"
	                    + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end),
	                layerConfig, row == end ? 0 : 1, extraStyle);
	        }
	    };
	    this.drawMultiLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
	        var padding = this.$padding;
	        var height = config.lineHeight;
	        var top = this.$getTop(range.start.row, config);
	        var left = padding + range.start.column * config.characterWidth;
	        extraStyle = extraStyle || "";

	        stringBuilder.push(
	            "<div class='", clazz, " ace_br1 ace_start' style='",
	            "height:", height, "px;",
	            "right:0;",
	            "top:", top, "px;",
	            "left:", left, "px;", extraStyle, "'></div>"
	        );
	        top = this.$getTop(range.end.row, config);
	        var width = range.end.column * config.characterWidth;

	        stringBuilder.push(
	            "<div class='", clazz, " ace_br12' style='",
	            "height:", height, "px;",
	            "width:", width, "px;",
	            "top:", top, "px;",
	            "left:", padding, "px;", extraStyle, "'></div>"
	        );
	        height = (range.end.row - range.start.row - 1) * config.lineHeight;
	        if (height <= 0)
	            return;
	        top = this.$getTop(range.start.row + 1, config);
	        
	        var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);

	        stringBuilder.push(
	            "<div class='", clazz, (radiusClass ? " ace_br" + radiusClass : ""), "' style='",
	            "height:", height, "px;",
	            "right:0;",
	            "top:", top, "px;",
	            "left:", padding, "px;", extraStyle, "'></div>"
	        );
	    };
	    this.drawSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
	        var height = config.lineHeight;
	        var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;

	        var top = this.$getTop(range.start.row, config);
	        var left = this.$padding + range.start.column * config.characterWidth;

	        stringBuilder.push(
	            "<div class='", clazz, "' style='",
	            "height:", height, "px;",
	            "width:", width, "px;",
	            "top:", top, "px;",
	            "left:", left, "px;", extraStyle || "", "'></div>"
	        );
	    };

	    this.drawFullLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
	        var top = this.$getTop(range.start.row, config);
	        var height = config.lineHeight;
	        if (range.start.row != range.end.row)
	            height += this.$getTop(range.end.row, config) - top;

	        stringBuilder.push(
	            "<div class='", clazz, "' style='",
	            "height:", height, "px;",
	            "top:", top, "px;",
	            "left:0;right:0;", extraStyle || "", "'></div>"
	        );
	    };
	    
	    this.drawScreenLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
	        var top = this.$getTop(range.start.row, config);
	        var height = config.lineHeight;

	        stringBuilder.push(
	            "<div class='", clazz, "' style='",
	            "height:", height, "px;",
	            "top:", top, "px;",
	            "left:0;right:0;", extraStyle || "", "'></div>"
	        );
	    };

	}).call(Marker.prototype);

	exports.Marker = Marker;

	});

	ace.define("ace/layer/text",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/useragent","ace/lib/event_emitter"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../lib/oop");
	var dom = acequire("../lib/dom");
	var lang = acequire("../lib/lang");
	var useragent = acequire("../lib/useragent");
	var EventEmitter = acequire("../lib/event_emitter").EventEmitter;

	var Text = function(parentEl) {
	    this.element = dom.createElement("div");
	    this.element.className = "ace_layer ace_text-layer";
	    parentEl.appendChild(this.element);
	    this.$updateEolChar = this.$updateEolChar.bind(this);
	};

	(function() {

	    oop.implement(this, EventEmitter);

	    this.EOF_CHAR = "\xB6";
	    this.EOL_CHAR_LF = "\xAC";
	    this.EOL_CHAR_CRLF = "\xa4";
	    this.EOL_CHAR = this.EOL_CHAR_LF;
	    this.TAB_CHAR = "\u2014"; //"\u21E5";
	    this.SPACE_CHAR = "\xB7";
	    this.$padding = 0;

	    this.$updateEolChar = function() {
	        var EOL_CHAR = this.session.doc.getNewLineCharacter() == "\n"
	           ? this.EOL_CHAR_LF
	           : this.EOL_CHAR_CRLF;
	        if (this.EOL_CHAR != EOL_CHAR) {
	            this.EOL_CHAR = EOL_CHAR;
	            return true;
	        }
	    }

	    this.setPadding = function(padding) {
	        this.$padding = padding;
	        this.element.style.padding = "0 " + padding + "px";
	    };

	    this.getLineHeight = function() {
	        return this.$fontMetrics.$characterSize.height || 0;
	    };

	    this.getCharacterWidth = function() {
	        return this.$fontMetrics.$characterSize.width || 0;
	    };
	    
	    this.$setFontMetrics = function(measure) {
	        this.$fontMetrics = measure;
	        this.$fontMetrics.on("changeCharacterSize", function(e) {
	            this._signal("changeCharacterSize", e);
	        }.bind(this));
	        this.$pollSizeChanges();
	    }

	    this.checkForSizeChanges = function() {
	        this.$fontMetrics.checkForSizeChanges();
	    };
	    this.$pollSizeChanges = function() {
	        return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
	    };
	    this.setSession = function(session) {
	        this.session = session;
	        if (session)
	            this.$computeTabString();
	    };

	    this.showInvisibles = false;
	    this.setShowInvisibles = function(showInvisibles) {
	        if (this.showInvisibles == showInvisibles)
	            return false;

	        this.showInvisibles = showInvisibles;
	        this.$computeTabString();
	        return true;
	    };

	    this.displayIndentGuides = true;
	    this.setDisplayIndentGuides = function(display) {
	        if (this.displayIndentGuides == display)
	            return false;

	        this.displayIndentGuides = display;
	        this.$computeTabString();
	        return true;
	    };

	    this.$tabStrings = [];
	    this.onChangeTabSize =
	    this.$computeTabString = function() {
	        var tabSize = this.session.getTabSize();
	        this.tabSize = tabSize;
	        var tabStr = this.$tabStrings = [0];
	        for (var i = 1; i < tabSize + 1; i++) {
	            if (this.showInvisibles) {
	                tabStr.push("<span class='ace_invisible ace_invisible_tab'>"
	                    + lang.stringRepeat(this.TAB_CHAR, i)
	                    + "</span>");
	            } else {
	                tabStr.push(lang.stringRepeat(" ", i));
	            }
	        }
	        if (this.displayIndentGuides) {
	            this.$indentGuideRe =  /\s\S| \t|\t |\s$/;
	            var className = "ace_indent-guide";
	            var spaceClass = "";
	            var tabClass = "";
	            if (this.showInvisibles) {
	                className += " ace_invisible";
	                spaceClass = " ace_invisible_space";
	                tabClass = " ace_invisible_tab";
	                var spaceContent = lang.stringRepeat(this.SPACE_CHAR, this.tabSize);
	                var tabContent = lang.stringRepeat(this.TAB_CHAR, this.tabSize);
	            } else{
	                var spaceContent = lang.stringRepeat(" ", this.tabSize);
	                var tabContent = spaceContent;
	            }

	            this.$tabStrings[" "] = "<span class='" + className + spaceClass + "'>" + spaceContent + "</span>";
	            this.$tabStrings["\t"] = "<span class='" + className + tabClass + "'>" + tabContent + "</span>";
	        }
	    };

	    this.updateLines = function(config, firstRow, lastRow) {
	        if (this.config.lastRow != config.lastRow ||
	            this.config.firstRow != config.firstRow) {
	            this.scrollLines(config);
	        }
	        this.config = config;

	        var first = Math.max(firstRow, config.firstRow);
	        var last = Math.min(lastRow, config.lastRow);

	        var lineElements = this.element.childNodes;
	        var lineElementsIdx = 0;

	        for (var row = config.firstRow; row < first; row++) {
	            var foldLine = this.session.getFoldLine(row);
	            if (foldLine) {
	                if (foldLine.containsRow(first)) {
	                    first = foldLine.start.row;
	                    break;
	                } else {
	                    row = foldLine.end.row;
	                }
	            }
	            lineElementsIdx ++;
	        }

	        var row = first;
	        var foldLine = this.session.getNextFoldLine(row);
	        var foldStart = foldLine ? foldLine.start.row : Infinity;

	        while (true) {
	            if (row > foldStart) {
	                row = foldLine.end.row+1;
	                foldLine = this.session.getNextFoldLine(row, foldLine);
	                foldStart = foldLine ? foldLine.start.row :Infinity;
	            }
	            if (row > last)
	                break;

	            var lineElement = lineElements[lineElementsIdx++];
	            if (lineElement) {
	                var html = [];
	                this.$renderLine(
	                    html, row, !this.$useLineGroups(), row == foldStart ? foldLine : false
	                );
	                lineElement.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
	                lineElement.innerHTML = html.join("");
	            }
	            row++;
	        }
	    };

	    this.scrollLines = function(config) {
	        var oldConfig = this.config;
	        this.config = config;

	        if (!oldConfig || oldConfig.lastRow < config.firstRow)
	            return this.update(config);

	        if (config.lastRow < oldConfig.firstRow)
	            return this.update(config);

	        var el = this.element;
	        if (oldConfig.firstRow < config.firstRow)
	            for (var row=this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row>0; row--)
	                el.removeChild(el.firstChild);

	        if (oldConfig.lastRow > config.lastRow)
	            for (var row=this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row>0; row--)
	                el.removeChild(el.lastChild);

	        if (config.firstRow < oldConfig.firstRow) {
	            var fragment = this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1);
	            if (el.firstChild)
	                el.insertBefore(fragment, el.firstChild);
	            else
	                el.appendChild(fragment);
	        }

	        if (config.lastRow > oldConfig.lastRow) {
	            var fragment = this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow);
	            el.appendChild(fragment);
	        }
	    };

	    this.$renderLinesFragment = function(config, firstRow, lastRow) {
	        var fragment = this.element.ownerDocument.createDocumentFragment();
	        var row = firstRow;
	        var foldLine = this.session.getNextFoldLine(row);
	        var foldStart = foldLine ? foldLine.start.row : Infinity;

	        while (true) {
	            if (row > foldStart) {
	                row = foldLine.end.row+1;
	                foldLine = this.session.getNextFoldLine(row, foldLine);
	                foldStart = foldLine ? foldLine.start.row : Infinity;
	            }
	            if (row > lastRow)
	                break;

	            var container = dom.createElement("div");

	            var html = [];
	            this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
	            container.innerHTML = html.join("");
	            if (this.$useLineGroups()) {
	                container.className = 'ace_line_group';
	                fragment.appendChild(container);
	                container.style.height = config.lineHeight * this.session.getRowLength(row) + "px";

	            } else {
	                while(container.firstChild)
	                    fragment.appendChild(container.firstChild);
	            }

	            row++;
	        }
	        return fragment;
	    };

	    this.update = function(config) {
	        this.config = config;

	        var html = [];
	        var firstRow = config.firstRow, lastRow = config.lastRow;

	        var row = firstRow;
	        var foldLine = this.session.getNextFoldLine(row);
	        var foldStart = foldLine ? foldLine.start.row : Infinity;

	        while (true) {
	            if (row > foldStart) {
	                row = foldLine.end.row+1;
	                foldLine = this.session.getNextFoldLine(row, foldLine);
	                foldStart = foldLine ? foldLine.start.row :Infinity;
	            }
	            if (row > lastRow)
	                break;

	            if (this.$useLineGroups())
	                html.push("<div class='ace_line_group' style='height:", config.lineHeight*this.session.getRowLength(row), "px'>")

	            this.$renderLine(html, row, false, row == foldStart ? foldLine : false);

	            if (this.$useLineGroups())
	                html.push("</div>"); // end the line group

	            row++;
	        }
	        this.element.innerHTML = html.join("");
	    };

	    this.$textToken = {
	        "text": true,
	        "rparen": true,
	        "lparen": true
	    };

	    this.$renderToken = function(stringBuilder, screenColumn, token, value) {
	        var self = this;
	        var replaceReg = /\t|&|<|>|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\u3000\uFEFF\uFFF9-\uFFFC])|[\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3000-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]/g;
	        var replaceFunc = function(c, a, b, tabIdx, idx4) {
	            if (a) {
	                return self.showInvisibles
	                    ? "<span class='ace_invisible ace_invisible_space'>" + lang.stringRepeat(self.SPACE_CHAR, c.length) + "</span>"
	                    : c;
	            } else if (c == "&") {
	                return "&#38;";
	            } else if (c == "<") {
	                return "&#60;";
	            } else if (c == ">") {
	                return "&#62;";
	            } else if (c == "\t") {
	                var tabSize = self.session.getScreenTabSize(screenColumn + tabIdx);
	                screenColumn += tabSize - 1;
	                return self.$tabStrings[tabSize];
	            } else if (c == "\u3000") {
	                var classToUse = self.showInvisibles ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
	                var space = self.showInvisibles ? self.SPACE_CHAR : "";
	                screenColumn += 1;
	                return "<span class='" + classToUse + "' style='width:" +
	                    (self.config.characterWidth * 2) +
	                    "px'>" + space + "</span>";
	            } else if (b) {
	                return "<span class='ace_invisible ace_invisible_space ace_invalid'>" + self.SPACE_CHAR + "</span>";
	            } else {
	                screenColumn += 1;
	                return "<span class='ace_cjk' style='width:" +
	                    (self.config.characterWidth * 2) +
	                    "px'>" + c + "</span>";
	            }
	        };

	        var output = value.replace(replaceReg, replaceFunc);

	        if (!this.$textToken[token.type]) {
	            var classes = "ace_" + token.type.replace(/\./g, " ace_");
	            var style = "";
	            if (token.type == "fold")
	                style = " style='width:" + (token.value.length * this.config.characterWidth) + "px;' ";
	            stringBuilder.push("<span class='", classes, "'", style, ">", output, "</span>");
	        }
	        else {
	            stringBuilder.push(output);
	        }
	        return screenColumn + value.length;
	    };

	    this.renderIndentGuide = function(stringBuilder, value, max) {
	        var cols = value.search(this.$indentGuideRe);
	        if (cols <= 0 || cols >= max)
	            return value;
	        if (value[0] == " ") {
	            cols -= cols % this.tabSize;
	            stringBuilder.push(lang.stringRepeat(this.$tabStrings[" "], cols/this.tabSize));
	            return value.substr(cols);
	        } else if (value[0] == "\t") {
	            stringBuilder.push(lang.stringRepeat(this.$tabStrings["\t"], cols));
	            return value.substr(cols);
	        }
	        return value;
	    };

	    this.$renderWrappedLine = function(stringBuilder, tokens, splits, onlyContents) {
	        var chars = 0;
	        var split = 0;
	        var splitChars = splits[0];
	        var screenColumn = 0;

	        for (var i = 0; i < tokens.length; i++) {
	            var token = tokens[i];
	            var value = token.value;
	            if (i == 0 && this.displayIndentGuides) {
	                chars = value.length;
	                value = this.renderIndentGuide(stringBuilder, value, splitChars);
	                if (!value)
	                    continue;
	                chars -= value.length;
	            }

	            if (chars + value.length < splitChars) {
	                screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
	                chars += value.length;
	            } else {
	                while (chars + value.length >= splitChars) {
	                    screenColumn = this.$renderToken(
	                        stringBuilder, screenColumn,
	                        token, value.substring(0, splitChars - chars)
	                    );
	                    value = value.substring(splitChars - chars);
	                    chars = splitChars;

	                    if (!onlyContents) {
	                        stringBuilder.push("</div>",
	                            "<div class='ace_line' style='height:",
	                            this.config.lineHeight, "px'>"
	                        );
	                    }

	                    stringBuilder.push(lang.stringRepeat("\xa0", splits.indent));

	                    split ++;
	                    screenColumn = 0;
	                    splitChars = splits[split] || Number.MAX_VALUE;
	                }
	                if (value.length != 0) {
	                    chars += value.length;
	                    screenColumn = this.$renderToken(
	                        stringBuilder, screenColumn, token, value
	                    );
	                }
	            }
	        }
	    };

	    this.$renderSimpleLine = function(stringBuilder, tokens) {
	        var screenColumn = 0;
	        var token = tokens[0];
	        var value = token.value;
	        if (this.displayIndentGuides)
	            value = this.renderIndentGuide(stringBuilder, value);
	        if (value)
	            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
	        for (var i = 1; i < tokens.length; i++) {
	            token = tokens[i];
	            value = token.value;
	            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
	        }
	    };
	    this.$renderLine = function(stringBuilder, row, onlyContents, foldLine) {
	        if (!foldLine && foldLine != false)
	            foldLine = this.session.getFoldLine(row);

	        if (foldLine)
	            var tokens = this.$getFoldLineTokens(row, foldLine);
	        else
	            var tokens = this.session.getTokens(row);


	        if (!onlyContents) {
	            stringBuilder.push(
	                "<div class='ace_line' style='height:", 
	                    this.config.lineHeight * (
	                        this.$useLineGroups() ? 1 :this.session.getRowLength(row)
	                    ), "px'>"
	            );
	        }

	        if (tokens.length) {
	            var splits = this.session.getRowSplitData(row);
	            if (splits && splits.length)
	                this.$renderWrappedLine(stringBuilder, tokens, splits, onlyContents);
	            else
	                this.$renderSimpleLine(stringBuilder, tokens);
	        }

	        if (this.showInvisibles) {
	            if (foldLine)
	                row = foldLine.end.row

	            stringBuilder.push(
	                "<span class='ace_invisible ace_invisible_eol'>",
	                row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR,
	                "</span>"
	            );
	        }
	        if (!onlyContents)
	            stringBuilder.push("</div>");
	    };

	    this.$getFoldLineTokens = function(row, foldLine) {
	        var session = this.session;
	        var renderTokens = [];

	        function addTokens(tokens, from, to) {
	            var idx = 0, col = 0;
	            while ((col + tokens[idx].value.length) < from) {
	                col += tokens[idx].value.length;
	                idx++;

	                if (idx == tokens.length)
	                    return;
	            }
	            if (col != from) {
	                var value = tokens[idx].value.substring(from - col);
	                if (value.length > (to - from))
	                    value = value.substring(0, to - from);

	                renderTokens.push({
	                    type: tokens[idx].type,
	                    value: value
	                });

	                col = from + value.length;
	                idx += 1;
	            }

	            while (col < to && idx < tokens.length) {
	                var value = tokens[idx].value;
	                if (value.length + col > to) {
	                    renderTokens.push({
	                        type: tokens[idx].type,
	                        value: value.substring(0, to - col)
	                    });
	                } else
	                    renderTokens.push(tokens[idx]);
	                col += value.length;
	                idx += 1;
	            }
	        }

	        var tokens = session.getTokens(row);
	        foldLine.walk(function(placeholder, row, column, lastColumn, isNewRow) {
	            if (placeholder != null) {
	                renderTokens.push({
	                    type: "fold",
	                    value: placeholder
	                });
	            } else {
	                if (isNewRow)
	                    tokens = session.getTokens(row);

	                if (tokens.length)
	                    addTokens(tokens, lastColumn, column);
	            }
	        }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);

	        return renderTokens;
	    };

	    this.$useLineGroups = function() {
	        return this.session.getUseWrapMode();
	    };

	    this.destroy = function() {
	        clearInterval(this.$pollSizeChangesTimer);
	        if (this.$measureNode)
	            this.$measureNode.parentNode.removeChild(this.$measureNode);
	        delete this.$measureNode;
	    };

	}).call(Text.prototype);

	exports.Text = Text;

	});

	ace.define("ace/layer/cursor",["require","exports","module","ace/lib/dom"], function(acequire, exports, module) {
	"use strict";

	var dom = acequire("../lib/dom");
	var isIE8;

	var Cursor = function(parentEl) {
	    this.element = dom.createElement("div");
	    this.element.className = "ace_layer ace_cursor-layer";
	    parentEl.appendChild(this.element);
	    
	    if (isIE8 === undefined)
	        isIE8 = !("opacity" in this.element.style);

	    this.isVisible = false;
	    this.isBlinking = true;
	    this.blinkInterval = 1000;
	    this.smoothBlinking = false;

	    this.cursors = [];
	    this.cursor = this.addCursor();
	    dom.addCssClass(this.element, "ace_hidden-cursors");
	    this.$updateCursors = (isIE8
	        ? this.$updateVisibility
	        : this.$updateOpacity).bind(this);
	};

	(function() {
	    
	    this.$updateVisibility = function(val) {
	        var cursors = this.cursors;
	        for (var i = cursors.length; i--; )
	            cursors[i].style.visibility = val ? "" : "hidden";
	    };
	    this.$updateOpacity = function(val) {
	        var cursors = this.cursors;
	        for (var i = cursors.length; i--; )
	            cursors[i].style.opacity = val ? "" : "0";
	    };
	    

	    this.$padding = 0;
	    this.setPadding = function(padding) {
	        this.$padding = padding;
	    };

	    this.setSession = function(session) {
	        this.session = session;
	    };

	    this.setBlinking = function(blinking) {
	        if (blinking != this.isBlinking){
	            this.isBlinking = blinking;
	            this.restartTimer();
	        }
	    };

	    this.setBlinkInterval = function(blinkInterval) {
	        if (blinkInterval != this.blinkInterval){
	            this.blinkInterval = blinkInterval;
	            this.restartTimer();
	        }
	    };

	    this.setSmoothBlinking = function(smoothBlinking) {
	        if (smoothBlinking != this.smoothBlinking && !isIE8) {
	            this.smoothBlinking = smoothBlinking;
	            dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
	            this.$updateCursors(true);
	            this.$updateCursors = (this.$updateOpacity).bind(this);
	            this.restartTimer();
	        }
	    };

	    this.addCursor = function() {
	        var el = dom.createElement("div");
	        el.className = "ace_cursor";
	        this.element.appendChild(el);
	        this.cursors.push(el);
	        return el;
	    };

	    this.removeCursor = function() {
	        if (this.cursors.length > 1) {
	            var el = this.cursors.pop();
	            el.parentNode.removeChild(el);
	            return el;
	        }
	    };

	    this.hideCursor = function() {
	        this.isVisible = false;
	        dom.addCssClass(this.element, "ace_hidden-cursors");
	        this.restartTimer();
	    };

	    this.showCursor = function() {
	        this.isVisible = true;
	        dom.removeCssClass(this.element, "ace_hidden-cursors");
	        this.restartTimer();
	    };

	    this.restartTimer = function() {
	        var update = this.$updateCursors;
	        clearInterval(this.intervalId);
	        clearTimeout(this.timeoutId);
	        if (this.smoothBlinking) {
	            dom.removeCssClass(this.element, "ace_smooth-blinking");
	        }
	        
	        update(true);

	        if (!this.isBlinking || !this.blinkInterval || !this.isVisible)
	            return;

	        if (this.smoothBlinking) {
	            setTimeout(function(){
	                dom.addCssClass(this.element, "ace_smooth-blinking");
	            }.bind(this));
	        }
	        
	        var blink = function(){
	            this.timeoutId = setTimeout(function() {
	                update(false);
	            }, 0.6 * this.blinkInterval);
	        }.bind(this);

	        this.intervalId = setInterval(function() {
	            update(true);
	            blink();
	        }, this.blinkInterval);

	        blink();
	    };

	    this.getPixelPosition = function(position, onScreen) {
	        if (!this.config || !this.session)
	            return {left : 0, top : 0};

	        if (!position)
	            position = this.session.selection.getCursor();
	        var pos = this.session.documentToScreenPosition(position);
	        var cursorLeft = this.$padding + pos.column * this.config.characterWidth;
	        var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) *
	            this.config.lineHeight;

	        return {left : cursorLeft, top : cursorTop};
	    };

	    this.update = function(config) {
	        this.config = config;

	        var selections = this.session.$selectionMarkers;
	        var i = 0, cursorIndex = 0;

	        if (selections === undefined || selections.length === 0){
	            selections = [{cursor: null}];
	        }

	        for (var i = 0, n = selections.length; i < n; i++) {
	            var pixelPos = this.getPixelPosition(selections[i].cursor, true);
	            if ((pixelPos.top > config.height + config.offset ||
	                 pixelPos.top < 0) && i > 1) {
	                continue;
	            }

	            var style = (this.cursors[cursorIndex++] || this.addCursor()).style;
	            
	            if (!this.drawCursor) {
	                style.left = pixelPos.left + "px";
	                style.top = pixelPos.top + "px";
	                style.width = config.characterWidth + "px";
	                style.height = config.lineHeight + "px";
	            } else {
	                this.drawCursor(style, pixelPos, config, selections[i], this.session);
	            }
	        }
	        while (this.cursors.length > cursorIndex)
	            this.removeCursor();

	        var overwrite = this.session.getOverwrite();
	        this.$setOverwrite(overwrite);
	        this.$pixelPos = pixelPos;
	        this.restartTimer();
	    };
	    
	    this.drawCursor = null;

	    this.$setOverwrite = function(overwrite) {
	        if (overwrite != this.overwrite) {
	            this.overwrite = overwrite;
	            if (overwrite)
	                dom.addCssClass(this.element, "ace_overwrite-cursors");
	            else
	                dom.removeCssClass(this.element, "ace_overwrite-cursors");
	        }
	    };

	    this.destroy = function() {
	        clearInterval(this.intervalId);
	        clearTimeout(this.timeoutId);
	    };

	}).call(Cursor.prototype);

	exports.Cursor = Cursor;

	});

	ace.define("ace/scrollbar",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/event","ace/lib/event_emitter"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("./lib/oop");
	var dom = acequire("./lib/dom");
	var event = acequire("./lib/event");
	var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
	var ScrollBar = function(parent) {
	    this.element = dom.createElement("div");
	    this.element.className = "ace_scrollbar ace_scrollbar" + this.classSuffix;

	    this.inner = dom.createElement("div");
	    this.inner.className = "ace_scrollbar-inner";
	    this.element.appendChild(this.inner);

	    parent.appendChild(this.element);

	    this.setVisible(false);
	    this.skipEvent = false;

	    event.addListener(this.element, "scroll", this.onScroll.bind(this));
	    event.addListener(this.element, "mousedown", event.preventDefault);
	};

	(function() {
	    oop.implement(this, EventEmitter);

	    this.setVisible = function(isVisible) {
	        this.element.style.display = isVisible ? "" : "none";
	        this.isVisible = isVisible;
	    };
	}).call(ScrollBar.prototype);
	var VScrollBar = function(parent, renderer) {
	    ScrollBar.call(this, parent);
	    this.scrollTop = 0;
	    renderer.$scrollbarWidth = 
	    this.width = dom.scrollbarWidth(parent.ownerDocument);
	    this.inner.style.width =
	    this.element.style.width = (this.width || 15) + 5 + "px";
	};

	oop.inherits(VScrollBar, ScrollBar);

	(function() {

	    this.classSuffix = '-v';
	    this.onScroll = function() {
	        if (!this.skipEvent) {
	            this.scrollTop = this.element.scrollTop;
	            this._emit("scroll", {data: this.scrollTop});
	        }
	        this.skipEvent = false;
	    };
	    this.getWidth = function() {
	        return this.isVisible ? this.width : 0;
	    };
	    this.setHeight = function(height) {
	        this.element.style.height = height + "px";
	    };
	    this.setInnerHeight = function(height) {
	        this.inner.style.height = height + "px";
	    };
	    this.setScrollHeight = function(height) {
	        this.inner.style.height = height + "px";
	    };
	    this.setScrollTop = function(scrollTop) {
	        if (this.scrollTop != scrollTop) {
	            this.skipEvent = true;
	            this.scrollTop = this.element.scrollTop = scrollTop;
	        }
	    };

	}).call(VScrollBar.prototype);
	var HScrollBar = function(parent, renderer) {
	    ScrollBar.call(this, parent);
	    this.scrollLeft = 0;
	    this.height = renderer.$scrollbarWidth;
	    this.inner.style.height =
	    this.element.style.height = (this.height || 15) + 5 + "px";
	};

	oop.inherits(HScrollBar, ScrollBar);

	(function() {

	    this.classSuffix = '-h';
	    this.onScroll = function() {
	        if (!this.skipEvent) {
	            this.scrollLeft = this.element.scrollLeft;
	            this._emit("scroll", {data: this.scrollLeft});
	        }
	        this.skipEvent = false;
	    };
	    this.getHeight = function() {
	        return this.isVisible ? this.height : 0;
	    };
	    this.setWidth = function(width) {
	        this.element.style.width = width + "px";
	    };
	    this.setInnerWidth = function(width) {
	        this.inner.style.width = width + "px";
	    };
	    this.setScrollWidth = function(width) {
	        this.inner.style.width = width + "px";
	    };
	    this.setScrollLeft = function(scrollLeft) {
	        if (this.scrollLeft != scrollLeft) {
	            this.skipEvent = true;
	            this.scrollLeft = this.element.scrollLeft = scrollLeft;
	        }
	    };

	}).call(HScrollBar.prototype);


	exports.ScrollBar = VScrollBar; // backward compatibility
	exports.ScrollBarV = VScrollBar; // backward compatibility
	exports.ScrollBarH = HScrollBar; // backward compatibility

	exports.VScrollBar = VScrollBar;
	exports.HScrollBar = HScrollBar;
	});

	ace.define("ace/renderloop",["require","exports","module","ace/lib/event"], function(acequire, exports, module) {
	"use strict";

	var event = acequire("./lib/event");


	var RenderLoop = function(onRender, win) {
	    this.onRender = onRender;
	    this.pending = false;
	    this.changes = 0;
	    this.window = win || window;
	};

	(function() {


	    this.schedule = function(change) {
	        this.changes = this.changes | change;
	        if (!this.pending && this.changes) {
	            this.pending = true;
	            var _self = this;
	            event.nextFrame(function() {
	                _self.pending = false;
	                var changes;
	                while (changes = _self.changes) {
	                    _self.changes = 0;
	                    _self.onRender(changes);
	                }
	            }, this.window);
	        }
	    };

	}).call(RenderLoop.prototype);

	exports.RenderLoop = RenderLoop;
	});

	ace.define("ace/layer/font_metrics",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/useragent","ace/lib/event_emitter"], function(acequire, exports, module) {

	var oop = acequire("../lib/oop");
	var dom = acequire("../lib/dom");
	var lang = acequire("../lib/lang");
	var useragent = acequire("../lib/useragent");
	var EventEmitter = acequire("../lib/event_emitter").EventEmitter;

	var CHAR_COUNT = 0;

	var FontMetrics = exports.FontMetrics = function(parentEl) {
	    this.el = dom.createElement("div");
	    this.$setMeasureNodeStyles(this.el.style, true);
	    
	    this.$main = dom.createElement("div");
	    this.$setMeasureNodeStyles(this.$main.style);
	    
	    this.$measureNode = dom.createElement("div");
	    this.$setMeasureNodeStyles(this.$measureNode.style);
	    
	    
	    this.el.appendChild(this.$main);
	    this.el.appendChild(this.$measureNode);
	    parentEl.appendChild(this.el);
	    
	    if (!CHAR_COUNT)
	        this.$testFractionalRect();
	    this.$measureNode.innerHTML = lang.stringRepeat("X", CHAR_COUNT);
	    
	    this.$characterSize = {width: 0, height: 0};
	    this.checkForSizeChanges();
	};

	(function() {

	    oop.implement(this, EventEmitter);
	        
	    this.$characterSize = {width: 0, height: 0};
	    
	    this.$testFractionalRect = function() {
	        var el = dom.createElement("div");
	        this.$setMeasureNodeStyles(el.style);
	        el.style.width = "0.2px";
	        document.documentElement.appendChild(el);
	        var w = el.getBoundingClientRect().width;
	        if (w > 0 && w < 1)
	            CHAR_COUNT = 50;
	        else
	            CHAR_COUNT = 100;
	        el.parentNode.removeChild(el);
	    };
	    
	    this.$setMeasureNodeStyles = function(style, isRoot) {
	        style.width = style.height = "auto";
	        style.left = style.top = "0px";
	        style.visibility = "hidden";
	        style.position = "absolute";
	        style.whiteSpace = "pre";

	        if (useragent.isIE < 8) {
	            style["font-family"] = "inherit";
	        } else {
	            style.font = "inherit";
	        }
	        style.overflow = isRoot ? "hidden" : "visible";
	    };

	    this.checkForSizeChanges = function() {
	        var size = this.$measureSizes();
	        if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
	            this.$measureNode.style.fontWeight = "bold";
	            var boldSize = this.$measureSizes();
	            this.$measureNode.style.fontWeight = "";
	            this.$characterSize = size;
	            this.charSizes = Object.create(null);
	            this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
	            this._emit("changeCharacterSize", {data: size});
	        }
	    };

	    this.$pollSizeChanges = function() {
	        if (this.$pollSizeChangesTimer)
	            return this.$pollSizeChangesTimer;
	        var self = this;
	        return this.$pollSizeChangesTimer = setInterval(function() {
	            self.checkForSizeChanges();
	        }, 500);
	    };
	    
	    this.setPolling = function(val) {
	        if (val) {
	            this.$pollSizeChanges();
	        } else if (this.$pollSizeChangesTimer) {
	            clearInterval(this.$pollSizeChangesTimer);
	            this.$pollSizeChangesTimer = 0;
	        }
	    };

	    this.$measureSizes = function() {
	        if (CHAR_COUNT === 50) {
	            var rect = null;
	            try { 
	               rect = this.$measureNode.getBoundingClientRect();
	            } catch(e) {
	               rect = {width: 0, height:0 };
	            }
	            var size = {
	                height: rect.height,
	                width: rect.width / CHAR_COUNT
	            };
	        } else {
	            var size = {
	                height: this.$measureNode.clientHeight,
	                width: this.$measureNode.clientWidth / CHAR_COUNT
	            };
	        }
	        if (size.width === 0 || size.height === 0)
	            return null;
	        return size;
	    };

	    this.$measureCharWidth = function(ch) {
	        this.$main.innerHTML = lang.stringRepeat(ch, CHAR_COUNT);
	        var rect = this.$main.getBoundingClientRect();
	        return rect.width / CHAR_COUNT;
	    };
	    
	    this.getCharacterWidth = function(ch) {
	        var w = this.charSizes[ch];
	        if (w === undefined) {
	            w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
	        }
	        return w;
	    };

	    this.destroy = function() {
	        clearInterval(this.$pollSizeChangesTimer);
	        if (this.el && this.el.parentNode)
	            this.el.parentNode.removeChild(this.el);
	    };

	}).call(FontMetrics.prototype);

	});

	ace.define("ace/virtual_renderer",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/config","ace/lib/useragent","ace/layer/gutter","ace/layer/marker","ace/layer/text","ace/layer/cursor","ace/scrollbar","ace/scrollbar","ace/renderloop","ace/layer/font_metrics","ace/lib/event_emitter"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("./lib/oop");
	var dom = acequire("./lib/dom");
	var config = acequire("./config");
	var useragent = acequire("./lib/useragent");
	var GutterLayer = acequire("./layer/gutter").Gutter;
	var MarkerLayer = acequire("./layer/marker").Marker;
	var TextLayer = acequire("./layer/text").Text;
	var CursorLayer = acequire("./layer/cursor").Cursor;
	var HScrollBar = acequire("./scrollbar").HScrollBar;
	var VScrollBar = acequire("./scrollbar").VScrollBar;
	var RenderLoop = acequire("./renderloop").RenderLoop;
	var FontMetrics = acequire("./layer/font_metrics").FontMetrics;
	var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
	var editorCss = ".ace_editor {\
	position: relative;\
	overflow: hidden;\
	font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;\
	direction: ltr;\
	}\
	.ace_scroller {\
	position: absolute;\
	overflow: hidden;\
	top: 0;\
	bottom: 0;\
	background-color: inherit;\
	-ms-user-select: none;\
	-moz-user-select: none;\
	-webkit-user-select: none;\
	user-select: none;\
	cursor: text;\
	}\
	.ace_content {\
	position: absolute;\
	-moz-box-sizing: border-box;\
	-webkit-box-sizing: border-box;\
	box-sizing: border-box;\
	min-width: 100%;\
	}\
	.ace_dragging .ace_scroller:before{\
	position: absolute;\
	top: 0;\
	left: 0;\
	right: 0;\
	bottom: 0;\
	content: '';\
	background: rgba(250, 250, 250, 0.01);\
	z-index: 1000;\
	}\
	.ace_dragging.ace_dark .ace_scroller:before{\
	background: rgba(0, 0, 0, 0.01);\
	}\
	.ace_selecting, .ace_selecting * {\
	cursor: text !important;\
	}\
	.ace_gutter {\
	position: absolute;\
	overflow : hidden;\
	width: auto;\
	top: 0;\
	bottom: 0;\
	left: 0;\
	cursor: default;\
	z-index: 4;\
	-ms-user-select: none;\
	-moz-user-select: none;\
	-webkit-user-select: none;\
	user-select: none;\
	}\
	.ace_gutter-active-line {\
	position: absolute;\
	left: 0;\
	right: 0;\
	}\
	.ace_scroller.ace_scroll-left {\
	box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\
	}\
	.ace_gutter-cell {\
	padding-left: 19px;\
	padding-right: 6px;\
	background-repeat: no-repeat;\
	}\
	.ace_gutter-cell.ace_error {\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==\");\
	background-repeat: no-repeat;\
	background-position: 2px center;\
	}\
	.ace_gutter-cell.ace_warning {\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==\");\
	background-position: 2px center;\
	}\
	.ace_gutter-cell.ace_info {\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=\");\
	background-position: 2px center;\
	}\
	.ace_dark .ace_gutter-cell.ace_info {\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC\");\
	}\
	.ace_scrollbar {\
	position: absolute;\
	right: 0;\
	bottom: 0;\
	z-index: 6;\
	}\
	.ace_scrollbar-inner {\
	position: absolute;\
	cursor: text;\
	left: 0;\
	top: 0;\
	}\
	.ace_scrollbar-v{\
	overflow-x: hidden;\
	overflow-y: scroll;\
	top: 0;\
	}\
	.ace_scrollbar-h {\
	overflow-x: scroll;\
	overflow-y: hidden;\
	left: 0;\
	}\
	.ace_print-margin {\
	position: absolute;\
	height: 100%;\
	}\
	.ace_text-input {\
	position: absolute;\
	z-index: 0;\
	width: 0.5em;\
	height: 1em;\
	opacity: 0;\
	background: transparent;\
	-moz-appearance: none;\
	appearance: none;\
	border: none;\
	resize: none;\
	outline: none;\
	overflow: hidden;\
	font: inherit;\
	padding: 0 1px;\
	margin: 0 -1px;\
	text-indent: -1em;\
	-ms-user-select: text;\
	-moz-user-select: text;\
	-webkit-user-select: text;\
	user-select: text;\
	white-space: pre!important;\
	}\
	.ace_text-input.ace_composition {\
	background: inherit;\
	color: inherit;\
	z-index: 1000;\
	opacity: 1;\
	text-indent: 0;\
	}\
	.ace_layer {\
	z-index: 1;\
	position: absolute;\
	overflow: hidden;\
	word-wrap: normal;\
	white-space: pre;\
	height: 100%;\
	width: 100%;\
	-moz-box-sizing: border-box;\
	-webkit-box-sizing: border-box;\
	box-sizing: border-box;\
	pointer-events: none;\
	}\
	.ace_gutter-layer {\
	position: relative;\
	width: auto;\
	text-align: right;\
	pointer-events: auto;\
	}\
	.ace_text-layer {\
	font: inherit !important;\
	}\
	.ace_cjk {\
	display: inline-block;\
	text-align: center;\
	}\
	.ace_cursor-layer {\
	z-index: 4;\
	}\
	.ace_cursor {\
	z-index: 4;\
	position: absolute;\
	-moz-box-sizing: border-box;\
	-webkit-box-sizing: border-box;\
	box-sizing: border-box;\
	border-left: 2px solid;\
	transform: translatez(0);\
	}\
	.ace_slim-cursors .ace_cursor {\
	border-left-width: 1px;\
	}\
	.ace_overwrite-cursors .ace_cursor {\
	border-left-width: 0;\
	border-bottom: 1px solid;\
	}\
	.ace_hidden-cursors .ace_cursor {\
	opacity: 0.2;\
	}\
	.ace_smooth-blinking .ace_cursor {\
	-webkit-transition: opacity 0.18s;\
	transition: opacity 0.18s;\
	}\
	.ace_editor.ace_multiselect .ace_cursor {\
	border-left-width: 1px;\
	}\
	.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\
	position: absolute;\
	z-index: 3;\
	}\
	.ace_marker-layer .ace_selection {\
	position: absolute;\
	z-index: 5;\
	}\
	.ace_marker-layer .ace_bracket {\
	position: absolute;\
	z-index: 6;\
	}\
	.ace_marker-layer .ace_active-line {\
	position: absolute;\
	z-index: 2;\
	}\
	.ace_marker-layer .ace_selected-word {\
	position: absolute;\
	z-index: 4;\
	-moz-box-sizing: border-box;\
	-webkit-box-sizing: border-box;\
	box-sizing: border-box;\
	}\
	.ace_line .ace_fold {\
	-moz-box-sizing: border-box;\
	-webkit-box-sizing: border-box;\
	box-sizing: border-box;\
	display: inline-block;\
	height: 11px;\
	margin-top: -2px;\
	vertical-align: middle;\
	background-image:\
	url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
	url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=\");\
	background-repeat: no-repeat, repeat-x;\
	background-position: center center, top left;\
	color: transparent;\
	border: 1px solid black;\
	border-radius: 2px;\
	cursor: pointer;\
	pointer-events: auto;\
	}\
	.ace_dark .ace_fold {\
	}\
	.ace_fold:hover{\
	background-image:\
	url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
	url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC\");\
	}\
	.ace_tooltip {\
	background-color: #FFF;\
	background-image: -webkit-linear-gradient(top, transparent, rgba(0, 0, 0, 0.1));\
	background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));\
	border: 1px solid gray;\
	border-radius: 1px;\
	box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\
	color: black;\
	max-width: 100%;\
	padding: 3px 4px;\
	position: fixed;\
	z-index: 999999;\
	-moz-box-sizing: border-box;\
	-webkit-box-sizing: border-box;\
	box-sizing: border-box;\
	cursor: default;\
	white-space: pre;\
	word-wrap: break-word;\
	line-height: normal;\
	font-style: normal;\
	font-weight: normal;\
	letter-spacing: normal;\
	pointer-events: none;\
	}\
	.ace_folding-enabled > .ace_gutter-cell {\
	padding-right: 13px;\
	}\
	.ace_fold-widget {\
	-moz-box-sizing: border-box;\
	-webkit-box-sizing: border-box;\
	box-sizing: border-box;\
	margin: 0 -12px 0 1px;\
	display: none;\
	width: 11px;\
	vertical-align: top;\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==\");\
	background-repeat: no-repeat;\
	background-position: center;\
	border-radius: 3px;\
	border: 1px solid transparent;\
	cursor: pointer;\
	}\
	.ace_folding-enabled .ace_fold-widget {\
	display: inline-block;   \
	}\
	.ace_fold-widget.ace_end {\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==\");\
	}\
	.ace_fold-widget.ace_closed {\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==\");\
	}\
	.ace_fold-widget:hover {\
	border: 1px solid rgba(0, 0, 0, 0.3);\
	background-color: rgba(255, 255, 255, 0.2);\
	box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\
	}\
	.ace_fold-widget:active {\
	border: 1px solid rgba(0, 0, 0, 0.4);\
	background-color: rgba(0, 0, 0, 0.05);\
	box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\
	}\
	.ace_dark .ace_fold-widget {\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC\");\
	}\
	.ace_dark .ace_fold-widget.ace_end {\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==\");\
	}\
	.ace_dark .ace_fold-widget.ace_closed {\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==\");\
	}\
	.ace_dark .ace_fold-widget:hover {\
	box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
	background-color: rgba(255, 255, 255, 0.1);\
	}\
	.ace_dark .ace_fold-widget:active {\
	box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
	}\
	.ace_fold-widget.ace_invalid {\
	background-color: #FFB4B4;\
	border-color: #DE5555;\
	}\
	.ace_fade-fold-widgets .ace_fold-widget {\
	-webkit-transition: opacity 0.4s ease 0.05s;\
	transition: opacity 0.4s ease 0.05s;\
	opacity: 0;\
	}\
	.ace_fade-fold-widgets:hover .ace_fold-widget {\
	-webkit-transition: opacity 0.05s ease 0.05s;\
	transition: opacity 0.05s ease 0.05s;\
	opacity:1;\
	}\
	.ace_underline {\
	text-decoration: underline;\
	}\
	.ace_bold {\
	font-weight: bold;\
	}\
	.ace_nobold .ace_bold {\
	font-weight: normal;\
	}\
	.ace_italic {\
	font-style: italic;\
	}\
	.ace_error-marker {\
	background-color: rgba(255, 0, 0,0.2);\
	position: absolute;\
	z-index: 9;\
	}\
	.ace_highlight-marker {\
	background-color: rgba(255, 255, 0,0.2);\
	position: absolute;\
	z-index: 8;\
	}\
	.ace_br1 {border-top-left-radius    : 3px;}\
	.ace_br2 {border-top-right-radius   : 3px;}\
	.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}\
	.ace_br4 {border-bottom-right-radius: 3px;}\
	.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}\
	.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}\
	.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}\
	.ace_br8 {border-bottom-left-radius : 3px;}\
	.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}\
	.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}\
	.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}\
	.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
	.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
	.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
	.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}\
	";

	dom.importCssString(editorCss, "ace_editor.css");

	var VirtualRenderer = function(container, theme) {
	    var _self = this;

	    this.container = container || dom.createElement("div");
	    this.$keepTextAreaAtCursor = !useragent.isOldIE;

	    dom.addCssClass(this.container, "ace_editor");

	    this.setTheme(theme);

	    this.$gutter = dom.createElement("div");
	    this.$gutter.className = "ace_gutter";
	    this.container.appendChild(this.$gutter);

	    this.scroller = dom.createElement("div");
	    this.scroller.className = "ace_scroller";
	    this.container.appendChild(this.scroller);

	    this.content = dom.createElement("div");
	    this.content.className = "ace_content";
	    this.scroller.appendChild(this.content);

	    this.$gutterLayer = new GutterLayer(this.$gutter);
	    this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));

	    this.$markerBack = new MarkerLayer(this.content);

	    var textLayer = this.$textLayer = new TextLayer(this.content);
	    this.canvas = textLayer.element;

	    this.$markerFront = new MarkerLayer(this.content);

	    this.$cursorLayer = new CursorLayer(this.content);
	    this.$horizScroll = false;
	    this.$vScroll = false;

	    this.scrollBar = 
	    this.scrollBarV = new VScrollBar(this.container, this);
	    this.scrollBarH = new HScrollBar(this.container, this);
	    this.scrollBarV.addEventListener("scroll", function(e) {
	        if (!_self.$scrollAnimation)
	            _self.session.setScrollTop(e.data - _self.scrollMargin.top);
	    });
	    this.scrollBarH.addEventListener("scroll", function(e) {
	        if (!_self.$scrollAnimation)
	            _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
	    });

	    this.scrollTop = 0;
	    this.scrollLeft = 0;

	    this.cursorPos = {
	        row : 0,
	        column : 0
	    };

	    this.$fontMetrics = new FontMetrics(this.container);
	    this.$textLayer.$setFontMetrics(this.$fontMetrics);
	    this.$textLayer.addEventListener("changeCharacterSize", function(e) {
	        _self.updateCharacterSize();
	        _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
	        _self._signal("changeCharacterSize", e);
	    });

	    this.$size = {
	        width: 0,
	        height: 0,
	        scrollerHeight: 0,
	        scrollerWidth: 0,
	        $dirty: true
	    };

	    this.layerConfig = {
	        width : 1,
	        padding : 0,
	        firstRow : 0,
	        firstRowScreen: 0,
	        lastRow : 0,
	        lineHeight : 0,
	        characterWidth : 0,
	        minHeight : 1,
	        maxHeight : 1,
	        offset : 0,
	        height : 1,
	        gutterOffset: 1
	    };
	    
	    this.scrollMargin = {
	        left: 0,
	        right: 0,
	        top: 0,
	        bottom: 0,
	        v: 0,
	        h: 0
	    };

	    this.$loop = new RenderLoop(
	        this.$renderChanges.bind(this),
	        this.container.ownerDocument.defaultView
	    );
	    this.$loop.schedule(this.CHANGE_FULL);

	    this.updateCharacterSize();
	    this.setPadding(4);
	    config.resetOptions(this);
	    config._emit("renderer", this);
	};

	(function() {

	    this.CHANGE_CURSOR = 1;
	    this.CHANGE_MARKER = 2;
	    this.CHANGE_GUTTER = 4;
	    this.CHANGE_SCROLL = 8;
	    this.CHANGE_LINES = 16;
	    this.CHANGE_TEXT = 32;
	    this.CHANGE_SIZE = 64;
	    this.CHANGE_MARKER_BACK = 128;
	    this.CHANGE_MARKER_FRONT = 256;
	    this.CHANGE_FULL = 512;
	    this.CHANGE_H_SCROLL = 1024;

	    oop.implement(this, EventEmitter);

	    this.updateCharacterSize = function() {
	        if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
	            this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
	            this.setStyle("ace_nobold", !this.$allowBoldFonts);
	        }

	        this.layerConfig.characterWidth =
	        this.characterWidth = this.$textLayer.getCharacterWidth();
	        this.layerConfig.lineHeight =
	        this.lineHeight = this.$textLayer.getLineHeight();
	        this.$updatePrintMargin();
	    };
	    this.setSession = function(session) {
	        if (this.session)
	            this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);
	            
	        this.session = session;
	        if (session && this.scrollMargin.top && session.getScrollTop() <= 0)
	            session.setScrollTop(-this.scrollMargin.top);

	        this.$cursorLayer.setSession(session);
	        this.$markerBack.setSession(session);
	        this.$markerFront.setSession(session);
	        this.$gutterLayer.setSession(session);
	        this.$textLayer.setSession(session);
	        if (!session)
	            return;
	        
	        this.$loop.schedule(this.CHANGE_FULL);
	        this.session.$setFontMetrics(this.$fontMetrics);
	        
	        this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
	        this.onChangeNewLineMode()
	        this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
	    };
	    this.updateLines = function(firstRow, lastRow, force) {
	        if (lastRow === undefined)
	            lastRow = Infinity;

	        if (!this.$changedLines) {
	            this.$changedLines = {
	                firstRow: firstRow,
	                lastRow: lastRow
	            };
	        }
	        else {
	            if (this.$changedLines.firstRow > firstRow)
	                this.$changedLines.firstRow = firstRow;

	            if (this.$changedLines.lastRow < lastRow)
	                this.$changedLines.lastRow = lastRow;
	        }
	        if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
	            if (force)
	                this.$changedLines.lastRow = this.layerConfig.lastRow;
	            else
	                return;
	        }
	        if (this.$changedLines.firstRow > this.layerConfig.lastRow)
	            return;
	        this.$loop.schedule(this.CHANGE_LINES);
	    };

	    this.onChangeNewLineMode = function() {
	        this.$loop.schedule(this.CHANGE_TEXT);
	        this.$textLayer.$updateEolChar();
	    };
	    
	    this.onChangeTabSize = function() {
	        this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
	        this.$textLayer.onChangeTabSize();
	    };
	    this.updateText = function() {
	        this.$loop.schedule(this.CHANGE_TEXT);
	    };
	    this.updateFull = function(force) {
	        if (force)
	            this.$renderChanges(this.CHANGE_FULL, true);
	        else
	            this.$loop.schedule(this.CHANGE_FULL);
	    };
	    this.updateFontSize = function() {
	        this.$textLayer.checkForSizeChanges();
	    };

	    this.$changes = 0;
	    this.$updateSizeAsync = function() {
	        if (this.$loop.pending)
	            this.$size.$dirty = true;
	        else
	            this.onResize();
	    };
	    this.onResize = function(force, gutterWidth, width, height) {
	        if (this.resizing > 2)
	            return;
	        else if (this.resizing > 0)
	            this.resizing++;
	        else
	            this.resizing = force ? 1 : 0;
	        var el = this.container;
	        if (!height)
	            height = el.clientHeight || el.scrollHeight;
	        if (!width)
	            width = el.clientWidth || el.scrollWidth;
	        var changes = this.$updateCachedSize(force, gutterWidth, width, height);

	        
	        if (!this.$size.scrollerHeight || (!width && !height))
	            return this.resizing = 0;

	        if (force)
	            this.$gutterLayer.$padding = null;

	        if (force)
	            this.$renderChanges(changes | this.$changes, true);
	        else
	            this.$loop.schedule(changes | this.$changes);

	        if (this.resizing)
	            this.resizing = 0;
	        this.scrollBarV.scrollLeft = this.scrollBarV.scrollTop = null;
	    };
	    
	    this.$updateCachedSize = function(force, gutterWidth, width, height) {
	        height -= (this.$extraHeight || 0);
	        var changes = 0;
	        var size = this.$size;
	        var oldSize = {
	            width: size.width,
	            height: size.height,
	            scrollerHeight: size.scrollerHeight,
	            scrollerWidth: size.scrollerWidth
	        };
	        if (height && (force || size.height != height)) {
	            size.height = height;
	            changes |= this.CHANGE_SIZE;

	            size.scrollerHeight = size.height;
	            if (this.$horizScroll)
	                size.scrollerHeight -= this.scrollBarH.getHeight();
	            this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";

	            changes = changes | this.CHANGE_SCROLL;
	        }

	        if (width && (force || size.width != width)) {
	            changes |= this.CHANGE_SIZE;
	            size.width = width;
	            
	            if (gutterWidth == null)
	                gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
	            
	            this.gutterWidth = gutterWidth;
	            
	            this.scrollBarH.element.style.left = 
	            this.scroller.style.left = gutterWidth + "px";
	            size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth());           
	            
	            this.scrollBarH.element.style.right = 
	            this.scroller.style.right = this.scrollBarV.getWidth() + "px";
	            this.scroller.style.bottom = this.scrollBarH.getHeight() + "px";

	            if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force)
	                changes |= this.CHANGE_FULL;
	        }
	        
	        size.$dirty = !width || !height;

	        if (changes)
	            this._signal("resize", oldSize);

	        return changes;
	    };

	    this.onGutterResize = function() {
	        var gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
	        if (gutterWidth != this.gutterWidth)
	            this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);

	        if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
	            this.$loop.schedule(this.CHANGE_FULL);
	        } else if (this.$size.$dirty) {
	            this.$loop.schedule(this.CHANGE_FULL);
	        } else {
	            this.$computeLayerConfig();
	            this.$loop.schedule(this.CHANGE_MARKER);
	        }
	    };
	    this.adjustWrapLimit = function() {
	        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
	        var limit = Math.floor(availableWidth / this.characterWidth);
	        return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
	    };
	    this.setAnimatedScroll = function(shouldAnimate){
	        this.setOption("animatedScroll", shouldAnimate);
	    };
	    this.getAnimatedScroll = function() {
	        return this.$animatedScroll;
	    };
	    this.setShowInvisibles = function(showInvisibles) {
	        this.setOption("showInvisibles", showInvisibles);
	    };
	    this.getShowInvisibles = function() {
	        return this.getOption("showInvisibles");
	    };
	    this.getDisplayIndentGuides = function() {
	        return this.getOption("displayIndentGuides");
	    };

	    this.setDisplayIndentGuides = function(display) {
	        this.setOption("displayIndentGuides", display);
	    };
	    this.setShowPrintMargin = function(showPrintMargin) {
	        this.setOption("showPrintMargin", showPrintMargin);
	    };
	    this.getShowPrintMargin = function() {
	        return this.getOption("showPrintMargin");
	    };
	    this.setPrintMarginColumn = function(showPrintMargin) {
	        this.setOption("printMarginColumn", showPrintMargin);
	    };
	    this.getPrintMarginColumn = function() {
	        return this.getOption("printMarginColumn");
	    };
	    this.getShowGutter = function(){
	        return this.getOption("showGutter");
	    };
	    this.setShowGutter = function(show){
	        return this.setOption("showGutter", show);
	    };

	    this.getFadeFoldWidgets = function(){
	        return this.getOption("fadeFoldWidgets")
	    };

	    this.setFadeFoldWidgets = function(show) {
	        this.setOption("fadeFoldWidgets", show);
	    };

	    this.setHighlightGutterLine = function(shouldHighlight) {
	        this.setOption("highlightGutterLine", shouldHighlight);
	    };

	    this.getHighlightGutterLine = function() {
	        return this.getOption("highlightGutterLine");
	    };

	    this.$updateGutterLineHighlight = function() {
	        var pos = this.$cursorLayer.$pixelPos;
	        var height = this.layerConfig.lineHeight;
	        if (this.session.getUseWrapMode()) {
	            var cursor = this.session.selection.getCursor();
	            cursor.column = 0;
	            pos = this.$cursorLayer.getPixelPosition(cursor, true);
	            height *= this.session.getRowLength(cursor.row);
	        }
	        this.$gutterLineHighlight.style.top = pos.top - this.layerConfig.offset + "px";
	        this.$gutterLineHighlight.style.height = height + "px";
	    };

	    this.$updatePrintMargin = function() {
	        if (!this.$showPrintMargin && !this.$printMarginEl)
	            return;

	        if (!this.$printMarginEl) {
	            var containerEl = dom.createElement("div");
	            containerEl.className = "ace_layer ace_print-margin-layer";
	            this.$printMarginEl = dom.createElement("div");
	            this.$printMarginEl.className = "ace_print-margin";
	            containerEl.appendChild(this.$printMarginEl);
	            this.content.insertBefore(containerEl, this.content.firstChild);
	        }

	        var style = this.$printMarginEl.style;
	        style.left = ((this.characterWidth * this.$printMarginColumn) + this.$padding) + "px";
	        style.visibility = this.$showPrintMargin ? "visible" : "hidden";
	        
	        if (this.session && this.session.$wrap == -1)
	            this.adjustWrapLimit();
	    };
	    this.getContainerElement = function() {
	        return this.container;
	    };
	    this.getMouseEventTarget = function() {
	        return this.scroller;
	    };
	    this.getTextAreaContainer = function() {
	        return this.container;
	    };
	    this.$moveTextAreaToCursor = function() {
	        if (!this.$keepTextAreaAtCursor)
	            return;
	        var config = this.layerConfig;
	        var posTop = this.$cursorLayer.$pixelPos.top;
	        var posLeft = this.$cursorLayer.$pixelPos.left;
	        posTop -= config.offset;

	        var style = this.textarea.style;
	        var h = this.lineHeight;
	        if (posTop < 0 || posTop > config.height - h) {
	            style.top = style.left = "0";
	            return;
	        }

	        var w = this.characterWidth;
	        if (this.$composition) {
	            var val = this.textarea.value.replace(/^\x01+/, "");
	            w *= (this.session.$getStringScreenWidth(val)[0]+2);
	            h += 2;
	        }
	        posLeft -= this.scrollLeft;
	        if (posLeft > this.$size.scrollerWidth - w)
	            posLeft = this.$size.scrollerWidth - w;

	        posLeft += this.gutterWidth;
	        style.height = h + "px";
	        style.width = w + "px";
	        style.left = Math.min(posLeft, this.$size.scrollerWidth - w) + "px";
	        style.top = Math.min(posTop, this.$size.height - h) + "px";
	    };
	    this.getFirstVisibleRow = function() {
	        return this.layerConfig.firstRow;
	    };
	    this.getFirstFullyVisibleRow = function() {
	        return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
	    };
	    this.getLastFullyVisibleRow = function() {
	        var config = this.layerConfig;
	        var lastRow = config.lastRow
	        var top = this.session.documentToScreenRow(lastRow, 0) * config.lineHeight;
	        if (top - this.session.getScrollTop() > config.height - config.lineHeight)
	            return lastRow - 1;
	        return lastRow;
	    };
	    this.getLastVisibleRow = function() {
	        return this.layerConfig.lastRow;
	    };

	    this.$padding = null;
	    this.setPadding = function(padding) {
	        this.$padding = padding;
	        this.$textLayer.setPadding(padding);
	        this.$cursorLayer.setPadding(padding);
	        this.$markerFront.setPadding(padding);
	        this.$markerBack.setPadding(padding);
	        this.$loop.schedule(this.CHANGE_FULL);
	        this.$updatePrintMargin();
	    };
	    
	    this.setScrollMargin = function(top, bottom, left, right) {
	        var sm = this.scrollMargin;
	        sm.top = top|0;
	        sm.bottom = bottom|0;
	        sm.right = right|0;
	        sm.left = left|0;
	        sm.v = sm.top + sm.bottom;
	        sm.h = sm.left + sm.right;
	        if (sm.top && this.scrollTop <= 0 && this.session)
	            this.session.setScrollTop(-sm.top);
	        this.updateFull();
	    };
	    this.getHScrollBarAlwaysVisible = function() {
	        return this.$hScrollBarAlwaysVisible;
	    };
	    this.setHScrollBarAlwaysVisible = function(alwaysVisible) {
	        this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
	    };
	    this.getVScrollBarAlwaysVisible = function() {
	        return this.$vScrollBarAlwaysVisible;
	    };
	    this.setVScrollBarAlwaysVisible = function(alwaysVisible) {
	        this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
	    };

	    this.$updateScrollBarV = function() {
	        var scrollHeight = this.layerConfig.maxHeight;
	        var scrollerHeight = this.$size.scrollerHeight;
	        if (!this.$maxLines && this.$scrollPastEnd) {
	            scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
	            if (this.scrollTop > scrollHeight - scrollerHeight) {
	                scrollHeight = this.scrollTop + scrollerHeight;
	                this.scrollBarV.scrollTop = null;
	            }
	        }
	        this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
	        this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
	    };
	    this.$updateScrollBarH = function() {
	        this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
	        this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
	    };
	    
	    this.$frozen = false;
	    this.freeze = function() {
	        this.$frozen = true;
	    };
	    
	    this.unfreeze = function() {
	        this.$frozen = false;
	    };

	    this.$renderChanges = function(changes, force) {
	        if (this.$changes) {
	            changes |= this.$changes;
	            this.$changes = 0;
	        }
	        if ((!this.session || !this.container.offsetWidth || this.$frozen) || (!changes && !force)) {
	            this.$changes |= changes;
	            return; 
	        } 
	        if (this.$size.$dirty) {
	            this.$changes |= changes;
	            return this.onResize(true);
	        }
	        if (!this.lineHeight) {
	            this.$textLayer.checkForSizeChanges();
	        }
	        
	        this._signal("beforeRender");
	        var config = this.layerConfig;
	        if (changes & this.CHANGE_FULL ||
	            changes & this.CHANGE_SIZE ||
	            changes & this.CHANGE_TEXT ||
	            changes & this.CHANGE_LINES ||
	            changes & this.CHANGE_SCROLL ||
	            changes & this.CHANGE_H_SCROLL
	        ) {
	            changes |= this.$computeLayerConfig();
	            if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {
	                var st = this.scrollTop + (config.firstRow - this.layerConfig.firstRow) * this.lineHeight;
	                if (st > 0) {
	                    this.scrollTop = st;
	                    changes = changes | this.CHANGE_SCROLL;
	                    changes |= this.$computeLayerConfig();
	                }
	            }
	            config = this.layerConfig;
	            this.$updateScrollBarV();
	            if (changes & this.CHANGE_H_SCROLL)
	                this.$updateScrollBarH();
	            this.$gutterLayer.element.style.marginTop = (-config.offset) + "px";
	            this.content.style.marginTop = (-config.offset) + "px";
	            this.content.style.width = config.width + 2 * this.$padding + "px";
	            this.content.style.height = config.minHeight + "px";
	        }
	        if (changes & this.CHANGE_H_SCROLL) {
	            this.content.style.marginLeft = -this.scrollLeft + "px";
	            this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller" : "ace_scroller ace_scroll-left";
	        }
	        if (changes & this.CHANGE_FULL) {
	            this.$textLayer.update(config);
	            if (this.$showGutter)
	                this.$gutterLayer.update(config);
	            this.$markerBack.update(config);
	            this.$markerFront.update(config);
	            this.$cursorLayer.update(config);
	            this.$moveTextAreaToCursor();
	            this.$highlightGutterLine && this.$updateGutterLineHighlight();
	            this._signal("afterRender");
	            return;
	        }
	        if (changes & this.CHANGE_SCROLL) {
	            if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
	                this.$textLayer.update(config);
	            else
	                this.$textLayer.scrollLines(config);

	            if (this.$showGutter)
	                this.$gutterLayer.update(config);
	            this.$markerBack.update(config);
	            this.$markerFront.update(config);
	            this.$cursorLayer.update(config);
	            this.$highlightGutterLine && this.$updateGutterLineHighlight();
	            this.$moveTextAreaToCursor();
	            this._signal("afterRender");
	            return;
	        }

	        if (changes & this.CHANGE_TEXT) {
	            this.$textLayer.update(config);
	            if (this.$showGutter)
	                this.$gutterLayer.update(config);
	        }
	        else if (changes & this.CHANGE_LINES) {
	            if (this.$updateLines() || (changes & this.CHANGE_GUTTER) && this.$showGutter)
	                this.$gutterLayer.update(config);
	        }
	        else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
	            if (this.$showGutter)
	                this.$gutterLayer.update(config);
	        }

	        if (changes & this.CHANGE_CURSOR) {
	            this.$cursorLayer.update(config);
	            this.$moveTextAreaToCursor();
	            this.$highlightGutterLine && this.$updateGutterLineHighlight();
	        }

	        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
	            this.$markerFront.update(config);
	        }

	        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
	            this.$markerBack.update(config);
	        }

	        this._signal("afterRender");
	    };

	    
	    this.$autosize = function() {
	        var height = this.session.getScreenLength() * this.lineHeight;
	        var maxHeight = this.$maxLines * this.lineHeight;
	        var desiredHeight = Math.max(
	            (this.$minLines||1) * this.lineHeight,
	            Math.min(maxHeight, height)
	        ) + this.scrollMargin.v + (this.$extraHeight || 0);
	        if (this.$horizScroll)
	            desiredHeight += this.scrollBarH.getHeight();
	        var vScroll = height > maxHeight;
	        
	        if (desiredHeight != this.desiredHeight ||
	            this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
	            if (vScroll != this.$vScroll) {
	                this.$vScroll = vScroll;
	                this.scrollBarV.setVisible(vScroll);
	            }
	            
	            var w = this.container.clientWidth;
	            this.container.style.height = desiredHeight + "px";
	            this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
	            this.desiredHeight = desiredHeight;
	            
	            this._signal("autosize");
	        }
	    };
	    
	    this.$computeLayerConfig = function() {
	        var session = this.session;
	        var size = this.$size;
	        
	        var hideScrollbars = size.height <= 2 * this.lineHeight;
	        var screenLines = this.session.getScreenLength();
	        var maxHeight = screenLines * this.lineHeight;

	        var longestLine = this.$getLongestLine();
	        
	        var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible ||
	            size.scrollerWidth - longestLine - 2 * this.$padding < 0);

	        var hScrollChanged = this.$horizScroll !== horizScroll;
	        if (hScrollChanged) {
	            this.$horizScroll = horizScroll;
	            this.scrollBarH.setVisible(horizScroll);
	        }
	        var vScrollBefore = this.$vScroll; // autosize can change vscroll value in which case we need to update longestLine
	        if (this.$maxLines && this.lineHeight > 1)
	            this.$autosize();

	        var offset = this.scrollTop % this.lineHeight;
	        var minHeight = size.scrollerHeight + this.lineHeight;
	        
	        var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd
	            ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd
	            : 0;
	        maxHeight += scrollPastEnd;
	        
	        var sm = this.scrollMargin;
	        this.session.setScrollTop(Math.max(-sm.top,
	            Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));

	        this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, 
	            longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));
	        
	        var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible ||
	            size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
	        var vScrollChanged = vScrollBefore !== vScroll;
	        if (vScrollChanged) {
	            this.$vScroll = vScroll;
	            this.scrollBarV.setVisible(vScroll);
	        }

	        var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
	        var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
	        var lastRow = firstRow + lineCount;
	        var firstRowScreen, firstRowHeight;
	        var lineHeight = this.lineHeight;
	        firstRow = session.screenToDocumentRow(firstRow, 0);
	        var foldLine = session.getFoldLine(firstRow);
	        if (foldLine) {
	            firstRow = foldLine.start.row;
	        }

	        firstRowScreen = session.documentToScreenRow(firstRow, 0);
	        firstRowHeight = session.getRowLength(firstRow) * lineHeight;

	        lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
	        minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight +
	                                                firstRowHeight;

	        offset = this.scrollTop - firstRowScreen * lineHeight;

	        var changes = 0;
	        if (this.layerConfig.width != longestLine) 
	            changes = this.CHANGE_H_SCROLL;
	        if (hScrollChanged || vScrollChanged) {
	            changes = this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
	            this._signal("scrollbarVisibilityChanged");
	            if (vScrollChanged)
	                longestLine = this.$getLongestLine();
	        }
	        
	        this.layerConfig = {
	            width : longestLine,
	            padding : this.$padding,
	            firstRow : firstRow,
	            firstRowScreen: firstRowScreen,
	            lastRow : lastRow,
	            lineHeight : lineHeight,
	            characterWidth : this.characterWidth,
	            minHeight : minHeight,
	            maxHeight : maxHeight,
	            offset : offset,
	            gutterOffset : Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)),
	            height : this.$size.scrollerHeight
	        };

	        return changes;
	    };

	    this.$updateLines = function() {
	        var firstRow = this.$changedLines.firstRow;
	        var lastRow = this.$changedLines.lastRow;
	        this.$changedLines = null;

	        var layerConfig = this.layerConfig;

	        if (firstRow > layerConfig.lastRow + 1) { return; }
	        if (lastRow < layerConfig.firstRow) { return; }
	        if (lastRow === Infinity) {
	            if (this.$showGutter)
	                this.$gutterLayer.update(layerConfig);
	            this.$textLayer.update(layerConfig);
	            return;
	        }
	        this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
	        return true;
	    };

	    this.$getLongestLine = function() {
	        var charCount = this.session.getScreenWidth();
	        if (this.showInvisibles && !this.session.$useWrapMode)
	            charCount += 1;

	        return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
	    };
	    this.updateFrontMarkers = function() {
	        this.$markerFront.setMarkers(this.session.getMarkers(true));
	        this.$loop.schedule(this.CHANGE_MARKER_FRONT);
	    };
	    this.updateBackMarkers = function() {
	        this.$markerBack.setMarkers(this.session.getMarkers());
	        this.$loop.schedule(this.CHANGE_MARKER_BACK);
	    };
	    this.addGutterDecoration = function(row, className){
	        this.$gutterLayer.addGutterDecoration(row, className);
	    };
	    this.removeGutterDecoration = function(row, className){
	        this.$gutterLayer.removeGutterDecoration(row, className);
	    };
	    this.updateBreakpoints = function(rows) {
	        this.$loop.schedule(this.CHANGE_GUTTER);
	    };
	    this.setAnnotations = function(annotations) {
	        this.$gutterLayer.setAnnotations(annotations);
	        this.$loop.schedule(this.CHANGE_GUTTER);
	    };
	    this.updateCursor = function() {
	        this.$loop.schedule(this.CHANGE_CURSOR);
	    };
	    this.hideCursor = function() {
	        this.$cursorLayer.hideCursor();
	    };
	    this.showCursor = function() {
	        this.$cursorLayer.showCursor();
	    };

	    this.scrollSelectionIntoView = function(anchor, lead, offset) {
	        this.scrollCursorIntoView(anchor, offset);
	        this.scrollCursorIntoView(lead, offset);
	    };
	    this.scrollCursorIntoView = function(cursor, offset, $viewMargin) {
	        if (this.$size.scrollerHeight === 0)
	            return;

	        var pos = this.$cursorLayer.getPixelPosition(cursor);

	        var left = pos.left;
	        var top = pos.top;
	        
	        var topMargin = $viewMargin && $viewMargin.top || 0;
	        var bottomMargin = $viewMargin && $viewMargin.bottom || 0;
	        
	        var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
	        
	        if (scrollTop + topMargin > top) {
	            if (offset && scrollTop + topMargin > top + this.lineHeight)
	                top -= offset * this.$size.scrollerHeight;
	            if (top === 0)
	                top = -this.scrollMargin.top;
	            this.session.setScrollTop(top);
	        } else if (scrollTop + this.$size.scrollerHeight - bottomMargin < top + this.lineHeight) {
	            if (offset && scrollTop + this.$size.scrollerHeight - bottomMargin < top -  this.lineHeight)
	                top += offset * this.$size.scrollerHeight;
	            this.session.setScrollTop(top + this.lineHeight - this.$size.scrollerHeight);
	        }

	        var scrollLeft = this.scrollLeft;

	        if (scrollLeft > left) {
	            if (left < this.$padding + 2 * this.layerConfig.characterWidth)
	                left = -this.scrollMargin.left;
	            this.session.setScrollLeft(left);
	        } else if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {
	            this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));
	        } else if (scrollLeft <= this.$padding && left - scrollLeft < this.characterWidth) {
	            this.session.setScrollLeft(0);
	        }
	    };
	    this.getScrollTop = function() {
	        return this.session.getScrollTop();
	    };
	    this.getScrollLeft = function() {
	        return this.session.getScrollLeft();
	    };
	    this.getScrollTopRow = function() {
	        return this.scrollTop / this.lineHeight;
	    };
	    this.getScrollBottomRow = function() {
	        return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
	    };
	    this.scrollToRow = function(row) {
	        this.session.setScrollTop(row * this.lineHeight);
	    };

	    this.alignCursor = function(cursor, alignment) {
	        if (typeof cursor == "number")
	            cursor = {row: cursor, column: 0};

	        var pos = this.$cursorLayer.getPixelPosition(cursor);
	        var h = this.$size.scrollerHeight - this.lineHeight;
	        var offset = pos.top - h * (alignment || 0);

	        this.session.setScrollTop(offset);
	        return offset;
	    };

	    this.STEPS = 8;
	    this.$calcSteps = function(fromValue, toValue){
	        var i = 0;
	        var l = this.STEPS;
	        var steps = [];

	        var func  = function(t, x_min, dx) {
	            return dx * (Math.pow(t - 1, 3) + 1) + x_min;
	        };

	        for (i = 0; i < l; ++i)
	            steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));

	        return steps;
	    };
	    this.scrollToLine = function(line, center, animate, callback) {
	        var pos = this.$cursorLayer.getPixelPosition({row: line, column: 0});
	        var offset = pos.top;
	        if (center)
	            offset -= this.$size.scrollerHeight / 2;

	        var initialScroll = this.scrollTop;
	        this.session.setScrollTop(offset);
	        if (animate !== false)
	            this.animateScrolling(initialScroll, callback);
	    };

	    this.animateScrolling = function(fromValue, callback) {
	        var toValue = this.scrollTop;
	        if (!this.$animatedScroll)
	            return;
	        var _self = this;
	        
	        if (fromValue == toValue)
	            return;
	        
	        if (this.$scrollAnimation) {
	            var oldSteps = this.$scrollAnimation.steps;
	            if (oldSteps.length) {
	                fromValue = oldSteps[0];
	                if (fromValue == toValue)
	                    return;
	            }
	        }
	        
	        var steps = _self.$calcSteps(fromValue, toValue);
	        this.$scrollAnimation = {from: fromValue, to: toValue, steps: steps};

	        clearInterval(this.$timer);

	        _self.session.setScrollTop(steps.shift());
	        _self.session.$scrollTop = toValue;
	        this.$timer = setInterval(function() {
	            if (steps.length) {
	                _self.session.setScrollTop(steps.shift());
	                _self.session.$scrollTop = toValue;
	            } else if (toValue != null) {
	                _self.session.$scrollTop = -1;
	                _self.session.setScrollTop(toValue);
	                toValue = null;
	            } else {
	                _self.$timer = clearInterval(_self.$timer);
	                _self.$scrollAnimation = null;
	                callback && callback();
	            }
	        }, 10);
	    };
	    this.scrollToY = function(scrollTop) {
	        if (this.scrollTop !== scrollTop) {
	            this.$loop.schedule(this.CHANGE_SCROLL);
	            this.scrollTop = scrollTop;
	        }
	    };
	    this.scrollToX = function(scrollLeft) {
	        if (this.scrollLeft !== scrollLeft)
	            this.scrollLeft = scrollLeft;
	        this.$loop.schedule(this.CHANGE_H_SCROLL);
	    };
	    this.scrollTo = function(x, y) {
	        this.session.setScrollTop(y);
	        this.session.setScrollLeft(y);
	    };
	    this.scrollBy = function(deltaX, deltaY) {
	        deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
	        deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
	    };
	    this.isScrollableBy = function(deltaX, deltaY) {
	        if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
	           return true;
	        if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight
	            - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
	           return true;
	        if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
	            return true;
	        if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth
	            - this.layerConfig.width < -1 + this.scrollMargin.right)
	           return true;
	    };

	    this.pixelToScreenCoordinates = function(x, y) {
	        var canvasPos = this.scroller.getBoundingClientRect();

	        var offset = (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth;
	        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
	        var col = Math.round(offset);

	        return {row: row, column: col, side: offset - col > 0 ? 1 : -1};
	    };

	    this.screenToTextCoordinates = function(x, y) {
	        var canvasPos = this.scroller.getBoundingClientRect();

	        var col = Math.round(
	            (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth
	        );

	        var row = (y + this.scrollTop - canvasPos.top) / this.lineHeight;

	        return this.session.screenToDocumentPosition(row, Math.max(col, 0));
	    };
	    this.textToScreenCoordinates = function(row, column) {
	        var canvasPos = this.scroller.getBoundingClientRect();
	        var pos = this.session.documentToScreenPosition(row, column);

	        var x = this.$padding + Math.round(pos.column * this.characterWidth);
	        var y = pos.row * this.lineHeight;

	        return {
	            pageX: canvasPos.left + x - this.scrollLeft,
	            pageY: canvasPos.top + y - this.scrollTop
	        };
	    };
	    this.visualizeFocus = function() {
	        dom.addCssClass(this.container, "ace_focus");
	    };
	    this.visualizeBlur = function() {
	        dom.removeCssClass(this.container, "ace_focus");
	    };
	    this.showComposition = function(position) {
	        if (!this.$composition)
	            this.$composition = {
	                keepTextAreaAtCursor: this.$keepTextAreaAtCursor,
	                cssText: this.textarea.style.cssText
	            };

	        this.$keepTextAreaAtCursor = true;
	        dom.addCssClass(this.textarea, "ace_composition");
	        this.textarea.style.cssText = "";
	        this.$moveTextAreaToCursor();
	    };
	    this.setCompositionText = function(text) {
	        this.$moveTextAreaToCursor();
	    };
	    this.hideComposition = function() {
	        if (!this.$composition)
	            return;

	        dom.removeCssClass(this.textarea, "ace_composition");
	        this.$keepTextAreaAtCursor = this.$composition.keepTextAreaAtCursor;
	        this.textarea.style.cssText = this.$composition.cssText;
	        this.$composition = null;
	    };
	    this.setTheme = function(theme, cb) {
	        var _self = this;
	        this.$themeId = theme;
	        _self._dispatchEvent('themeChange',{theme:theme});

	        if (!theme || typeof theme == "string") {
	            var moduleName = theme || this.$options.theme.initialValue;
	            config.loadModule(["theme", moduleName], afterLoad);
	        } else {
	            afterLoad(theme);
	        }

	        function afterLoad(module) {
	            if (_self.$themeId != theme)
	                return cb && cb();
	            if (!module.cssClass)
	                return;
	            dom.importCssString(
	                module.cssText,
	                module.cssClass,
	                _self.container.ownerDocument
	            );

	            if (_self.theme)
	                dom.removeCssClass(_self.container, _self.theme.cssClass);

	            var padding = "padding" in module ? module.padding 
	                : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
	            if (_self.$padding && padding != _self.$padding)
	                _self.setPadding(padding);
	            _self.$theme = module.cssClass;

	            _self.theme = module;
	            dom.addCssClass(_self.container, module.cssClass);
	            dom.setCssClass(_self.container, "ace_dark", module.isDark);
	            if (_self.$size) {
	                _self.$size.width = 0;
	                _self.$updateSizeAsync();
	            }

	            _self._dispatchEvent('themeLoaded', {theme:module});
	            cb && cb();
	        }
	    };
	    this.getTheme = function() {
	        return this.$themeId;
	    };
	    this.setStyle = function(style, include) {
	        dom.setCssClass(this.container, style, include !== false);
	    };
	    this.unsetStyle = function(style) {
	        dom.removeCssClass(this.container, style);
	    };
	    
	    this.setCursorStyle = function(style) {
	        if (this.scroller.style.cursor != style)
	            this.scroller.style.cursor = style;
	    };
	    this.setMouseCursor = function(cursorStyle) {
	        this.scroller.style.cursor = cursorStyle;
	    };
	    this.destroy = function() {
	        this.$textLayer.destroy();
	        this.$cursorLayer.destroy();
	    };

	}).call(VirtualRenderer.prototype);


	config.defineOptions(VirtualRenderer.prototype, "renderer", {
	    animatedScroll: {initialValue: false},
	    showInvisibles: {
	        set: function(value) {
	            if (this.$textLayer.setShowInvisibles(value))
	                this.$loop.schedule(this.CHANGE_TEXT);
	        },
	        initialValue: false
	    },
	    showPrintMargin: {
	        set: function() { this.$updatePrintMargin(); },
	        initialValue: true
	    },
	    printMarginColumn: {
	        set: function() { this.$updatePrintMargin(); },
	        initialValue: 80
	    },
	    printMargin: {
	        set: function(val) {
	            if (typeof val == "number")
	                this.$printMarginColumn = val;
	            this.$showPrintMargin = !!val;
	            this.$updatePrintMargin();
	        },
	        get: function() {
	            return this.$showPrintMargin && this.$printMarginColumn; 
	        }
	    },
	    showGutter: {
	        set: function(show){
	            this.$gutter.style.display = show ? "block" : "none";
	            this.$loop.schedule(this.CHANGE_FULL);
	            this.onGutterResize();
	        },
	        initialValue: true
	    },
	    fadeFoldWidgets: {
	        set: function(show) {
	            dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
	        },
	        initialValue: false
	    },
	    showFoldWidgets: {
	        set: function(show) {this.$gutterLayer.setShowFoldWidgets(show)},
	        initialValue: true
	    },
	    showLineNumbers: {
	        set: function(show) {
	            this.$gutterLayer.setShowLineNumbers(show);
	            this.$loop.schedule(this.CHANGE_GUTTER);
	        },
	        initialValue: true
	    },
	    displayIndentGuides: {
	        set: function(show) {
	            if (this.$textLayer.setDisplayIndentGuides(show))
	                this.$loop.schedule(this.CHANGE_TEXT);
	        },
	        initialValue: true
	    },
	    highlightGutterLine: {
	        set: function(shouldHighlight) {
	            if (!this.$gutterLineHighlight) {
	                this.$gutterLineHighlight = dom.createElement("div");
	                this.$gutterLineHighlight.className = "ace_gutter-active-line";
	                this.$gutter.appendChild(this.$gutterLineHighlight);
	                return;
	            }

	            this.$gutterLineHighlight.style.display = shouldHighlight ? "" : "none";
	            if (this.$cursorLayer.$pixelPos)
	                this.$updateGutterLineHighlight();
	        },
	        initialValue: false,
	        value: true
	    },
	    hScrollBarAlwaysVisible: {
	        set: function(val) {
	            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
	                this.$loop.schedule(this.CHANGE_SCROLL);
	        },
	        initialValue: false
	    },
	    vScrollBarAlwaysVisible: {
	        set: function(val) {
	            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
	                this.$loop.schedule(this.CHANGE_SCROLL);
	        },
	        initialValue: false
	    },
	    fontSize:  {
	        set: function(size) {
	            if (typeof size == "number")
	                size = size + "px";
	            this.container.style.fontSize = size;
	            this.updateFontSize();
	        },
	        initialValue: 12
	    },
	    fontFamily: {
	        set: function(name) {
	            this.container.style.fontFamily = name;
	            this.updateFontSize();
	        }
	    },
	    maxLines: {
	        set: function(val) {
	            this.updateFull();
	        }
	    },
	    minLines: {
	        set: function(val) {
	            this.updateFull();
	        }
	    },
	    scrollPastEnd: {
	        set: function(val) {
	            val = +val || 0;
	            if (this.$scrollPastEnd == val)
	                return;
	            this.$scrollPastEnd = val;
	            this.$loop.schedule(this.CHANGE_SCROLL);
	        },
	        initialValue: 0,
	        handlesSet: true
	    },
	    fixedWidthGutter: {
	        set: function(val) {
	            this.$gutterLayer.$fixedWidth = !!val;
	            this.$loop.schedule(this.CHANGE_GUTTER);
	        }
	    },
	    theme: {
	        set: function(val) { this.setTheme(val) },
	        get: function() { return this.$themeId || this.theme; },
	        initialValue: "./theme/textmate",
	        handlesSet: true
	    }
	});

	exports.VirtualRenderer = VirtualRenderer;
	});

	ace.define("ace/worker/worker_client",["require","exports","module","ace/lib/oop","ace/lib/net","ace/lib/event_emitter","ace/config"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../lib/oop");
	var net = acequire("../lib/net");
	var EventEmitter = acequire("../lib/event_emitter").EventEmitter;
	var config = acequire("../config");

	var WorkerClient = function(topLevelNamespaces, mod, classname, workerUrl) {
	    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
	    this.changeListener = this.changeListener.bind(this);
	    this.onMessage = this.onMessage.bind(this);
	    if (acequire.nameToUrl && !acequire.toUrl)
	        acequire.toUrl = acequire.nameToUrl;
	    
	    if (config.get("packaged") || !acequire.toUrl) {
	        workerUrl = workerUrl || config.moduleUrl(mod.id, "worker")
	    } else {
	        var normalizePath = this.$normalizePath;
	        workerUrl = workerUrl || normalizePath(acequire.toUrl("ace/worker/worker.js", null, "_"));

	        var tlns = {};
	        topLevelNamespaces.forEach(function(ns) {
	            tlns[ns] = normalizePath(acequire.toUrl(ns, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
	        });
	    }

	    try {
	            var workerSrc = mod.src;
	    var Blob = __webpack_require__(97);
	    var blob = new Blob([ workerSrc ], { type: 'application/javascript' });
	    var blobUrl = (window.URL || window.webkitURL).createObjectURL(blob);

	    this.$worker = new Worker(blobUrl);

	    } catch(e) {
	        if (e instanceof window.DOMException) {
	            var blob = this.$workerBlob(workerUrl);
	            var URL = window.URL || window.webkitURL;
	            var blobURL = URL.createObjectURL(blob);

	            this.$worker = new Worker(blobURL);
	            URL.revokeObjectURL(blobURL);
	        } else {
	            throw e;
	        }
	    }
	    this.$worker.postMessage({
	        init : true,
	        tlns : tlns,
	        module : mod.id,
	        classname : classname
	    });

	    this.callbackId = 1;
	    this.callbacks = {};

	    this.$worker.onmessage = this.onMessage;
	};

	(function(){

	    oop.implement(this, EventEmitter);

	    this.onMessage = function(e) {
	        var msg = e.data;
	        switch(msg.type) {
	            case "event":
	                this._signal(msg.name, {data: msg.data});
	                break;
	            case "call":
	                var callback = this.callbacks[msg.id];
	                if (callback) {
	                    callback(msg.data);
	                    delete this.callbacks[msg.id];
	                }
	                break;
	            case "error":
	                this.reportError(msg.data);
	                break;
	            case "log":
	                window.console && console.log && console.log.apply(console, msg.data);
	                break;
	        }
	    };
	    
	    this.reportError = function(err) {
	        window.console && console.error && console.error(err);
	    };

	    this.$normalizePath = function(path) {
	        return net.qualifyURL(path);
	    };

	    this.terminate = function() {
	        this._signal("terminate", {});
	        this.deltaQueue = null;
	        this.$worker.terminate();
	        this.$worker = null;
	        if (this.$doc)
	            this.$doc.off("change", this.changeListener);
	        this.$doc = null;
	    };

	    this.send = function(cmd, args) {
	        this.$worker.postMessage({command: cmd, args: args});
	    };

	    this.call = function(cmd, args, callback) {
	        if (callback) {
	            var id = this.callbackId++;
	            this.callbacks[id] = callback;
	            args.push(id);
	        }
	        this.send(cmd, args);
	    };

	    this.emit = function(event, data) {
	        try {
	            this.$worker.postMessage({event: event, data: {data: data.data}});
	        }
	        catch(ex) {
	            console.error(ex.stack);
	        }
	    };

	    this.attachToDocument = function(doc) {
	        if(this.$doc)
	            this.terminate();

	        this.$doc = doc;
	        this.call("setValue", [doc.getValue()]);
	        doc.on("change", this.changeListener);
	    };

	    this.changeListener = function(delta) {
	        if (!this.deltaQueue) {
	            this.deltaQueue = [];
	            setTimeout(this.$sendDeltaQueue, 0);
	        }
	        if (delta.action == "insert")
	            this.deltaQueue.push(delta.start, delta.lines);
	        else
	            this.deltaQueue.push(delta.start, delta.end);
	    };

	    this.$sendDeltaQueue = function() {
	        var q = this.deltaQueue;
	        if (!q) return;
	        this.deltaQueue = null;
	        if (q.length > 50 && q.length > this.$doc.getLength() >> 1) {
	            this.call("setValue", [this.$doc.getValue()]);
	        } else
	            this.emit("change", {data: q});
	    };

	    this.$workerBlob = function(workerUrl) {
	        var script = "importScripts('" + net.qualifyURL(workerUrl) + "');";
	        try {
	            return new Blob([script], {"type": "application/javascript"});
	        } catch (e) { // Backwards-compatibility
	            var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
	            var blobBuilder = new BlobBuilder();
	            blobBuilder.append(script);
	            return blobBuilder.getBlob("application/javascript");
	        }
	    };

	}).call(WorkerClient.prototype);


	var UIWorkerClient = function(topLevelNamespaces, mod, classname) {
	    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
	    this.changeListener = this.changeListener.bind(this);
	    this.callbackId = 1;
	    this.callbacks = {};
	    this.messageBuffer = [];

	    var main = null;
	    var emitSync = false;
	    var sender = Object.create(EventEmitter);
	    var _self = this;

	    this.$worker = {};
	    this.$worker.terminate = function() {};
	    this.$worker.postMessage = function(e) {
	        _self.messageBuffer.push(e);
	        if (main) {
	            if (emitSync)
	                setTimeout(processNext);
	            else
	                processNext();
	        }
	    };
	    this.setEmitSync = function(val) { emitSync = val };

	    var processNext = function() {
	        var msg = _self.messageBuffer.shift();
	        if (msg.command)
	            main[msg.command].apply(main, msg.args);
	        else if (msg.event)
	            sender._signal(msg.event, msg.data);
	    };

	    sender.postMessage = function(msg) {
	        _self.onMessage({data: msg});
	    };
	    sender.callback = function(data, callbackId) {
	        this.postMessage({type: "call", id: callbackId, data: data});
	    };
	    sender.emit = function(name, data) {
	        this.postMessage({type: "event", name: name, data: data});
	    };

	    config.loadModule(["worker", mod], function(Main) {
	        main = new Main[classname](sender);
	        while (_self.messageBuffer.length)
	            processNext();
	    });
	};

	UIWorkerClient.prototype = WorkerClient.prototype;

	exports.UIWorkerClient = UIWorkerClient;
	exports.WorkerClient = WorkerClient;

	});

	ace.define("ace/placeholder",["require","exports","module","ace/range","ace/lib/event_emitter","ace/lib/oop"], function(acequire, exports, module) {
	"use strict";

	var Range = acequire("./range").Range;
	var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
	var oop = acequire("./lib/oop");

	var PlaceHolder = function(session, length, pos, others, mainClass, othersClass) {
	    var _self = this;
	    this.length = length;
	    this.session = session;
	    this.doc = session.getDocument();
	    this.mainClass = mainClass;
	    this.othersClass = othersClass;
	    this.$onUpdate = this.onUpdate.bind(this);
	    this.doc.on("change", this.$onUpdate);
	    this.$others = others;
	    
	    this.$onCursorChange = function() {
	        setTimeout(function() {
	            _self.onCursorChange();
	        });
	    };
	    
	    this.$pos = pos;
	    var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || {length: -1};
	    this.$undoStackDepth = undoStack.length;
	    this.setup();

	    session.selection.on("changeCursor", this.$onCursorChange);
	};

	(function() {

	    oop.implement(this, EventEmitter);
	    this.setup = function() {
	        var _self = this;
	        var doc = this.doc;
	        var session = this.session;
	        
	        this.selectionBefore = session.selection.toJSON();
	        if (session.selection.inMultiSelectMode)
	            session.selection.toSingleRange();

	        this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);
	        var pos = this.pos;
	        pos.$insertRight = true;
	        pos.detach();
	        pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
	        this.others = [];
	        this.$others.forEach(function(other) {
	            var anchor = doc.createAnchor(other.row, other.column);
	            anchor.$insertRight = true;
	            anchor.detach();
	            _self.others.push(anchor);
	        });
	        session.setUndoSelect(false);
	    };
	    this.showOtherMarkers = function() {
	        if (this.othersActive) return;
	        var session = this.session;
	        var _self = this;
	        this.othersActive = true;
	        this.others.forEach(function(anchor) {
	            anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column+_self.length), _self.othersClass, null, false);
	        });
	    };
	    this.hideOtherMarkers = function() {
	        if (!this.othersActive) return;
	        this.othersActive = false;
	        for (var i = 0; i < this.others.length; i++) {
	            this.session.removeMarker(this.others[i].markerId);
	        }
	    };
	    this.onUpdate = function(delta) {
	        if (this.$updating)
	            return this.updateAnchors(delta);
	            
	        var range = delta;
	        if (range.start.row !== range.end.row) return;
	        if (range.start.row !== this.pos.row) return;
	        this.$updating = true;
	        var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;
	        var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;
	        var distanceFromStart = range.start.column - this.pos.column;
	        
	        this.updateAnchors(delta);
	        
	        if (inMainRange)
	            this.length += lengthDiff;

	        if (inMainRange && !this.session.$fromUndo) {
	            if (delta.action === 'insert') {
	                for (var i = this.others.length - 1; i >= 0; i--) {
	                    var otherPos = this.others[i];
	                    var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
	                    this.doc.insertMergedLines(newPos, delta.lines);
	                }
	            } else if (delta.action === 'remove') {
	                for (var i = this.others.length - 1; i >= 0; i--) {
	                    var otherPos = this.others[i];
	                    var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
	                    this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
	                }
	            }
	        }
	        
	        this.$updating = false;
	        this.updateMarkers();
	    };
	    
	    this.updateAnchors = function(delta) {
	        this.pos.onChange(delta);
	        for (var i = this.others.length; i--;)
	            this.others[i].onChange(delta);
	        this.updateMarkers();
	    };
	    
	    this.updateMarkers = function() {
	        if (this.$updating)
	            return;
	        var _self = this;
	        var session = this.session;
	        var updateMarker = function(pos, className) {
	            session.removeMarker(pos.markerId);
	            pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column+_self.length), className, null, false);
	        };
	        updateMarker(this.pos, this.mainClass);
	        for (var i = this.others.length; i--;)
	            updateMarker(this.others[i], this.othersClass);
	    };

	    this.onCursorChange = function(event) {
	        if (this.$updating || !this.session) return;
	        var pos = this.session.selection.getCursor();
	        if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
	            this.showOtherMarkers();
	            this._emit("cursorEnter", event);
	        } else {
	            this.hideOtherMarkers();
	            this._emit("cursorLeave", event);
	        }
	    };    
	    this.detach = function() {
	        this.session.removeMarker(this.pos && this.pos.markerId);
	        this.hideOtherMarkers();
	        this.doc.removeEventListener("change", this.$onUpdate);
	        this.session.selection.removeEventListener("changeCursor", this.$onCursorChange);
	        this.session.setUndoSelect(true);
	        this.session = null;
	    };
	    this.cancel = function() {
	        if (this.$undoStackDepth === -1)
	            return;
	        var undoManager = this.session.getUndoManager();
	        var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
	        for (var i = 0; i < undosRequired; i++) {
	            undoManager.undo(true);
	        }
	        if (this.selectionBefore)
	            this.session.selection.fromJSON(this.selectionBefore);
	    };
	}).call(PlaceHolder.prototype);


	exports.PlaceHolder = PlaceHolder;
	});

	ace.define("ace/mouse/multi_select_handler",["require","exports","module","ace/lib/event","ace/lib/useragent"], function(acequire, exports, module) {

	var event = acequire("../lib/event");
	var useragent = acequire("../lib/useragent");
	function isSamePoint(p1, p2) {
	    return p1.row == p2.row && p1.column == p2.column;
	}

	function onMouseDown(e) {
	    var ev = e.domEvent;
	    var alt = ev.altKey;
	    var shift = ev.shiftKey;
	    var ctrl = ev.ctrlKey;
	    var accel = e.getAccelKey();
	    var button = e.getButton();
	    
	    if (ctrl && useragent.isMac)
	        button = ev.button;

	    if (e.editor.inMultiSelectMode && button == 2) {
	        e.editor.textInput.onContextMenu(e.domEvent);
	        return;
	    }
	    
	    if (!ctrl && !alt && !accel) {
	        if (button === 0 && e.editor.inMultiSelectMode)
	            e.editor.exitMultiSelectMode();
	        return;
	    }
	    
	    if (button !== 0)
	        return;

	    var editor = e.editor;
	    var selection = editor.selection;
	    var isMultiSelect = editor.inMultiSelectMode;
	    var pos = e.getDocumentPosition();
	    var cursor = selection.getCursor();
	    var inSelection = e.inSelection() || (selection.isEmpty() && isSamePoint(pos, cursor));

	    var mouseX = e.x, mouseY = e.y;
	    var onMouseSelection = function(e) {
	        mouseX = e.clientX;
	        mouseY = e.clientY;
	    };
	    
	    var session = editor.session;
	    var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
	    var screenCursor = screenAnchor;
	    
	    var selectionMode;
	    if (editor.$mouseHandler.$enableJumpToDef) {
	        if (ctrl && alt || accel && alt)
	            selectionMode = shift ? "block" : "add";
	        else if (alt && editor.$blockSelectEnabled)
	            selectionMode = "block";
	    } else {
	        if (accel && !alt) {
	            selectionMode = "add";
	            if (!isMultiSelect && shift)
	                return;
	        } else if (alt && editor.$blockSelectEnabled) {
	            selectionMode = "block";
	        }
	    }
	    
	    if (selectionMode && useragent.isMac && ev.ctrlKey) {
	        editor.$mouseHandler.cancelContextMenu();
	    }

	    if (selectionMode == "add") {
	        if (!isMultiSelect && inSelection)
	            return; // dragging

	        if (!isMultiSelect) {
	            var range = selection.toOrientedRange();
	            editor.addSelectionMarker(range);
	        }

	        var oldRange = selection.rangeList.rangeAtPoint(pos);
	        
	        
	        editor.$blockScrolling++;
	        editor.inVirtualSelectionMode = true;
	        
	        if (shift) {
	            oldRange = null;
	            range = selection.ranges[0] || range;
	            editor.removeSelectionMarker(range);
	        }
	        editor.once("mouseup", function() {
	            var tmpSel = selection.toOrientedRange();

	            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
	                selection.substractPoint(tmpSel.cursor);
	            else {
	                if (shift) {
	                    selection.substractPoint(range.cursor);
	                } else if (range) {
	                    editor.removeSelectionMarker(range);
	                    selection.addRange(range);
	                }
	                selection.addRange(tmpSel);
	            }
	            editor.$blockScrolling--;
	            editor.inVirtualSelectionMode = false;
	        });

	    } else if (selectionMode == "block") {
	        e.stop();
	        editor.inVirtualSelectionMode = true;        
	        var initialRange;
	        var rectSel = [];
	        var blockSelect = function() {
	            var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
	            var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column);

	            if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead))
	                return;
	            screenCursor = newCursor;
	            
	            editor.$blockScrolling++;
	            editor.selection.moveToPosition(cursor);
	            editor.renderer.scrollCursorIntoView();

	            editor.removeSelectionMarkers(rectSel);
	            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
	            if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())
	                rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
	            rectSel.forEach(editor.addSelectionMarker, editor);
	            editor.updateSelectionMarkers();
	            editor.$blockScrolling--;
	        };
	        editor.$blockScrolling++;
	        if (isMultiSelect && !accel) {
	            selection.toSingleRange();
	        } else if (!isMultiSelect && accel) {
	            initialRange = selection.toOrientedRange();
	            editor.addSelectionMarker(initialRange);
	        }
	        
	        if (shift)
	            screenAnchor = session.documentToScreenPosition(selection.lead);            
	        else
	            selection.moveToPosition(pos);
	        editor.$blockScrolling--;
	        
	        screenCursor = {row: -1, column: -1};

	        var onMouseSelectionEnd = function(e) {
	            clearInterval(timerId);
	            editor.removeSelectionMarkers(rectSel);
	            if (!rectSel.length)
	                rectSel = [selection.toOrientedRange()];
	            editor.$blockScrolling++;
	            if (initialRange) {
	                editor.removeSelectionMarker(initialRange);
	                selection.toSingleRange(initialRange);
	            }
	            for (var i = 0; i < rectSel.length; i++)
	                selection.addRange(rectSel[i]);
	            editor.inVirtualSelectionMode = false;
	            editor.$mouseHandler.$clickSelection = null;
	            editor.$blockScrolling--;
	        };

	        var onSelectionInterval = blockSelect;

	        event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
	        var timerId = setInterval(function() {onSelectionInterval();}, 20);

	        return e.preventDefault();
	    }
	}


	exports.onMouseDown = onMouseDown;

	});

	ace.define("ace/commands/multi_select_commands",["require","exports","module","ace/keyboard/hash_handler"], function(acequire, exports, module) {
	exports.defaultCommands = [{
	    name: "addCursorAbove",
	    exec: function(editor) { editor.selectMoreLines(-1); },
	    bindKey: {win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up"},
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "addCursorBelow",
	    exec: function(editor) { editor.selectMoreLines(1); },
	    bindKey: {win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down"},
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "addCursorAboveSkipCurrent",
	    exec: function(editor) { editor.selectMoreLines(-1, true); },
	    bindKey: {win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up"},
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "addCursorBelowSkipCurrent",
	    exec: function(editor) { editor.selectMoreLines(1, true); },
	    bindKey: {win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down"},
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selectMoreBefore",
	    exec: function(editor) { editor.selectMore(-1); },
	    bindKey: {win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left"},
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selectMoreAfter",
	    exec: function(editor) { editor.selectMore(1); },
	    bindKey: {win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right"},
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selectNextBefore",
	    exec: function(editor) { editor.selectMore(-1, true); },
	    bindKey: {win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left"},
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selectNextAfter",
	    exec: function(editor) { editor.selectMore(1, true); },
	    bindKey: {win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right"},
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "splitIntoLines",
	    exec: function(editor) { editor.multiSelect.splitIntoLines(); },
	    bindKey: {win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L"},
	    readOnly: true
	}, {
	    name: "alignCursors",
	    exec: function(editor) { editor.alignCursors(); },
	    bindKey: {win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A"},
	    scrollIntoView: "cursor"
	}, {
	    name: "findAll",
	    exec: function(editor) { editor.findAll(); },
	    bindKey: {win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G"},
	    scrollIntoView: "cursor",
	    readOnly: true
	}];
	exports.multiSelectCommands = [{
	    name: "singleSelection",
	    bindKey: "esc",
	    exec: function(editor) { editor.exitMultiSelectMode(); },
	    scrollIntoView: "cursor",
	    readOnly: true,
	    isAvailable: function(editor) {return editor && editor.inMultiSelectMode}
	}];

	var HashHandler = acequire("../keyboard/hash_handler").HashHandler;
	exports.keyboardHandler = new HashHandler(exports.multiSelectCommands);

	});

	ace.define("ace/multi_select",["require","exports","module","ace/range_list","ace/range","ace/selection","ace/mouse/multi_select_handler","ace/lib/event","ace/lib/lang","ace/commands/multi_select_commands","ace/search","ace/edit_session","ace/editor","ace/config"], function(acequire, exports, module) {

	var RangeList = acequire("./range_list").RangeList;
	var Range = acequire("./range").Range;
	var Selection = acequire("./selection").Selection;
	var onMouseDown = acequire("./mouse/multi_select_handler").onMouseDown;
	var event = acequire("./lib/event");
	var lang = acequire("./lib/lang");
	var commands = acequire("./commands/multi_select_commands");
	exports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
	var Search = acequire("./search").Search;
	var search = new Search();

	function find(session, needle, dir) {
	    search.$options.wrap = true;
	    search.$options.needle = needle;
	    search.$options.backwards = dir == -1;
	    return search.find(session);
	}
	var EditSession = acequire("./edit_session").EditSession;
	(function() {
	    this.getSelectionMarkers = function() {
	        return this.$selectionMarkers;
	    };
	}).call(EditSession.prototype);
	(function() {
	    this.ranges = null;
	    this.rangeList = null;
	    this.addRange = function(range, $blockChangeEvents) {
	        if (!range)
	            return;

	        if (!this.inMultiSelectMode && this.rangeCount === 0) {
	            var oldRange = this.toOrientedRange();
	            this.rangeList.add(oldRange);
	            this.rangeList.add(range);
	            if (this.rangeList.ranges.length != 2) {
	                this.rangeList.removeAll();
	                return $blockChangeEvents || this.fromOrientedRange(range);
	            }
	            this.rangeList.removeAll();
	            this.rangeList.add(oldRange);
	            this.$onAddRange(oldRange);
	        }

	        if (!range.cursor)
	            range.cursor = range.end;

	        var removed = this.rangeList.add(range);

	        this.$onAddRange(range);

	        if (removed.length)
	            this.$onRemoveRange(removed);

	        if (this.rangeCount > 1 && !this.inMultiSelectMode) {
	            this._signal("multiSelect");
	            this.inMultiSelectMode = true;
	            this.session.$undoSelect = false;
	            this.rangeList.attach(this.session);
	        }

	        return $blockChangeEvents || this.fromOrientedRange(range);
	    };

	    this.toSingleRange = function(range) {
	        range = range || this.ranges[0];
	        var removed = this.rangeList.removeAll();
	        if (removed.length)
	            this.$onRemoveRange(removed);

	        range && this.fromOrientedRange(range);
	    };
	    this.substractPoint = function(pos) {
	        var removed = this.rangeList.substractPoint(pos);
	        if (removed) {
	            this.$onRemoveRange(removed);
	            return removed[0];
	        }
	    };
	    this.mergeOverlappingRanges = function() {
	        var removed = this.rangeList.merge();
	        if (removed.length)
	            this.$onRemoveRange(removed);
	        else if(this.ranges[0])
	            this.fromOrientedRange(this.ranges[0]);
	    };

	    this.$onAddRange = function(range) {
	        this.rangeCount = this.rangeList.ranges.length;
	        this.ranges.unshift(range);
	        this._signal("addRange", {range: range});
	    };

	    this.$onRemoveRange = function(removed) {
	        this.rangeCount = this.rangeList.ranges.length;
	        if (this.rangeCount == 1 && this.inMultiSelectMode) {
	            var lastRange = this.rangeList.ranges.pop();
	            removed.push(lastRange);
	            this.rangeCount = 0;
	        }

	        for (var i = removed.length; i--; ) {
	            var index = this.ranges.indexOf(removed[i]);
	            this.ranges.splice(index, 1);
	        }

	        this._signal("removeRange", {ranges: removed});

	        if (this.rangeCount === 0 && this.inMultiSelectMode) {
	            this.inMultiSelectMode = false;
	            this._signal("singleSelect");
	            this.session.$undoSelect = true;
	            this.rangeList.detach(this.session);
	        }

	        lastRange = lastRange || this.ranges[0];
	        if (lastRange && !lastRange.isEqual(this.getRange()))
	            this.fromOrientedRange(lastRange);
	    };
	    this.$initRangeList = function() {
	        if (this.rangeList)
	            return;

	        this.rangeList = new RangeList();
	        this.ranges = [];
	        this.rangeCount = 0;
	    };
	    this.getAllRanges = function() {
	        return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
	    };

	    this.splitIntoLines = function () {
	        if (this.rangeCount > 1) {
	            var ranges = this.rangeList.ranges;
	            var lastRange = ranges[ranges.length - 1];
	            var range = Range.fromPoints(ranges[0].start, lastRange.end);

	            this.toSingleRange();
	            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
	        } else {
	            var range = this.getRange();
	            var isBackwards = this.isBackwards();
	            var startRow = range.start.row;
	            var endRow = range.end.row;
	            if (startRow == endRow) {
	                if (isBackwards)
	                    var start = range.end, end = range.start;
	                else
	                    var start = range.start, end = range.end;
	                
	                this.addRange(Range.fromPoints(end, end));
	                this.addRange(Range.fromPoints(start, start));
	                return;
	            }

	            var rectSel = [];
	            var r = this.getLineRange(startRow, true);
	            r.start.column = range.start.column;
	            rectSel.push(r);

	            for (var i = startRow + 1; i < endRow; i++)
	                rectSel.push(this.getLineRange(i, true));

	            r = this.getLineRange(endRow, true);
	            r.end.column = range.end.column;
	            rectSel.push(r);

	            rectSel.forEach(this.addRange, this);
	        }
	    };
	    this.toggleBlockSelection = function () {
	        if (this.rangeCount > 1) {
	            var ranges = this.rangeList.ranges;
	            var lastRange = ranges[ranges.length - 1];
	            var range = Range.fromPoints(ranges[0].start, lastRange.end);

	            this.toSingleRange();
	            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
	        } else {
	            var cursor = this.session.documentToScreenPosition(this.selectionLead);
	            var anchor = this.session.documentToScreenPosition(this.selectionAnchor);

	            var rectSel = this.rectangularRangeBlock(cursor, anchor);
	            rectSel.forEach(this.addRange, this);
	        }
	    };
	    this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {
	        var rectSel = [];

	        var xBackwards = screenCursor.column < screenAnchor.column;
	        if (xBackwards) {
	            var startColumn = screenCursor.column;
	            var endColumn = screenAnchor.column;
	        } else {
	            var startColumn = screenAnchor.column;
	            var endColumn = screenCursor.column;
	        }

	        var yBackwards = screenCursor.row < screenAnchor.row;
	        if (yBackwards) {
	            var startRow = screenCursor.row;
	            var endRow = screenAnchor.row;
	        } else {
	            var startRow = screenAnchor.row;
	            var endRow = screenCursor.row;
	        }

	        if (startColumn < 0)
	            startColumn = 0;
	        if (startRow < 0)
	            startRow = 0;

	        if (startRow == endRow)
	            includeEmptyLines = true;

	        for (var row = startRow; row <= endRow; row++) {
	            var range = Range.fromPoints(
	                this.session.screenToDocumentPosition(row, startColumn),
	                this.session.screenToDocumentPosition(row, endColumn)
	            );
	            if (range.isEmpty()) {
	                if (docEnd && isSamePoint(range.end, docEnd))
	                    break;
	                var docEnd = range.end;
	            }
	            range.cursor = xBackwards ? range.start : range.end;
	            rectSel.push(range);
	        }

	        if (yBackwards)
	            rectSel.reverse();

	        if (!includeEmptyLines) {
	            var end = rectSel.length - 1;
	            while (rectSel[end].isEmpty() && end > 0)
	                end--;
	            if (end > 0) {
	                var start = 0;
	                while (rectSel[start].isEmpty())
	                    start++;
	            }
	            for (var i = end; i >= start; i--) {
	                if (rectSel[i].isEmpty())
	                    rectSel.splice(i, 1);
	            }
	        }

	        return rectSel;
	    };
	}).call(Selection.prototype);
	var Editor = acequire("./editor").Editor;
	(function() {
	    this.updateSelectionMarkers = function() {
	        this.renderer.updateCursor();
	        this.renderer.updateBackMarkers();
	    };
	    this.addSelectionMarker = function(orientedRange) {
	        if (!orientedRange.cursor)
	            orientedRange.cursor = orientedRange.end;

	        var style = this.getSelectionStyle();
	        orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);

	        this.session.$selectionMarkers.push(orientedRange);
	        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
	        return orientedRange;
	    };
	    this.removeSelectionMarker = function(range) {
	        if (!range.marker)
	            return;
	        this.session.removeMarker(range.marker);
	        var index = this.session.$selectionMarkers.indexOf(range);
	        if (index != -1)
	            this.session.$selectionMarkers.splice(index, 1);
	        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
	    };

	    this.removeSelectionMarkers = function(ranges) {
	        var markerList = this.session.$selectionMarkers;
	        for (var i = ranges.length; i--; ) {
	            var range = ranges[i];
	            if (!range.marker)
	                continue;
	            this.session.removeMarker(range.marker);
	            var index = markerList.indexOf(range);
	            if (index != -1)
	                markerList.splice(index, 1);
	        }
	        this.session.selectionMarkerCount = markerList.length;
	    };

	    this.$onAddRange = function(e) {
	        this.addSelectionMarker(e.range);
	        this.renderer.updateCursor();
	        this.renderer.updateBackMarkers();
	    };

	    this.$onRemoveRange = function(e) {
	        this.removeSelectionMarkers(e.ranges);
	        this.renderer.updateCursor();
	        this.renderer.updateBackMarkers();
	    };

	    this.$onMultiSelect = function(e) {
	        if (this.inMultiSelectMode)
	            return;
	        this.inMultiSelectMode = true;

	        this.setStyle("ace_multiselect");
	        this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
	        this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);

	        this.renderer.updateCursor();
	        this.renderer.updateBackMarkers();
	    };

	    this.$onSingleSelect = function(e) {
	        if (this.session.multiSelect.inVirtualMode)
	            return;
	        this.inMultiSelectMode = false;

	        this.unsetStyle("ace_multiselect");
	        this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);

	        this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
	        this.renderer.updateCursor();
	        this.renderer.updateBackMarkers();
	        this._emit("changeSelection");
	    };

	    this.$onMultiSelectExec = function(e) {
	        var command = e.command;
	        var editor = e.editor;
	        if (!editor.multiSelect)
	            return;
	        if (!command.multiSelectAction) {
	            var result = command.exec(editor, e.args || {});
	            editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
	            editor.multiSelect.mergeOverlappingRanges();
	        } else if (command.multiSelectAction == "forEach") {
	            result = editor.forEachSelection(command, e.args);
	        } else if (command.multiSelectAction == "forEachLine") {
	            result = editor.forEachSelection(command, e.args, true);
	        } else if (command.multiSelectAction == "single") {
	            editor.exitMultiSelectMode();
	            result = command.exec(editor, e.args || {});
	        } else {
	            result = command.multiSelectAction(editor, e.args || {});
	        }
	        return result;
	    }; 
	    this.forEachSelection = function(cmd, args, options) {
	        if (this.inVirtualSelectionMode)
	            return;
	        var keepOrder = options && options.keepOrder;
	        var $byLines = options == true || options && options.$byLines
	        var session = this.session;
	        var selection = this.selection;
	        var rangeList = selection.rangeList;
	        var ranges = (keepOrder ? selection : rangeList).ranges;
	        var result;
	        
	        if (!ranges.length)
	            return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
	        
	        var reg = selection._eventRegistry;
	        selection._eventRegistry = {};

	        var tmpSel = new Selection(session);
	        this.inVirtualSelectionMode = true;
	        for (var i = ranges.length; i--;) {
	            if ($byLines) {
	                while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)
	                    i--;
	            }
	            tmpSel.fromOrientedRange(ranges[i]);
	            tmpSel.index = i;
	            this.selection = session.selection = tmpSel;
	            var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
	            if (!result && cmdResult !== undefined)
	                result = cmdResult;
	            tmpSel.toOrientedRange(ranges[i]);
	        }
	        tmpSel.detach();

	        this.selection = session.selection = selection;
	        this.inVirtualSelectionMode = false;
	        selection._eventRegistry = reg;
	        selection.mergeOverlappingRanges();
	        
	        var anim = this.renderer.$scrollAnimation;
	        this.onCursorChange();
	        this.onSelectionChange();
	        if (anim && anim.from == anim.to)
	            this.renderer.animateScrolling(anim.from);
	        
	        return result;
	    };
	    this.exitMultiSelectMode = function() {
	        if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
	            return;
	        this.multiSelect.toSingleRange();
	    };

	    this.getSelectedText = function() {
	        var text = "";
	        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
	            var ranges = this.multiSelect.rangeList.ranges;
	            var buf = [];
	            for (var i = 0; i < ranges.length; i++) {
	                buf.push(this.session.getTextRange(ranges[i]));
	            }
	            var nl = this.session.getDocument().getNewLineCharacter();
	            text = buf.join(nl);
	            if (text.length == (buf.length - 1) * nl.length)
	                text = "";
	        } else if (!this.selection.isEmpty()) {
	            text = this.session.getTextRange(this.getSelectionRange());
	        }
	        return text;
	    };
	    
	    this.$checkMultiselectChange = function(e, anchor) {
	        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
	            var range = this.multiSelect.ranges[0];
	            if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)
	                return;
	            var pos = anchor == this.multiSelect.anchor
	                ? range.cursor == range.start ? range.end : range.start
	                : range.cursor;
	            if (pos.row != anchor.row 
	                || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)
	                this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
	        }
	    };
	    this.findAll = function(needle, options, additive) {
	        options = options || {};
	        options.needle = needle || options.needle;
	        if (options.needle == undefined) {
	            var range = this.selection.isEmpty()
	                ? this.selection.getWordRange()
	                : this.selection.getRange();
	            options.needle = this.session.getTextRange(range);
	        }    
	        this.$search.set(options);
	        
	        var ranges = this.$search.findAll(this.session);
	        if (!ranges.length)
	            return 0;

	        this.$blockScrolling += 1;
	        var selection = this.multiSelect;

	        if (!additive)
	            selection.toSingleRange(ranges[0]);

	        for (var i = ranges.length; i--; )
	            selection.addRange(ranges[i], true);
	        if (range && selection.rangeList.rangeAtPoint(range.start))
	            selection.addRange(range, true);
	        
	        this.$blockScrolling -= 1;

	        return ranges.length;
	    };
	    this.selectMoreLines = function(dir, skip) {
	        var range = this.selection.toOrientedRange();
	        var isBackwards = range.cursor == range.end;

	        var screenLead = this.session.documentToScreenPosition(range.cursor);
	        if (this.selection.$desiredColumn)
	            screenLead.column = this.selection.$desiredColumn;

	        var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);

	        if (!range.isEmpty()) {
	            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
	            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
	        } else {
	            var anchor = lead;
	        }

	        if (isBackwards) {
	            var newRange = Range.fromPoints(lead, anchor);
	            newRange.cursor = newRange.start;
	        } else {
	            var newRange = Range.fromPoints(anchor, lead);
	            newRange.cursor = newRange.end;
	        }

	        newRange.desiredColumn = screenLead.column;
	        if (!this.selection.inMultiSelectMode) {
	            this.selection.addRange(range);
	        } else {
	            if (skip)
	                var toRemove = range.cursor;
	        }

	        this.selection.addRange(newRange);
	        if (toRemove)
	            this.selection.substractPoint(toRemove);
	    };
	    this.transposeSelections = function(dir) {
	        var session = this.session;
	        var sel = session.multiSelect;
	        var all = sel.ranges;

	        for (var i = all.length; i--; ) {
	            var range = all[i];
	            if (range.isEmpty()) {
	                var tmp = session.getWordRange(range.start.row, range.start.column);
	                range.start.row = tmp.start.row;
	                range.start.column = tmp.start.column;
	                range.end.row = tmp.end.row;
	                range.end.column = tmp.end.column;
	            }
	        }
	        sel.mergeOverlappingRanges();

	        var words = [];
	        for (var i = all.length; i--; ) {
	            var range = all[i];
	            words.unshift(session.getTextRange(range));
	        }

	        if (dir < 0)
	            words.unshift(words.pop());
	        else
	            words.push(words.shift());

	        for (var i = all.length; i--; ) {
	            var range = all[i];
	            var tmp = range.clone();
	            session.replace(range, words[i]);
	            range.start.row = tmp.start.row;
	            range.start.column = tmp.start.column;
	        }
	    };
	    this.selectMore = function(dir, skip, stopAtFirst) {
	        var session = this.session;
	        var sel = session.multiSelect;

	        var range = sel.toOrientedRange();
	        if (range.isEmpty()) {
	            range = session.getWordRange(range.start.row, range.start.column);
	            range.cursor = dir == -1 ? range.start : range.end;
	            this.multiSelect.addRange(range);
	            if (stopAtFirst)
	                return;
	        }
	        var needle = session.getTextRange(range);

	        var newRange = find(session, needle, dir);
	        if (newRange) {
	            newRange.cursor = dir == -1 ? newRange.start : newRange.end;
	            this.$blockScrolling += 1;
	            this.session.unfold(newRange);
	            this.multiSelect.addRange(newRange);
	            this.$blockScrolling -= 1;
	            this.renderer.scrollCursorIntoView(null, 0.5);
	        }
	        if (skip)
	            this.multiSelect.substractPoint(range.cursor);
	    };
	    this.alignCursors = function() {
	        var session = this.session;
	        var sel = session.multiSelect;
	        var ranges = sel.ranges;
	        var row = -1;
	        var sameRowRanges = ranges.filter(function(r) {
	            if (r.cursor.row == row)
	                return true;
	            row = r.cursor.row;
	        });
	        
	        if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
	            var range = this.selection.getRange();
	            var fr = range.start.row, lr = range.end.row;
	            var guessRange = fr == lr;
	            if (guessRange) {
	                var max = this.session.getLength();
	                var line;
	                do {
	                    line = this.session.getLine(lr);
	                } while (/[=:]/.test(line) && ++lr < max);
	                do {
	                    line = this.session.getLine(fr);
	                } while (/[=:]/.test(line) && --fr > 0);
	                
	                if (fr < 0) fr = 0;
	                if (lr >= max) lr = max - 1;
	            }
	            var lines = this.session.removeFullLines(fr, lr);
	            lines = this.$reAlignText(lines, guessRange);
	            this.session.insert({row: fr, column: 0}, lines.join("\n") + "\n");
	            if (!guessRange) {
	                range.start.column = 0;
	                range.end.column = lines[lines.length - 1].length;
	            }
	            this.selection.setRange(range);
	        } else {
	            sameRowRanges.forEach(function(r) {
	                sel.substractPoint(r.cursor);
	            });

	            var maxCol = 0;
	            var minSpace = Infinity;
	            var spaceOffsets = ranges.map(function(r) {
	                var p = r.cursor;
	                var line = session.getLine(p.row);
	                var spaceOffset = line.substr(p.column).search(/\S/g);
	                if (spaceOffset == -1)
	                    spaceOffset = 0;

	                if (p.column > maxCol)
	                    maxCol = p.column;
	                if (spaceOffset < minSpace)
	                    minSpace = spaceOffset;
	                return spaceOffset;
	            });
	            ranges.forEach(function(r, i) {
	                var p = r.cursor;
	                var l = maxCol - p.column;
	                var d = spaceOffsets[i] - minSpace;
	                if (l > d)
	                    session.insert(p, lang.stringRepeat(" ", l - d));
	                else
	                    session.remove(new Range(p.row, p.column, p.row, p.column - l + d));

	                r.start.column = r.end.column = maxCol;
	                r.start.row = r.end.row = p.row;
	                r.cursor = r.end;
	            });
	            sel.fromOrientedRange(ranges[0]);
	            this.renderer.updateCursor();
	            this.renderer.updateBackMarkers();
	        }
	    };

	    this.$reAlignText = function(lines, forceLeft) {
	        var isLeftAligned = true, isRightAligned = true;
	        var startW, textW, endW;

	        return lines.map(function(line) {
	            var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
	            if (!m)
	                return [line];

	            if (startW == null) {
	                startW = m[1].length;
	                textW = m[2].length;
	                endW = m[3].length;
	                return m;
	            }

	            if (startW + textW + endW != m[1].length + m[2].length + m[3].length)
	                isRightAligned = false;
	            if (startW != m[1].length)
	                isLeftAligned = false;

	            if (startW > m[1].length)
	                startW = m[1].length;
	            if (textW < m[2].length)
	                textW = m[2].length;
	            if (endW > m[3].length)
	                endW = m[3].length;

	            return m;
	        }).map(forceLeft ? alignLeft :
	            isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);

	        function spaces(n) {
	            return lang.stringRepeat(" ", n);
	        }

	        function alignLeft(m) {
	            return !m[2] ? m[0] : spaces(startW) + m[2]
	                + spaces(textW - m[2].length + endW)
	                + m[4].replace(/^([=:])\s+/, "$1 ");
	        }
	        function alignRight(m) {
	            return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2]
	                + spaces(endW, " ")
	                + m[4].replace(/^([=:])\s+/, "$1 ");
	        }
	        function unAlign(m) {
	            return !m[2] ? m[0] : spaces(startW) + m[2]
	                + spaces(endW)
	                + m[4].replace(/^([=:])\s+/, "$1 ");
	        }
	    };
	}).call(Editor.prototype);


	function isSamePoint(p1, p2) {
	    return p1.row == p2.row && p1.column == p2.column;
	}
	exports.onSessionChange = function(e) {
	    var session = e.session;
	    if (session && !session.multiSelect) {
	        session.$selectionMarkers = [];
	        session.selection.$initRangeList();
	        session.multiSelect = session.selection;
	    }
	    this.multiSelect = session && session.multiSelect;

	    var oldSession = e.oldSession;
	    if (oldSession) {
	        oldSession.multiSelect.off("addRange", this.$onAddRange);
	        oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
	        oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
	        oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
	        oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
	        oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
	    }

	    if (session) {
	        session.multiSelect.on("addRange", this.$onAddRange);
	        session.multiSelect.on("removeRange", this.$onRemoveRange);
	        session.multiSelect.on("multiSelect", this.$onMultiSelect);
	        session.multiSelect.on("singleSelect", this.$onSingleSelect);
	        session.multiSelect.lead.on("change", this.$checkMultiselectChange);
	        session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
	    }

	    if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
	        if (session.selection.inMultiSelectMode)
	            this.$onMultiSelect();
	        else
	            this.$onSingleSelect();
	    }
	};
	function MultiSelect(editor) {
	    if (editor.$multiselectOnSessionChange)
	        return;
	    editor.$onAddRange = editor.$onAddRange.bind(editor);
	    editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
	    editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
	    editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
	    editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);
	    editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);

	    editor.$multiselectOnSessionChange(editor);
	    editor.on("changeSession", editor.$multiselectOnSessionChange);

	    editor.on("mousedown", onMouseDown);
	    editor.commands.addCommands(commands.defaultCommands);

	    addAltCursorListeners(editor);
	}

	function addAltCursorListeners(editor){
	    var el = editor.textInput.getElement();
	    var altCursor = false;
	    event.addListener(el, "keydown", function(e) {
	        var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);
	        if (editor.$blockSelectEnabled && altDown) {
	            if (!altCursor) {
	                editor.renderer.setMouseCursor("crosshair");
	                altCursor = true;
	            }
	        } else if (altCursor) {
	            reset();
	        }
	    });

	    event.addListener(el, "keyup", reset);
	    event.addListener(el, "blur", reset);
	    function reset(e) {
	        if (altCursor) {
	            editor.renderer.setMouseCursor("");
	            altCursor = false;
	        }
	    }
	}

	exports.MultiSelect = MultiSelect;


	acequire("./config").defineOptions(Editor.prototype, "editor", {
	    enableMultiselect: {
	        set: function(val) {
	            MultiSelect(this);
	            if (val) {
	                this.on("changeSession", this.$multiselectOnSessionChange);
	                this.on("mousedown", onMouseDown);
	            } else {
	                this.off("changeSession", this.$multiselectOnSessionChange);
	                this.off("mousedown", onMouseDown);
	            }
	        },
	        value: true
	    },
	    enableBlockSelect: {
	        set: function(val) {
	            this.$blockSelectEnabled = val;
	        },
	        value: true
	    }
	});



	});

	ace.define("ace/mode/folding/fold_mode",["require","exports","module","ace/range"], function(acequire, exports, module) {
	"use strict";

	var Range = acequire("../../range").Range;

	var FoldMode = exports.FoldMode = function() {};

	(function() {

	    this.foldingStartMarker = null;
	    this.foldingStopMarker = null;
	    this.getFoldWidget = function(session, foldStyle, row) {
	        var line = session.getLine(row);
	        if (this.foldingStartMarker.test(line))
	            return "start";
	        if (foldStyle == "markbeginend"
	                && this.foldingStopMarker
	                && this.foldingStopMarker.test(line))
	            return "end";
	        return "";
	    };

	    this.getFoldWidgetRange = function(session, foldStyle, row) {
	        return null;
	    };

	    this.indentationBlock = function(session, row, column) {
	        var re = /\S/;
	        var line = session.getLine(row);
	        var startLevel = line.search(re);
	        if (startLevel == -1)
	            return;

	        var startColumn = column || line.length;
	        var maxRow = session.getLength();
	        var startRow = row;
	        var endRow = row;

	        while (++row < maxRow) {
	            var level = session.getLine(row).search(re);

	            if (level == -1)
	                continue;

	            if (level <= startLevel)
	                break;

	            endRow = row;
	        }

	        if (endRow > startRow) {
	            var endColumn = session.getLine(endRow).length;
	            return new Range(startRow, startColumn, endRow, endColumn);
	        }
	    };

	    this.openingBracketBlock = function(session, bracket, row, column, typeRe) {
	        var start = {row: row, column: column + 1};
	        var end = session.$findClosingBracket(bracket, start, typeRe);
	        if (!end)
	            return;

	        var fw = session.foldWidgets[end.row];
	        if (fw == null)
	            fw = session.getFoldWidget(end.row);

	        if (fw == "start" && end.row > start.row) {
	            end.row --;
	            end.column = session.getLine(end.row).length;
	        }
	        return Range.fromPoints(start, end);
	    };

	    this.closingBracketBlock = function(session, bracket, row, column, typeRe) {
	        var end = {row: row, column: column};
	        var start = session.$findOpeningBracket(bracket, end);

	        if (!start)
	            return;

	        start.column++;
	        end.column--;

	        return  Range.fromPoints(start, end);
	    };
	}).call(FoldMode.prototype);

	});

	ace.define("ace/theme/textmate",["require","exports","module","ace/lib/dom"], function(acequire, exports, module) {
	"use strict";

	exports.isDark = false;
	exports.cssClass = "ace-tm";
	exports.cssText = ".ace-tm .ace_gutter {\
	background: #f0f0f0;\
	color: #333;\
	}\
	.ace-tm .ace_print-margin {\
	width: 1px;\
	background: #e8e8e8;\
	}\
	.ace-tm .ace_fold {\
	background-color: #6B72E6;\
	}\
	.ace-tm {\
	background-color: #FFFFFF;\
	color: black;\
	}\
	.ace-tm .ace_cursor {\
	color: black;\
	}\
	.ace-tm .ace_invisible {\
	color: rgb(191, 191, 191);\
	}\
	.ace-tm .ace_storage,\
	.ace-tm .ace_keyword {\
	color: blue;\
	}\
	.ace-tm .ace_constant {\
	color: rgb(197, 6, 11);\
	}\
	.ace-tm .ace_constant.ace_buildin {\
	color: rgb(88, 72, 246);\
	}\
	.ace-tm .ace_constant.ace_language {\
	color: rgb(88, 92, 246);\
	}\
	.ace-tm .ace_constant.ace_library {\
	color: rgb(6, 150, 14);\
	}\
	.ace-tm .ace_invalid {\
	background-color: rgba(255, 0, 0, 0.1);\
	color: red;\
	}\
	.ace-tm .ace_support.ace_function {\
	color: rgb(60, 76, 114);\
	}\
	.ace-tm .ace_support.ace_constant {\
	color: rgb(6, 150, 14);\
	}\
	.ace-tm .ace_support.ace_type,\
	.ace-tm .ace_support.ace_class {\
	color: rgb(109, 121, 222);\
	}\
	.ace-tm .ace_keyword.ace_operator {\
	color: rgb(104, 118, 135);\
	}\
	.ace-tm .ace_string {\
	color: rgb(3, 106, 7);\
	}\
	.ace-tm .ace_comment {\
	color: rgb(76, 136, 107);\
	}\
	.ace-tm .ace_comment.ace_doc {\
	color: rgb(0, 102, 255);\
	}\
	.ace-tm .ace_comment.ace_doc.ace_tag {\
	color: rgb(128, 159, 191);\
	}\
	.ace-tm .ace_constant.ace_numeric {\
	color: rgb(0, 0, 205);\
	}\
	.ace-tm .ace_variable {\
	color: rgb(49, 132, 149);\
	}\
	.ace-tm .ace_xml-pe {\
	color: rgb(104, 104, 91);\
	}\
	.ace-tm .ace_entity.ace_name.ace_function {\
	color: #0000A2;\
	}\
	.ace-tm .ace_heading {\
	color: rgb(12, 7, 255);\
	}\
	.ace-tm .ace_list {\
	color:rgb(185, 6, 144);\
	}\
	.ace-tm .ace_meta.ace_tag {\
	color:rgb(0, 22, 142);\
	}\
	.ace-tm .ace_string.ace_regex {\
	color: rgb(255, 0, 0)\
	}\
	.ace-tm .ace_marker-layer .ace_selection {\
	background: rgb(181, 213, 255);\
	}\
	.ace-tm.ace_multiselect .ace_selection.ace_start {\
	box-shadow: 0 0 3px 0px white;\
	}\
	.ace-tm .ace_marker-layer .ace_step {\
	background: rgb(252, 255, 0);\
	}\
	.ace-tm .ace_marker-layer .ace_stack {\
	background: rgb(164, 229, 101);\
	}\
	.ace-tm .ace_marker-layer .ace_bracket {\
	margin: -1px 0 0 -1px;\
	border: 1px solid rgb(192, 192, 192);\
	}\
	.ace-tm .ace_marker-layer .ace_active-line {\
	background: rgba(0, 0, 0, 0.07);\
	}\
	.ace-tm .ace_gutter-active-line {\
	background-color : #dcdcdc;\
	}\
	.ace-tm .ace_marker-layer .ace_selected-word {\
	background: rgb(250, 250, 255);\
	border: 1px solid rgb(200, 200, 250);\
	}\
	.ace-tm .ace_indent-guide {\
	background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\") right repeat-y;\
	}\
	";

	var dom = acequire("../lib/dom");
	dom.importCssString(exports.cssText, exports.cssClass);
	});

	ace.define("ace/line_widgets",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/range"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("./lib/oop");
	var dom = acequire("./lib/dom");
	var Range = acequire("./range").Range;


	function LineWidgets(session) {
	    this.session = session;
	    this.session.widgetManager = this;
	    this.session.getRowLength = this.getRowLength;
	    this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
	    this.updateOnChange = this.updateOnChange.bind(this);
	    this.renderWidgets = this.renderWidgets.bind(this);
	    this.measureWidgets = this.measureWidgets.bind(this);
	    this.session._changedWidgets = [];
	    this.$onChangeEditor = this.$onChangeEditor.bind(this);
	    
	    this.session.on("change", this.updateOnChange);
	    this.session.on("changeFold", this.updateOnFold);
	    this.session.on("changeEditor", this.$onChangeEditor);
	}

	(function() {
	    this.getRowLength = function(row) {
	        var h;
	        if (this.lineWidgets)
	            h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
	        else 
	            h = 0;
	        if (!this.$useWrapMode || !this.$wrapData[row]) {
	            return 1 + h;
	        } else {
	            return this.$wrapData[row].length + 1 + h;
	        }
	    };

	    this.$getWidgetScreenLength = function() {
	        var screenRows = 0;
	        this.lineWidgets.forEach(function(w){
	            if (w && w.rowCount && !w.hidden)
	                screenRows += w.rowCount;
	        });
	        return screenRows;
	    };    
	    
	    this.$onChangeEditor = function(e) {
	        this.attach(e.editor);
	    };
	    
	    this.attach = function(editor) {
	        if (editor  && editor.widgetManager && editor.widgetManager != this)
	            editor.widgetManager.detach();

	        if (this.editor == editor)
	            return;

	        this.detach();
	        this.editor = editor;
	        
	        if (editor) {
	            editor.widgetManager = this;
	            editor.renderer.on("beforeRender", this.measureWidgets);
	            editor.renderer.on("afterRender", this.renderWidgets);
	        }
	    };
	    this.detach = function(e) {
	        var editor = this.editor;
	        if (!editor)
	            return;
	        
	        this.editor = null;
	        editor.widgetManager = null;
	        
	        editor.renderer.off("beforeRender", this.measureWidgets);
	        editor.renderer.off("afterRender", this.renderWidgets);
	        var lineWidgets = this.session.lineWidgets;
	        lineWidgets && lineWidgets.forEach(function(w) {
	            if (w && w.el && w.el.parentNode) {
	                w._inDocument = false;
	                w.el.parentNode.removeChild(w.el);
	            }
	        });
	    };

	    this.updateOnFold = function(e, session) {
	        var lineWidgets = session.lineWidgets;
	        if (!lineWidgets || !e.action)
	            return;
	        var fold = e.data;
	        var start = fold.start.row;
	        var end = fold.end.row;
	        var hide = e.action == "add";
	        for (var i = start + 1; i < end; i++) {
	            if (lineWidgets[i])
	                lineWidgets[i].hidden = hide;
	        }
	        if (lineWidgets[end]) {
	            if (hide) {
	                if (!lineWidgets[start])
	                    lineWidgets[start] = lineWidgets[end];
	                else
	                    lineWidgets[end].hidden = hide;
	            } else {
	                if (lineWidgets[start] == lineWidgets[end])
	                    lineWidgets[start] = undefined;
	                lineWidgets[end].hidden = hide;
	            }
	        }
	    };
	    
	    this.updateOnChange = function(delta) {
	        var lineWidgets = this.session.lineWidgets;
	        if (!lineWidgets) return;
	        
	        var startRow = delta.start.row;
	        var len = delta.end.row - startRow;

	        if (len === 0) {
	        } else if (delta.action == 'remove') {
	            var removed = lineWidgets.splice(startRow + 1, len);
	            removed.forEach(function(w) {
	                w && this.removeLineWidget(w);
	            }, this);
	            this.$updateRows();
	        } else {
	            var args = new Array(len);
	            args.unshift(startRow, 0);
	            lineWidgets.splice.apply(lineWidgets, args);
	            this.$updateRows();
	        }
	    };
	    
	    this.$updateRows = function() {
	        var lineWidgets = this.session.lineWidgets;
	        if (!lineWidgets) return;
	        var noWidgets = true;
	        lineWidgets.forEach(function(w, i) {
	            if (w) {
	                noWidgets = false;
	                w.row = i;
	                while (w.$oldWidget) {
	                    w.$oldWidget.row = i;
	                    w = w.$oldWidget;
	                }
	            }
	        });
	        if (noWidgets)
	            this.session.lineWidgets = null;
	    };

	    this.addLineWidget = function(w) {
	        if (!this.session.lineWidgets)
	            this.session.lineWidgets = new Array(this.session.getLength());
	        
	        var old = this.session.lineWidgets[w.row];
	        if (old) {
	            w.$oldWidget = old;
	            if (old.el && old.el.parentNode) {
	                old.el.parentNode.removeChild(old.el);
	                old._inDocument = false;
	            }
	        }
	            
	        this.session.lineWidgets[w.row] = w;
	        
	        w.session = this.session;
	        
	        var renderer = this.editor.renderer;
	        if (w.html && !w.el) {
	            w.el = dom.createElement("div");
	            w.el.innerHTML = w.html;
	        }
	        if (w.el) {
	            dom.addCssClass(w.el, "ace_lineWidgetContainer");
	            w.el.style.position = "absolute";
	            w.el.style.zIndex = 5;
	            renderer.container.appendChild(w.el);
	            w._inDocument = true;
	        }
	        
	        if (!w.coverGutter) {
	            w.el.style.zIndex = 3;
	        }
	        if (!w.pixelHeight) {
	            w.pixelHeight = w.el.offsetHeight;
	        }
	        if (w.rowCount == null) {
	            w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
	        }
	        
	        var fold = this.session.getFoldAt(w.row, 0);
	        w.$fold = fold;
	        if (fold) {
	            var lineWidgets = this.session.lineWidgets;
	            if (w.row == fold.end.row && !lineWidgets[fold.start.row])
	                lineWidgets[fold.start.row] = w;
	            else
	                w.hidden = true;
	        }
	            
	        this.session._emit("changeFold", {data:{start:{row: w.row}}});
	        
	        this.$updateRows();
	        this.renderWidgets(null, renderer);
	        this.onWidgetChanged(w);
	        return w;
	    };
	    
	    this.removeLineWidget = function(w) {
	        w._inDocument = false;
	        w.session = null;
	        if (w.el && w.el.parentNode)
	            w.el.parentNode.removeChild(w.el);
	        if (w.editor && w.editor.destroy) try {
	            w.editor.destroy();
	        } catch(e){}
	        if (this.session.lineWidgets) {
	            var w1 = this.session.lineWidgets[w.row]
	            if (w1 == w) {
	                this.session.lineWidgets[w.row] = w.$oldWidget;
	                if (w.$oldWidget)
	                    this.onWidgetChanged(w.$oldWidget);
	            } else {
	                while (w1) {
	                    if (w1.$oldWidget == w) {
	                        w1.$oldWidget = w.$oldWidget;
	                        break;
	                    }
	                    w1 = w1.$oldWidget;
	                }
	            }
	        }
	        this.session._emit("changeFold", {data:{start:{row: w.row}}});
	        this.$updateRows();
	    };
	    
	    this.getWidgetsAtRow = function(row) {
	        var lineWidgets = this.session.lineWidgets;
	        var w = lineWidgets && lineWidgets[row];
	        var list = [];
	        while (w) {
	            list.push(w);
	            w = w.$oldWidget;
	        }
	        return list;
	    };
	    
	    this.onWidgetChanged = function(w) {
	        this.session._changedWidgets.push(w);
	        this.editor && this.editor.renderer.updateFull();
	    };
	    
	    this.measureWidgets = function(e, renderer) {
	        var changedWidgets = this.session._changedWidgets;
	        var config = renderer.layerConfig;
	        
	        if (!changedWidgets || !changedWidgets.length) return;
	        var min = Infinity;
	        for (var i = 0; i < changedWidgets.length; i++) {
	            var w = changedWidgets[i];
	            if (!w || !w.el) continue;
	            if (w.session != this.session) continue;
	            if (!w._inDocument) {
	                if (this.session.lineWidgets[w.row] != w)
	                    continue;
	                w._inDocument = true;
	                renderer.container.appendChild(w.el);
	            }
	            
	            w.h = w.el.offsetHeight;
	            
	            if (!w.fixedWidth) {
	                w.w = w.el.offsetWidth;
	                w.screenWidth = Math.ceil(w.w / config.characterWidth);
	            }
	            
	            var rowCount = w.h / config.lineHeight;
	            if (w.coverLine) {
	                rowCount -= this.session.getRowLineCount(w.row);
	                if (rowCount < 0)
	                    rowCount = 0;
	            }
	            if (w.rowCount != rowCount) {
	                w.rowCount = rowCount;
	                if (w.row < min)
	                    min = w.row;
	            }
	        }
	        if (min != Infinity) {
	            this.session._emit("changeFold", {data:{start:{row: min}}});
	            this.session.lineWidgetWidth = null;
	        }
	        this.session._changedWidgets = [];
	    };
	    
	    this.renderWidgets = function(e, renderer) {
	        var config = renderer.layerConfig;
	        var lineWidgets = this.session.lineWidgets;
	        if (!lineWidgets)
	            return;
	        var first = Math.min(this.firstRow, config.firstRow);
	        var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);
	        
	        while (first > 0 && !lineWidgets[first])
	            first--;
	        
	        this.firstRow = config.firstRow;
	        this.lastRow = config.lastRow;

	        renderer.$cursorLayer.config = config;
	        for (var i = first; i <= last; i++) {
	            var w = lineWidgets[i];
	            if (!w || !w.el) continue;
	            if (w.hidden) {
	                w.el.style.top = -100 - (w.pixelHeight || 0) + "px";
	                continue;
	            }
	            if (!w._inDocument) {
	                w._inDocument = true;
	                renderer.container.appendChild(w.el);
	            }
	            var top = renderer.$cursorLayer.getPixelPosition({row: i, column:0}, true).top;
	            if (!w.coverLine)
	                top += config.lineHeight * this.session.getRowLineCount(w.row);
	            w.el.style.top = top - config.offset + "px";
	            
	            var left = w.coverGutter ? 0 : renderer.gutterWidth;
	            if (!w.fixedWidth)
	                left -= renderer.scrollLeft;
	            w.el.style.left = left + "px";
	            
	            if (w.fullWidth && w.screenWidth) {
	                w.el.style.minWidth = config.width + 2 * config.padding + "px";
	            }
	            
	            if (w.fixedWidth) {
	                w.el.style.right = renderer.scrollBar.getWidth() + "px";
	            } else {
	                w.el.style.right = "";
	            }
	        }
	    };
	    
	}).call(LineWidgets.prototype);


	exports.LineWidgets = LineWidgets;

	});

	ace.define("ace/ext/error_marker",["require","exports","module","ace/line_widgets","ace/lib/dom","ace/range"], function(acequire, exports, module) {
	"use strict";
	var LineWidgets = acequire("../line_widgets").LineWidgets;
	var dom = acequire("../lib/dom");
	var Range = acequire("../range").Range;

	function binarySearch(array, needle, comparator) {
	    var first = 0;
	    var last = array.length - 1;

	    while (first <= last) {
	        var mid = (first + last) >> 1;
	        var c = comparator(needle, array[mid]);
	        if (c > 0)
	            first = mid + 1;
	        else if (c < 0)
	            last = mid - 1;
	        else
	            return mid;
	    }
	    return -(first + 1);
	}

	function findAnnotations(session, row, dir) {
	    var annotations = session.getAnnotations().sort(Range.comparePoints);
	    if (!annotations.length)
	        return;
	    
	    var i = binarySearch(annotations, {row: row, column: -1}, Range.comparePoints);
	    if (i < 0)
	        i = -i - 1;
	    
	    if (i >= annotations.length)
	        i = dir > 0 ? 0 : annotations.length - 1;
	    else if (i === 0 && dir < 0)
	        i = annotations.length - 1;
	    
	    var annotation = annotations[i];
	    if (!annotation || !dir)
	        return;

	    if (annotation.row === row) {
	        do {
	            annotation = annotations[i += dir];
	        } while (annotation && annotation.row === row);
	        if (!annotation)
	            return annotations.slice();
	    }
	    
	    
	    var matched = [];
	    row = annotation.row;
	    do {
	        matched[dir < 0 ? "unshift" : "push"](annotation);
	        annotation = annotations[i += dir];
	    } while (annotation && annotation.row == row);
	    return matched.length && matched;
	}

	exports.showErrorMarker = function(editor, dir) {
	    var session = editor.session;
	    if (!session.widgetManager) {
	        session.widgetManager = new LineWidgets(session);
	        session.widgetManager.attach(editor);
	    }
	    
	    var pos = editor.getCursorPosition();
	    var row = pos.row;
	    var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function(w) {
	        return w.type == "errorMarker";
	    })[0];
	    if (oldWidget) {
	        oldWidget.destroy();
	    } else {
	        row -= dir;
	    }
	    var annotations = findAnnotations(session, row, dir);
	    var gutterAnno;
	    if (annotations) {
	        var annotation = annotations[0];
	        pos.column = (annotation.pos && typeof annotation.column != "number"
	            ? annotation.pos.sc
	            : annotation.column) || 0;
	        pos.row = annotation.row;
	        gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
	    } else if (oldWidget) {
	        return;
	    } else {
	        gutterAnno = {
	            text: ["Looks good!"],
	            className: "ace_ok"
	        };
	    }
	    editor.session.unfold(pos.row);
	    editor.selection.moveToPosition(pos);
	    
	    var w = {
	        row: pos.row, 
	        fixedWidth: true,
	        coverGutter: true,
	        el: dom.createElement("div"),
	        type: "errorMarker"
	    };
	    var el = w.el.appendChild(dom.createElement("div"));
	    var arrow = w.el.appendChild(dom.createElement("div"));
	    arrow.className = "error_widget_arrow " + gutterAnno.className;
	    
	    var left = editor.renderer.$cursorLayer
	        .getPixelPosition(pos).left;
	    arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";
	    
	    w.el.className = "error_widget_wrapper";
	    el.className = "error_widget " + gutterAnno.className;
	    el.innerHTML = gutterAnno.text.join("<br>");
	    
	    el.appendChild(dom.createElement("div"));
	    
	    var kb = function(_, hashId, keyString) {
	        if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
	            w.destroy();
	            return {command: "null"};
	        }
	    };
	    
	    w.destroy = function() {
	        if (editor.$mouseHandler.isMousePressed)
	            return;
	        editor.keyBinding.removeKeyboardHandler(kb);
	        session.widgetManager.removeLineWidget(w);
	        editor.off("changeSelection", w.destroy);
	        editor.off("changeSession", w.destroy);
	        editor.off("mouseup", w.destroy);
	        editor.off("change", w.destroy);
	    };
	    
	    editor.keyBinding.addKeyboardHandler(kb);
	    editor.on("changeSelection", w.destroy);
	    editor.on("changeSession", w.destroy);
	    editor.on("mouseup", w.destroy);
	    editor.on("change", w.destroy);
	    
	    editor.session.widgetManager.addLineWidget(w);
	    
	    w.el.onmousedown = editor.focus.bind(editor);
	    
	    editor.renderer.scrollCursorIntoView(null, 0.5, {bottom: w.el.offsetHeight});
	};


	dom.importCssString("\
	    .error_widget_wrapper {\
	        background: inherit;\
	        color: inherit;\
	        border:none\
	    }\
	    .error_widget {\
	        border-top: solid 2px;\
	        border-bottom: solid 2px;\
	        margin: 5px 0;\
	        padding: 10px 40px;\
	        white-space: pre-wrap;\
	    }\
	    .error_widget.ace_error, .error_widget_arrow.ace_error{\
	        border-color: #ff5a5a\
	    }\
	    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\
	        border-color: #F1D817\
	    }\
	    .error_widget.ace_info, .error_widget_arrow.ace_info{\
	        border-color: #5a5a5a\
	    }\
	    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\
	        border-color: #5aaa5a\
	    }\
	    .error_widget_arrow {\
	        position: absolute;\
	        border: solid 5px;\
	        border-top-color: transparent!important;\
	        border-right-color: transparent!important;\
	        border-left-color: transparent!important;\
	        top: -5px;\
	    }\
	", "");

	});

	ace.define("ace/ace",["require","exports","module","ace/lib/fixoldbrowsers","ace/lib/dom","ace/lib/event","ace/editor","ace/edit_session","ace/undomanager","ace/virtual_renderer","ace/worker/worker_client","ace/keyboard/hash_handler","ace/placeholder","ace/multi_select","ace/mode/folding/fold_mode","ace/theme/textmate","ace/ext/error_marker","ace/config"], function(acequire, exports, module) {
	"use strict";

	acequire("./lib/fixoldbrowsers");

	var dom = acequire("./lib/dom");
	var event = acequire("./lib/event");

	var Editor = acequire("./editor").Editor;
	var EditSession = acequire("./edit_session").EditSession;
	var UndoManager = acequire("./undomanager").UndoManager;
	var Renderer = acequire("./virtual_renderer").VirtualRenderer;
	acequire("./worker/worker_client");
	acequire("./keyboard/hash_handler");
	acequire("./placeholder");
	acequire("./multi_select");
	acequire("./mode/folding/fold_mode");
	acequire("./theme/textmate");
	acequire("./ext/error_marker");

	exports.config = acequire("./config");
	exports.acequire = acequire;
	exports.edit = function(el) {
	    if (typeof el == "string") {
	        var _id = el;
	        el = document.getElementById(_id);
	        if (!el)
	            throw new Error("ace.edit can't find div #" + _id);
	    }

	    if (el && el.env && el.env.editor instanceof Editor)
	        return el.env.editor;

	    var value = "";
	    if (el && /input|textarea/i.test(el.tagName)) {
	        var oldNode = el;
	        value = oldNode.value;
	        el = dom.createElement("pre");
	        oldNode.parentNode.replaceChild(el, oldNode);
	    } else if (el) {
	        value = dom.getInnerText(el);
	        el.innerHTML = "";
	    }

	    var doc = exports.createEditSession(value);

	    var editor = new Editor(new Renderer(el));
	    editor.setSession(doc);

	    var env = {
	        document: doc,
	        editor: editor,
	        onResize: editor.resize.bind(editor, null)
	    };
	    if (oldNode) env.textarea = oldNode;
	    event.addListener(window, "resize", env.onResize);
	    editor.on("destroy", function() {
	        event.removeListener(window, "resize", env.onResize);
	        env.editor.container.env = null; // prevent memory leak on old ie
	    });
	    editor.container.env = editor.env = env;
	    return editor;
	};
	exports.createEditSession = function(text, mode) {
	    var doc = new EditSession(text, mode);
	    doc.setUndoManager(new UndoManager());
	    return doc;
	}
	exports.EditSession = EditSession;
	exports.UndoManager = UndoManager;
	exports.version = "1.2.3";
	});
	            (function() {
	                ace.acequire(["ace/ace"], function(a) {
	                    a && a.config.init(true);
	                    if (!window.ace)
	                        window.ace = a;
	                    for (var key in a) if (a.hasOwnProperty(key))
	                        window.ace[key] = a[key];
	                });
	            })();
	        
	module.exports = window.ace.acequire("ace/ace");

/***/ },
/* 96 */
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 97 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {module.exports = get_blob()

	function get_blob() {
	  if(global.Blob) {
	    try {
	      new Blob(['asdf'], {type: 'text/plain'})
	      return Blob
	    } catch(err) {}
	  }

	  var Builder = global.WebKitBlobBuilder ||
	                global.MozBlobBuilder ||
	                global.MSBlobBuilder

	  return function(parts, bag) {
	    var builder = new Builder
	      , endings = bag.endings
	      , type = bag.type

	    if(endings) for(var i = 0, len = parts.length; i < len; ++i) {
	      builder.append(parts[i], endings)
	    } else for(var i = 0, len = parts.length; i < len; ++i) {
	      builder.append(parts[i])
	    }

	    return type ? builder.getBlob(type) : builder.getBlob()
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	ace.define("ace/mode/doc_comment_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/text_highlight_rules"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../lib/oop");
	var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;

	var DocCommentHighlightRules = function() {
	    this.$rules = {
	        "start" : [ {
	            token : "comment.doc.tag",
	            regex : "@[\\w\\d_]+" // TODO: fix email addresses
	        }, 
	        DocCommentHighlightRules.getTagRule(),
	        {
	            defaultToken : "comment.doc",
	            caseInsensitive: true
	        }]
	    };
	};

	oop.inherits(DocCommentHighlightRules, TextHighlightRules);

	DocCommentHighlightRules.getTagRule = function(start) {
	    return {
	        token : "comment.doc.tag.storage.type",
	        regex : "\\b(?:TODO|FIXME|XXX|HACK)\\b"
	    };
	}

	DocCommentHighlightRules.getStartRule = function(start) {
	    return {
	        token : "comment.doc", // doc comment
	        regex : "\\/\\*(?=\\*)",
	        next  : start
	    };
	};

	DocCommentHighlightRules.getEndRule = function (start) {
	    return {
	        token : "comment.doc", // closing comment
	        regex : "\\*\\/",
	        next  : start
	    };
	};


	exports.DocCommentHighlightRules = DocCommentHighlightRules;

	});

	ace.define("ace/mode/javascript_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/doc_comment_highlight_rules","ace/mode/text_highlight_rules"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../lib/oop");
	var DocCommentHighlightRules = acequire("./doc_comment_highlight_rules").DocCommentHighlightRules;
	var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;
	var identifierRe = "[a-zA-Z\\$_\u00a1-\uffff][a-zA-Z\\d\\$_\u00a1-\uffff]*\\b";

	var JavaScriptHighlightRules = function(options) {
	    var keywordMapper = this.createKeywordMapper({
	        "variable.language":
	            "Array|Boolean|Date|Function|Iterator|Number|Object|RegExp|String|Proxy|"  + // Constructors
	            "Namespace|QName|XML|XMLList|"                                             + // E4X
	            "ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|"   +
	            "Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|"                    +
	            "Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|"   + // Errors
	            "SyntaxError|TypeError|URIError|"                                          +
	            "decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|eval|isFinite|" + // Non-constructor functions
	            "isNaN|parseFloat|parseInt|"                                               +
	            "JSON|Math|"                                                               + // Other
	            "this|arguments|prototype|window|document"                                 , // Pseudo
	        "keyword":
	            "const|yield|import|get|set|" +
	            "break|case|catch|continue|default|delete|do|else|finally|for|function|" +
	            "if|in|instanceof|new|return|switch|throw|try|typeof|let|var|while|with|debugger|" +
	            "__parent__|__count__|escape|unescape|with|__proto__|" +
	            "class|enum|extends|super|export|implements|private|public|interface|package|protected|static",
	        "storage.type":
	            "const|let|var|function",
	        "constant.language":
	            "null|Infinity|NaN|undefined",
	        "support.function":
	            "alert",
	        "constant.language.boolean": "true|false"
	    }, "identifier");
	    var kwBeforeRe = "case|do|else|finally|in|instanceof|return|throw|try|typeof|yield|void";

	    var escapedRe = "\\\\(?:x[0-9a-fA-F]{2}|" + // hex
	        "u[0-9a-fA-F]{4}|" + // unicode
	        "u{[0-9a-fA-F]{1,6}}|" + // es6 unicode
	        "[0-2][0-7]{0,2}|" + // oct
	        "3[0-7][0-7]?|" + // oct
	        "[4-7][0-7]?|" + //oct
	        ".)";

	    this.$rules = {
	        "no_regex" : [
	            DocCommentHighlightRules.getStartRule("doc-start"),
	            comments("no_regex"),
	            {
	                token : "string",
	                regex : "'(?=.)",
	                next  : "qstring"
	            }, {
	                token : "string",
	                regex : '"(?=.)',
	                next  : "qqstring"
	            }, {
	                token : "constant.numeric", // hex
	                regex : /0(?:[xX][0-9a-fA-F]+|[bB][01]+)\b/
	            }, {
	                token : "constant.numeric", // float
	                regex : /[+-]?\d[\d_]*(?:(?:\.\d*)?(?:[eE][+-]?\d+)?)?\b/
	            }, {
	                token : [
	                    "storage.type", "punctuation.operator", "support.function",
	                    "punctuation.operator", "entity.name.function", "text","keyword.operator"
	                ],
	                regex : "(" + identifierRe + ")(\\.)(prototype)(\\.)(" + identifierRe +")(\\s*)(=)",
	                next: "function_arguments"
	            }, {
	                token : [
	                    "storage.type", "punctuation.operator", "entity.name.function", "text",
	                    "keyword.operator", "text", "storage.type", "text", "paren.lparen"
	                ],
	                regex : "(" + identifierRe + ")(\\.)(" + identifierRe +")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
	                next: "function_arguments"
	            }, {
	                token : [
	                    "entity.name.function", "text", "keyword.operator", "text", "storage.type",
	                    "text", "paren.lparen"
	                ],
	                regex : "(" + identifierRe +")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
	                next: "function_arguments"
	            }, {
	                token : [
	                    "storage.type", "punctuation.operator", "entity.name.function", "text",
	                    "keyword.operator", "text",
	                    "storage.type", "text", "entity.name.function", "text", "paren.lparen"
	                ],
	                regex : "(" + identifierRe + ")(\\.)(" + identifierRe +")(\\s*)(=)(\\s*)(function)(\\s+)(\\w+)(\\s*)(\\()",
	                next: "function_arguments"
	            }, {
	                token : [
	                    "storage.type", "text", "entity.name.function", "text", "paren.lparen"
	                ],
	                regex : "(function)(\\s+)(" + identifierRe + ")(\\s*)(\\()",
	                next: "function_arguments"
	            }, {
	                token : [
	                    "entity.name.function", "text", "punctuation.operator",
	                    "text", "storage.type", "text", "paren.lparen"
	                ],
	                regex : "(" + identifierRe + ")(\\s*)(:)(\\s*)(function)(\\s*)(\\()",
	                next: "function_arguments"
	            }, {
	                token : [
	                    "text", "text", "storage.type", "text", "paren.lparen"
	                ],
	                regex : "(:)(\\s*)(function)(\\s*)(\\()",
	                next: "function_arguments"
	            }, {
	                token : "keyword",
	                regex : "(?:" + kwBeforeRe + ")\\b",
	                next : "start"
	            }, {
	                token : ["support.constant"],
	                regex : /that\b/
	            }, {
	                token : ["storage.type", "punctuation.operator", "support.function.firebug"],
	                regex : /(console)(\.)(warn|info|log|error|time|trace|timeEnd|assert)\b/
	            }, {
	                token : keywordMapper,
	                regex : identifierRe
	            }, {
	                token : "punctuation.operator",
	                regex : /[.](?![.])/,
	                next  : "property"
	            }, {
	                token : "keyword.operator",
	                regex : /--|\+\+|\.{3}|===|==|=|!=|!==|<+=?|>+=?|!|&&|\|\||\?\:|[!$%&*+\-~\/^]=?/,
	                next  : "start"
	            }, {
	                token : "punctuation.operator",
	                regex : /[?:,;.]/,
	                next  : "start"
	            }, {
	                token : "paren.lparen",
	                regex : /[\[({]/,
	                next  : "start"
	            }, {
	                token : "paren.rparen",
	                regex : /[\])}]/
	            }, {
	                token: "comment",
	                regex: /^#!.*$/
	            }
	        ],
	        property: [{
	                token : "text",
	                regex : "\\s+"
	            }, {
	                token : [
	                    "storage.type", "punctuation.operator", "entity.name.function", "text",
	                    "keyword.operator", "text",
	                    "storage.type", "text", "entity.name.function", "text", "paren.lparen"
	                ],
	                regex : "(" + identifierRe + ")(\\.)(" + identifierRe +")(\\s*)(=)(\\s*)(function)(?:(\\s+)(\\w+))?(\\s*)(\\()",
	                next: "function_arguments"
	            }, {
	                token : "punctuation.operator",
	                regex : /[.](?![.])/
	            }, {
	                token : "support.function",
	                regex : /(s(?:h(?:ift|ow(?:Mod(?:elessDialog|alDialog)|Help))|croll(?:X|By(?:Pages|Lines)?|Y|To)?|t(?:op|rike)|i(?:n|zeToContent|debar|gnText)|ort|u(?:p|b(?:str(?:ing)?)?)|pli(?:ce|t)|e(?:nd|t(?:Re(?:sizable|questHeader)|M(?:i(?:nutes|lliseconds)|onth)|Seconds|Ho(?:tKeys|urs)|Year|Cursor|Time(?:out)?|Interval|ZOptions|Date|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Date|FullYear)|FullYear|Active)|arch)|qrt|lice|avePreferences|mall)|h(?:ome|andleEvent)|navigate|c(?:har(?:CodeAt|At)|o(?:s|n(?:cat|textual|firm)|mpile)|eil|lear(?:Timeout|Interval)?|a(?:ptureEvents|ll)|reate(?:StyleSheet|Popup|EventObject))|t(?:o(?:GMTString|S(?:tring|ource)|U(?:TCString|pperCase)|Lo(?:caleString|werCase))|est|a(?:n|int(?:Enabled)?))|i(?:s(?:NaN|Finite)|ndexOf|talics)|d(?:isableExternalCapture|ump|etachEvent)|u(?:n(?:shift|taint|escape|watch)|pdateCommands)|j(?:oin|avaEnabled)|p(?:o(?:p|w)|ush|lugins.refresh|a(?:ddings|rse(?:Int|Float)?)|r(?:int|ompt|eference))|e(?:scape|nableExternalCapture|val|lementFromPoint|x(?:p|ec(?:Script|Command)?))|valueOf|UTC|queryCommand(?:State|Indeterm|Enabled|Value)|f(?:i(?:nd|le(?:ModifiedDate|Size|CreatedDate|UpdatedDate)|xed)|o(?:nt(?:size|color)|rward)|loor|romCharCode)|watch|l(?:ink|o(?:ad|g)|astIndexOf)|a(?:sin|nchor|cos|t(?:tachEvent|ob|an(?:2)?)|pply|lert|b(?:s|ort))|r(?:ou(?:nd|teEvents)|e(?:size(?:By|To)|calc|turnValue|place|verse|l(?:oad|ease(?:Capture|Events)))|andom)|g(?:o|et(?:ResponseHeader|M(?:i(?:nutes|lliseconds)|onth)|Se(?:conds|lection)|Hours|Year|Time(?:zoneOffset)?|Da(?:y|te)|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Da(?:y|te)|FullYear)|FullYear|A(?:ttention|llResponseHeaders)))|m(?:in|ove(?:B(?:y|elow)|To(?:Absolute)?|Above)|ergeAttributes|a(?:tch|rgins|x))|b(?:toa|ig|o(?:ld|rderWidths)|link|ack))\b(?=\()/
	            }, {
	                token : "support.function.dom",
	                regex : /(s(?:ub(?:stringData|mit)|plitText|e(?:t(?:NamedItem|Attribute(?:Node)?)|lect))|has(?:ChildNodes|Feature)|namedItem|c(?:l(?:ick|o(?:se|neNode))|reate(?:C(?:omment|DATASection|aption)|T(?:Head|extNode|Foot)|DocumentFragment|ProcessingInstruction|E(?:ntityReference|lement)|Attribute))|tabIndex|i(?:nsert(?:Row|Before|Cell|Data)|tem)|open|delete(?:Row|C(?:ell|aption)|T(?:Head|Foot)|Data)|focus|write(?:ln)?|a(?:dd|ppend(?:Child|Data))|re(?:set|place(?:Child|Data)|move(?:NamedItem|Child|Attribute(?:Node)?)?)|get(?:NamedItem|Element(?:sBy(?:Name|TagName|ClassName)|ById)|Attribute(?:Node)?)|blur)\b(?=\()/
	            }, {
	                token :  "support.constant",
	                regex : /(s(?:ystemLanguage|cr(?:ipts|ollbars|een(?:X|Y|Top|Left))|t(?:yle(?:Sheets)?|atus(?:Text|bar)?)|ibling(?:Below|Above)|ource|uffixes|e(?:curity(?:Policy)?|l(?:ection|f)))|h(?:istory|ost(?:name)?|as(?:h|Focus))|y|X(?:MLDocument|SLDocument)|n(?:ext|ame(?:space(?:s|URI)|Prop))|M(?:IN_VALUE|AX_VALUE)|c(?:haracterSet|o(?:n(?:structor|trollers)|okieEnabled|lorDepth|mp(?:onents|lete))|urrent|puClass|l(?:i(?:p(?:boardData)?|entInformation)|osed|asses)|alle(?:e|r)|rypto)|t(?:o(?:olbar|p)|ext(?:Transform|Indent|Decoration|Align)|ags)|SQRT(?:1_2|2)|i(?:n(?:ner(?:Height|Width)|put)|ds|gnoreCase)|zIndex|o(?:scpu|n(?:readystatechange|Line)|uter(?:Height|Width)|p(?:sProfile|ener)|ffscreenBuffering)|NEGATIVE_INFINITY|d(?:i(?:splay|alog(?:Height|Top|Width|Left|Arguments)|rectories)|e(?:scription|fault(?:Status|Ch(?:ecked|arset)|View)))|u(?:ser(?:Profile|Language|Agent)|n(?:iqueID|defined)|pdateInterval)|_content|p(?:ixelDepth|ort|ersonalbar|kcs11|l(?:ugins|atform)|a(?:thname|dding(?:Right|Bottom|Top|Left)|rent(?:Window|Layer)?|ge(?:X(?:Offset)?|Y(?:Offset)?))|r(?:o(?:to(?:col|type)|duct(?:Sub)?|mpter)|e(?:vious|fix)))|e(?:n(?:coding|abledPlugin)|x(?:ternal|pando)|mbeds)|v(?:isibility|endor(?:Sub)?|Linkcolor)|URLUnencoded|P(?:I|OSITIVE_INFINITY)|f(?:ilename|o(?:nt(?:Size|Family|Weight)|rmName)|rame(?:s|Element)|gColor)|E|whiteSpace|l(?:i(?:stStyleType|n(?:eHeight|kColor))|o(?:ca(?:tion(?:bar)?|lName)|wsrc)|e(?:ngth|ft(?:Context)?)|a(?:st(?:M(?:odified|atch)|Index|Paren)|yer(?:s|X)|nguage))|a(?:pp(?:MinorVersion|Name|Co(?:deName|re)|Version)|vail(?:Height|Top|Width|Left)|ll|r(?:ity|guments)|Linkcolor|bove)|r(?:ight(?:Context)?|e(?:sponse(?:XML|Text)|adyState))|global|x|m(?:imeTypes|ultiline|enubar|argin(?:Right|Bottom|Top|Left))|L(?:N(?:10|2)|OG(?:10E|2E))|b(?:o(?:ttom|rder(?:Width|RightWidth|BottomWidth|Style|Color|TopWidth|LeftWidth))|ufferDepth|elow|ackground(?:Color|Image)))\b/
	            }, {
	                token : "identifier",
	                regex : identifierRe
	            }, {
	                regex: "",
	                token: "empty",
	                next: "no_regex"
	            }
	        ],
	        "start": [
	            DocCommentHighlightRules.getStartRule("doc-start"),
	            comments("start"),
	            {
	                token: "string.regexp",
	                regex: "\\/",
	                next: "regex"
	            }, {
	                token : "text",
	                regex : "\\s+|^$",
	                next : "start"
	            }, {
	                token: "empty",
	                regex: "",
	                next: "no_regex"
	            }
	        ],
	        "regex": [
	            {
	                token: "regexp.keyword.operator",
	                regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
	            }, {
	                token: "string.regexp",
	                regex: "/[sxngimy]*",
	                next: "no_regex"
	            }, {
	                token : "invalid",
	                regex: /\{\d+\b,?\d*\}[+*]|[+*$^?][+*]|[$^][?]|\?{3,}/
	            }, {
	                token : "constant.language.escape",
	                regex: /\(\?[:=!]|\)|\{\d+\b,?\d*\}|[+*]\?|[()$^+*?.]/
	            }, {
	                token : "constant.language.delimiter",
	                regex: /\|/
	            }, {
	                token: "constant.language.escape",
	                regex: /\[\^?/,
	                next: "regex_character_class"
	            }, {
	                token: "empty",
	                regex: "$",
	                next: "no_regex"
	            }, {
	                defaultToken: "string.regexp"
	            }
	        ],
	        "regex_character_class": [
	            {
	                token: "regexp.charclass.keyword.operator",
	                regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
	            }, {
	                token: "constant.language.escape",
	                regex: "]",
	                next: "regex"
	            }, {
	                token: "constant.language.escape",
	                regex: "-"
	            }, {
	                token: "empty",
	                regex: "$",
	                next: "no_regex"
	            }, {
	                defaultToken: "string.regexp.charachterclass"
	            }
	        ],
	        "function_arguments": [
	            {
	                token: "variable.parameter",
	                regex: identifierRe
	            }, {
	                token: "punctuation.operator",
	                regex: "[, ]+"
	            }, {
	                token: "punctuation.operator",
	                regex: "$"
	            }, {
	                token: "empty",
	                regex: "",
	                next: "no_regex"
	            }
	        ],
	        "qqstring" : [
	            {
	                token : "constant.language.escape",
	                regex : escapedRe
	            }, {
	                token : "string",
	                regex : "\\\\$",
	                next  : "qqstring"
	            }, {
	                token : "string",
	                regex : '"|$',
	                next  : "no_regex"
	            }, {
	                defaultToken: "string"
	            }
	        ],
	        "qstring" : [
	            {
	                token : "constant.language.escape",
	                regex : escapedRe
	            }, {
	                token : "string",
	                regex : "\\\\$",
	                next  : "qstring"
	            }, {
	                token : "string",
	                regex : "'|$",
	                next  : "no_regex"
	            }, {
	                defaultToken: "string"
	            }
	        ]
	    };
	    
	    
	    if (!options || !options.noES6) {
	        this.$rules.no_regex.unshift({
	            regex: "[{}]", onMatch: function(val, state, stack) {
	                this.next = val == "{" ? this.nextState : "";
	                if (val == "{" && stack.length) {
	                    stack.unshift("start", state);
	                }
	                else if (val == "}" && stack.length) {
	                    stack.shift();
	                    this.next = stack.shift();
	                    if (this.next.indexOf("string") != -1 || this.next.indexOf("jsx") != -1)
	                        return "paren.quasi.end";
	                }
	                return val == "{" ? "paren.lparen" : "paren.rparen";
	            },
	            nextState: "start"
	        }, {
	            token : "string.quasi.start",
	            regex : /`/,
	            push  : [{
	                token : "constant.language.escape",
	                regex : escapedRe
	            }, {
	                token : "paren.quasi.start",
	                regex : /\${/,
	                push  : "start"
	            }, {
	                token : "string.quasi.end",
	                regex : /`/,
	                next  : "pop"
	            }, {
	                defaultToken: "string.quasi"
	            }]
	        });
	        
	        if (!options || !options.noJSX)
	            JSX.call(this);
	    }
	    
	    this.embedRules(DocCommentHighlightRules, "doc-",
	        [ DocCommentHighlightRules.getEndRule("no_regex") ]);
	    
	    this.normalizeRules();
	};

	oop.inherits(JavaScriptHighlightRules, TextHighlightRules);

	function JSX() {
	    var tagRegex = identifierRe.replace("\\d", "\\d\\-");
	    var jsxTag = {
	        onMatch : function(val, state, stack) {
	            var offset = val.charAt(1) == "/" ? 2 : 1;
	            if (offset == 1) {
	                if (state != this.nextState)
	                    stack.unshift(this.next, this.nextState, 0);
	                else
	                    stack.unshift(this.next);
	                stack[2]++;
	            } else if (offset == 2) {
	                if (state == this.nextState) {
	                    stack[1]--;
	                    if (!stack[1] || stack[1] < 0) {
	                        stack.shift();
	                        stack.shift();
	                    }
	                }
	            }
	            return [{
	                type: "meta.tag.punctuation." + (offset == 1 ? "" : "end-") + "tag-open.xml",
	                value: val.slice(0, offset)
	            }, {
	                type: "meta.tag.tag-name.xml",
	                value: val.substr(offset)
	            }];
	        },
	        regex : "</?" + tagRegex + "",
	        next: "jsxAttributes",
	        nextState: "jsx"
	    };
	    this.$rules.start.unshift(jsxTag);
	    var jsxJsRule = {
	        regex: "{",
	        token: "paren.quasi.start",
	        push: "start"
	    };
	    this.$rules.jsx = [
	        jsxJsRule,
	        jsxTag,
	        {include : "reference"},
	        {defaultToken: "string"}
	    ];
	    this.$rules.jsxAttributes = [{
	        token : "meta.tag.punctuation.tag-close.xml", 
	        regex : "/?>", 
	        onMatch : function(value, currentState, stack) {
	            if (currentState == stack[0])
	                stack.shift();
	            if (value.length == 2) {
	                if (stack[0] == this.nextState)
	                    stack[1]--;
	                if (!stack[1] || stack[1] < 0) {
	                    stack.splice(0, 2);
	                }
	            }
	            this.next = stack[0] || "start";
	            return [{type: this.token, value: value}];
	        },
	        nextState: "jsx"
	    }, 
	    jsxJsRule,
	    comments("jsxAttributes"),
	    {
	        token : "entity.other.attribute-name.xml",
	        regex : tagRegex
	    }, {
	        token : "keyword.operator.attribute-equals.xml",
	        regex : "="
	    }, {
	        token : "text.tag-whitespace.xml",
	        regex : "\\s+"
	    }, {
	        token : "string.attribute-value.xml",
	        regex : "'",
	        stateName : "jsx_attr_q",
	        push : [
	            {token : "string.attribute-value.xml", regex: "'", next: "pop"},
	            {include : "reference"},
	            {defaultToken : "string.attribute-value.xml"}
	        ]
	    }, {
	        token : "string.attribute-value.xml",
	        regex : '"',
	        stateName : "jsx_attr_qq",
	        push : [
	            {token : "string.attribute-value.xml", regex: '"', next: "pop"},
	            {include : "reference"},
	            {defaultToken : "string.attribute-value.xml"}
	        ]
	    },
	    jsxTag
	    ];
	    this.$rules.reference = [{
	        token : "constant.language.escape.reference.xml",
	        regex : "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
	    }];
	}

	function comments(next) {
	    return [
	        {
	            token : "comment", // multi line comment
	            regex : /\/\*/,
	            next: [
	                DocCommentHighlightRules.getTagRule(),
	                {token : "comment", regex : "\\*\\/", next : next || "pop"},
	                {defaultToken : "comment", caseInsensitive: true}
	            ]
	        }, {
	            token : "comment",
	            regex : "\\/\\/",
	            next: [
	                DocCommentHighlightRules.getTagRule(),
	                {token : "comment", regex : "$|^", next : next || "pop"},
	                {defaultToken : "comment", caseInsensitive: true}
	            ]
	        }
	    ];
	}
	exports.JavaScriptHighlightRules = JavaScriptHighlightRules;
	});

	ace.define("ace/mode/matching_brace_outdent",["require","exports","module","ace/range"], function(acequire, exports, module) {
	"use strict";

	var Range = acequire("../range").Range;

	var MatchingBraceOutdent = function() {};

	(function() {

	    this.checkOutdent = function(line, input) {
	        if (! /^\s+$/.test(line))
	            return false;

	        return /^\s*\}/.test(input);
	    };

	    this.autoOutdent = function(doc, row) {
	        var line = doc.getLine(row);
	        var match = line.match(/^(\s*\})/);

	        if (!match) return 0;

	        var column = match[1].length;
	        var openBracePos = doc.findMatchingBracket({row: row, column: column});

	        if (!openBracePos || openBracePos.row == row) return 0;

	        var indent = this.$getIndent(doc.getLine(openBracePos.row));
	        doc.replace(new Range(row, 0, row, column-1), indent);
	    };

	    this.$getIndent = function(line) {
	        return line.match(/^\s*/)[0];
	    };

	}).call(MatchingBraceOutdent.prototype);

	exports.MatchingBraceOutdent = MatchingBraceOutdent;
	});

	ace.define("ace/mode/behaviour/cstyle",["require","exports","module","ace/lib/oop","ace/mode/behaviour","ace/token_iterator","ace/lib/lang"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../../lib/oop");
	var Behaviour = acequire("../behaviour").Behaviour;
	var TokenIterator = acequire("../../token_iterator").TokenIterator;
	var lang = acequire("../../lib/lang");

	var SAFE_INSERT_IN_TOKENS =
	    ["text", "paren.rparen", "punctuation.operator"];
	var SAFE_INSERT_BEFORE_TOKENS =
	    ["text", "paren.rparen", "punctuation.operator", "comment"];

	var context;
	var contextCache = {};
	var initContext = function(editor) {
	    var id = -1;
	    if (editor.multiSelect) {
	        id = editor.selection.index;
	        if (contextCache.rangeCount != editor.multiSelect.rangeCount)
	            contextCache = {rangeCount: editor.multiSelect.rangeCount};
	    }
	    if (contextCache[id])
	        return context = contextCache[id];
	    context = contextCache[id] = {
	        autoInsertedBrackets: 0,
	        autoInsertedRow: -1,
	        autoInsertedLineEnd: "",
	        maybeInsertedBrackets: 0,
	        maybeInsertedRow: -1,
	        maybeInsertedLineStart: "",
	        maybeInsertedLineEnd: ""
	    };
	};

	var getWrapped = function(selection, selected, opening, closing) {
	    var rowDiff = selection.end.row - selection.start.row;
	    return {
	        text: opening + selected + closing,
	        selection: [
	                0,
	                selection.start.column + 1,
	                rowDiff,
	                selection.end.column + (rowDiff ? 0 : 1)
	            ]
	    };
	};

	var CstyleBehaviour = function() {
	    this.add("braces", "insertion", function(state, action, editor, session, text) {
	        var cursor = editor.getCursorPosition();
	        var line = session.doc.getLine(cursor.row);
	        if (text == '{') {
	            initContext(editor);
	            var selection = editor.getSelectionRange();
	            var selected = session.doc.getTextRange(selection);
	            if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
	                return getWrapped(selection, selected, '{', '}');
	            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
	                if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode) {
	                    CstyleBehaviour.recordAutoInsert(editor, session, "}");
	                    return {
	                        text: '{}',
	                        selection: [1, 1]
	                    };
	                } else {
	                    CstyleBehaviour.recordMaybeInsert(editor, session, "{");
	                    return {
	                        text: '{',
	                        selection: [1, 1]
	                    };
	                }
	            }
	        } else if (text == '}') {
	            initContext(editor);
	            var rightChar = line.substring(cursor.column, cursor.column + 1);
	            if (rightChar == '}') {
	                var matching = session.$findOpeningBracket('}', {column: cursor.column + 1, row: cursor.row});
	                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
	                    CstyleBehaviour.popAutoInsertedClosing();
	                    return {
	                        text: '',
	                        selection: [1, 1]
	                    };
	                }
	            }
	        } else if (text == "\n" || text == "\r\n") {
	            initContext(editor);
	            var closing = "";
	            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
	                closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
	                CstyleBehaviour.clearMaybeInsertedClosing();
	            }
	            var rightChar = line.substring(cursor.column, cursor.column + 1);
	            if (rightChar === '}') {
	                var openBracePos = session.findMatchingBracket({row: cursor.row, column: cursor.column+1}, '}');
	                if (!openBracePos)
	                     return null;
	                var next_indent = this.$getIndent(session.getLine(openBracePos.row));
	            } else if (closing) {
	                var next_indent = this.$getIndent(line);
	            } else {
	                CstyleBehaviour.clearMaybeInsertedClosing();
	                return;
	            }
	            var indent = next_indent + session.getTabString();

	            return {
	                text: '\n' + indent + '\n' + next_indent + closing,
	                selection: [1, indent.length, 1, indent.length]
	            };
	        } else {
	            CstyleBehaviour.clearMaybeInsertedClosing();
	        }
	    });

	    this.add("braces", "deletion", function(state, action, editor, session, range) {
	        var selected = session.doc.getTextRange(range);
	        if (!range.isMultiLine() && selected == '{') {
	            initContext(editor);
	            var line = session.doc.getLine(range.start.row);
	            var rightChar = line.substring(range.end.column, range.end.column + 1);
	            if (rightChar == '}') {
	                range.end.column++;
	                return range;
	            } else {
	                context.maybeInsertedBrackets--;
	            }
	        }
	    });

	    this.add("parens", "insertion", function(state, action, editor, session, text) {
	        if (text == '(') {
	            initContext(editor);
	            var selection = editor.getSelectionRange();
	            var selected = session.doc.getTextRange(selection);
	            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
	                return getWrapped(selection, selected, '(', ')');
	            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
	                CstyleBehaviour.recordAutoInsert(editor, session, ")");
	                return {
	                    text: '()',
	                    selection: [1, 1]
	                };
	            }
	        } else if (text == ')') {
	            initContext(editor);
	            var cursor = editor.getCursorPosition();
	            var line = session.doc.getLine(cursor.row);
	            var rightChar = line.substring(cursor.column, cursor.column + 1);
	            if (rightChar == ')') {
	                var matching = session.$findOpeningBracket(')', {column: cursor.column + 1, row: cursor.row});
	                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
	                    CstyleBehaviour.popAutoInsertedClosing();
	                    return {
	                        text: '',
	                        selection: [1, 1]
	                    };
	                }
	            }
	        }
	    });

	    this.add("parens", "deletion", function(state, action, editor, session, range) {
	        var selected = session.doc.getTextRange(range);
	        if (!range.isMultiLine() && selected == '(') {
	            initContext(editor);
	            var line = session.doc.getLine(range.start.row);
	            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
	            if (rightChar == ')') {
	                range.end.column++;
	                return range;
	            }
	        }
	    });

	    this.add("brackets", "insertion", function(state, action, editor, session, text) {
	        if (text == '[') {
	            initContext(editor);
	            var selection = editor.getSelectionRange();
	            var selected = session.doc.getTextRange(selection);
	            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
	                return getWrapped(selection, selected, '[', ']');
	            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
	                CstyleBehaviour.recordAutoInsert(editor, session, "]");
	                return {
	                    text: '[]',
	                    selection: [1, 1]
	                };
	            }
	        } else if (text == ']') {
	            initContext(editor);
	            var cursor = editor.getCursorPosition();
	            var line = session.doc.getLine(cursor.row);
	            var rightChar = line.substring(cursor.column, cursor.column + 1);
	            if (rightChar == ']') {
	                var matching = session.$findOpeningBracket(']', {column: cursor.column + 1, row: cursor.row});
	                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
	                    CstyleBehaviour.popAutoInsertedClosing();
	                    return {
	                        text: '',
	                        selection: [1, 1]
	                    };
	                }
	            }
	        }
	    });

	    this.add("brackets", "deletion", function(state, action, editor, session, range) {
	        var selected = session.doc.getTextRange(range);
	        if (!range.isMultiLine() && selected == '[') {
	            initContext(editor);
	            var line = session.doc.getLine(range.start.row);
	            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
	            if (rightChar == ']') {
	                range.end.column++;
	                return range;
	            }
	        }
	    });

	    this.add("string_dquotes", "insertion", function(state, action, editor, session, text) {
	        if (text == '"' || text == "'") {
	            initContext(editor);
	            var quote = text;
	            var selection = editor.getSelectionRange();
	            var selected = session.doc.getTextRange(selection);
	            if (selected !== "" && selected !== "'" && selected != '"' && editor.getWrapBehavioursEnabled()) {
	                return getWrapped(selection, selected, quote, quote);
	            } else if (!selected) {
	                var cursor = editor.getCursorPosition();
	                var line = session.doc.getLine(cursor.row);
	                var leftChar = line.substring(cursor.column-1, cursor.column);
	                var rightChar = line.substring(cursor.column, cursor.column + 1);
	                
	                var token = session.getTokenAt(cursor.row, cursor.column);
	                var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
	                if (leftChar == "\\" && token && /escape/.test(token.type))
	                    return null;
	                
	                var stringBefore = token && /string|escape/.test(token.type);
	                var stringAfter = !rightToken || /string|escape/.test(rightToken.type);
	                
	                var pair;
	                if (rightChar == quote) {
	                    pair = stringBefore !== stringAfter;
	                } else {
	                    if (stringBefore && !stringAfter)
	                        return null; // wrap string with different quote
	                    if (stringBefore && stringAfter)
	                        return null; // do not pair quotes inside strings
	                    var wordRe = session.$mode.tokenRe;
	                    wordRe.lastIndex = 0;
	                    var isWordBefore = wordRe.test(leftChar);
	                    wordRe.lastIndex = 0;
	                    var isWordAfter = wordRe.test(leftChar);
	                    if (isWordBefore || isWordAfter)
	                        return null; // before or after alphanumeric
	                    if (rightChar && !/[\s;,.})\]\\]/.test(rightChar))
	                        return null; // there is rightChar and it isn't closing
	                    pair = true;
	                }
	                return {
	                    text: pair ? quote + quote : "",
	                    selection: [1,1]
	                };
	            }
	        }
	    });

	    this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
	        var selected = session.doc.getTextRange(range);
	        if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
	            initContext(editor);
	            var line = session.doc.getLine(range.start.row);
	            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
	            if (rightChar == selected) {
	                range.end.column++;
	                return range;
	            }
	        }
	    });

	};

	    
	CstyleBehaviour.isSaneInsertion = function(editor, session) {
	    var cursor = editor.getCursorPosition();
	    var iterator = new TokenIterator(session, cursor.row, cursor.column);
	    if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
	        var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
	        if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS))
	            return false;
	    }
	    iterator.stepForward();
	    return iterator.getCurrentTokenRow() !== cursor.row ||
	        this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
	};

	CstyleBehaviour.$matchTokenType = function(token, types) {
	    return types.indexOf(token.type || token) > -1;
	};

	CstyleBehaviour.recordAutoInsert = function(editor, session, bracket) {
	    var cursor = editor.getCursorPosition();
	    var line = session.doc.getLine(cursor.row);
	    if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0]))
	        context.autoInsertedBrackets = 0;
	    context.autoInsertedRow = cursor.row;
	    context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
	    context.autoInsertedBrackets++;
	};

	CstyleBehaviour.recordMaybeInsert = function(editor, session, bracket) {
	    var cursor = editor.getCursorPosition();
	    var line = session.doc.getLine(cursor.row);
	    if (!this.isMaybeInsertedClosing(cursor, line))
	        context.maybeInsertedBrackets = 0;
	    context.maybeInsertedRow = cursor.row;
	    context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
	    context.maybeInsertedLineEnd = line.substr(cursor.column);
	    context.maybeInsertedBrackets++;
	};

	CstyleBehaviour.isAutoInsertedClosing = function(cursor, line, bracket) {
	    return context.autoInsertedBrackets > 0 &&
	        cursor.row === context.autoInsertedRow &&
	        bracket === context.autoInsertedLineEnd[0] &&
	        line.substr(cursor.column) === context.autoInsertedLineEnd;
	};

	CstyleBehaviour.isMaybeInsertedClosing = function(cursor, line) {
	    return context.maybeInsertedBrackets > 0 &&
	        cursor.row === context.maybeInsertedRow &&
	        line.substr(cursor.column) === context.maybeInsertedLineEnd &&
	        line.substr(0, cursor.column) == context.maybeInsertedLineStart;
	};

	CstyleBehaviour.popAutoInsertedClosing = function() {
	    context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
	    context.autoInsertedBrackets--;
	};

	CstyleBehaviour.clearMaybeInsertedClosing = function() {
	    if (context) {
	        context.maybeInsertedBrackets = 0;
	        context.maybeInsertedRow = -1;
	    }
	};



	oop.inherits(CstyleBehaviour, Behaviour);

	exports.CstyleBehaviour = CstyleBehaviour;
	});

	ace.define("ace/mode/folding/cstyle",["require","exports","module","ace/lib/oop","ace/range","ace/mode/folding/fold_mode"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../../lib/oop");
	var Range = acequire("../../range").Range;
	var BaseFoldMode = acequire("./fold_mode").FoldMode;

	var FoldMode = exports.FoldMode = function(commentRegex) {
	    if (commentRegex) {
	        this.foldingStartMarker = new RegExp(
	            this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start)
	        );
	        this.foldingStopMarker = new RegExp(
	            this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end)
	        );
	    }
	};
	oop.inherits(FoldMode, BaseFoldMode);

	(function() {
	    
	    this.foldingStartMarker = /(\{|\[)[^\}\]]*$|^\s*(\/\*)/;
	    this.foldingStopMarker = /^[^\[\{]*(\}|\])|^[\s\*]*(\*\/)/;
	    this.singleLineBlockCommentRe= /^\s*(\/\*).*\*\/\s*$/;
	    this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
	    this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
	    this._getFoldWidgetBase = this.getFoldWidget;
	    this.getFoldWidget = function(session, foldStyle, row) {
	        var line = session.getLine(row);
	    
	        if (this.singleLineBlockCommentRe.test(line)) {
	            if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line))
	                return "";
	        }
	    
	        var fw = this._getFoldWidgetBase(session, foldStyle, row);
	    
	        if (!fw && this.startRegionRe.test(line))
	            return "start"; // lineCommentRegionStart
	    
	        return fw;
	    };

	    this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {
	        var line = session.getLine(row);
	        
	        if (this.startRegionRe.test(line))
	            return this.getCommentRegionBlock(session, line, row);
	        
	        var match = line.match(this.foldingStartMarker);
	        if (match) {
	            var i = match.index;

	            if (match[1])
	                return this.openingBracketBlock(session, match[1], row, i);
	                
	            var range = session.getCommentFoldRange(row, i + match[0].length, 1);
	            
	            if (range && !range.isMultiLine()) {
	                if (forceMultiline) {
	                    range = this.getSectionRange(session, row);
	                } else if (foldStyle != "all")
	                    range = null;
	            }
	            
	            return range;
	        }

	        if (foldStyle === "markbegin")
	            return;

	        var match = line.match(this.foldingStopMarker);
	        if (match) {
	            var i = match.index + match[0].length;

	            if (match[1])
	                return this.closingBracketBlock(session, match[1], row, i);

	            return session.getCommentFoldRange(row, i, -1);
	        }
	    };
	    
	    this.getSectionRange = function(session, row) {
	        var line = session.getLine(row);
	        var startIndent = line.search(/\S/);
	        var startRow = row;
	        var startColumn = line.length;
	        row = row + 1;
	        var endRow = row;
	        var maxRow = session.getLength();
	        while (++row < maxRow) {
	            line = session.getLine(row);
	            var indent = line.search(/\S/);
	            if (indent === -1)
	                continue;
	            if  (startIndent > indent)
	                break;
	            var subRange = this.getFoldWidgetRange(session, "all", row);
	            
	            if (subRange) {
	                if (subRange.start.row <= startRow) {
	                    break;
	                } else if (subRange.isMultiLine()) {
	                    row = subRange.end.row;
	                } else if (startIndent == indent) {
	                    break;
	                }
	            }
	            endRow = row;
	        }
	        
	        return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
	    };
	    this.getCommentRegionBlock = function(session, line, row) {
	        var startColumn = line.search(/\s*$/);
	        var maxRow = session.getLength();
	        var startRow = row;
	        
	        var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
	        var depth = 1;
	        while (++row < maxRow) {
	            line = session.getLine(row);
	            var m = re.exec(line);
	            if (!m) continue;
	            if (m[1]) depth--;
	            else depth++;

	            if (!depth) break;
	        }

	        var endRow = row;
	        if (endRow > startRow) {
	            return new Range(startRow, startColumn, endRow, line.length);
	        }
	    };

	}).call(FoldMode.prototype);

	});

	ace.define("ace/mode/javascript",["require","exports","module","ace/lib/oop","ace/mode/text","ace/mode/javascript_highlight_rules","ace/mode/matching_brace_outdent","ace/range","ace/worker/worker_client","ace/mode/behaviour/cstyle","ace/mode/folding/cstyle"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../lib/oop");
	var TextMode = acequire("./text").Mode;
	var JavaScriptHighlightRules = acequire("./javascript_highlight_rules").JavaScriptHighlightRules;
	var MatchingBraceOutdent = acequire("./matching_brace_outdent").MatchingBraceOutdent;
	var Range = acequire("../range").Range;
	var WorkerClient = acequire("../worker/worker_client").WorkerClient;
	var CstyleBehaviour = acequire("./behaviour/cstyle").CstyleBehaviour;
	var CStyleFoldMode = acequire("./folding/cstyle").FoldMode;

	var Mode = function() {
	    this.HighlightRules = JavaScriptHighlightRules;
	    
	    this.$outdent = new MatchingBraceOutdent();
	    this.$behaviour = new CstyleBehaviour();
	    this.foldingRules = new CStyleFoldMode();
	};
	oop.inherits(Mode, TextMode);

	(function() {

	    this.lineCommentStart = "//";
	    this.blockComment = {start: "/*", end: "*/"};

	    this.getNextLineIndent = function(state, line, tab) {
	        var indent = this.$getIndent(line);

	        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
	        var tokens = tokenizedLine.tokens;
	        var endState = tokenizedLine.state;

	        if (tokens.length && tokens[tokens.length-1].type == "comment") {
	            return indent;
	        }

	        if (state == "start" || state == "no_regex") {
	            var match = line.match(/^.*(?:\bcase\b.*\:|[\{\(\[])\s*$/);
	            if (match) {
	                indent += tab;
	            }
	        } else if (state == "doc-start") {
	            if (endState == "start" || endState == "no_regex") {
	                return "";
	            }
	            var match = line.match(/^\s*(\/?)\*/);
	            if (match) {
	                if (match[1]) {
	                    indent += " ";
	                }
	                indent += "* ";
	            }
	        }

	        return indent;
	    };

	    this.checkOutdent = function(state, line, input) {
	        return this.$outdent.checkOutdent(line, input);
	    };

	    this.autoOutdent = function(state, doc, row) {
	        this.$outdent.autoOutdent(doc, row);
	    };

	    this.createWorker = function(session) {
	        var worker = new WorkerClient(["ace"], __webpack_require__(99), "JavaScriptWorker");
	        worker.attachToDocument(session.getDocument());

	        worker.on("annotate", function(results) {
	            session.setAnnotations(results.data);
	        });

	        worker.on("terminate", function() {
	            session.clearAnnotations();
	        });

	        return worker;
	    };

	    this.$id = "ace/mode/javascript";
	}).call(Mode.prototype);

	exports.Mode = Mode;
	});

	ace.define("ace/mode/xml_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/text_highlight_rules"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../lib/oop");
	var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;

	var XmlHighlightRules = function(normalize) {
	    var tagRegex = "[_:a-zA-Z\xc0-\uffff][-_:.a-zA-Z0-9\xc0-\uffff]*";

	    this.$rules = {
	        start : [
	            {token : "string.cdata.xml", regex : "<\\!\\[CDATA\\[", next : "cdata"},
	            {
	                token : ["punctuation.xml-decl.xml", "keyword.xml-decl.xml"],
	                regex : "(<\\?)(xml)(?=[\\s])", next : "xml_decl", caseInsensitive: true
	            },
	            {
	                token : ["punctuation.instruction.xml", "keyword.instruction.xml"],
	                regex : "(<\\?)(" + tagRegex + ")", next : "processing_instruction"
	            },
	            {token : "comment.xml", regex : "<\\!--", next : "comment"},
	            {
	                token : ["xml-pe.doctype.xml", "xml-pe.doctype.xml"],
	                regex : "(<\\!)(DOCTYPE)(?=[\\s])", next : "doctype", caseInsensitive: true
	            },
	            {include : "tag"},
	            {token : "text.end-tag-open.xml", regex: "</"},
	            {token : "text.tag-open.xml", regex: "<"},
	            {include : "reference"},
	            {defaultToken : "text.xml"}
	        ],

	        xml_decl : [{
	            token : "entity.other.attribute-name.decl-attribute-name.xml",
	            regex : "(?:" + tagRegex + ":)?" + tagRegex + ""
	        }, {
	            token : "keyword.operator.decl-attribute-equals.xml",
	            regex : "="
	        }, {
	            include: "whitespace"
	        }, {
	            include: "string"
	        }, {
	            token : "punctuation.xml-decl.xml",
	            regex : "\\?>",
	            next : "start"
	        }],

	        processing_instruction : [
	            {token : "punctuation.instruction.xml", regex : "\\?>", next : "start"},
	            {defaultToken : "instruction.xml"}
	        ],

	        doctype : [
	            {include : "whitespace"},
	            {include : "string"},
	            {token : "xml-pe.doctype.xml", regex : ">", next : "start"},
	            {token : "xml-pe.xml", regex : "[-_a-zA-Z0-9:]+"},
	            {token : "punctuation.int-subset", regex : "\\[", push : "int_subset"}
	        ],

	        int_subset : [{
	            token : "text.xml",
	            regex : "\\s+"
	        }, {
	            token: "punctuation.int-subset.xml",
	            regex: "]",
	            next: "pop"
	        }, {
	            token : ["punctuation.markup-decl.xml", "keyword.markup-decl.xml"],
	            regex : "(<\\!)(" + tagRegex + ")",
	            push : [{
	                token : "text",
	                regex : "\\s+"
	            },
	            {
	                token : "punctuation.markup-decl.xml",
	                regex : ">",
	                next : "pop"
	            },
	            {include : "string"}]
	        }],

	        cdata : [
	            {token : "string.cdata.xml", regex : "\\]\\]>", next : "start"},
	            {token : "text.xml", regex : "\\s+"},
	            {token : "text.xml", regex : "(?:[^\\]]|\\](?!\\]>))+"}
	        ],

	        comment : [
	            {token : "comment.xml", regex : "-->", next : "start"},
	            {defaultToken : "comment.xml"}
	        ],

	        reference : [{
	            token : "constant.language.escape.reference.xml",
	            regex : "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
	        }],

	        attr_reference : [{
	            token : "constant.language.escape.reference.attribute-value.xml",
	            regex : "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
	        }],

	        tag : [{
	            token : ["meta.tag.punctuation.tag-open.xml", "meta.tag.punctuation.end-tag-open.xml", "meta.tag.tag-name.xml"],
	            regex : "(?:(<)|(</))((?:" + tagRegex + ":)?" + tagRegex + ")",
	            next: [
	                {include : "attributes"},
	                {token : "meta.tag.punctuation.tag-close.xml", regex : "/?>", next : "start"}
	            ]
	        }],

	        tag_whitespace : [
	            {token : "text.tag-whitespace.xml", regex : "\\s+"}
	        ],
	        whitespace : [
	            {token : "text.whitespace.xml", regex : "\\s+"}
	        ],
	        string: [{
	            token : "string.xml",
	            regex : "'",
	            push : [
	                {token : "string.xml", regex: "'", next: "pop"},
	                {defaultToken : "string.xml"}
	            ]
	        }, {
	            token : "string.xml",
	            regex : '"',
	            push : [
	                {token : "string.xml", regex: '"', next: "pop"},
	                {defaultToken : "string.xml"}
	            ]
	        }],

	        attributes: [{
	            token : "entity.other.attribute-name.xml",
	            regex : "(?:" + tagRegex + ":)?" + tagRegex + ""
	        }, {
	            token : "keyword.operator.attribute-equals.xml",
	            regex : "="
	        }, {
	            include: "tag_whitespace"
	        }, {
	            include: "attribute_value"
	        }],

	        attribute_value: [{
	            token : "string.attribute-value.xml",
	            regex : "'",
	            push : [
	                {token : "string.attribute-value.xml", regex: "'", next: "pop"},
	                {include : "attr_reference"},
	                {defaultToken : "string.attribute-value.xml"}
	            ]
	        }, {
	            token : "string.attribute-value.xml",
	            regex : '"',
	            push : [
	                {token : "string.attribute-value.xml", regex: '"', next: "pop"},
	                {include : "attr_reference"},
	                {defaultToken : "string.attribute-value.xml"}
	            ]
	        }]
	    };

	    if (this.constructor === XmlHighlightRules)
	        this.normalizeRules();
	};


	(function() {

	    this.embedTagRules = function(HighlightRules, prefix, tag){
	        this.$rules.tag.unshift({
	            token : ["meta.tag.punctuation.tag-open.xml", "meta.tag." + tag + ".tag-name.xml"],
	            regex : "(<)(" + tag + "(?=\\s|>|$))",
	            next: [
	                {include : "attributes"},
	                {token : "meta.tag.punctuation.tag-close.xml", regex : "/?>", next : prefix + "start"}
	            ]
	        });

	        this.$rules[tag + "-end"] = [
	            {include : "attributes"},
	            {token : "meta.tag.punctuation.tag-close.xml", regex : "/?>",  next: "start",
	                onMatch : function(value, currentState, stack) {
	                    stack.splice(0);
	                    return this.token;
	            }}
	        ]

	        this.embedRules(HighlightRules, prefix, [{
	            token: ["meta.tag.punctuation.end-tag-open.xml", "meta.tag." + tag + ".tag-name.xml"],
	            regex : "(</)(" + tag + "(?=\\s|>|$))",
	            next: tag + "-end"
	        }, {
	            token: "string.cdata.xml",
	            regex : "<\\!\\[CDATA\\["
	        }, {
	            token: "string.cdata.xml",
	            regex : "\\]\\]>"
	        }]);
	    };

	}).call(TextHighlightRules.prototype);

	oop.inherits(XmlHighlightRules, TextHighlightRules);

	exports.XmlHighlightRules = XmlHighlightRules;
	});

	ace.define("ace/mode/behaviour/xml",["require","exports","module","ace/lib/oop","ace/mode/behaviour","ace/token_iterator","ace/lib/lang"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../../lib/oop");
	var Behaviour = acequire("../behaviour").Behaviour;
	var TokenIterator = acequire("../../token_iterator").TokenIterator;
	var lang = acequire("../../lib/lang");

	function is(token, type) {
	    return token.type.lastIndexOf(type + ".xml") > -1;
	}

	var XmlBehaviour = function () {

	    this.add("string_dquotes", "insertion", function (state, action, editor, session, text) {
	        if (text == '"' || text == "'") {
	            var quote = text;
	            var selected = session.doc.getTextRange(editor.getSelectionRange());
	            if (selected !== "" && selected !== "'" && selected != '"' && editor.getWrapBehavioursEnabled()) {
	                return {
	                    text: quote + selected + quote,
	                    selection: false
	                };
	            }

	            var cursor = editor.getCursorPosition();
	            var line = session.doc.getLine(cursor.row);
	            var rightChar = line.substring(cursor.column, cursor.column + 1);
	            var iterator = new TokenIterator(session, cursor.row, cursor.column);
	            var token = iterator.getCurrentToken();

	            if (rightChar == quote && (is(token, "attribute-value") || is(token, "string"))) {
	                return {
	                    text: "",
	                    selection: [1, 1]
	                };
	            }

	            if (!token)
	                token = iterator.stepBackward();

	            if (!token)
	                return;

	            while (is(token, "tag-whitespace") || is(token, "whitespace")) {
	                token = iterator.stepBackward();
	            }
	            var rightSpace = !rightChar || rightChar.match(/\s/);
	            if (is(token, "attribute-equals") && (rightSpace || rightChar == '>') || (is(token, "decl-attribute-equals") && (rightSpace || rightChar == '?'))) {
	                return {
	                    text: quote + quote,
	                    selection: [1, 1]
	                };
	            }
	        }
	    });

	    this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
	        var selected = session.doc.getTextRange(range);
	        if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
	            var line = session.doc.getLine(range.start.row);
	            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
	            if (rightChar == selected) {
	                range.end.column++;
	                return range;
	            }
	        }
	    });

	    this.add("autoclosing", "insertion", function (state, action, editor, session, text) {
	        if (text == '>') {
	            var position = editor.getCursorPosition();
	            var iterator = new TokenIterator(session, position.row, position.column);
	            var token = iterator.getCurrentToken() || iterator.stepBackward();
	            if (!token || !(is(token, "tag-name") || is(token, "tag-whitespace") || is(token, "attribute-name") || is(token, "attribute-equals") || is(token, "attribute-value")))
	                return;
	            if (is(token, "reference.attribute-value"))
	                return;
	            if (is(token, "attribute-value")) {
	                var firstChar = token.value.charAt(0);
	                if (firstChar == '"' || firstChar == "'") {
	                    var lastChar = token.value.charAt(token.value.length - 1);
	                    var tokenEnd = iterator.getCurrentTokenColumn() + token.value.length;
	                    if (tokenEnd > position.column || tokenEnd == position.column && firstChar != lastChar)
	                        return;
	                }
	            }
	            while (!is(token, "tag-name")) {
	                token = iterator.stepBackward();
	            }

	            var tokenRow = iterator.getCurrentTokenRow();
	            var tokenColumn = iterator.getCurrentTokenColumn();
	            if (is(iterator.stepBackward(), "end-tag-open"))
	                return;

	            var element = token.value;
	            if (tokenRow == position.row)
	                element = element.substring(0, position.column - tokenColumn);

	            if (this.voidElements.hasOwnProperty(element.toLowerCase()))
	                 return;

	            return {
	               text: ">" + "</" + element + ">",
	               selection: [1, 1]
	            };
	        }
	    });

	    this.add("autoindent", "insertion", function (state, action, editor, session, text) {
	        if (text == "\n") {
	            var cursor = editor.getCursorPosition();
	            var line = session.getLine(cursor.row);
	            var iterator = new TokenIterator(session, cursor.row, cursor.column);
	            var token = iterator.getCurrentToken();

	            if (token && token.type.indexOf("tag-close") !== -1) {
	                if (token.value == "/>")
	                    return;
	                while (token && token.type.indexOf("tag-name") === -1) {
	                    token = iterator.stepBackward();
	                }

	                if (!token) {
	                    return;
	                }

	                var tag = token.value;
	                var row = iterator.getCurrentTokenRow();
	                token = iterator.stepBackward();
	                if (!token || token.type.indexOf("end-tag") !== -1) {
	                    return;
	                }

	                if (this.voidElements && !this.voidElements[tag]) {
	                    var nextToken = session.getTokenAt(cursor.row, cursor.column+1);
	                    var line = session.getLine(row);
	                    var nextIndent = this.$getIndent(line);
	                    var indent = nextIndent + session.getTabString();

	                    if (nextToken && nextToken.value === "</") {
	                        return {
	                            text: "\n" + indent + "\n" + nextIndent,
	                            selection: [1, indent.length, 1, indent.length]
	                        };
	                    } else {
	                        return {
	                            text: "\n" + indent
	                        };
	                    }
	                }
	            }
	        }
	    });

	};

	oop.inherits(XmlBehaviour, Behaviour);

	exports.XmlBehaviour = XmlBehaviour;
	});

	ace.define("ace/mode/folding/xml",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/range","ace/mode/folding/fold_mode","ace/token_iterator"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../../lib/oop");
	var lang = acequire("../../lib/lang");
	var Range = acequire("../../range").Range;
	var BaseFoldMode = acequire("./fold_mode").FoldMode;
	var TokenIterator = acequire("../../token_iterator").TokenIterator;

	var FoldMode = exports.FoldMode = function(voidElements, optionalEndTags) {
	    BaseFoldMode.call(this);
	    this.voidElements = voidElements || {};
	    this.optionalEndTags = oop.mixin({}, this.voidElements);
	    if (optionalEndTags)
	        oop.mixin(this.optionalEndTags, optionalEndTags);
	    
	};
	oop.inherits(FoldMode, BaseFoldMode);

	var Tag = function() {
	    this.tagName = "";
	    this.closing = false;
	    this.selfClosing = false;
	    this.start = {row: 0, column: 0};
	    this.end = {row: 0, column: 0};
	};

	function is(token, type) {
	    return token.type.lastIndexOf(type + ".xml") > -1;
	}

	(function() {

	    this.getFoldWidget = function(session, foldStyle, row) {
	        var tag = this._getFirstTagInLine(session, row);

	        if (!tag)
	            return "";

	        if (tag.closing || (!tag.tagName && tag.selfClosing))
	            return foldStyle == "markbeginend" ? "end" : "";

	        if (!tag.tagName || tag.selfClosing || this.voidElements.hasOwnProperty(tag.tagName.toLowerCase()))
	            return "";

	        if (this._findEndTagInLine(session, row, tag.tagName, tag.end.column))
	            return "";

	        return "start";
	    };
	    this._getFirstTagInLine = function(session, row) {
	        var tokens = session.getTokens(row);
	        var tag = new Tag();

	        for (var i = 0; i < tokens.length; i++) {
	            var token = tokens[i];
	            if (is(token, "tag-open")) {
	                tag.end.column = tag.start.column + token.value.length;
	                tag.closing = is(token, "end-tag-open");
	                token = tokens[++i];
	                if (!token)
	                    return null;
	                tag.tagName = token.value;
	                tag.end.column += token.value.length;
	                for (i++; i < tokens.length; i++) {
	                    token = tokens[i];
	                    tag.end.column += token.value.length;
	                    if (is(token, "tag-close")) {
	                        tag.selfClosing = token.value == '/>';
	                        break;
	                    }
	                }
	                return tag;
	            } else if (is(token, "tag-close")) {
	                tag.selfClosing = token.value == '/>';
	                return tag;
	            }
	            tag.start.column += token.value.length;
	        }

	        return null;
	    };

	    this._findEndTagInLine = function(session, row, tagName, startColumn) {
	        var tokens = session.getTokens(row);
	        var column = 0;
	        for (var i = 0; i < tokens.length; i++) {
	            var token = tokens[i];
	            column += token.value.length;
	            if (column < startColumn)
	                continue;
	            if (is(token, "end-tag-open")) {
	                token = tokens[i + 1];
	                if (token && token.value == tagName)
	                    return true;
	            }
	        }
	        return false;
	    };
	    this._readTagForward = function(iterator) {
	        var token = iterator.getCurrentToken();
	        if (!token)
	            return null;

	        var tag = new Tag();
	        do {
	            if (is(token, "tag-open")) {
	                tag.closing = is(token, "end-tag-open");
	                tag.start.row = iterator.getCurrentTokenRow();
	                tag.start.column = iterator.getCurrentTokenColumn();
	            } else if (is(token, "tag-name")) {
	                tag.tagName = token.value;
	            } else if (is(token, "tag-close")) {
	                tag.selfClosing = token.value == "/>";
	                tag.end.row = iterator.getCurrentTokenRow();
	                tag.end.column = iterator.getCurrentTokenColumn() + token.value.length;
	                iterator.stepForward();
	                return tag;
	            }
	        } while(token = iterator.stepForward());

	        return null;
	    };
	    
	    this._readTagBackward = function(iterator) {
	        var token = iterator.getCurrentToken();
	        if (!token)
	            return null;

	        var tag = new Tag();
	        do {
	            if (is(token, "tag-open")) {
	                tag.closing = is(token, "end-tag-open");
	                tag.start.row = iterator.getCurrentTokenRow();
	                tag.start.column = iterator.getCurrentTokenColumn();
	                iterator.stepBackward();
	                return tag;
	            } else if (is(token, "tag-name")) {
	                tag.tagName = token.value;
	            } else if (is(token, "tag-close")) {
	                tag.selfClosing = token.value == "/>";
	                tag.end.row = iterator.getCurrentTokenRow();
	                tag.end.column = iterator.getCurrentTokenColumn() + token.value.length;
	            }
	        } while(token = iterator.stepBackward());

	        return null;
	    };
	    
	    this._pop = function(stack, tag) {
	        while (stack.length) {
	            
	            var top = stack[stack.length-1];
	            if (!tag || top.tagName == tag.tagName) {
	                return stack.pop();
	            }
	            else if (this.optionalEndTags.hasOwnProperty(top.tagName)) {
	                stack.pop();
	                continue;
	            } else {
	                return null;
	            }
	        }
	    };
	    
	    this.getFoldWidgetRange = function(session, foldStyle, row) {
	        var firstTag = this._getFirstTagInLine(session, row);
	        
	        if (!firstTag)
	            return null;
	        
	        var isBackward = firstTag.closing || firstTag.selfClosing;
	        var stack = [];
	        var tag;
	        
	        if (!isBackward) {
	            var iterator = new TokenIterator(session, row, firstTag.start.column);
	            var start = {
	                row: row,
	                column: firstTag.start.column + firstTag.tagName.length + 2
	            };
	            if (firstTag.start.row == firstTag.end.row)
	                start.column = firstTag.end.column;
	            while (tag = this._readTagForward(iterator)) {
	                if (tag.selfClosing) {
	                    if (!stack.length) {
	                        tag.start.column += tag.tagName.length + 2;
	                        tag.end.column -= 2;
	                        return Range.fromPoints(tag.start, tag.end);
	                    } else
	                        continue;
	                }
	                
	                if (tag.closing) {
	                    this._pop(stack, tag);
	                    if (stack.length == 0)
	                        return Range.fromPoints(start, tag.start);
	                }
	                else {
	                    stack.push(tag);
	                }
	            }
	        }
	        else {
	            var iterator = new TokenIterator(session, row, firstTag.end.column);
	            var end = {
	                row: row,
	                column: firstTag.start.column
	            };
	            
	            while (tag = this._readTagBackward(iterator)) {
	                if (tag.selfClosing) {
	                    if (!stack.length) {
	                        tag.start.column += tag.tagName.length + 2;
	                        tag.end.column -= 2;
	                        return Range.fromPoints(tag.start, tag.end);
	                    } else
	                        continue;
	                }
	                
	                if (!tag.closing) {
	                    this._pop(stack, tag);
	                    if (stack.length == 0) {
	                        tag.start.column += tag.tagName.length + 2;
	                        if (tag.start.row == tag.end.row && tag.start.column < tag.end.column)
	                            tag.start.column = tag.end.column;
	                        return Range.fromPoints(tag.start, end);
	                    }
	                }
	                else {
	                    stack.push(tag);
	                }
	            }
	        }
	        
	    };

	}).call(FoldMode.prototype);

	});

	ace.define("ace/mode/xml",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/mode/text","ace/mode/xml_highlight_rules","ace/mode/behaviour/xml","ace/mode/folding/xml","ace/worker/worker_client"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../lib/oop");
	var lang = acequire("../lib/lang");
	var TextMode = acequire("./text").Mode;
	var XmlHighlightRules = acequire("./xml_highlight_rules").XmlHighlightRules;
	var XmlBehaviour = acequire("./behaviour/xml").XmlBehaviour;
	var XmlFoldMode = acequire("./folding/xml").FoldMode;
	var WorkerClient = acequire("../worker/worker_client").WorkerClient;

	var Mode = function() {
	   this.HighlightRules = XmlHighlightRules;
	   this.$behaviour = new XmlBehaviour();
	   this.foldingRules = new XmlFoldMode();
	};

	oop.inherits(Mode, TextMode);

	(function() {

	    this.voidElements = lang.arrayToMap([]);

	    this.blockComment = {start: "<!--", end: "-->"};

	    this.createWorker = function(session) {
	        var worker = new WorkerClient(["ace"], __webpack_require__(100), "Worker");
	        worker.attachToDocument(session.getDocument());

	        worker.on("error", function(e) {
	            session.setAnnotations(e.data);
	        });

	        worker.on("terminate", function() {
	            session.clearAnnotations();
	        });

	        return worker;
	    };
	    
	    this.$id = "ace/mode/xml";
	}).call(Mode.prototype);

	exports.Mode = Mode;
	});

	ace.define("ace/mode/css_highlight_rules",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/mode/text_highlight_rules"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../lib/oop");
	var lang = acequire("../lib/lang");
	var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;
	var supportType = exports.supportType = "align-content|align-items|align-self|all|animation|animation-delay|animation-direction|animation-duration|animation-fill-mode|animation-iteration-count|animation-name|animation-play-state|animation-timing-function|backface-visibility|background|background-attachment|background-blend-mode|background-clip|background-color|background-image|background-origin|background-position|background-repeat|background-size|border|border-bottom|border-bottom-color|border-bottom-left-radius|border-bottom-right-radius|border-bottom-style|border-bottom-width|border-collapse|border-color|border-image|border-image-outset|border-image-repeat|border-image-slice|border-image-source|border-image-width|border-left|border-left-color|border-left-style|border-left-width|border-radius|border-right|border-right-color|border-right-style|border-right-width|border-spacing|border-style|border-top|border-top-color|border-top-left-radius|border-top-right-radius|border-top-style|border-top-width|border-width|bottom|box-shadow|box-sizing|caption-side|clear|clip|color|column-count|column-fill|column-gap|column-rule|column-rule-color|column-rule-style|column-rule-width|column-span|column-width|columns|content|counter-increment|counter-reset|cursor|direction|display|empty-cells|filter|flex|flex-basis|flex-direction|flex-flow|flex-grow|flex-shrink|flex-wrap|float|font|font-family|font-size|font-size-adjust|font-stretch|font-style|font-variant|font-weight|hanging-punctuation|height|justify-content|left|letter-spacing|line-height|list-style|list-style-image|list-style-position|list-style-type|margin|margin-bottom|margin-left|margin-right|margin-top|max-height|max-width|min-height|min-width|nav-down|nav-index|nav-left|nav-right|nav-up|opacity|order|outline|outline-color|outline-offset|outline-style|outline-width|overflow|overflow-x|overflow-y|padding|padding-bottom|padding-left|padding-right|padding-top|page-break-after|page-break-before|page-break-inside|perspective|perspective-origin|position|quotes|resize|right|tab-size|table-layout|text-align|text-align-last|text-decoration|text-decoration-color|text-decoration-line|text-decoration-style|text-indent|text-justify|text-overflow|text-shadow|text-transform|top|transform|transform-origin|transform-style|transition|transition-delay|transition-duration|transition-property|transition-timing-function|unicode-bidi|vertical-align|visibility|white-space|width|word-break|word-spacing|word-wrap|z-index";
	var supportFunction = exports.supportFunction = "rgb|rgba|url|attr|counter|counters";
	var supportConstant = exports.supportConstant = "absolute|after-edge|after|all-scroll|all|alphabetic|always|antialiased|armenian|auto|avoid-column|avoid-page|avoid|balance|baseline|before-edge|before|below|bidi-override|block-line-height|block|bold|bolder|border-box|both|bottom|box|break-all|break-word|capitalize|caps-height|caption|center|central|char|circle|cjk-ideographic|clone|close-quote|col-resize|collapse|column|consider-shifts|contain|content-box|cover|crosshair|cubic-bezier|dashed|decimal-leading-zero|decimal|default|disabled|disc|disregard-shifts|distribute-all-lines|distribute-letter|distribute-space|distribute|dotted|double|e-resize|ease-in|ease-in-out|ease-out|ease|ellipsis|end|exclude-ruby|fill|fixed|georgian|glyphs|grid-height|groove|hand|hanging|hebrew|help|hidden|hiragana-iroha|hiragana|horizontal|icon|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space|ideographic|inactive|include-ruby|inherit|initial|inline-block|inline-box|inline-line-height|inline-table|inline|inset|inside|inter-ideograph|inter-word|invert|italic|justify|katakana-iroha|katakana|keep-all|last|left|lighter|line-edge|line-through|line|linear|list-item|local|loose|lower-alpha|lower-greek|lower-latin|lower-roman|lowercase|lr-tb|ltr|mathematical|max-height|max-size|medium|menu|message-box|middle|move|n-resize|ne-resize|newspaper|no-change|no-close-quote|no-drop|no-open-quote|no-repeat|none|normal|not-allowed|nowrap|nw-resize|oblique|open-quote|outset|outside|overline|padding-box|page|pointer|pre-line|pre-wrap|pre|preserve-3d|progress|relative|repeat-x|repeat-y|repeat|replaced|reset-size|ridge|right|round|row-resize|rtl|s-resize|scroll|se-resize|separate|slice|small-caps|small-caption|solid|space|square|start|static|status-bar|step-end|step-start|steps|stretch|strict|sub|super|sw-resize|table-caption|table-cell|table-column-group|table-column|table-footer-group|table-header-group|table-row-group|table-row|table|tb-rl|text-after-edge|text-before-edge|text-bottom|text-size|text-top|text|thick|thin|transparent|underline|upper-alpha|upper-latin|upper-roman|uppercase|use-script|vertical-ideographic|vertical-text|visible|w-resize|wait|whitespace|z-index|zero";
	var supportConstantColor = exports.supportConstantColor = "aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow";
	var supportConstantFonts = exports.supportConstantFonts = "arial|century|comic|courier|cursive|fantasy|garamond|georgia|helvetica|impact|lucida|symbol|system|tahoma|times|trebuchet|utopia|verdana|webdings|sans-serif|serif|monospace";

	var numRe = exports.numRe = "\\-?(?:(?:[0-9]+)|(?:[0-9]*\\.[0-9]+))";
	var pseudoElements = exports.pseudoElements = "(\\:+)\\b(after|before|first-letter|first-line|moz-selection|selection)\\b";
	var pseudoClasses  = exports.pseudoClasses =  "(:)\\b(active|checked|disabled|empty|enabled|first-child|first-of-type|focus|hover|indeterminate|invalid|last-child|last-of-type|link|not|nth-child|nth-last-child|nth-last-of-type|nth-of-type|only-child|only-of-type|acequired|root|target|valid|visited)\\b";

	var CssHighlightRules = function() {

	    var keywordMapper = this.createKeywordMapper({
	        "support.function": supportFunction,
	        "support.constant": supportConstant,
	        "support.type": supportType,
	        "support.constant.color": supportConstantColor,
	        "support.constant.fonts": supportConstantFonts
	    }, "text", true);

	    this.$rules = {
	        "start" : [{
	            token : "comment", // multi line comment
	            regex : "\\/\\*",
	            push : "comment"
	        }, {
	            token: "paren.lparen",
	            regex: "\\{",
	            push:  "ruleset"
	        }, {
	            token: "string",
	            regex: "@.*?{",
	            push:  "media"
	        }, {
	            token: "keyword",
	            regex: "#[a-z0-9-_]+"
	        }, {
	            token: "variable",
	            regex: "\\.[a-z0-9-_]+"
	        }, {
	            token: "string",
	            regex: ":[a-z0-9-_]+"
	        }, {
	            token: "constant",
	            regex: "[a-z0-9-_]+"
	        }, {
	            caseInsensitive: true
	        }],

	        "media" : [{
	            token : "comment", // multi line comment
	            regex : "\\/\\*",
	            push : "comment"
	        }, {
	            token: "paren.lparen",
	            regex: "\\{",
	            push:  "ruleset"
	        }, {
	            token: "string",
	            regex: "\\}",
	            next:  "pop"
	        }, {
	            token: "keyword",
	            regex: "#[a-z0-9-_]+"
	        }, {
	            token: "variable",
	            regex: "\\.[a-z0-9-_]+"
	        }, {
	            token: "string",
	            regex: ":[a-z0-9-_]+"
	        }, {
	            token: "constant",
	            regex: "[a-z0-9-_]+"
	        }, {
	            caseInsensitive: true
	        }],

	        "comment" : [{
	            token : "comment",
	            regex : "\\*\\/",
	            next : "pop"
	        }, {
	            defaultToken : "comment"
	        }],

	        "ruleset" : [
	        {
	            token : "paren.rparen",
	            regex : "\\}",
	            next:   "pop"
	        }, {
	            token : "comment", // multi line comment
	            regex : "\\/\\*",
	            push : "comment"
	        }, {
	            token : "string", // single line
	            regex : '["](?:(?:\\\\.)|(?:[^"\\\\]))*?["]'
	        }, {
	            token : "string", // single line
	            regex : "['](?:(?:\\\\.)|(?:[^'\\\\]))*?[']"
	        }, {
	            token : ["constant.numeric", "keyword"],
	            regex : "(" + numRe + ")(ch|cm|deg|em|ex|fr|gd|grad|Hz|in|kHz|mm|ms|pc|pt|px|rad|rem|s|turn|vh|vm|vw|%)"
	        }, {
	            token : "constant.numeric",
	            regex : numRe
	        }, {
	            token : "constant.numeric",  // hex6 color
	            regex : "#[a-f0-9]{6}"
	        }, {
	            token : "constant.numeric", // hex3 color
	            regex : "#[a-f0-9]{3}"
	        }, {
	            token : ["punctuation", "entity.other.attribute-name.pseudo-element.css"],
	            regex : pseudoElements
	        }, {
	            token : ["punctuation", "entity.other.attribute-name.pseudo-class.css"],
	            regex : pseudoClasses
	        }, {
	            token : ["support.function", "string", "support.function"],
	            regex : "(url\\()(.*)(\\))"
	        }, {
	            token : keywordMapper,
	            regex : "\\-?[a-zA-Z_][a-zA-Z0-9_\\-]*"
	        }, {
	            caseInsensitive: true
	        }]
	    };

	    this.normalizeRules();
	};

	oop.inherits(CssHighlightRules, TextHighlightRules);

	exports.CssHighlightRules = CssHighlightRules;

	});

	ace.define("ace/mode/css_completions",["require","exports","module"], function(acequire, exports, module) {
	"use strict";

	var propertyMap = {
	    "background": {"#$0": 1},
	    "background-color": {"#$0": 1, "transparent": 1, "fixed": 1},
	    "background-image": {"url('/$0')": 1},
	    "background-repeat": {"repeat": 1, "repeat-x": 1, "repeat-y": 1, "no-repeat": 1, "inherit": 1},
	    "background-position": {"bottom":2, "center":2, "left":2, "right":2, "top":2, "inherit":2},
	    "background-attachment": {"scroll": 1, "fixed": 1},
	    "background-size": {"cover": 1, "contain": 1},
	    "background-clip": {"border-box": 1, "padding-box": 1, "content-box": 1},
	    "background-origin": {"border-box": 1, "padding-box": 1, "content-box": 1},
	    "border": {"solid $0": 1, "dashed $0": 1, "dotted $0": 1, "#$0": 1},
	    "border-color": {"#$0": 1},
	    "border-style": {"solid":2, "dashed":2, "dotted":2, "double":2, "groove":2, "hidden":2, "inherit":2, "inset":2, "none":2, "outset":2, "ridged":2},
	    "border-collapse": {"collapse": 1, "separate": 1},
	    "bottom": {"px": 1, "em": 1, "%": 1},
	    "clear": {"left": 1, "right": 1, "both": 1, "none": 1},
	    "color": {"#$0": 1, "rgb(#$00,0,0)": 1},
	    "cursor": {"default": 1, "pointer": 1, "move": 1, "text": 1, "wait": 1, "help": 1, "progress": 1, "n-resize": 1, "ne-resize": 1, "e-resize": 1, "se-resize": 1, "s-resize": 1, "sw-resize": 1, "w-resize": 1, "nw-resize": 1},
	    "display": {"none": 1, "block": 1, "inline": 1, "inline-block": 1, "table-cell": 1},
	    "empty-cells": {"show": 1, "hide": 1},
	    "float": {"left": 1, "right": 1, "none": 1},
	    "font-family": {"Arial":2,"Comic Sans MS":2,"Consolas":2,"Courier New":2,"Courier":2,"Georgia":2,"Monospace":2,"Sans-Serif":2, "Segoe UI":2,"Tahoma":2,"Times New Roman":2,"Trebuchet MS":2,"Verdana": 1},
	    "font-size": {"px": 1, "em": 1, "%": 1},
	    "font-weight": {"bold": 1, "normal": 1},
	    "font-style": {"italic": 1, "normal": 1},
	    "font-variant": {"normal": 1, "small-caps": 1},
	    "height": {"px": 1, "em": 1, "%": 1},
	    "left": {"px": 1, "em": 1, "%": 1},
	    "letter-spacing": {"normal": 1},
	    "line-height": {"normal": 1},
	    "list-style-type": {"none": 1, "disc": 1, "circle": 1, "square": 1, "decimal": 1, "decimal-leading-zero": 1, "lower-roman": 1, "upper-roman": 1, "lower-greek": 1, "lower-latin": 1, "upper-latin": 1, "georgian": 1, "lower-alpha": 1, "upper-alpha": 1},
	    "margin": {"px": 1, "em": 1, "%": 1},
	    "margin-right": {"px": 1, "em": 1, "%": 1},
	    "margin-left": {"px": 1, "em": 1, "%": 1},
	    "margin-top": {"px": 1, "em": 1, "%": 1},
	    "margin-bottom": {"px": 1, "em": 1, "%": 1},
	    "max-height": {"px": 1, "em": 1, "%": 1},
	    "max-width": {"px": 1, "em": 1, "%": 1},
	    "min-height": {"px": 1, "em": 1, "%": 1},
	    "min-width": {"px": 1, "em": 1, "%": 1},
	    "overflow": {"hidden": 1, "visible": 1, "auto": 1, "scroll": 1},
	    "overflow-x": {"hidden": 1, "visible": 1, "auto": 1, "scroll": 1},
	    "overflow-y": {"hidden": 1, "visible": 1, "auto": 1, "scroll": 1},
	    "padding": {"px": 1, "em": 1, "%": 1},
	    "padding-top": {"px": 1, "em": 1, "%": 1},
	    "padding-right": {"px": 1, "em": 1, "%": 1},
	    "padding-bottom": {"px": 1, "em": 1, "%": 1},
	    "padding-left": {"px": 1, "em": 1, "%": 1},
	    "page-break-after": {"auto": 1, "always": 1, "avoid": 1, "left": 1, "right": 1},
	    "page-break-before": {"auto": 1, "always": 1, "avoid": 1, "left": 1, "right": 1},
	    "position": {"absolute": 1, "relative": 1, "fixed": 1, "static": 1},
	    "right": {"px": 1, "em": 1, "%": 1},
	    "table-layout": {"fixed": 1, "auto": 1},
	    "text-decoration": {"none": 1, "underline": 1, "line-through": 1, "blink": 1},
	    "text-align": {"left": 1, "right": 1, "center": 1, "justify": 1},
	    "text-transform": {"capitalize": 1, "uppercase": 1, "lowercase": 1, "none": 1},
	    "top": {"px": 1, "em": 1, "%": 1},
	    "vertical-align": {"top": 1, "bottom": 1},
	    "visibility": {"hidden": 1, "visible": 1},
	    "white-space": {"nowrap": 1, "normal": 1, "pre": 1, "pre-line": 1, "pre-wrap": 1},
	    "width": {"px": 1, "em": 1, "%": 1},
	    "word-spacing": {"normal": 1},
	    "filter": {"alpha(opacity=$0100)": 1},

	    "text-shadow": {"$02px 2px 2px #777": 1},
	    "text-overflow": {"ellipsis-word": 1, "clip": 1, "ellipsis": 1},
	    "-moz-border-radius": 1,
	    "-moz-border-radius-topright": 1,
	    "-moz-border-radius-bottomright": 1,
	    "-moz-border-radius-topleft": 1,
	    "-moz-border-radius-bottomleft": 1,
	    "-webkit-border-radius": 1,
	    "-webkit-border-top-right-radius": 1,
	    "-webkit-border-top-left-radius": 1,
	    "-webkit-border-bottom-right-radius": 1,
	    "-webkit-border-bottom-left-radius": 1,
	    "-moz-box-shadow": 1,
	    "-webkit-box-shadow": 1,
	    "transform": {"rotate($00deg)": 1, "skew($00deg)": 1},
	    "-moz-transform": {"rotate($00deg)": 1, "skew($00deg)": 1},
	    "-webkit-transform": {"rotate($00deg)": 1, "skew($00deg)": 1 }
	};

	var CssCompletions = function() {

	};

	(function() {

	    this.completionsDefined = false;

	    this.defineCompletions = function() {
	        if (document) {
	            var style = document.createElement('c').style;

	            for (var i in style) {
	                if (typeof style[i] !== 'string')
	                    continue;

	                var name = i.replace(/[A-Z]/g, function(x) {
	                    return '-' + x.toLowerCase();
	                });

	                if (!propertyMap.hasOwnProperty(name))
	                    propertyMap[name] = 1;
	            }
	        }

	        this.completionsDefined = true;
	    }

	    this.getCompletions = function(state, session, pos, prefix) {
	        if (!this.completionsDefined) {
	            this.defineCompletions();
	        }

	        var token = session.getTokenAt(pos.row, pos.column);

	        if (!token)
	            return [];
	        if (state==='ruleset'){
	            var line = session.getLine(pos.row).substr(0, pos.column);
	            if (/:[^;]+$/.test(line)) {
	                /([\w\-]+):[^:]*$/.test(line);

	                return this.getPropertyValueCompletions(state, session, pos, prefix);
	            } else {
	                return this.getPropertyCompletions(state, session, pos, prefix);
	            }
	        }

	        return [];
	    };

	    this.getPropertyCompletions = function(state, session, pos, prefix) {
	        var properties = Object.keys(propertyMap);
	        return properties.map(function(property){
	            return {
	                caption: property,
	                snippet: property + ': $0',
	                meta: "property",
	                score: Number.MAX_VALUE
	            };
	        });
	    };

	    this.getPropertyValueCompletions = function(state, session, pos, prefix) {
	        var line = session.getLine(pos.row).substr(0, pos.column);
	        var property = (/([\w\-]+):[^:]*$/.exec(line) || {})[1];

	        if (!property)
	            return [];
	        var values = [];
	        if (property in propertyMap && typeof propertyMap[property] === "object") {
	            values = Object.keys(propertyMap[property]);
	        }
	        return values.map(function(value){
	            return {
	                caption: value,
	                snippet: value,
	                meta: "property value",
	                score: Number.MAX_VALUE
	            };
	        });
	    };

	}).call(CssCompletions.prototype);

	exports.CssCompletions = CssCompletions;
	});

	ace.define("ace/mode/behaviour/css",["require","exports","module","ace/lib/oop","ace/mode/behaviour","ace/mode/behaviour/cstyle","ace/token_iterator"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../../lib/oop");
	var Behaviour = acequire("../behaviour").Behaviour;
	var CstyleBehaviour = acequire("./cstyle").CstyleBehaviour;
	var TokenIterator = acequire("../../token_iterator").TokenIterator;

	var CssBehaviour = function () {

	    this.inherit(CstyleBehaviour);

	    this.add("colon", "insertion", function (state, action, editor, session, text) {
	        if (text === ':') {
	            var cursor = editor.getCursorPosition();
	            var iterator = new TokenIterator(session, cursor.row, cursor.column);
	            var token = iterator.getCurrentToken();
	            if (token && token.value.match(/\s+/)) {
	                token = iterator.stepBackward();
	            }
	            if (token && token.type === 'support.type') {
	                var line = session.doc.getLine(cursor.row);
	                var rightChar = line.substring(cursor.column, cursor.column + 1);
	                if (rightChar === ':') {
	                    return {
	                       text: '',
	                       selection: [1, 1]
	                    }
	                }
	                if (!line.substring(cursor.column).match(/^\s*;/)) {
	                    return {
	                       text: ':;',
	                       selection: [1, 1]
	                    }
	                }
	            }
	        }
	    });

	    this.add("colon", "deletion", function (state, action, editor, session, range) {
	        var selected = session.doc.getTextRange(range);
	        if (!range.isMultiLine() && selected === ':') {
	            var cursor = editor.getCursorPosition();
	            var iterator = new TokenIterator(session, cursor.row, cursor.column);
	            var token = iterator.getCurrentToken();
	            if (token && token.value.match(/\s+/)) {
	                token = iterator.stepBackward();
	            }
	            if (token && token.type === 'support.type') {
	                var line = session.doc.getLine(range.start.row);
	                var rightChar = line.substring(range.end.column, range.end.column + 1);
	                if (rightChar === ';') {
	                    range.end.column ++;
	                    return range;
	                }
	            }
	        }
	    });

	    this.add("semicolon", "insertion", function (state, action, editor, session, text) {
	        if (text === ';') {
	            var cursor = editor.getCursorPosition();
	            var line = session.doc.getLine(cursor.row);
	            var rightChar = line.substring(cursor.column, cursor.column + 1);
	            if (rightChar === ';') {
	                return {
	                   text: '',
	                   selection: [1, 1]
	                }
	            }
	        }
	    });

	}
	oop.inherits(CssBehaviour, CstyleBehaviour);

	exports.CssBehaviour = CssBehaviour;
	});

	ace.define("ace/mode/css",["require","exports","module","ace/lib/oop","ace/mode/text","ace/mode/css_highlight_rules","ace/mode/matching_brace_outdent","ace/worker/worker_client","ace/mode/css_completions","ace/mode/behaviour/css","ace/mode/folding/cstyle"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../lib/oop");
	var TextMode = acequire("./text").Mode;
	var CssHighlightRules = acequire("./css_highlight_rules").CssHighlightRules;
	var MatchingBraceOutdent = acequire("./matching_brace_outdent").MatchingBraceOutdent;
	var WorkerClient = acequire("../worker/worker_client").WorkerClient;
	var CssCompletions = acequire("./css_completions").CssCompletions;
	var CssBehaviour = acequire("./behaviour/css").CssBehaviour;
	var CStyleFoldMode = acequire("./folding/cstyle").FoldMode;

	var Mode = function() {
	    this.HighlightRules = CssHighlightRules;
	    this.$outdent = new MatchingBraceOutdent();
	    this.$behaviour = new CssBehaviour();
	    this.$completer = new CssCompletions();
	    this.foldingRules = new CStyleFoldMode();
	};
	oop.inherits(Mode, TextMode);

	(function() {

	    this.foldingRules = "cStyle";
	    this.blockComment = {start: "/*", end: "*/"};

	    this.getNextLineIndent = function(state, line, tab) {
	        var indent = this.$getIndent(line);
	        var tokens = this.getTokenizer().getLineTokens(line, state).tokens;
	        if (tokens.length && tokens[tokens.length-1].type == "comment") {
	            return indent;
	        }

	        var match = line.match(/^.*\{\s*$/);
	        if (match) {
	            indent += tab;
	        }

	        return indent;
	    };

	    this.checkOutdent = function(state, line, input) {
	        return this.$outdent.checkOutdent(line, input);
	    };

	    this.autoOutdent = function(state, doc, row) {
	        this.$outdent.autoOutdent(doc, row);
	    };

	    this.getCompletions = function(state, session, pos, prefix) {
	        return this.$completer.getCompletions(state, session, pos, prefix);
	    };

	    this.createWorker = function(session) {
	        var worker = new WorkerClient(["ace"], __webpack_require__(101), "Worker");
	        worker.attachToDocument(session.getDocument());

	        worker.on("annotate", function(e) {
	            session.setAnnotations(e.data);
	        });

	        worker.on("terminate", function() {
	            session.clearAnnotations();
	        });

	        return worker;
	    };

	    this.$id = "ace/mode/css";
	}).call(Mode.prototype);

	exports.Mode = Mode;

	});

	ace.define("ace/mode/html_highlight_rules",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/mode/css_highlight_rules","ace/mode/javascript_highlight_rules","ace/mode/xml_highlight_rules"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../lib/oop");
	var lang = acequire("../lib/lang");
	var CssHighlightRules = acequire("./css_highlight_rules").CssHighlightRules;
	var JavaScriptHighlightRules = acequire("./javascript_highlight_rules").JavaScriptHighlightRules;
	var XmlHighlightRules = acequire("./xml_highlight_rules").XmlHighlightRules;

	var tagMap = lang.createMap({
	    a           : 'anchor',
	    button 	    : 'form',
	    form        : 'form',
	    img         : 'image',
	    input       : 'form',
	    label       : 'form',
	    option      : 'form',
	    script      : 'script',
	    select      : 'form',
	    textarea    : 'form',
	    style       : 'style',
	    table       : 'table',
	    tbody       : 'table',
	    td          : 'table',
	    tfoot       : 'table',
	    th          : 'table',
	    tr          : 'table'
	});

	var HtmlHighlightRules = function() {
	    XmlHighlightRules.call(this);

	    this.addRules({
	        attributes: [{
	            include : "tag_whitespace"
	        }, {
	            token : "entity.other.attribute-name.xml",
	            regex : "[-_a-zA-Z0-9:.]+"
	        }, {
	            token : "keyword.operator.attribute-equals.xml",
	            regex : "=",
	            push : [{
	                include: "tag_whitespace"
	            }, {
	                token : "string.unquoted.attribute-value.html",
	                regex : "[^<>='\"`\\s]+",
	                next : "pop"
	            }, {
	                token : "empty",
	                regex : "",
	                next : "pop"
	            }]
	        }, {
	            include : "attribute_value"
	        }],
	        tag: [{
	            token : function(start, tag) {
	                var group = tagMap[tag];
	                return ["meta.tag.punctuation." + (start == "<" ? "" : "end-") + "tag-open.xml",
	                    "meta.tag" + (group ? "." + group : "") + ".tag-name.xml"];
	            },
	            regex : "(</?)([-_a-zA-Z0-9:.]+)",
	            next: "tag_stuff"
	        }],
	        tag_stuff: [
	            {include : "attributes"},
	            {token : "meta.tag.punctuation.tag-close.xml", regex : "/?>", next : "start"}
	        ]
	    });

	    this.embedTagRules(CssHighlightRules, "css-", "style");
	    this.embedTagRules(new JavaScriptHighlightRules({noJSX: true}).getRules(), "js-", "script");

	    if (this.constructor === HtmlHighlightRules)
	        this.normalizeRules();
	};

	oop.inherits(HtmlHighlightRules, XmlHighlightRules);

	exports.HtmlHighlightRules = HtmlHighlightRules;
	});

	ace.define("ace/mode/folding/mixed",["require","exports","module","ace/lib/oop","ace/mode/folding/fold_mode"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../../lib/oop");
	var BaseFoldMode = acequire("./fold_mode").FoldMode;

	var FoldMode = exports.FoldMode = function(defaultMode, subModes) {
	    this.defaultMode = defaultMode;
	    this.subModes = subModes;
	};
	oop.inherits(FoldMode, BaseFoldMode);

	(function() {


	    this.$getMode = function(state) {
	        if (typeof state != "string") 
	            state = state[0];
	        for (var key in this.subModes) {
	            if (state.indexOf(key) === 0)
	                return this.subModes[key];
	        }
	        return null;
	    };
	    
	    this.$tryMode = function(state, session, foldStyle, row) {
	        var mode = this.$getMode(state);
	        return (mode ? mode.getFoldWidget(session, foldStyle, row) : "");
	    };

	    this.getFoldWidget = function(session, foldStyle, row) {
	        return (
	            this.$tryMode(session.getState(row-1), session, foldStyle, row) ||
	            this.$tryMode(session.getState(row), session, foldStyle, row) ||
	            this.defaultMode.getFoldWidget(session, foldStyle, row)
	        );
	    };

	    this.getFoldWidgetRange = function(session, foldStyle, row) {
	        var mode = this.$getMode(session.getState(row-1));
	        
	        if (!mode || !mode.getFoldWidget(session, foldStyle, row))
	            mode = this.$getMode(session.getState(row));
	        
	        if (!mode || !mode.getFoldWidget(session, foldStyle, row))
	            mode = this.defaultMode;
	        
	        return mode.getFoldWidgetRange(session, foldStyle, row);
	    };

	}).call(FoldMode.prototype);

	});

	ace.define("ace/mode/folding/html",["require","exports","module","ace/lib/oop","ace/mode/folding/mixed","ace/mode/folding/xml","ace/mode/folding/cstyle"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../../lib/oop");
	var MixedFoldMode = acequire("./mixed").FoldMode;
	var XmlFoldMode = acequire("./xml").FoldMode;
	var CStyleFoldMode = acequire("./cstyle").FoldMode;

	var FoldMode = exports.FoldMode = function(voidElements, optionalTags) {
	    MixedFoldMode.call(this, new XmlFoldMode(voidElements, optionalTags), {
	        "js-": new CStyleFoldMode(),
	        "css-": new CStyleFoldMode()
	    });
	};

	oop.inherits(FoldMode, MixedFoldMode);

	});

	ace.define("ace/mode/html_completions",["require","exports","module","ace/token_iterator"], function(acequire, exports, module) {
	"use strict";

	var TokenIterator = acequire("../token_iterator").TokenIterator;

	var commonAttributes = [
	    "accesskey",
	    "class",
	    "contenteditable",
	    "contextmenu",
	    "dir",
	    "draggable",
	    "dropzone",
	    "hidden",
	    "id",
	    "inert",
	    "itemid",
	    "itemprop",
	    "itemref",
	    "itemscope",
	    "itemtype",
	    "lang",
	    "spellcheck",
	    "style",
	    "tabindex",
	    "title",
	    "translate"
	];

	var eventAttributes = [
	    "onabort",
	    "onblur",
	    "oncancel",
	    "oncanplay",
	    "oncanplaythrough",
	    "onchange",
	    "onclick",
	    "onclose",
	    "oncontextmenu",
	    "oncuechange",
	    "ondblclick",
	    "ondrag",
	    "ondragend",
	    "ondragenter",
	    "ondragleave",
	    "ondragover",
	    "ondragstart",
	    "ondrop",
	    "ondurationchange",
	    "onemptied",
	    "onended",
	    "onerror",
	    "onfocus",
	    "oninput",
	    "oninvalid",
	    "onkeydown",
	    "onkeypress",
	    "onkeyup",
	    "onload",
	    "onloadeddata",
	    "onloadedmetadata",
	    "onloadstart",
	    "onmousedown",
	    "onmousemove",
	    "onmouseout",
	    "onmouseover",
	    "onmouseup",
	    "onmousewheel",
	    "onpause",
	    "onplay",
	    "onplaying",
	    "onprogress",
	    "onratechange",
	    "onreset",
	    "onscroll",
	    "onseeked",
	    "onseeking",
	    "onselect",
	    "onshow",
	    "onstalled",
	    "onsubmit",
	    "onsuspend",
	    "ontimeupdate",
	    "onvolumechange",
	    "onwaiting"
	];

	var globalAttributes = commonAttributes.concat(eventAttributes);

	var attributeMap = {
	    "html": {"manifest": 1},
	    "head": {},
	    "title": {},
	    "base": {"href": 1, "target": 1},
	    "link": {"href": 1, "hreflang": 1, "rel": {"stylesheet": 1, "icon": 1}, "media": {"all": 1, "screen": 1, "print": 1}, "type": {"text/css": 1, "image/png": 1, "image/jpeg": 1, "image/gif": 1}, "sizes": 1},
	    "meta": {"http-equiv": {"content-type": 1}, "name": {"description": 1, "keywords": 1}, "content": {"text/html; charset=UTF-8": 1}, "charset": 1},
	    "style": {"type": 1, "media": {"all": 1, "screen": 1, "print": 1}, "scoped": 1},
	    "script": {"charset": 1, "type": {"text/javascript": 1}, "src": 1, "defer": 1, "async": 1},
	    "noscript": {"href": 1},
	    "body": {"onafterprint": 1, "onbeforeprint": 1, "onbeforeunload": 1, "onhashchange": 1, "onmessage": 1, "onoffline": 1, "onpopstate": 1, "onredo": 1, "onresize": 1, "onstorage": 1, "onundo": 1, "onunload": 1},
	    "section": {},
	    "nav": {},
	    "article": {"pubdate": 1},
	    "aside": {},
	    "h1": {},
	    "h2": {},
	    "h3": {},
	    "h4": {},
	    "h5": {},
	    "h6": {},
	    "header": {},
	    "footer": {},
	    "address": {},
	    "main": {},
	    "p": {},
	    "hr": {},
	    "pre": {},
	    "blockquote": {"cite": 1},
	    "ol": {"start": 1, "reversed": 1},
	    "ul": {},
	    "li": {"value": 1},
	    "dl": {},
	    "dt": {},
	    "dd": {},
	    "figure": {},
	    "figcaption": {},
	    "div": {},
	    "a": {"href": 1, "target": {"_blank": 1, "top": 1}, "ping": 1, "rel": {"nofollow": 1, "alternate": 1, "author": 1, "bookmark": 1, "help": 1, "license": 1, "next": 1, "noreferrer": 1, "prefetch": 1, "prev": 1, "search": 1, "tag": 1}, "media": 1, "hreflang": 1, "type": 1},
	    "em": {},
	    "strong": {},
	    "small": {},
	    "s": {},
	    "cite": {},
	    "q": {"cite": 1},
	    "dfn": {},
	    "abbr": {},
	    "data": {},
	    "time": {"datetime": 1},
	    "code": {},
	    "var": {},
	    "samp": {},
	    "kbd": {},
	    "sub": {},
	    "sup": {},
	    "i": {},
	    "b": {},
	    "u": {},
	    "mark": {},
	    "ruby": {},
	    "rt": {},
	    "rp": {},
	    "bdi": {},
	    "bdo": {},
	    "span": {},
	    "br": {},
	    "wbr": {},
	    "ins": {"cite": 1, "datetime": 1},
	    "del": {"cite": 1, "datetime": 1},
	    "img": {"alt": 1, "src": 1, "height": 1, "width": 1, "usemap": 1, "ismap": 1},
	    "iframe": {"name": 1, "src": 1, "height": 1, "width": 1, "sandbox": {"allow-same-origin": 1, "allow-top-navigation": 1, "allow-forms": 1, "allow-scripts": 1}, "seamless": {"seamless": 1}},
	    "embed": {"src": 1, "height": 1, "width": 1, "type": 1},
	    "object": {"param": 1, "data": 1, "type": 1, "height" : 1, "width": 1, "usemap": 1, "name": 1, "form": 1, "classid": 1},
	    "param": {"name": 1, "value": 1},
	    "video": {"src": 1, "autobuffer": 1, "autoplay": {"autoplay": 1}, "loop": {"loop": 1}, "controls": {"controls": 1}, "width": 1, "height": 1, "poster": 1, "muted": {"muted": 1}, "preload": {"auto": 1, "metadata": 1, "none": 1}},
	    "audio": {"src": 1, "autobuffer": 1, "autoplay": {"autoplay": 1}, "loop": {"loop": 1}, "controls": {"controls": 1}, "muted": {"muted": 1}, "preload": {"auto": 1, "metadata": 1, "none": 1 }},
	    "source": {"src": 1, "type": 1, "media": 1},
	    "track": {"kind": 1, "src": 1, "srclang": 1, "label": 1, "default": 1},
	    "canvas": {"width": 1, "height": 1},
	    "map": {"name": 1},
	    "area": {"shape": 1, "coords": 1, "href": 1, "hreflang": 1, "alt": 1, "target": 1, "media": 1, "rel": 1, "ping": 1, "type": 1},
	    "svg": {},
	    "math": {},
	    "table": {"summary": 1},
	    "caption": {},
	    "colgroup": {"span": 1},
	    "col": {"span": 1},
	    "tbody": {},
	    "thead": {},
	    "tfoot": {},
	    "tr": {},
	    "td": {"headers": 1, "rowspan": 1, "colspan": 1},
	    "th": {"headers": 1, "rowspan": 1, "colspan": 1, "scope": 1},
	    "form": {"accept-charset": 1, "action": 1, "autocomplete": 1, "enctype": {"multipart/form-data": 1, "application/x-www-form-urlencoded": 1}, "method": {"get": 1, "post": 1}, "name": 1, "novalidate": 1, "target": {"_blank": 1, "top": 1}},
	    "fieldset": {"disabled": 1, "form": 1, "name": 1},
	    "legend": {},
	    "label": {"form": 1, "for": 1},
	    "input": {
	        "type": {"text": 1, "password": 1, "hidden": 1, "checkbox": 1, "submit": 1, "radio": 1, "file": 1, "button": 1, "reset": 1, "image": 31, "color": 1, "date": 1, "datetime": 1, "datetime-local": 1, "email": 1, "month": 1, "number": 1, "range": 1, "search": 1, "tel": 1, "time": 1, "url": 1, "week": 1},
	        "accept": 1, "alt": 1, "autocomplete": {"on": 1, "off": 1}, "autofocus": {"autofocus": 1}, "checked": {"checked": 1}, "disabled": {"disabled": 1}, "form": 1, "formaction": 1, "formenctype": {"application/x-www-form-urlencoded": 1, "multipart/form-data": 1, "text/plain": 1}, "formmethod": {"get": 1, "post": 1}, "formnovalidate": {"formnovalidate": 1}, "formtarget": {"_blank": 1, "_self": 1, "_parent": 1, "_top": 1}, "height": 1, "list": 1, "max": 1, "maxlength": 1, "min": 1, "multiple": {"multiple": 1}, "pattern": 1, "placeholder": 1, "readonly": {"readonly": 1}, "acequired": {"acequired": 1}, "size": 1, "src": 1, "step": 1, "width": 1, "files": 1, "value": 1},
	    "button": {"autofocus": 1, "disabled": {"disabled": 1}, "form": 1, "formaction": 1, "formenctype": 1, "formmethod": 1, "formnovalidate": 1, "formtarget": 1, "name": 1, "value": 1, "type": {"button": 1, "submit": 1}},
	    "select": {"autofocus": 1, "disabled": 1, "form": 1, "multiple": {"multiple": 1}, "name": 1, "size": 1, "readonly":{"readonly": 1}},
	    "datalist": {},
	    "optgroup": {"disabled": 1, "label": 1},
	    "option": {"disabled": 1, "selected": 1, "label": 1, "value": 1},
	    "textarea": {"autofocus": {"autofocus": 1}, "disabled": {"disabled": 1}, "form": 1, "maxlength": 1, "name": 1, "placeholder": 1, "readonly": {"readonly": 1}, "acequired": {"acequired": 1}, "rows": 1, "cols": 1, "wrap": {"on": 1, "off": 1, "hard": 1, "soft": 1}},
	    "keygen": {"autofocus": 1, "challenge": {"challenge": 1}, "disabled": {"disabled": 1}, "form": 1, "keytype": {"rsa": 1, "dsa": 1, "ec": 1}, "name": 1},
	    "output": {"for": 1, "form": 1, "name": 1},
	    "progress": {"value": 1, "max": 1},
	    "meter": {"value": 1, "min": 1, "max": 1, "low": 1, "high": 1, "optimum": 1},
	    "details": {"open": 1},
	    "summary": {},
	    "command": {"type": 1, "label": 1, "icon": 1, "disabled": 1, "checked": 1, "radiogroup": 1, "command": 1},
	    "menu": {"type": 1, "label": 1},
	    "dialog": {"open": 1}
	};

	var elements = Object.keys(attributeMap);

	function is(token, type) {
	    return token.type.lastIndexOf(type + ".xml") > -1;
	}

	function findTagName(session, pos) {
	    var iterator = new TokenIterator(session, pos.row, pos.column);
	    var token = iterator.getCurrentToken();
	    while (token && !is(token, "tag-name")){
	        token = iterator.stepBackward();
	    }
	    if (token)
	        return token.value;
	}

	function findAttributeName(session, pos) {
	    var iterator = new TokenIterator(session, pos.row, pos.column);
	    var token = iterator.getCurrentToken();
	    while (token && !is(token, "attribute-name")){
	        token = iterator.stepBackward();
	    }
	    if (token)
	        return token.value;
	}

	var HtmlCompletions = function() {

	};

	(function() {

	    this.getCompletions = function(state, session, pos, prefix) {
	        var token = session.getTokenAt(pos.row, pos.column);

	        if (!token)
	            return [];
	        if (is(token, "tag-name") || is(token, "tag-open") || is(token, "end-tag-open"))
	            return this.getTagCompletions(state, session, pos, prefix);
	        if (is(token, "tag-whitespace") || is(token, "attribute-name"))
	            return this.getAttributeCompletions(state, session, pos, prefix);
	        if (is(token, "attribute-value"))
	            return this.getAttributeValueCompletions(state, session, pos, prefix);
	        var line = session.getLine(pos.row).substr(0, pos.column);
	        if (/&[A-z]*$/i.test(line))
	            return this.getHTMLEntityCompletions(state, session, pos, prefix);

	        return [];
	    };

	    this.getTagCompletions = function(state, session, pos, prefix) {
	        return elements.map(function(element){
	            return {
	                value: element,
	                meta: "tag",
	                score: Number.MAX_VALUE
	            };
	        });
	    };

	    this.getAttributeCompletions = function(state, session, pos, prefix) {
	        var tagName = findTagName(session, pos);
	        if (!tagName)
	            return [];
	        var attributes = globalAttributes;
	        if (tagName in attributeMap) {
	            attributes = attributes.concat(Object.keys(attributeMap[tagName]));
	        }
	        return attributes.map(function(attribute){
	            return {
	                caption: attribute,
	                snippet: attribute + '="$0"',
	                meta: "attribute",
	                score: Number.MAX_VALUE
	            };
	        });
	    };

	    this.getAttributeValueCompletions = function(state, session, pos, prefix) {
	        var tagName = findTagName(session, pos);
	        var attributeName = findAttributeName(session, pos);
	        
	        if (!tagName)
	            return [];
	        var values = [];
	        if (tagName in attributeMap && attributeName in attributeMap[tagName] && typeof attributeMap[tagName][attributeName] === "object") {
	            values = Object.keys(attributeMap[tagName][attributeName]);
	        }
	        return values.map(function(value){
	            return {
	                caption: value,
	                snippet: value,
	                meta: "attribute value",
	                score: Number.MAX_VALUE
	            };
	        });
	    };

	    this.getHTMLEntityCompletions = function(state, session, pos, prefix) {
	        var values = ['Aacute;', 'aacute;', 'Acirc;', 'acirc;', 'acute;', 'AElig;', 'aelig;', 'Agrave;', 'agrave;', 'alefsym;', 'Alpha;', 'alpha;', 'amp;', 'and;', 'ang;', 'Aring;', 'aring;', 'asymp;', 'Atilde;', 'atilde;', 'Auml;', 'auml;', 'bdquo;', 'Beta;', 'beta;', 'brvbar;', 'bull;', 'cap;', 'Ccedil;', 'ccedil;', 'cedil;', 'cent;', 'Chi;', 'chi;', 'circ;', 'clubs;', 'cong;', 'copy;', 'crarr;', 'cup;', 'curren;', 'Dagger;', 'dagger;', 'dArr;', 'darr;', 'deg;', 'Delta;', 'delta;', 'diams;', 'divide;', 'Eacute;', 'eacute;', 'Ecirc;', 'ecirc;', 'Egrave;', 'egrave;', 'empty;', 'emsp;', 'ensp;', 'Epsilon;', 'epsilon;', 'equiv;', 'Eta;', 'eta;', 'ETH;', 'eth;', 'Euml;', 'euml;', 'euro;', 'exist;', 'fnof;', 'forall;', 'frac12;', 'frac14;', 'frac34;', 'frasl;', 'Gamma;', 'gamma;', 'ge;', 'gt;', 'hArr;', 'harr;', 'hearts;', 'hellip;', 'Iacute;', 'iacute;', 'Icirc;', 'icirc;', 'iexcl;', 'Igrave;', 'igrave;', 'image;', 'infin;', 'int;', 'Iota;', 'iota;', 'iquest;', 'isin;', 'Iuml;', 'iuml;', 'Kappa;', 'kappa;', 'Lambda;', 'lambda;', 'lang;', 'laquo;', 'lArr;', 'larr;', 'lceil;', 'ldquo;', 'le;', 'lfloor;', 'lowast;', 'loz;', 'lrm;', 'lsaquo;', 'lsquo;', 'lt;', 'macr;', 'mdash;', 'micro;', 'middot;', 'minus;', 'Mu;', 'mu;', 'nabla;', 'nbsp;', 'ndash;', 'ne;', 'ni;', 'not;', 'notin;', 'nsub;', 'Ntilde;', 'ntilde;', 'Nu;', 'nu;', 'Oacute;', 'oacute;', 'Ocirc;', 'ocirc;', 'OElig;', 'oelig;', 'Ograve;', 'ograve;', 'oline;', 'Omega;', 'omega;', 'Omicron;', 'omicron;', 'oplus;', 'or;', 'ordf;', 'ordm;', 'Oslash;', 'oslash;', 'Otilde;', 'otilde;', 'otimes;', 'Ouml;', 'ouml;', 'para;', 'part;', 'permil;', 'perp;', 'Phi;', 'phi;', 'Pi;', 'pi;', 'piv;', 'plusmn;', 'pound;', 'Prime;', 'prime;', 'prod;', 'prop;', 'Psi;', 'psi;', 'quot;', 'radic;', 'rang;', 'raquo;', 'rArr;', 'rarr;', 'rceil;', 'rdquo;', 'real;', 'reg;', 'rfloor;', 'Rho;', 'rho;', 'rlm;', 'rsaquo;', 'rsquo;', 'sbquo;', 'Scaron;', 'scaron;', 'sdot;', 'sect;', 'shy;', 'Sigma;', 'sigma;', 'sigmaf;', 'sim;', 'spades;', 'sub;', 'sube;', 'sum;', 'sup;', 'sup1;', 'sup2;', 'sup3;', 'supe;', 'szlig;', 'Tau;', 'tau;', 'there4;', 'Theta;', 'theta;', 'thetasym;', 'thinsp;', 'THORN;', 'thorn;', 'tilde;', 'times;', 'trade;', 'Uacute;', 'uacute;', 'uArr;', 'uarr;', 'Ucirc;', 'ucirc;', 'Ugrave;', 'ugrave;', 'uml;', 'upsih;', 'Upsilon;', 'upsilon;', 'Uuml;', 'uuml;', 'weierp;', 'Xi;', 'xi;', 'Yacute;', 'yacute;', 'yen;', 'Yuml;', 'yuml;', 'Zeta;', 'zeta;', 'zwj;', 'zwnj;'];

	        return values.map(function(value){
	            return {
	                caption: value,
	                snippet: value,
	                meta: "html entity",
	                score: Number.MAX_VALUE
	            };
	        });
	    };

	}).call(HtmlCompletions.prototype);

	exports.HtmlCompletions = HtmlCompletions;
	});

	ace.define("ace/mode/html",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/mode/text","ace/mode/javascript","ace/mode/css","ace/mode/html_highlight_rules","ace/mode/behaviour/xml","ace/mode/folding/html","ace/mode/html_completions","ace/worker/worker_client"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../lib/oop");
	var lang = acequire("../lib/lang");
	var TextMode = acequire("./text").Mode;
	var JavaScriptMode = acequire("./javascript").Mode;
	var CssMode = acequire("./css").Mode;
	var HtmlHighlightRules = acequire("./html_highlight_rules").HtmlHighlightRules;
	var XmlBehaviour = acequire("./behaviour/xml").XmlBehaviour;
	var HtmlFoldMode = acequire("./folding/html").FoldMode;
	var HtmlCompletions = acequire("./html_completions").HtmlCompletions;
	var WorkerClient = acequire("../worker/worker_client").WorkerClient;
	var voidElements = ["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "meta", "menuitem", "param", "source", "track", "wbr"];
	var optionalEndTags = ["li", "dt", "dd", "p", "rt", "rp", "optgroup", "option", "colgroup", "td", "th"];

	var Mode = function(options) {
	    this.fragmentContext = options && options.fragmentContext;
	    this.HighlightRules = HtmlHighlightRules;
	    this.$behaviour = new XmlBehaviour();
	    this.$completer = new HtmlCompletions();
	    
	    this.createModeDelegates({
	        "js-": JavaScriptMode,
	        "css-": CssMode
	    });
	    
	    this.foldingRules = new HtmlFoldMode(this.voidElements, lang.arrayToMap(optionalEndTags));
	};
	oop.inherits(Mode, TextMode);

	(function() {

	    this.blockComment = {start: "<!--", end: "-->"};

	    this.voidElements = lang.arrayToMap(voidElements);

	    this.getNextLineIndent = function(state, line, tab) {
	        return this.$getIndent(line);
	    };

	    this.checkOutdent = function(state, line, input) {
	        return false;
	    };

	    this.getCompletions = function(state, session, pos, prefix) {
	        return this.$completer.getCompletions(state, session, pos, prefix);
	    };

	    this.createWorker = function(session) {
	        if (this.constructor != Mode)
	            return;
	        var worker = new WorkerClient(["ace"], __webpack_require__(102), "Worker");
	        worker.attachToDocument(session.getDocument());

	        if (this.fragmentContext)
	            worker.call("setOptions", [{context: this.fragmentContext}]);

	        worker.on("error", function(e) {
	            session.setAnnotations(e.data);
	        });

	        worker.on("terminate", function() {
	            session.clearAnnotations();
	        });

	        return worker;
	    };

	    this.$id = "ace/mode/html";
	}).call(Mode.prototype);

	exports.Mode = Mode;
	});

	ace.define("ace/mode/markdown_highlight_rules",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/mode/text_highlight_rules","ace/mode/javascript_highlight_rules","ace/mode/xml_highlight_rules","ace/mode/html_highlight_rules","ace/mode/css_highlight_rules"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../lib/oop");
	var lang = acequire("../lib/lang");
	var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;
	var JavaScriptHighlightRules = acequire("./javascript_highlight_rules").JavaScriptHighlightRules;
	var XmlHighlightRules = acequire("./xml_highlight_rules").XmlHighlightRules;
	var HtmlHighlightRules = acequire("./html_highlight_rules").HtmlHighlightRules;
	var CssHighlightRules = acequire("./css_highlight_rules").CssHighlightRules;

	var escaped = function(ch) {
	    return "(?:[^" + lang.escapeRegExp(ch) + "\\\\]|\\\\.)*";
	}

	function github_embed(tag, prefix) {
	    return { // Github style block
	        token : "support.function",
	        regex : "^\\s*```" + tag + "\\s*$",
	        push  : prefix + "start"
	    };
	}

	var MarkdownHighlightRules = function() {
	    HtmlHighlightRules.call(this);

	    this.$rules["start"].unshift({
	        token : "empty_line",
	        regex : '^$',
	        next: "allowBlock"
	    }, { // h1
	        token: "markup.heading.1",
	        regex: "^=+(?=\\s*$)"
	    }, { // h2
	        token: "markup.heading.2",
	        regex: "^\\-+(?=\\s*$)"
	    }, {
	        token : function(value) {
	            return "markup.heading." + value.length;
	        },
	        regex : /^#{1,6}(?=\s*[^ #]|\s+#.)/,
	        next : "header"
	    },
	       github_embed("(?:javascript|js)", "jscode-"),
	       github_embed("xml", "xmlcode-"),
	       github_embed("html", "htmlcode-"),
	       github_embed("css", "csscode-"),
	    { // Github style block
	        token : "support.function",
	        regex : "^\\s*```\\s*\\S*(?:{.*?\\})?\\s*$",
	        next  : "githubblock"
	    }, { // block quote
	        token : "string.blockquote",
	        regex : "^\\s*>\\s*(?:[*+-]|\\d+\\.)?\\s+",
	        next  : "blockquote"
	    }, { // HR * - _
	        token : "constant",
	        regex : "^ {0,2}(?:(?: ?\\* ?){3,}|(?: ?\\- ?){3,}|(?: ?\\_ ?){3,})\\s*$",
	        next: "allowBlock"
	    }, { // list
	        token : "markup.list",
	        regex : "^\\s{0,3}(?:[*+-]|\\d+\\.)\\s+",
	        next  : "listblock-start"
	    }, {
	        include : "basic"
	    });

	    this.addRules({
	        "basic" : [{
	            token : "constant.language.escape",
	            regex : /\\[\\`*_{}\[\]()#+\-.!]/
	        }, { // code span `
	            token : "support.function",
	            regex : "(`+)(.*?[^`])(\\1)"
	        }, { // reference
	            token : ["text", "constant", "text", "url", "string", "text"],
	            regex : "^([ ]{0,3}\\[)([^\\]]+)(\\]:\\s*)([^ ]+)(\\s*(?:[\"][^\"]+[\"])?(\\s*))$"
	        }, { // link by reference
	            token : ["text", "string", "text", "constant", "text"],
	            regex : "(\\[)(" + escaped("]") + ")(\\]\s*\\[)("+ escaped("]") + ")(\\])"
	        }, { // link by url
	            token : ["text", "string", "text", "markup.underline", "string", "text"],
	            regex : "(\\[)(" +                                        // [
	                    escaped("]") +                                    // link text
	                    ")(\\]\\()"+                                      // ](
	                    '((?:[^\\)\\s\\\\]|\\\\.|\\s(?=[^"]))*)' +        // href
	                    '(\\s*"' +  escaped('"') + '"\\s*)?' +            // "title"
	                    "(\\))"                                           // )
	        }, { // strong ** __
	            token : "string.strong",
	            regex : "([*]{2}|[_]{2}(?=\\S))(.*?\\S[*_]*)(\\1)"
	        }, { // emphasis * _
	            token : "string.emphasis",
	            regex : "([*]|[_](?=\\S))(.*?\\S[*_]*)(\\1)"
	        }, { //
	            token : ["text", "url", "text"],
	            regex : "(<)("+
	                      "(?:https?|ftp|dict):[^'\">\\s]+"+
	                      "|"+
	                      "(?:mailto:)?[-.\\w]+\\@[-a-z0-9]+(?:\\.[-a-z0-9]+)*\\.[a-z]+"+
	                    ")(>)"
	        }],
	        "allowBlock": [
	            {token : "support.function", regex : "^ {4}.+", next : "allowBlock"},
	            {token : "empty_line", regex : '^$', next: "allowBlock"},
	            {token : "empty", regex : "", next : "start"}
	        ],

	        "header" : [{
	            regex: "$",
	            next : "start"
	        }, {
	            include: "basic"
	        }, {
	            defaultToken : "heading"
	        } ],

	        "listblock-start" : [{
	            token : "support.variable",
	            regex : /(?:\[[ x]\])?/,
	            next  : "listblock"
	        }],

	        "listblock" : [ { // Lists only escape on completely blank lines.
	            token : "empty_line",
	            regex : "^$",
	            next  : "start"
	        }, { // list
	            token : "markup.list",
	            regex : "^\\s{0,3}(?:[*+-]|\\d+\\.)\\s+",
	            next  : "listblock-start"
	        }, {
	            include : "basic", noEscape: true
	        }, { // Github style block
	            token : "support.function",
	            regex : "^\\s*```\\s*[a-zA-Z]*(?:{.*?\\})?\\s*$",
	            next  : "githubblock"
	        }, {
	            defaultToken : "list" //do not use markup.list to allow stling leading `*` differntly
	        } ],

	        "blockquote" : [ { // Blockquotes only escape on blank lines.
	            token : "empty_line",
	            regex : "^\\s*$",
	            next  : "start"
	        }, { // block quote
	            token : "string.blockquote",
	            regex : "^\\s*>\\s*(?:[*+-]|\\d+\\.)?\\s+",
	            next  : "blockquote"
	        }, {
	            include : "basic", noEscape: true
	        }, {
	            defaultToken : "string.blockquote"
	        } ],

	        "githubblock" : [ {
	            token : "support.function",
	            regex : "^\\s*```",
	            next  : "start"
	        }, {
	            token : "support.function",
	            regex : ".+"
	        } ]
	    });

	    this.embedRules(JavaScriptHighlightRules, "jscode-", [{
	       token : "support.function",
	       regex : "^\\s*```",
	       next  : "pop"
	    }]);

	    this.embedRules(HtmlHighlightRules, "htmlcode-", [{
	       token : "support.function",
	       regex : "^\\s*```",
	       next  : "pop"
	    }]);

	    this.embedRules(CssHighlightRules, "csscode-", [{
	       token : "support.function",
	       regex : "^\\s*```",
	       next  : "pop"
	    }]);

	    this.embedRules(XmlHighlightRules, "xmlcode-", [{
	       token : "support.function",
	       regex : "^\\s*```",
	       next  : "pop"
	    }]);

	    this.normalizeRules();
	};
	oop.inherits(MarkdownHighlightRules, TextHighlightRules);

	exports.MarkdownHighlightRules = MarkdownHighlightRules;
	});

	ace.define("ace/mode/folding/markdown",["require","exports","module","ace/lib/oop","ace/mode/folding/fold_mode","ace/range"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../../lib/oop");
	var BaseFoldMode = acequire("./fold_mode").FoldMode;
	var Range = acequire("../../range").Range;

	var FoldMode = exports.FoldMode = function() {};
	oop.inherits(FoldMode, BaseFoldMode);

	(function() {
	    this.foldingStartMarker = /^(?:[=-]+\s*$|#{1,6} |`{3})/;

	    this.getFoldWidget = function(session, foldStyle, row) {
	        var line = session.getLine(row);
	        if (!this.foldingStartMarker.test(line))
	            return "";

	        if (line[0] == "`") {
	            if (session.bgTokenizer.getState(row) == "start")
	                return "end";
	            return "start";
	        }

	        return "start";
	    };

	    this.getFoldWidgetRange = function(session, foldStyle, row) {
	        var line = session.getLine(row);
	        var startColumn = line.length;
	        var maxRow = session.getLength();
	        var startRow = row;
	        var endRow = row;
	        if (!line.match(this.foldingStartMarker))
	            return;

	        if (line[0] == "`") {
	            if (session.bgTokenizer.getState(row) !== "start") {
	                while (++row < maxRow) {
	                    line = session.getLine(row);
	                    if (line[0] == "`" & line.substring(0, 3) == "```")
	                        break;
	                }
	                return new Range(startRow, startColumn, row, 0);
	            } else {
	                while (row -- > 0) {
	                    line = session.getLine(row);
	                    if (line[0] == "`" & line.substring(0, 3) == "```")
	                        break;
	                }
	                return new Range(row, line.length, startRow, 0);
	            }
	        }

	        var token;
	        function isHeading(row) {
	            token = session.getTokens(row)[0];
	            return token && token.type.lastIndexOf(heading, 0) === 0;
	        }

	        var heading = "markup.heading";
	        function getLevel() {
	            var ch = token.value[0];
	            if (ch == "=") return 6;
	            if (ch == "-") return 5;
	            return 7 - token.value.search(/[^#]/);
	        }

	        if (isHeading(row)) {
	            var startHeadingLevel = getLevel();
	            while (++row < maxRow) {
	                if (!isHeading(row))
	                    continue;
	                var level = getLevel();
	                if (level >= startHeadingLevel)
	                    break;
	            }

	            endRow = row - (!token || ["=", "-"].indexOf(token.value[0]) == -1 ? 1 : 2);

	            if (endRow > startRow) {
	                while (endRow > startRow && /^\s*$/.test(session.getLine(endRow)))
	                    endRow--;
	            }

	            if (endRow > startRow) {
	                var endColumn = session.getLine(endRow).length;
	                return new Range(startRow, startColumn, endRow, endColumn);
	            }
	        }
	    };

	}).call(FoldMode.prototype);

	});

	ace.define("ace/mode/markdown",["require","exports","module","ace/lib/oop","ace/mode/text","ace/mode/javascript","ace/mode/xml","ace/mode/html","ace/mode/markdown_highlight_rules","ace/mode/folding/markdown"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../lib/oop");
	var TextMode = acequire("./text").Mode;
	var JavaScriptMode = acequire("./javascript").Mode;
	var XmlMode = acequire("./xml").Mode;
	var HtmlMode = acequire("./html").Mode;
	var MarkdownHighlightRules = acequire("./markdown_highlight_rules").MarkdownHighlightRules;
	var MarkdownFoldMode = acequire("./folding/markdown").FoldMode;

	var Mode = function() {
	    this.HighlightRules = MarkdownHighlightRules;

	    this.createModeDelegates({
	        "js-": JavaScriptMode,
	        "xml-": XmlMode,
	        "html-": HtmlMode
	    });

	    this.foldingRules = new MarkdownFoldMode();
	};
	oop.inherits(Mode, TextMode);

	(function() {
	    this.type = "text";
	    this.blockComment = {start: "<!--", end: "-->"};

	    this.getNextLineIndent = function(state, line, tab) {
	        if (state == "listblock") {
	            var match = /^(\s*)(?:([-+*])|(\d+)\.)(\s+)/.exec(line);
	            if (!match)
	                return "";
	            var marker = match[2];
	            if (!marker)
	                marker = parseInt(match[3], 10) + 1 + ".";
	            return match[1] + marker + match[4];
	        } else {
	            return this.$getIndent(line);
	        }
	    };
	    this.$id = "ace/mode/markdown";
	}).call(Mode.prototype);

	exports.Mode = Mode;
	});


/***/ },
/* 99 */
/***/ function(module, exports) {

	module.exports.id = 'ace/mode/javascript_worker';
	module.exports.src = "\"no use strict\";(function(window){function resolveModuleId(id,paths){for(var testPath=id,tail=\"\";testPath;){var alias=paths[testPath];if(\"string\"==typeof alias)return alias+tail;if(alias)return alias.location.replace(/\\/*$/,\"/\")+(tail||alias.main||alias.name);if(alias===!1)return\"\";var i=testPath.lastIndexOf(\"/\");if(-1===i)break;tail=testPath.substr(i)+tail,testPath=testPath.slice(0,i)}return id}if(!(void 0!==window.window&&window.document||window.acequire&&window.define)){window.console||(window.console=function(){var msgs=Array.prototype.slice.call(arguments,0);postMessage({type:\"log\",data:msgs})},window.console.error=window.console.warn=window.console.log=window.console.trace=window.console),window.window=window,window.ace=window,window.onerror=function(message,file,line,col,err){postMessage({type:\"error\",data:{message:message,data:err.data,file:file,line:line,col:col,stack:err.stack}})},window.normalizeModule=function(parentId,moduleName){if(-1!==moduleName.indexOf(\"!\")){var chunks=moduleName.split(\"!\");return window.normalizeModule(parentId,chunks[0])+\"!\"+window.normalizeModule(parentId,chunks[1])}if(\".\"==moduleName.charAt(0)){var base=parentId.split(\"/\").slice(0,-1).join(\"/\");for(moduleName=(base?base+\"/\":\"\")+moduleName;-1!==moduleName.indexOf(\".\")&&previous!=moduleName;){var previous=moduleName;moduleName=moduleName.replace(/^\\.\\//,\"\").replace(/\\/\\.\\//,\"/\").replace(/[^\\/]+\\/\\.\\.\\//,\"\")}}return moduleName},window.acequire=function acequire(parentId,id){if(id||(id=parentId,parentId=null),!id.charAt)throw Error(\"worker.js acequire() accepts only (parentId, id) as arguments\");id=window.normalizeModule(parentId,id);var module=window.acequire.modules[id];if(module)return module.initialized||(module.initialized=!0,module.exports=module.factory().exports),module.exports;if(!window.acequire.tlns)return console.log(\"unable to load \"+id);var path=resolveModuleId(id,window.acequire.tlns);return\".js\"!=path.slice(-3)&&(path+=\".js\"),window.acequire.id=id,window.acequire.modules[id]={},importScripts(path),window.acequire(parentId,id)},window.acequire.modules={},window.acequire.tlns={},window.define=function(id,deps,factory){if(2==arguments.length?(factory=deps,\"string\"!=typeof id&&(deps=id,id=window.acequire.id)):1==arguments.length&&(factory=id,deps=[],id=window.acequire.id),\"function\"!=typeof factory)return window.acequire.modules[id]={exports:factory,initialized:!0},void 0;deps.length||(deps=[\"require\",\"exports\",\"module\"]);var req=function(childId){return window.acequire(id,childId)};window.acequire.modules[id]={exports:{},factory:function(){var module=this,returnExports=factory.apply(this,deps.map(function(dep){switch(dep){case\"require\":return req;case\"exports\":return module.exports;case\"module\":return module;default:return req(dep)}}));return returnExports&&(module.exports=returnExports),module}}},window.define.amd={},acequire.tlns={},window.initBaseUrls=function(topLevelNamespaces){for(var i in topLevelNamespaces)acequire.tlns[i]=topLevelNamespaces[i]},window.initSender=function(){var EventEmitter=window.acequire(\"ace/lib/event_emitter\").EventEmitter,oop=window.acequire(\"ace/lib/oop\"),Sender=function(){};return function(){oop.implement(this,EventEmitter),this.callback=function(data,callbackId){postMessage({type:\"call\",id:callbackId,data:data})},this.emit=function(name,data){postMessage({type:\"event\",name:name,data:data})}}.call(Sender.prototype),new Sender};var main=window.main=null,sender=window.sender=null;window.onmessage=function(e){var msg=e.data;if(msg.event&&sender)sender._signal(msg.event,msg.data);else if(msg.command)if(main[msg.command])main[msg.command].apply(main,msg.args);else{if(!window[msg.command])throw Error(\"Unknown command:\"+msg.command);window[msg.command].apply(window,msg.args)}else if(msg.init){window.initBaseUrls(msg.tlns),acequire(\"ace/lib/es5-shim\"),sender=window.sender=window.initSender();var clazz=acequire(msg.module)[msg.classname];main=window.main=new clazz(sender)}}}})(this),ace.define(\"ace/lib/oop\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";exports.inherits=function(ctor,superCtor){ctor.super_=superCtor,ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:!1,writable:!0,configurable:!0}})},exports.mixin=function(obj,mixin){for(var key in mixin)obj[key]=mixin[key];return obj},exports.implement=function(proto,mixin){exports.mixin(proto,mixin)}}),ace.define(\"ace/range\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";var comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},Range=function(startRow,startColumn,endRow,endColumn){this.start={row:startRow,column:startColumn},this.end={row:endRow,column:endColumn}};(function(){this.isEqual=function(range){return this.start.row===range.start.row&&this.end.row===range.end.row&&this.start.column===range.start.column&&this.end.column===range.end.column},this.toString=function(){return\"Range: [\"+this.start.row+\"/\"+this.start.column+\"] -> [\"+this.end.row+\"/\"+this.end.column+\"]\"},this.contains=function(row,column){return 0==this.compare(row,column)},this.compareRange=function(range){var cmp,end=range.end,start=range.start;return cmp=this.compare(end.row,end.column),1==cmp?(cmp=this.compare(start.row,start.column),1==cmp?2:0==cmp?1:0):-1==cmp?-2:(cmp=this.compare(start.row,start.column),-1==cmp?-1:1==cmp?42:0)},this.comparePoint=function(p){return this.compare(p.row,p.column)},this.containsRange=function(range){return 0==this.comparePoint(range.start)&&0==this.comparePoint(range.end)},this.intersects=function(range){var cmp=this.compareRange(range);return-1==cmp||0==cmp||1==cmp},this.isEnd=function(row,column){return this.end.row==row&&this.end.column==column},this.isStart=function(row,column){return this.start.row==row&&this.start.column==column},this.setStart=function(row,column){\"object\"==typeof row?(this.start.column=row.column,this.start.row=row.row):(this.start.row=row,this.start.column=column)},this.setEnd=function(row,column){\"object\"==typeof row?(this.end.column=row.column,this.end.row=row.row):(this.end.row=row,this.end.column=column)},this.inside=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)||this.isStart(row,column)?!1:!0:!1},this.insideStart=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)?!1:!0:!1},this.insideEnd=function(row,column){return 0==this.compare(row,column)?this.isStart(row,column)?!1:!0:!1},this.compare=function(row,column){return this.isMultiLine()||row!==this.start.row?this.start.row>row?-1:row>this.end.row?1:this.start.row===row?column>=this.start.column?0:-1:this.end.row===row?this.end.column>=column?0:1:0:this.start.column>column?-1:column>this.end.column?1:0},this.compareStart=function(row,column){return this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.compareEnd=function(row,column){return this.end.row==row&&this.end.column==column?1:this.compare(row,column)},this.compareInside=function(row,column){return this.end.row==row&&this.end.column==column?1:this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.clipRows=function(firstRow,lastRow){if(this.end.row>lastRow)var end={row:lastRow+1,column:0};else if(firstRow>this.end.row)var end={row:firstRow,column:0};if(this.start.row>lastRow)var start={row:lastRow+1,column:0};else if(firstRow>this.start.row)var start={row:firstRow,column:0};return Range.fromPoints(start||this.start,end||this.end)},this.extend=function(row,column){var cmp=this.compare(row,column);if(0==cmp)return this;if(-1==cmp)var start={row:row,column:column};else var end={row:row,column:column};return Range.fromPoints(start||this.start,end||this.end)},this.isEmpty=function(){return this.start.row===this.end.row&&this.start.column===this.end.column},this.isMultiLine=function(){return this.start.row!==this.end.row},this.clone=function(){return Range.fromPoints(this.start,this.end)},this.collapseRows=function(){return 0==this.end.column?new Range(this.start.row,0,Math.max(this.start.row,this.end.row-1),0):new Range(this.start.row,0,this.end.row,0)},this.toScreenRange=function(session){var screenPosStart=session.documentToScreenPosition(this.start),screenPosEnd=session.documentToScreenPosition(this.end);return new Range(screenPosStart.row,screenPosStart.column,screenPosEnd.row,screenPosEnd.column)},this.moveBy=function(row,column){this.start.row+=row,this.start.column+=column,this.end.row+=row,this.end.column+=column}}).call(Range.prototype),Range.fromPoints=function(start,end){return new Range(start.row,start.column,end.row,end.column)},Range.comparePoints=comparePoints,Range.comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},exports.Range=Range}),ace.define(\"ace/apply_delta\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";exports.applyDelta=function(docLines,delta){var row=delta.start.row,startColumn=delta.start.column,line=docLines[row]||\"\";switch(delta.action){case\"insert\":var lines=delta.lines;if(1===lines.length)docLines[row]=line.substring(0,startColumn)+delta.lines[0]+line.substring(startColumn);else{var args=[row,1].concat(delta.lines);docLines.splice.apply(docLines,args),docLines[row]=line.substring(0,startColumn)+docLines[row],docLines[row+delta.lines.length-1]+=line.substring(startColumn)}break;case\"remove\":var endColumn=delta.end.column,endRow=delta.end.row;row===endRow?docLines[row]=line.substring(0,startColumn)+line.substring(endColumn):docLines.splice(row,endRow-row+1,line.substring(0,startColumn)+docLines[endRow].substring(endColumn))}}}),ace.define(\"ace/lib/event_emitter\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";var EventEmitter={},stopPropagation=function(){this.propagationStopped=!0},preventDefault=function(){this.defaultPrevented=!0};EventEmitter._emit=EventEmitter._dispatchEvent=function(eventName,e){this._eventRegistry||(this._eventRegistry={}),this._defaultHandlers||(this._defaultHandlers={});var listeners=this._eventRegistry[eventName]||[],defaultHandler=this._defaultHandlers[eventName];if(listeners.length||defaultHandler){\"object\"==typeof e&&e||(e={}),e.type||(e.type=eventName),e.stopPropagation||(e.stopPropagation=stopPropagation),e.preventDefault||(e.preventDefault=preventDefault),listeners=listeners.slice();for(var i=0;listeners.length>i&&(listeners[i](e,this),!e.propagationStopped);i++);return defaultHandler&&!e.defaultPrevented?defaultHandler(e,this):void 0}},EventEmitter._signal=function(eventName,e){var listeners=(this._eventRegistry||{})[eventName];if(listeners){listeners=listeners.slice();for(var i=0;listeners.length>i;i++)listeners[i](e,this)}},EventEmitter.once=function(eventName,callback){var _self=this;callback&&this.addEventListener(eventName,function newCallback(){_self.removeEventListener(eventName,newCallback),callback.apply(null,arguments)})},EventEmitter.setDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers||(handlers=this._defaultHandlers={_disabled_:{}}),handlers[eventName]){var old=handlers[eventName],disabled=handlers._disabled_[eventName];disabled||(handlers._disabled_[eventName]=disabled=[]),disabled.push(old);var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}handlers[eventName]=callback},EventEmitter.removeDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers){var disabled=handlers._disabled_[eventName];if(handlers[eventName]==callback)handlers[eventName],disabled&&this.setDefaultHandler(eventName,disabled.pop());else if(disabled){var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}}},EventEmitter.on=EventEmitter.addEventListener=function(eventName,callback,capturing){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];return listeners||(listeners=this._eventRegistry[eventName]=[]),-1==listeners.indexOf(callback)&&listeners[capturing?\"unshift\":\"push\"](callback),callback},EventEmitter.off=EventEmitter.removeListener=EventEmitter.removeEventListener=function(eventName,callback){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];if(listeners){var index=listeners.indexOf(callback);-1!==index&&listeners.splice(index,1)}},EventEmitter.removeAllListeners=function(eventName){this._eventRegistry&&(this._eventRegistry[eventName]=[])},exports.EventEmitter=EventEmitter}),ace.define(\"ace/anchor\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\"],function(acequire,exports){\"use strict\";var oop=acequire(\"./lib/oop\"),EventEmitter=acequire(\"./lib/event_emitter\").EventEmitter,Anchor=exports.Anchor=function(doc,row,column){this.$onChange=this.onChange.bind(this),this.attach(doc),column===void 0?this.setPosition(row.row,row.column):this.setPosition(row,column)};(function(){function $pointsInOrder(point1,point2,equalPointsInOrder){var bColIsAfter=equalPointsInOrder?point1.column<=point2.column:point1.column<point2.column;return point1.row<point2.row||point1.row==point2.row&&bColIsAfter}function $getTransformedPoint(delta,point,moveIfEqual){var deltaIsInsert=\"insert\"==delta.action,deltaRowShift=(deltaIsInsert?1:-1)*(delta.end.row-delta.start.row),deltaColShift=(deltaIsInsert?1:-1)*(delta.end.column-delta.start.column),deltaStart=delta.start,deltaEnd=deltaIsInsert?deltaStart:delta.end;return $pointsInOrder(point,deltaStart,moveIfEqual)?{row:point.row,column:point.column}:$pointsInOrder(deltaEnd,point,!moveIfEqual)?{row:point.row+deltaRowShift,column:point.column+(point.row==deltaEnd.row?deltaColShift:0)}:{row:deltaStart.row,column:deltaStart.column}}oop.implement(this,EventEmitter),this.getPosition=function(){return this.$clipPositionToDocument(this.row,this.column)},this.getDocument=function(){return this.document},this.$insertRight=!1,this.onChange=function(delta){if(!(delta.start.row==delta.end.row&&delta.start.row!=this.row||delta.start.row>this.row)){var point=$getTransformedPoint(delta,{row:this.row,column:this.column},this.$insertRight);this.setPosition(point.row,point.column,!0)}},this.setPosition=function(row,column,noClip){var pos;if(pos=noClip?{row:row,column:column}:this.$clipPositionToDocument(row,column),this.row!=pos.row||this.column!=pos.column){var old={row:this.row,column:this.column};this.row=pos.row,this.column=pos.column,this._signal(\"change\",{old:old,value:pos})}},this.detach=function(){this.document.removeEventListener(\"change\",this.$onChange)},this.attach=function(doc){this.document=doc||this.document,this.document.on(\"change\",this.$onChange)},this.$clipPositionToDocument=function(row,column){var pos={};return row>=this.document.getLength()?(pos.row=Math.max(0,this.document.getLength()-1),pos.column=this.document.getLine(pos.row).length):0>row?(pos.row=0,pos.column=0):(pos.row=row,pos.column=Math.min(this.document.getLine(pos.row).length,Math.max(0,column))),0>column&&(pos.column=0),pos}}).call(Anchor.prototype)}),ace.define(\"ace/document\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/apply_delta\",\"ace/lib/event_emitter\",\"ace/range\",\"ace/anchor\"],function(acequire,exports){\"use strict\";var oop=acequire(\"./lib/oop\"),applyDelta=acequire(\"./apply_delta\").applyDelta,EventEmitter=acequire(\"./lib/event_emitter\").EventEmitter,Range=acequire(\"./range\").Range,Anchor=acequire(\"./anchor\").Anchor,Document=function(textOrLines){this.$lines=[\"\"],0===textOrLines.length?this.$lines=[\"\"]:Array.isArray(textOrLines)?this.insertMergedLines({row:0,column:0},textOrLines):this.insert({row:0,column:0},textOrLines)};(function(){oop.implement(this,EventEmitter),this.setValue=function(text){var len=this.getLength()-1;this.remove(new Range(0,0,len,this.getLine(len).length)),this.insert({row:0,column:0},text)},this.getValue=function(){return this.getAllLines().join(this.getNewLineCharacter())},this.createAnchor=function(row,column){return new Anchor(this,row,column)},this.$split=0===\"aaa\".split(/a/).length?function(text){return text.replace(/\\r\\n|\\r/g,\"\\n\").split(\"\\n\")}:function(text){return text.split(/\\r\\n|\\r|\\n/)},this.$detectNewLine=function(text){var match=text.match(/^.*?(\\r\\n|\\r|\\n)/m);this.$autoNewLine=match?match[1]:\"\\n\",this._signal(\"changeNewLineMode\")},this.getNewLineCharacter=function(){switch(this.$newLineMode){case\"windows\":return\"\\r\\n\";case\"unix\":return\"\\n\";default:return this.$autoNewLine||\"\\n\"}},this.$autoNewLine=\"\",this.$newLineMode=\"auto\",this.setNewLineMode=function(newLineMode){this.$newLineMode!==newLineMode&&(this.$newLineMode=newLineMode,this._signal(\"changeNewLineMode\"))},this.getNewLineMode=function(){return this.$newLineMode},this.isNewLine=function(text){return\"\\r\\n\"==text||\"\\r\"==text||\"\\n\"==text},this.getLine=function(row){return this.$lines[row]||\"\"},this.getLines=function(firstRow,lastRow){return this.$lines.slice(firstRow,lastRow+1)},this.getAllLines=function(){return this.getLines(0,this.getLength())},this.getLength=function(){return this.$lines.length},this.getTextRange=function(range){return this.getLinesForRange(range).join(this.getNewLineCharacter())},this.getLinesForRange=function(range){var lines;if(range.start.row===range.end.row)lines=[this.getLine(range.start.row).substring(range.start.column,range.end.column)];else{lines=this.getLines(range.start.row,range.end.row),lines[0]=(lines[0]||\"\").substring(range.start.column);var l=lines.length-1;range.end.row-range.start.row==l&&(lines[l]=lines[l].substring(0,range.end.column))}return lines},this.insertLines=function(row,lines){return console.warn(\"Use of document.insertLines is deprecated. Use the insertFullLines method instead.\"),this.insertFullLines(row,lines)},this.removeLines=function(firstRow,lastRow){return console.warn(\"Use of document.removeLines is deprecated. Use the removeFullLines method instead.\"),this.removeFullLines(firstRow,lastRow)},this.insertNewLine=function(position){return console.warn(\"Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.\"),this.insertMergedLines(position,[\"\",\"\"])},this.insert=function(position,text){return 1>=this.getLength()&&this.$detectNewLine(text),this.insertMergedLines(position,this.$split(text))},this.insertInLine=function(position,text){var start=this.clippedPos(position.row,position.column),end=this.pos(position.row,position.column+text.length);return this.applyDelta({start:start,end:end,action:\"insert\",lines:[text]},!0),this.clonePos(end)},this.clippedPos=function(row,column){var length=this.getLength();void 0===row?row=length:0>row?row=0:row>=length&&(row=length-1,column=void 0);var line=this.getLine(row);return void 0==column&&(column=line.length),column=Math.min(Math.max(column,0),line.length),{row:row,column:column}},this.clonePos=function(pos){return{row:pos.row,column:pos.column}},this.pos=function(row,column){return{row:row,column:column}},this.$clipPosition=function(position){var length=this.getLength();return position.row>=length?(position.row=Math.max(0,length-1),position.column=this.getLine(length-1).length):(position.row=Math.max(0,position.row),position.column=Math.min(Math.max(position.column,0),this.getLine(position.row).length)),position},this.insertFullLines=function(row,lines){row=Math.min(Math.max(row,0),this.getLength());var column=0;this.getLength()>row?(lines=lines.concat([\"\"]),column=0):(lines=[\"\"].concat(lines),row--,column=this.$lines[row].length),this.insertMergedLines({row:row,column:column},lines)},this.insertMergedLines=function(position,lines){var start=this.clippedPos(position.row,position.column),end={row:start.row+lines.length-1,column:(1==lines.length?start.column:0)+lines[lines.length-1].length};return this.applyDelta({start:start,end:end,action:\"insert\",lines:lines}),this.clonePos(end)},this.remove=function(range){var start=this.clippedPos(range.start.row,range.start.column),end=this.clippedPos(range.end.row,range.end.column);return this.applyDelta({start:start,end:end,action:\"remove\",lines:this.getLinesForRange({start:start,end:end})}),this.clonePos(start)},this.removeInLine=function(row,startColumn,endColumn){var start=this.clippedPos(row,startColumn),end=this.clippedPos(row,endColumn);return this.applyDelta({start:start,end:end,action:\"remove\",lines:this.getLinesForRange({start:start,end:end})},!0),this.clonePos(start)},this.removeFullLines=function(firstRow,lastRow){firstRow=Math.min(Math.max(0,firstRow),this.getLength()-1),lastRow=Math.min(Math.max(0,lastRow),this.getLength()-1);var deleteFirstNewLine=lastRow==this.getLength()-1&&firstRow>0,deleteLastNewLine=this.getLength()-1>lastRow,startRow=deleteFirstNewLine?firstRow-1:firstRow,startCol=deleteFirstNewLine?this.getLine(startRow).length:0,endRow=deleteLastNewLine?lastRow+1:lastRow,endCol=deleteLastNewLine?0:this.getLine(endRow).length,range=new Range(startRow,startCol,endRow,endCol),deletedLines=this.$lines.slice(firstRow,lastRow+1);return this.applyDelta({start:range.start,end:range.end,action:\"remove\",lines:this.getLinesForRange(range)}),deletedLines},this.removeNewLine=function(row){this.getLength()-1>row&&row>=0&&this.applyDelta({start:this.pos(row,this.getLine(row).length),end:this.pos(row+1,0),action:\"remove\",lines:[\"\",\"\"]})},this.replace=function(range,text){if(range instanceof Range||(range=Range.fromPoints(range.start,range.end)),0===text.length&&range.isEmpty())return range.start;if(text==this.getTextRange(range))return range.end;this.remove(range);var end;return end=text?this.insert(range.start,text):range.start},this.applyDeltas=function(deltas){for(var i=0;deltas.length>i;i++)this.applyDelta(deltas[i])},this.revertDeltas=function(deltas){for(var i=deltas.length-1;i>=0;i--)this.revertDelta(deltas[i])},this.applyDelta=function(delta,doNotValidate){var isInsert=\"insert\"==delta.action;(isInsert?1>=delta.lines.length&&!delta.lines[0]:!Range.comparePoints(delta.start,delta.end))||(isInsert&&delta.lines.length>2e4&&this.$splitAndapplyLargeDelta(delta,2e4),applyDelta(this.$lines,delta,doNotValidate),this._signal(\"change\",delta))},this.$splitAndapplyLargeDelta=function(delta,MAX){for(var lines=delta.lines,l=lines.length,row=delta.start.row,column=delta.start.column,from=0,to=0;;){from=to,to+=MAX-1;var chunk=lines.slice(from,to);if(to>l){delta.lines=chunk,delta.start.row=row+from,delta.start.column=column;break}chunk.push(\"\"),this.applyDelta({start:this.pos(row+from,column),end:this.pos(row+to,column=0),action:delta.action,lines:chunk},!0)}},this.revertDelta=function(delta){this.applyDelta({start:this.clonePos(delta.start),end:this.clonePos(delta.end),action:\"insert\"==delta.action?\"remove\":\"insert\",lines:delta.lines.slice()})},this.indexToPosition=function(index,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,i=startRow||0,l=lines.length;l>i;i++)if(index-=lines[i].length+newlineLength,0>index)return{row:i,column:index+lines[i].length+newlineLength};return{row:l-1,column:lines[l-1].length}},this.positionToIndex=function(pos,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,index=0,row=Math.min(pos.row,lines.length),i=startRow||0;row>i;++i)index+=lines[i].length+newlineLength;return index+pos.column}}).call(Document.prototype),exports.Document=Document}),ace.define(\"ace/lib/lang\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";exports.last=function(a){return a[a.length-1]},exports.stringReverse=function(string){return string.split(\"\").reverse().join(\"\")},exports.stringRepeat=function(string,count){for(var result=\"\";count>0;)1&count&&(result+=string),(count>>=1)&&(string+=string);return result};var trimBeginRegexp=/^\\s\\s*/,trimEndRegexp=/\\s\\s*$/;exports.stringTrimLeft=function(string){return string.replace(trimBeginRegexp,\"\")},exports.stringTrimRight=function(string){return string.replace(trimEndRegexp,\"\")},exports.copyObject=function(obj){var copy={};for(var key in obj)copy[key]=obj[key];return copy},exports.copyArray=function(array){for(var copy=[],i=0,l=array.length;l>i;i++)copy[i]=array[i]&&\"object\"==typeof array[i]?this.copyObject(array[i]):array[i];return copy},exports.deepCopy=function deepCopy(obj){if(\"object\"!=typeof obj||!obj)return obj;var copy;if(Array.isArray(obj)){copy=[];for(var key=0;obj.length>key;key++)copy[key]=deepCopy(obj[key]);return copy}var cons=obj.constructor;if(cons===RegExp)return obj;copy=cons();for(var key in obj)copy[key]=deepCopy(obj[key]);return copy},exports.arrayToMap=function(arr){for(var map={},i=0;arr.length>i;i++)map[arr[i]]=1;return map},exports.createMap=function(props){var map=Object.create(null);for(var i in props)map[i]=props[i];return map},exports.arrayRemove=function(array,value){for(var i=0;array.length>=i;i++)value===array[i]&&array.splice(i,1)},exports.escapeRegExp=function(str){return str.replace(/([.*+?^${}()|[\\]\\/\\\\])/g,\"\\\\$1\")},exports.escapeHTML=function(str){return str.replace(/&/g,\"&#38;\").replace(/\"/g,\"&#34;\").replace(/'/g,\"&#39;\").replace(/</g,\"&#60;\")},exports.getMatchOffsets=function(string,regExp){var matches=[];return string.replace(regExp,function(str){matches.push({offset:arguments[arguments.length-2],length:str.length})}),matches},exports.deferredCall=function(fcn){var timer=null,callback=function(){timer=null,fcn()},deferred=function(timeout){return deferred.cancel(),timer=setTimeout(callback,timeout||0),deferred};return deferred.schedule=deferred,deferred.call=function(){return this.cancel(),fcn(),deferred},deferred.cancel=function(){return clearTimeout(timer),timer=null,deferred},deferred.isPending=function(){return timer},deferred},exports.delayedCall=function(fcn,defaultTimeout){var timer=null,callback=function(){timer=null,fcn()},_self=function(timeout){null==timer&&(timer=setTimeout(callback,timeout||defaultTimeout))};return _self.delay=function(timeout){timer&&clearTimeout(timer),timer=setTimeout(callback,timeout||defaultTimeout)},_self.schedule=_self,_self.call=function(){this.cancel(),fcn()},_self.cancel=function(){timer&&clearTimeout(timer),timer=null},_self.isPending=function(){return timer},_self}}),ace.define(\"ace/worker/mirror\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/document\",\"ace/lib/lang\"],function(acequire,exports){\"use strict\";acequire(\"../range\").Range;var Document=acequire(\"../document\").Document,lang=acequire(\"../lib/lang\"),Mirror=exports.Mirror=function(sender){this.sender=sender;var doc=this.doc=new Document(\"\"),deferredUpdate=this.deferredUpdate=lang.delayedCall(this.onUpdate.bind(this)),_self=this;sender.on(\"change\",function(e){var data=e.data;if(data[0].start)doc.applyDeltas(data);else for(var i=0;data.length>i;i+=2){if(Array.isArray(data[i+1]))var d={action:\"insert\",start:data[i],lines:data[i+1]};else var d={action:\"remove\",start:data[i],end:data[i+1]};doc.applyDelta(d,!0)}return _self.$timeout?deferredUpdate.schedule(_self.$timeout):(_self.onUpdate(),void 0)})};(function(){this.$timeout=500,this.setTimeout=function(timeout){this.$timeout=timeout},this.setValue=function(value){this.doc.setValue(value),this.deferredUpdate.schedule(this.$timeout)},this.getValue=function(callbackId){this.sender.callback(this.doc.getValue(),callbackId)},this.onUpdate=function(){},this.isPending=function(){return this.deferredUpdate.isPending()}}).call(Mirror.prototype)}),ace.define(\"ace/mode/javascript/jshint\",[\"require\",\"exports\",\"module\"],function(acequire,exports,module){module.exports=function outer(modules,cache,entry){function newRequire(name,jumped){if(!cache[name]){if(!modules[name]){var currentRequire=\"function\"==typeof acequire&&acequire;if(!jumped&&currentRequire)return currentRequire(name,!0);if(previousRequire)return previousRequire(name,!0);var err=Error(\"Cannot find module '\"+name+\"'\");throw err.code=\"MODULE_NOT_FOUND\",err}var m=cache[name]={exports:{}};modules[name][0].call(m.exports,function(x){var id=modules[name][1][x];return newRequire(id?id:x)},m,m.exports,outer,modules,cache,entry)}return cache[name].exports}for(var previousRequire=\"function\"==typeof acequire&&acequire,i=0;entry.length>i;i++)newRequire(entry[i]);return newRequire(entry[0])}({\"/node_modules/browserify/node_modules/events/events.js\":[function(_dereq_,module){function EventEmitter(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0}function isFunction(arg){return\"function\"==typeof arg}function isNumber(arg){return\"number\"==typeof arg}function isObject(arg){return\"object\"==typeof arg&&null!==arg}function isUndefined(arg){return void 0===arg}module.exports=EventEmitter,EventEmitter.EventEmitter=EventEmitter,EventEmitter.prototype._events=void 0,EventEmitter.prototype._maxListeners=void 0,EventEmitter.defaultMaxListeners=10,EventEmitter.prototype.setMaxListeners=function(n){if(!isNumber(n)||0>n||isNaN(n))throw TypeError(\"n must be a positive number\");return this._maxListeners=n,this},EventEmitter.prototype.emit=function(type){var er,handler,len,args,i,listeners;if(this._events||(this._events={}),\"error\"===type&&(!this._events.error||isObject(this._events.error)&&!this._events.error.length)){if(er=arguments[1],er instanceof Error)throw er;throw TypeError('Uncaught, unspecified \"error\" event.')}if(handler=this._events[type],isUndefined(handler))return!1;if(isFunction(handler))switch(arguments.length){case 1:handler.call(this);break;case 2:handler.call(this,arguments[1]);break;case 3:handler.call(this,arguments[1],arguments[2]);break;default:for(len=arguments.length,args=Array(len-1),i=1;len>i;i++)args[i-1]=arguments[i];handler.apply(this,args)}else if(isObject(handler)){for(len=arguments.length,args=Array(len-1),i=1;len>i;i++)args[i-1]=arguments[i];for(listeners=handler.slice(),len=listeners.length,i=0;len>i;i++)listeners[i].apply(this,args)}return!0},EventEmitter.prototype.addListener=function(type,listener){var m;if(!isFunction(listener))throw TypeError(\"listener must be a function\");if(this._events||(this._events={}),this._events.newListener&&this.emit(\"newListener\",type,isFunction(listener.listener)?listener.listener:listener),this._events[type]?isObject(this._events[type])?this._events[type].push(listener):this._events[type]=[this._events[type],listener]:this._events[type]=listener,isObject(this._events[type])&&!this._events[type].warned){var m;m=isUndefined(this._maxListeners)?EventEmitter.defaultMaxListeners:this._maxListeners,m&&m>0&&this._events[type].length>m&&(this._events[type].warned=!0,console.error(\"(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.\",this._events[type].length),\"function\"==typeof console.trace&&console.trace())}return this},EventEmitter.prototype.on=EventEmitter.prototype.addListener,EventEmitter.prototype.once=function(type,listener){function g(){this.removeListener(type,g),fired||(fired=!0,listener.apply(this,arguments))}if(!isFunction(listener))throw TypeError(\"listener must be a function\");var fired=!1;return g.listener=listener,this.on(type,g),this},EventEmitter.prototype.removeListener=function(type,listener){var list,position,length,i;if(!isFunction(listener))throw TypeError(\"listener must be a function\");if(!this._events||!this._events[type])return this;if(list=this._events[type],length=list.length,position=-1,list===listener||isFunction(list.listener)&&list.listener===listener)delete this._events[type],this._events.removeListener&&this.emit(\"removeListener\",type,listener);else if(isObject(list)){for(i=length;i-->0;)if(list[i]===listener||list[i].listener&&list[i].listener===listener){position=i;break}if(0>position)return this;1===list.length?(list.length=0,delete this._events[type]):list.splice(position,1),this._events.removeListener&&this.emit(\"removeListener\",type,listener)}return this},EventEmitter.prototype.removeAllListeners=function(type){var key,listeners;if(!this._events)return this;if(!this._events.removeListener)return 0===arguments.length?this._events={}:this._events[type]&&delete this._events[type],this;if(0===arguments.length){for(key in this._events)\"removeListener\"!==key&&this.removeAllListeners(key);return this.removeAllListeners(\"removeListener\"),this._events={},this\n}if(listeners=this._events[type],isFunction(listeners))this.removeListener(type,listeners);else for(;listeners.length;)this.removeListener(type,listeners[listeners.length-1]);return delete this._events[type],this},EventEmitter.prototype.listeners=function(type){var ret;return ret=this._events&&this._events[type]?isFunction(this._events[type])?[this._events[type]]:this._events[type].slice():[]},EventEmitter.listenerCount=function(emitter,type){var ret;return ret=emitter._events&&emitter._events[type]?isFunction(emitter._events[type])?1:emitter._events[type].length:0}},{}],\"/node_modules/jshint/data/ascii-identifier-data.js\":[function(_dereq_,module){for(var identifierStartTable=[],i=0;128>i;i++)identifierStartTable[i]=36===i||i>=65&&90>=i||95===i||i>=97&&122>=i;for(var identifierPartTable=[],i=0;128>i;i++)identifierPartTable[i]=identifierStartTable[i]||i>=48&&57>=i;module.exports={asciiIdentifierStartTable:identifierStartTable,asciiIdentifierPartTable:identifierPartTable}},{}],\"/node_modules/jshint/lodash.js\":[function(_dereq_,module,exports){(function(global){(function(){function baseFindIndex(array,predicate,fromRight){for(var length=array.length,index=fromRight?length:-1;fromRight?index--:length>++index;)if(predicate(array[index],index,array))return index;return-1}function baseIndexOf(array,value,fromIndex){if(value!==value)return indexOfNaN(array,fromIndex);for(var index=fromIndex-1,length=array.length;length>++index;)if(array[index]===value)return index;return-1}function baseIsFunction(value){return\"function\"==typeof value||!1}function baseToString(value){return\"string\"==typeof value?value:null==value?\"\":value+\"\"}function indexOfNaN(array,fromIndex,fromRight){for(var length=array.length,index=fromIndex+(fromRight?0:-1);fromRight?index--:length>++index;){var other=array[index];if(other!==other)return index}return-1}function isObjectLike(value){return!!value&&\"object\"==typeof value}function lodash(){}function arrayCopy(source,array){var index=-1,length=source.length;for(array||(array=Array(length));length>++index;)array[index]=source[index];return array}function arrayEach(array,iteratee){for(var index=-1,length=array.length;length>++index&&iteratee(array[index],index,array)!==!1;);return array}function arrayFilter(array,predicate){for(var index=-1,length=array.length,resIndex=-1,result=[];length>++index;){var value=array[index];predicate(value,index,array)&&(result[++resIndex]=value)}return result}function arrayMap(array,iteratee){for(var index=-1,length=array.length,result=Array(length);length>++index;)result[index]=iteratee(array[index],index,array);return result}function arrayMax(array){for(var index=-1,length=array.length,result=NEGATIVE_INFINITY;length>++index;){var value=array[index];value>result&&(result=value)}return result}function arraySome(array,predicate){for(var index=-1,length=array.length;length>++index;)if(predicate(array[index],index,array))return!0;return!1}function assignWith(object,source,customizer){var props=keys(source);push.apply(props,getSymbols(source));for(var index=-1,length=props.length;length>++index;){var key=props[index],value=object[key],result=customizer(value,source[key],key,object,source);(result===result?result===value:value!==value)&&(value!==undefined||key in object)||(object[key]=result)}return object}function baseCopy(source,props,object){object||(object={});for(var index=-1,length=props.length;length>++index;){var key=props[index];object[key]=source[key]}return object}function baseCallback(func,thisArg,argCount){var type=typeof func;return\"function\"==type?thisArg===undefined?func:bindCallback(func,thisArg,argCount):null==func?identity:\"object\"==type?baseMatches(func):thisArg===undefined?property(func):baseMatchesProperty(func,thisArg)}function baseClone(value,isDeep,customizer,key,object,stackA,stackB){var result;if(customizer&&(result=object?customizer(value,key,object):customizer(value)),result!==undefined)return result;if(!isObject(value))return value;var isArr=isArray(value);if(isArr){if(result=initCloneArray(value),!isDeep)return arrayCopy(value,result)}else{var tag=objToString.call(value),isFunc=tag==funcTag;if(tag!=objectTag&&tag!=argsTag&&(!isFunc||object))return cloneableTags[tag]?initCloneByTag(value,tag,isDeep):object?value:{};if(result=initCloneObject(isFunc?{}:value),!isDeep)return baseAssign(result,value)}stackA||(stackA=[]),stackB||(stackB=[]);for(var length=stackA.length;length--;)if(stackA[length]==value)return stackB[length];return stackA.push(value),stackB.push(result),(isArr?arrayEach:baseForOwn)(value,function(subValue,key){result[key]=baseClone(subValue,isDeep,customizer,key,value,stackA,stackB)}),result}function baseFilter(collection,predicate){var result=[];return baseEach(collection,function(value,index,collection){predicate(value,index,collection)&&result.push(value)}),result}function baseForIn(object,iteratee){return baseFor(object,iteratee,keysIn)}function baseForOwn(object,iteratee){return baseFor(object,iteratee,keys)}function baseGet(object,path,pathKey){if(null!=object){pathKey!==undefined&&pathKey in toObject(object)&&(path=[pathKey]);for(var index=-1,length=path.length;null!=object&&length>++index;)var result=object=object[path[index]];return result}}function baseIsEqual(value,other,customizer,isLoose,stackA,stackB){if(value===other)return 0!==value||1/value==1/other;var valType=typeof value,othType=typeof other;return\"function\"!=valType&&\"object\"!=valType&&\"function\"!=othType&&\"object\"!=othType||null==value||null==other?value!==value&&other!==other:baseIsEqualDeep(value,other,baseIsEqual,customizer,isLoose,stackA,stackB)}function baseIsEqualDeep(object,other,equalFunc,customizer,isLoose,stackA,stackB){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=arrayTag,othTag=arrayTag;objIsArr||(objTag=objToString.call(object),objTag==argsTag?objTag=objectTag:objTag!=objectTag&&(objIsArr=isTypedArray(object))),othIsArr||(othTag=objToString.call(other),othTag==argsTag?othTag=objectTag:othTag!=objectTag&&(othIsArr=isTypedArray(other)));var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&!objIsArr&&!objIsObj)return equalByTag(object,other,objTag);if(!isLoose){var valWrapped=objIsObj&&hasOwnProperty.call(object,\"__wrapped__\"),othWrapped=othIsObj&&hasOwnProperty.call(other,\"__wrapped__\");if(valWrapped||othWrapped)return equalFunc(valWrapped?object.value():object,othWrapped?other.value():other,customizer,isLoose,stackA,stackB)}if(!isSameTag)return!1;stackA||(stackA=[]),stackB||(stackB=[]);for(var length=stackA.length;length--;)if(stackA[length]==object)return stackB[length]==other;stackA.push(object),stackB.push(other);var result=(objIsArr?equalArrays:equalObjects)(object,other,equalFunc,customizer,isLoose,stackA,stackB);return stackA.pop(),stackB.pop(),result}function baseIsMatch(object,props,values,strictCompareFlags,customizer){for(var index=-1,length=props.length,noCustomizer=!customizer;length>++index;)if(noCustomizer&&strictCompareFlags[index]?values[index]!==object[props[index]]:!(props[index]in object))return!1;for(index=-1;length>++index;){var key=props[index],objValue=object[key],srcValue=values[index];if(noCustomizer&&strictCompareFlags[index])var result=objValue!==undefined||key in object;else result=customizer?customizer(objValue,srcValue,key):undefined,result===undefined&&(result=baseIsEqual(srcValue,objValue,customizer,!0));if(!result)return!1}return!0}function baseMatches(source){var props=keys(source),length=props.length;if(!length)return constant(!0);if(1==length){var key=props[0],value=source[key];if(isStrictComparable(value))return function(object){return null==object?!1:object[key]===value&&(value!==undefined||key in toObject(object))}}for(var values=Array(length),strictCompareFlags=Array(length);length--;)value=source[props[length]],values[length]=value,strictCompareFlags[length]=isStrictComparable(value);return function(object){return null!=object&&baseIsMatch(toObject(object),props,values,strictCompareFlags)}}function baseMatchesProperty(path,value){var isArr=isArray(path),isCommon=isKey(path)&&isStrictComparable(value),pathKey=path+\"\";return path=toPath(path),function(object){if(null==object)return!1;var key=pathKey;if(object=toObject(object),!(!isArr&&isCommon||key in object)){if(object=1==path.length?object:baseGet(object,baseSlice(path,0,-1)),null==object)return!1;key=last(path),object=toObject(object)}return object[key]===value?value!==undefined||key in object:baseIsEqual(value,object[key],null,!0)}}function baseMerge(object,source,customizer,stackA,stackB){if(!isObject(object))return object;var isSrcArr=isLength(source.length)&&(isArray(source)||isTypedArray(source));if(!isSrcArr){var props=keys(source);push.apply(props,getSymbols(source))}return arrayEach(props||source,function(srcValue,key){if(props&&(key=srcValue,srcValue=source[key]),isObjectLike(srcValue))stackA||(stackA=[]),stackB||(stackB=[]),baseMergeDeep(object,source,key,baseMerge,customizer,stackA,stackB);else{var value=object[key],result=customizer?customizer(value,srcValue,key,object,source):undefined,isCommon=result===undefined;isCommon&&(result=srcValue),!isSrcArr&&result===undefined||!isCommon&&(result===result?result===value:value!==value)||(object[key]=result)}}),object}function baseMergeDeep(object,source,key,mergeFunc,customizer,stackA,stackB){for(var length=stackA.length,srcValue=source[key];length--;)if(stackA[length]==srcValue)return object[key]=stackB[length],undefined;var value=object[key],result=customizer?customizer(value,srcValue,key,object,source):undefined,isCommon=result===undefined;isCommon&&(result=srcValue,isLength(srcValue.length)&&(isArray(srcValue)||isTypedArray(srcValue))?result=isArray(value)?value:getLength(value)?arrayCopy(value):[]:isPlainObject(srcValue)||isArguments(srcValue)?result=isArguments(value)?toPlainObject(value):isPlainObject(value)?value:{}:isCommon=!1),stackA.push(srcValue),stackB.push(result),isCommon?object[key]=mergeFunc(result,srcValue,customizer,stackA,stackB):(result===result?result!==value:value===value)&&(object[key]=result)}function baseProperty(key){return function(object){return null==object?undefined:object[key]}}function basePropertyDeep(path){var pathKey=path+\"\";return path=toPath(path),function(object){return baseGet(object,path,pathKey)}}function baseSlice(array,start,end){var index=-1,length=array.length;start=null==start?0:+start||0,0>start&&(start=-start>length?0:length+start),end=end===undefined||end>length?length:+end||0,0>end&&(end+=length),length=start>end?0:end-start>>>0,start>>>=0;for(var result=Array(length);length>++index;)result[index]=array[index+start];return result}function baseSome(collection,predicate){var result;return baseEach(collection,function(value,index,collection){return result=predicate(value,index,collection),!result}),!!result}function baseValues(object,props){for(var index=-1,length=props.length,result=Array(length);length>++index;)result[index]=object[props[index]];return result}function binaryIndex(array,value,retHighest){var low=0,high=array?array.length:low;if(\"number\"==typeof value&&value===value&&HALF_MAX_ARRAY_LENGTH>=high){for(;high>low;){var mid=low+high>>>1,computed=array[mid];(retHighest?value>=computed:value>computed)?low=mid+1:high=mid}return high}return binaryIndexBy(array,value,identity,retHighest)}function binaryIndexBy(array,value,iteratee,retHighest){value=iteratee(value);for(var low=0,high=array?array.length:0,valIsNaN=value!==value,valIsUndef=value===undefined;high>low;){var mid=floor((low+high)/2),computed=iteratee(array[mid]),isReflexive=computed===computed;if(valIsNaN)var setLow=isReflexive||retHighest;else setLow=valIsUndef?isReflexive&&(retHighest||computed!==undefined):retHighest?value>=computed:value>computed;setLow?low=mid+1:high=mid}return nativeMin(high,MAX_ARRAY_INDEX)}function bindCallback(func,thisArg,argCount){if(\"function\"!=typeof func)return identity;if(thisArg===undefined)return func;switch(argCount){case 1:return function(value){return func.call(thisArg,value)};case 3:return function(value,index,collection){return func.call(thisArg,value,index,collection)};case 4:return function(accumulator,value,index,collection){return func.call(thisArg,accumulator,value,index,collection)};case 5:return function(value,other,key,object,source){return func.call(thisArg,value,other,key,object,source)}}return function(){return func.apply(thisArg,arguments)}}function bufferClone(buffer){return bufferSlice.call(buffer,0)}function createAssigner(assigner){return restParam(function(object,sources){var index=-1,length=null==object?0:sources.length,customizer=length>2&&sources[length-2],guard=length>2&&sources[2],thisArg=length>1&&sources[length-1];for(\"function\"==typeof customizer?(customizer=bindCallback(customizer,thisArg,5),length-=2):(customizer=\"function\"==typeof thisArg?thisArg:null,length-=customizer?1:0),guard&&isIterateeCall(sources[0],sources[1],guard)&&(customizer=3>length?null:customizer,length=1);length>++index;){var source=sources[index];source&&assigner(object,source,customizer)}return object})}function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){var length=collection?getLength(collection):0;if(!isLength(length))return eachFunc(collection,iteratee);for(var index=fromRight?length:-1,iterable=toObject(collection);(fromRight?index--:length>++index)&&iteratee(iterable[index],index,iterable)!==!1;);return collection}}function createBaseFor(fromRight){return function(object,iteratee,keysFunc){for(var iterable=toObject(object),props=keysFunc(object),length=props.length,index=fromRight?length:-1;fromRight?index--:length>++index;){var key=props[index];if(iteratee(iterable[key],key,iterable)===!1)break}return object}}function createFindIndex(fromRight){return function(array,predicate,thisArg){return array&&array.length?(predicate=getCallback(predicate,thisArg,3),baseFindIndex(array,predicate,fromRight)):-1}}function createForEach(arrayFunc,eachFunc){return function(collection,iteratee,thisArg){return\"function\"==typeof iteratee&&thisArg===undefined&&isArray(collection)?arrayFunc(collection,iteratee):eachFunc(collection,bindCallback(iteratee,thisArg,3))}}function equalArrays(array,other,equalFunc,customizer,isLoose,stackA,stackB){var index=-1,arrLength=array.length,othLength=other.length,result=!0;if(arrLength!=othLength&&!(isLoose&&othLength>arrLength))return!1;for(;result&&arrLength>++index;){var arrValue=array[index],othValue=other[index];if(result=undefined,customizer&&(result=isLoose?customizer(othValue,arrValue,index):customizer(arrValue,othValue,index)),result===undefined)if(isLoose)for(var othIndex=othLength;othIndex--&&(othValue=other[othIndex],!(result=arrValue&&arrValue===othValue||equalFunc(arrValue,othValue,customizer,isLoose,stackA,stackB))););else result=arrValue&&arrValue===othValue||equalFunc(arrValue,othValue,customizer,isLoose,stackA,stackB)}return!!result}function equalByTag(object,other,tag){switch(tag){case boolTag:case dateTag:return+object==+other;case errorTag:return object.name==other.name&&object.message==other.message;case numberTag:return object!=+object?other!=+other:0==object?1/object==1/other:object==+other;case regexpTag:case stringTag:return object==other+\"\"}return!1}function equalObjects(object,other,equalFunc,customizer,isLoose,stackA,stackB){var objProps=keys(object),objLength=objProps.length,othProps=keys(other),othLength=othProps.length;if(objLength!=othLength&&!isLoose)return!1;for(var skipCtor=isLoose,index=-1;objLength>++index;){var key=objProps[index],result=isLoose?key in other:hasOwnProperty.call(other,key);if(result){var objValue=object[key],othValue=other[key];result=undefined,customizer&&(result=isLoose?customizer(othValue,objValue,key):customizer(objValue,othValue,key)),result===undefined&&(result=objValue&&objValue===othValue||equalFunc(objValue,othValue,customizer,isLoose,stackA,stackB))}if(!result)return!1;skipCtor||(skipCtor=\"constructor\"==key)}if(!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;if(objCtor!=othCtor&&\"constructor\"in object&&\"constructor\"in other&&!(\"function\"==typeof objCtor&&objCtor instanceof objCtor&&\"function\"==typeof othCtor&&othCtor instanceof othCtor))return!1}return!0}function getCallback(func,thisArg,argCount){var result=lodash.callback||callback;return result=result===callback?baseCallback:result,argCount?result(func,thisArg,argCount):result}function getIndexOf(collection,target,fromIndex){var result=lodash.indexOf||indexOf;return result=result===indexOf?baseIndexOf:result,collection?result(collection,target,fromIndex):result}function initCloneArray(array){var length=array.length,result=new array.constructor(length);return length&&\"string\"==typeof array[0]&&hasOwnProperty.call(array,\"index\")&&(result.index=array.index,result.input=array.input),result}function initCloneObject(object){var Ctor=object.constructor;return\"function\"==typeof Ctor&&Ctor instanceof Ctor||(Ctor=Object),new Ctor}function initCloneByTag(object,tag,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return bufferClone(object);case boolTag:case dateTag:return new Ctor(+object);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:var buffer=object.buffer;return new Ctor(isDeep?bufferClone(buffer):buffer,object.byteOffset,object.length);case numberTag:case stringTag:return new Ctor(object);case regexpTag:var result=new Ctor(object.source,reFlags.exec(object));result.lastIndex=object.lastIndex}return result}function isIndex(value,length){return value=+value,length=null==length?MAX_SAFE_INTEGER:length,value>-1&&0==value%1&&length>value}function isIterateeCall(value,index,object){if(!isObject(object))return!1;var type=typeof index;if(\"number\"==type)var length=getLength(object),prereq=isLength(length)&&isIndex(index,length);else prereq=\"string\"==type&&index in object;if(prereq){var other=object[index];return value===value?value===other:other!==other}return!1}function isKey(value,object){var type=typeof value;if(\"string\"==type&&reIsPlainProp.test(value)||\"number\"==type)return!0;if(isArray(value))return!1;var result=!reIsDeepProp.test(value);return result||null!=object&&value in toObject(object)}function isLength(value){return\"number\"==typeof value&&value>-1&&0==value%1&&MAX_SAFE_INTEGER>=value}function isStrictComparable(value){return value===value&&(0===value?1/value>0:!isObject(value))}function shimIsPlainObject(value){var Ctor;if(lodash.support,!isObjectLike(value)||objToString.call(value)!=objectTag||!hasOwnProperty.call(value,\"constructor\")&&(Ctor=value.constructor,\"function\"==typeof Ctor&&!(Ctor instanceof Ctor)))return!1;var result;return baseForIn(value,function(subValue,key){result=key}),result===undefined||hasOwnProperty.call(value,result)}function shimKeys(object){for(var props=keysIn(object),propsLength=props.length,length=propsLength&&object.length,support=lodash.support,allowIndexes=length&&isLength(length)&&(isArray(object)||support.nonEnumArgs&&isArguments(object)),index=-1,result=[];propsLength>++index;){var key=props[index];(allowIndexes&&isIndex(key,length)||hasOwnProperty.call(object,key))&&result.push(key)}return result}function toObject(value){return isObject(value)?value:Object(value)}function toPath(value){if(isArray(value))return value;var result=[];return baseToString(value).replace(rePropName,function(match,number,quote,string){result.push(quote?string.replace(reEscapeChar,\"$1\"):number||match)}),result}function indexOf(array,value,fromIndex){var length=array?array.length:0;if(!length)return-1;if(\"number\"==typeof fromIndex)fromIndex=0>fromIndex?nativeMax(length+fromIndex,0):fromIndex;else if(fromIndex){var index=binaryIndex(array,value),other=array[index];return(value===value?value===other:other!==other)?index:-1}return baseIndexOf(array,value,fromIndex||0)}function last(array){var length=array?array.length:0;return length?array[length-1]:undefined}function slice(array,start,end){var length=array?array.length:0;return length?(end&&\"number\"!=typeof end&&isIterateeCall(array,start,end)&&(start=0,end=length),baseSlice(array,start,end)):[]}function unzip(array){for(var index=-1,length=(array&&array.length&&arrayMax(arrayMap(array,getLength)))>>>0,result=Array(length);length>++index;)result[index]=arrayMap(array,baseProperty(index));return result}function includes(collection,target,fromIndex,guard){var length=collection?getLength(collection):0;return isLength(length)||(collection=values(collection),length=collection.length),length?(fromIndex=\"number\"!=typeof fromIndex||guard&&isIterateeCall(target,fromIndex,guard)?0:0>fromIndex?nativeMax(length+fromIndex,0):fromIndex||0,\"string\"==typeof collection||!isArray(collection)&&isString(collection)?length>fromIndex&&collection.indexOf(target,fromIndex)>-1:getIndexOf(collection,target,fromIndex)>-1):!1}function reject(collection,predicate,thisArg){var func=isArray(collection)?arrayFilter:baseFilter;return predicate=getCallback(predicate,thisArg,3),func(collection,function(value,index,collection){return!predicate(value,index,collection)})}function some(collection,predicate,thisArg){var func=isArray(collection)?arraySome:baseSome;return thisArg&&isIterateeCall(collection,predicate,thisArg)&&(predicate=null),(\"function\"!=typeof predicate||thisArg!==undefined)&&(predicate=getCallback(predicate,thisArg,3)),func(collection,predicate)}function restParam(func,start){if(\"function\"!=typeof func)throw new TypeError(FUNC_ERROR_TEXT);return start=nativeMax(start===undefined?func.length-1:+start||0,0),function(){for(var args=arguments,index=-1,length=nativeMax(args.length-start,0),rest=Array(length);length>++index;)rest[index]=args[start+index];switch(start){case 0:return func.call(this,rest);case 1:return func.call(this,args[0],rest);case 2:return func.call(this,args[0],args[1],rest)}var otherArgs=Array(start+1);for(index=-1;start>++index;)otherArgs[index]=args[index];return otherArgs[start]=rest,func.apply(this,otherArgs)}}function clone(value,isDeep,customizer,thisArg){return isDeep&&\"boolean\"!=typeof isDeep&&isIterateeCall(value,isDeep,customizer)?isDeep=!1:\"function\"==typeof isDeep&&(thisArg=customizer,customizer=isDeep,isDeep=!1),customizer=\"function\"==typeof customizer&&bindCallback(customizer,thisArg,1),baseClone(value,isDeep,customizer)}function isArguments(value){var length=isObjectLike(value)?value.length:undefined;return isLength(length)&&objToString.call(value)==argsTag}function isEmpty(value){if(null==value)return!0;var length=getLength(value);return isLength(length)&&(isArray(value)||isString(value)||isArguments(value)||isObjectLike(value)&&isFunction(value.splice))?!length:!keys(value).length}function isObject(value){var type=typeof value;return\"function\"==type||!!value&&\"object\"==type}function isNative(value){return null==value?!1:objToString.call(value)==funcTag?reIsNative.test(fnToString.call(value)):isObjectLike(value)&&reIsHostCtor.test(value)}function isNumber(value){return\"number\"==typeof value||isObjectLike(value)&&objToString.call(value)==numberTag}function isString(value){return\"string\"==typeof value||isObjectLike(value)&&objToString.call(value)==stringTag}function isTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[objToString.call(value)]}function toPlainObject(value){return baseCopy(value,keysIn(value))}function has(object,path){if(null==object)return!1;var result=hasOwnProperty.call(object,path);return result||isKey(path)||(path=toPath(path),object=1==path.length?object:baseGet(object,baseSlice(path,0,-1)),path=last(path),result=null!=object&&hasOwnProperty.call(object,path)),result}function keysIn(object){if(null==object)return[];isObject(object)||(object=Object(object));var length=object.length;length=length&&isLength(length)&&(isArray(object)||support.nonEnumArgs&&isArguments(object))&&length||0;for(var Ctor=object.constructor,index=-1,isProto=\"function\"==typeof Ctor&&Ctor.prototype===object,result=Array(length),skipIndexes=length>0;length>++index;)result[index]=index+\"\";for(var key in object)skipIndexes&&isIndex(key,length)||\"constructor\"==key&&(isProto||!hasOwnProperty.call(object,key))||result.push(key);return result}function values(object){return baseValues(object,keys(object))}function escapeRegExp(string){return string=baseToString(string),string&&reHasRegExpChars.test(string)?string.replace(reRegExpChars,\"\\\\$&\"):string}function callback(func,thisArg,guard){return guard&&isIterateeCall(func,thisArg,guard)&&(thisArg=null),baseCallback(func,thisArg)}function constant(value){return function(){return value}}function identity(value){return value}function property(path){return isKey(path)?baseProperty(path):basePropertyDeep(path)}var undefined,VERSION=\"3.7.0\",FUNC_ERROR_TEXT=\"Expected a function\",argsTag=\"[object Arguments]\",arrayTag=\"[object Array]\",boolTag=\"[object Boolean]\",dateTag=\"[object Date]\",errorTag=\"[object Error]\",funcTag=\"[object Function]\",mapTag=\"[object Map]\",numberTag=\"[object Number]\",objectTag=\"[object Object]\",regexpTag=\"[object RegExp]\",setTag=\"[object Set]\",stringTag=\"[object String]\",weakMapTag=\"[object WeakMap]\",arrayBufferTag=\"[object ArrayBuffer]\",float32Tag=\"[object Float32Array]\",float64Tag=\"[object Float64Array]\",int8Tag=\"[object Int8Array]\",int16Tag=\"[object Int16Array]\",int32Tag=\"[object Int32Array]\",uint8Tag=\"[object Uint8Array]\",uint8ClampedTag=\"[object Uint8ClampedArray]\",uint16Tag=\"[object Uint16Array]\",uint32Tag=\"[object Uint32Array]\",reIsDeepProp=/\\.|\\[(?:[^[\\]]+|([\"'])(?:(?!\\1)[^\\n\\\\]|\\\\.)*?)\\1\\]/,reIsPlainProp=/^\\w*$/,rePropName=/[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\n\\\\]|\\\\.)*?)\\2)\\]/g,reRegExpChars=/[.*+?^${}()|[\\]\\/\\\\]/g,reHasRegExpChars=RegExp(reRegExpChars.source),reEscapeChar=/\\\\(\\\\)?/g,reFlags=/\\w*$/,reIsHostCtor=/^\\[object .+?Constructor\\]$/,typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=!0,typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=!1;var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[stringTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=!0,cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[mapTag]=cloneableTags[setTag]=cloneableTags[weakMapTag]=!1;var objectTypes={\"function\":!0,object:!0},freeExports=objectTypes[typeof exports]&&exports&&!exports.nodeType&&exports,freeModule=objectTypes[typeof module]&&module&&!module.nodeType&&module,freeGlobal=freeExports&&freeModule&&\"object\"==typeof global&&global&&global.Object&&global,freeSelf=objectTypes[typeof self]&&self&&self.Object&&self,freeWindow=objectTypes[typeof window]&&window&&window.Object&&window,moduleExports=freeModule&&freeModule.exports===freeExports&&freeExports,root=freeGlobal||freeWindow!==(this&&this.window)&&freeWindow||freeSelf||this,arrayProto=Array.prototype,objectProto=Object.prototype,fnToString=Function.prototype.toString,hasOwnProperty=objectProto.hasOwnProperty,objToString=objectProto.toString,reIsNative=RegExp(\"^\"+escapeRegExp(objToString).replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g,\"$1.*?\")+\"$\"),ArrayBuffer=isNative(ArrayBuffer=root.ArrayBuffer)&&ArrayBuffer,bufferSlice=isNative(bufferSlice=ArrayBuffer&&new ArrayBuffer(0).slice)&&bufferSlice,floor=Math.floor,getOwnPropertySymbols=isNative(getOwnPropertySymbols=Object.getOwnPropertySymbols)&&getOwnPropertySymbols,getPrototypeOf=isNative(getPrototypeOf=Object.getPrototypeOf)&&getPrototypeOf,push=arrayProto.push,preventExtensions=isNative(Object.preventExtensions=Object.preventExtensions)&&preventExtensions,propertyIsEnumerable=objectProto.propertyIsEnumerable,Uint8Array=isNative(Uint8Array=root.Uint8Array)&&Uint8Array,Float64Array=function(){try{var func=isNative(func=root.Float64Array)&&func,result=new func(new ArrayBuffer(10),0,1)&&func}catch(e){}return result}(),nativeAssign=function(){var object={1:0},func=preventExtensions&&isNative(func=Object.assign)&&func;try{func(preventExtensions(object),\"xo\")}catch(e){}return!object[1]&&func}(),nativeIsArray=isNative(nativeIsArray=Array.isArray)&&nativeIsArray,nativeKeys=isNative(nativeKeys=Object.keys)&&nativeKeys,nativeMax=Math.max,nativeMin=Math.min,NEGATIVE_INFINITY=Number.NEGATIVE_INFINITY,MAX_ARRAY_LENGTH=Math.pow(2,32)-1,MAX_ARRAY_INDEX=MAX_ARRAY_LENGTH-1,HALF_MAX_ARRAY_LENGTH=MAX_ARRAY_LENGTH>>>1,FLOAT64_BYTES_PER_ELEMENT=Float64Array?Float64Array.BYTES_PER_ELEMENT:0,MAX_SAFE_INTEGER=Math.pow(2,53)-1,support=lodash.support={};(function(x){var Ctor=function(){this.x=x},props=[];Ctor.prototype={valueOf:x,y:x};for(var key in new Ctor)props.push(key);support.funcDecomp=/\\bthis\\b/.test(function(){return this}),support.funcNames=\"string\"==typeof Function.name;try{support.nonEnumArgs=!propertyIsEnumerable.call(arguments,1)}catch(e){support.nonEnumArgs=!0}})(1,0);var baseAssign=nativeAssign||function(object,source){return null==source?object:baseCopy(source,getSymbols(source),baseCopy(source,keys(source),object))},baseEach=createBaseEach(baseForOwn),baseFor=createBaseFor();bufferSlice||(bufferClone=ArrayBuffer&&Uint8Array?function(buffer){var byteLength=buffer.byteLength,floatLength=Float64Array?floor(byteLength/FLOAT64_BYTES_PER_ELEMENT):0,offset=floatLength*FLOAT64_BYTES_PER_ELEMENT,result=new ArrayBuffer(byteLength);if(floatLength){var view=new Float64Array(result,0,floatLength);view.set(new Float64Array(buffer,0,floatLength))}return byteLength!=offset&&(view=new Uint8Array(result,offset),view.set(new Uint8Array(buffer,offset))),result}:constant(null));var getLength=baseProperty(\"length\"),getSymbols=getOwnPropertySymbols?function(object){return getOwnPropertySymbols(toObject(object))}:constant([]),findLastIndex=createFindIndex(!0),zip=restParam(unzip),forEach=createForEach(arrayEach,baseEach),isArray=nativeIsArray||function(value){return isObjectLike(value)&&isLength(value.length)&&objToString.call(value)==arrayTag},isFunction=baseIsFunction(/x/)||Uint8Array&&!baseIsFunction(Uint8Array)?function(value){return objToString.call(value)==funcTag}:baseIsFunction,isPlainObject=getPrototypeOf?function(value){if(!value||objToString.call(value)!=objectTag)return!1;var valueOf=value.valueOf,objProto=isNative(valueOf)&&(objProto=getPrototypeOf(valueOf))&&getPrototypeOf(objProto);return objProto?value==objProto||getPrototypeOf(value)==objProto:shimIsPlainObject(value)}:shimIsPlainObject,assign=createAssigner(function(object,source,customizer){return customizer?assignWith(object,source,customizer):baseAssign(object,source)}),keys=nativeKeys?function(object){if(object)var Ctor=object.constructor,length=object.length;return\"function\"==typeof Ctor&&Ctor.prototype===object||\"function\"!=typeof object&&isLength(length)?shimKeys(object):isObject(object)?nativeKeys(object):[]}:shimKeys,merge=createAssigner(baseMerge);lodash.assign=assign,lodash.callback=callback,lodash.constant=constant,lodash.forEach=forEach,lodash.keys=keys,lodash.keysIn=keysIn,lodash.merge=merge,lodash.property=property,lodash.reject=reject,lodash.restParam=restParam,lodash.slice=slice,lodash.toPlainObject=toPlainObject,lodash.unzip=unzip,lodash.values=values,lodash.zip=zip,lodash.each=forEach,lodash.extend=assign,lodash.iteratee=callback,lodash.clone=clone,lodash.escapeRegExp=escapeRegExp,lodash.findLastIndex=findLastIndex,lodash.has=has,lodash.identity=identity,lodash.includes=includes,lodash.indexOf=indexOf,lodash.isArguments=isArguments,lodash.isArray=isArray,lodash.isEmpty=isEmpty,lodash.isFunction=isFunction,lodash.isNative=isNative,lodash.isNumber=isNumber,lodash.isObject=isObject,lodash.isPlainObject=isPlainObject,lodash.isString=isString,lodash.isTypedArray=isTypedArray,lodash.last=last,lodash.some=some,lodash.any=some,lodash.contains=includes,lodash.include=includes,lodash.VERSION=VERSION,freeExports&&freeModule?moduleExports?(freeModule.exports=lodash)._=lodash:freeExports._=lodash:root._=lodash\n}).call(this)}).call(this,\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}],\"/node_modules/jshint/src/jshint.js\":[function(_dereq_,module,exports){var _=_dereq_(\"../lodash\"),events=_dereq_(\"events\"),vars=_dereq_(\"./vars.js\"),messages=_dereq_(\"./messages.js\"),Lexer=_dereq_(\"./lex.js\").Lexer,reg=_dereq_(\"./reg.js\"),state=_dereq_(\"./state.js\").state,style=_dereq_(\"./style.js\"),options=_dereq_(\"./options.js\"),scopeManager=_dereq_(\"./scope-manager.js\"),JSHINT=function(){\"use strict\";function checkOption(name,t){return name=name.trim(),/^[+-]W\\d{3}$/g.test(name)?!0:-1!==options.validNames.indexOf(name)||\"jslint\"===t.type||_.has(options.removed,name)?!0:(error(\"E001\",t,name),!1)}function isString(obj){return\"[object String]\"===Object.prototype.toString.call(obj)}function isIdentifier(tkn,value){return tkn?tkn.identifier&&tkn.value===value?!0:!1:!1}function isReserved(token){if(!token.reserved)return!1;var meta=token.meta;if(meta&&meta.isFutureReservedWord&&state.inES5()){if(!meta.es5)return!1;if(meta.strictOnly&&!state.option.strict&&!state.isStrict())return!1;if(token.isProperty)return!1}return!0}function supplant(str,data){return str.replace(/\\{([^{}]*)\\}/g,function(a,b){var r=data[b];return\"string\"==typeof r||\"number\"==typeof r?r:a})}function combine(dest,src){Object.keys(src).forEach(function(name){_.has(JSHINT.blacklist,name)||(dest[name]=src[name])})}function processenforceall(){if(state.option.enforceall){for(var enforceopt in options.bool.enforcing)void 0!==state.option[enforceopt]||options.noenforceall[enforceopt]||(state.option[enforceopt]=!0);for(var relaxopt in options.bool.relaxing)void 0===state.option[relaxopt]&&(state.option[relaxopt]=!1)}}function assume(){processenforceall(),state.option.esversion||state.option.moz||(state.option.esversion=state.option.es3?3:state.option.esnext?6:5),state.inES5()&&combine(predefined,vars.ecmaIdentifiers[5]),state.inES6()&&combine(predefined,vars.ecmaIdentifiers[6]),state.option.module&&(state.option.strict===!0&&(state.option.strict=\"global\"),state.inES6()||warning(\"W134\",state.tokens.next,\"module\",6)),state.option.couch&&combine(predefined,vars.couch),state.option.qunit&&combine(predefined,vars.qunit),state.option.rhino&&combine(predefined,vars.rhino),state.option.shelljs&&(combine(predefined,vars.shelljs),combine(predefined,vars.node)),state.option.typed&&combine(predefined,vars.typed),state.option.phantom&&(combine(predefined,vars.phantom),state.option.strict===!0&&(state.option.strict=\"global\")),state.option.prototypejs&&combine(predefined,vars.prototypejs),state.option.node&&(combine(predefined,vars.node),combine(predefined,vars.typed),state.option.strict===!0&&(state.option.strict=\"global\")),state.option.devel&&combine(predefined,vars.devel),state.option.dojo&&combine(predefined,vars.dojo),state.option.browser&&(combine(predefined,vars.browser),combine(predefined,vars.typed)),state.option.browserify&&(combine(predefined,vars.browser),combine(predefined,vars.typed),combine(predefined,vars.browserify),state.option.strict===!0&&(state.option.strict=\"global\")),state.option.nonstandard&&combine(predefined,vars.nonstandard),state.option.jasmine&&combine(predefined,vars.jasmine),state.option.jquery&&combine(predefined,vars.jquery),state.option.mootools&&combine(predefined,vars.mootools),state.option.worker&&combine(predefined,vars.worker),state.option.wsh&&combine(predefined,vars.wsh),state.option.globalstrict&&state.option.strict!==!1&&(state.option.strict=\"global\"),state.option.yui&&combine(predefined,vars.yui),state.option.mocha&&combine(predefined,vars.mocha)}function quit(code,line,chr){var percentage=Math.floor(100*(line/state.lines.length)),message=messages.errors[code].desc;throw{name:\"JSHintError\",line:line,character:chr,message:message+\" (\"+percentage+\"% scanned).\",raw:message,code:code}}function removeIgnoredMessages(){var ignored=state.ignoredLines;_.isEmpty(ignored)||(JSHINT.errors=_.reject(JSHINT.errors,function(err){return ignored[err.line]}))}function warning(code,t,a,b,c,d){var ch,l,w,msg;if(/^W\\d{3}$/.test(code)){if(state.ignored[code])return;msg=messages.warnings[code]}else/E\\d{3}/.test(code)?msg=messages.errors[code]:/I\\d{3}/.test(code)&&(msg=messages.info[code]);return t=t||state.tokens.next||{},\"(end)\"===t.id&&(t=state.tokens.curr),l=t.line||0,ch=t.from||0,w={id:\"(error)\",raw:msg.desc,code:msg.code,evidence:state.lines[l-1]||\"\",line:l,character:ch,scope:JSHINT.scope,a:a,b:b,c:c,d:d},w.reason=supplant(msg.desc,w),JSHINT.errors.push(w),removeIgnoredMessages(),JSHINT.errors.length>=state.option.maxerr&&quit(\"E043\",l,ch),w}function warningAt(m,l,ch,a,b,c,d){return warning(m,{line:l,from:ch},a,b,c,d)}function error(m,t,a,b,c,d){warning(m,t,a,b,c,d)}function errorAt(m,l,ch,a,b,c,d){return error(m,{line:l,from:ch},a,b,c,d)}function addInternalSrc(elem,src){var i;return i={id:\"(internal)\",elem:elem,value:src},JSHINT.internals.push(i),i}function doOption(){var nt=state.tokens.next,body=nt.body.match(/(-\\s+)?[^\\s,:]+(?:\\s*:\\s*(-\\s+)?[^\\s,]+)?/g)||[],predef={};if(\"globals\"===nt.type){body.forEach(function(g,idx){g=g.split(\":\");var key=(g[0]||\"\").trim(),val=(g[1]||\"\").trim();if(\"-\"===key||!key.length){if(idx>0&&idx===body.length-1)return;return error(\"E002\",nt),void 0}\"-\"===key.charAt(0)?(key=key.slice(1),val=!1,JSHINT.blacklist[key]=key,delete predefined[key]):predef[key]=\"true\"===val}),combine(predefined,predef);for(var key in predef)_.has(predef,key)&&(declared[key]=nt)}\"exported\"===nt.type&&body.forEach(function(e,idx){if(!e.length){if(idx>0&&idx===body.length-1)return;return error(\"E002\",nt),void 0}state.funct[\"(scope)\"].addExported(e)}),\"members\"===nt.type&&(membersOnly=membersOnly||{},body.forEach(function(m){var ch1=m.charAt(0),ch2=m.charAt(m.length-1);ch1!==ch2||'\"'!==ch1&&\"'\"!==ch1||(m=m.substr(1,m.length-2).replace('\\\\\"','\"')),membersOnly[m]=!1}));var numvals=[\"maxstatements\",\"maxparams\",\"maxdepth\",\"maxcomplexity\",\"maxerr\",\"maxlen\",\"indent\"];(\"jshint\"===nt.type||\"jslint\"===nt.type)&&(body.forEach(function(g){g=g.split(\":\");var key=(g[0]||\"\").trim(),val=(g[1]||\"\").trim();if(checkOption(key,nt))if(numvals.indexOf(key)>=0)if(\"false\"!==val){if(val=+val,\"number\"!=typeof val||!isFinite(val)||0>=val||Math.floor(val)!==val)return error(\"E032\",nt,g[1].trim()),void 0;state.option[key]=val}else state.option[key]=\"indent\"===key?4:!1;else{if(\"validthis\"===key)return state.funct[\"(global)\"]?void error(\"E009\"):\"true\"!==val&&\"false\"!==val?void error(\"E002\",nt):(state.option.validthis=\"true\"===val,void 0);if(\"quotmark\"!==key)if(\"shadow\"!==key)if(\"unused\"!==key)if(\"latedef\"!==key)if(\"ignore\"!==key)if(\"strict\"!==key){\"module\"===key&&(hasParsedCode(state.funct)||error(\"E055\",state.tokens.next,\"module\"));var esversions={es3:3,es5:5,esnext:6};if(!_.has(esversions,key)){if(\"esversion\"===key){switch(val){case\"5\":state.inES5(!0)&&warning(\"I003\");case\"3\":case\"6\":state.option.moz=!1,state.option.esversion=+val;break;case\"2015\":state.option.moz=!1,state.option.esversion=6;break;default:error(\"E002\",nt)}return hasParsedCode(state.funct)||error(\"E055\",state.tokens.next,\"esversion\"),void 0}var match=/^([+-])(W\\d{3})$/g.exec(key);if(match)return state.ignored[match[2]]=\"-\"===match[1],void 0;var tn;return\"true\"===val||\"false\"===val?(\"jslint\"===nt.type?(tn=options.renamed[key]||key,state.option[tn]=\"true\"===val,void 0!==options.inverted[tn]&&(state.option[tn]=!state.option[tn])):state.option[key]=\"true\"===val,\"newcap\"===key&&(state.option[\"(explicitNewcap)\"]=!0),void 0):(error(\"E002\",nt),void 0)}switch(val){case\"true\":state.option.moz=!1,state.option.esversion=esversions[key];break;case\"false\":state.option.moz||(state.option.esversion=5);break;default:error(\"E002\",nt)}}else switch(val){case\"true\":state.option.strict=!0;break;case\"false\":state.option.strict=!1;break;case\"func\":case\"global\":case\"implied\":state.option.strict=val;break;default:error(\"E002\",nt)}else switch(val){case\"line\":state.ignoredLines[nt.line]=!0,removeIgnoredMessages();break;default:error(\"E002\",nt)}else switch(val){case\"true\":state.option.latedef=!0;break;case\"false\":state.option.latedef=!1;break;case\"nofunc\":state.option.latedef=\"nofunc\";break;default:error(\"E002\",nt)}else switch(val){case\"true\":state.option.unused=!0;break;case\"false\":state.option.unused=!1;break;case\"vars\":case\"strict\":state.option.unused=val;break;default:error(\"E002\",nt)}else switch(val){case\"true\":state.option.shadow=!0;break;case\"outer\":state.option.shadow=\"outer\";break;case\"false\":case\"inner\":state.option.shadow=\"inner\";break;default:error(\"E002\",nt)}else switch(val){case\"true\":case\"false\":state.option.quotmark=\"true\"===val;break;case\"double\":case\"single\":state.option.quotmark=val;break;default:error(\"E002\",nt)}}}),assume())}function peek(p){var t,i=p||0,j=lookahead.length;if(j>i)return lookahead[i];for(;i>=j;)t=lookahead[j],t||(t=lookahead[j]=lex.token()),j+=1;return t||\"(end)\"!==state.tokens.next.id?t:state.tokens.next}function peekIgnoreEOL(){var t,i=0;do t=peek(i++);while(\"(endline)\"===t.id);return t}function advance(id,t){switch(state.tokens.curr.id){case\"(number)\":\".\"===state.tokens.next.id&&warning(\"W005\",state.tokens.curr);break;case\"-\":(\"-\"===state.tokens.next.id||\"--\"===state.tokens.next.id)&&warning(\"W006\");break;case\"+\":(\"+\"===state.tokens.next.id||\"++\"===state.tokens.next.id)&&warning(\"W007\")}for(id&&state.tokens.next.id!==id&&(t?\"(end)\"===state.tokens.next.id?error(\"E019\",t,t.id):error(\"E020\",state.tokens.next,id,t.id,t.line,state.tokens.next.value):(\"(identifier)\"!==state.tokens.next.type||state.tokens.next.value!==id)&&warning(\"W116\",state.tokens.next,id,state.tokens.next.value)),state.tokens.prev=state.tokens.curr,state.tokens.curr=state.tokens.next;;){if(state.tokens.next=lookahead.shift()||lex.token(),state.tokens.next||quit(\"E041\",state.tokens.curr.line),\"(end)\"===state.tokens.next.id||\"(error)\"===state.tokens.next.id)return;if(state.tokens.next.check&&state.tokens.next.check(),state.tokens.next.isSpecial)\"falls through\"===state.tokens.next.type?state.tokens.curr.caseFallsThrough=!0:doOption();else if(\"(endline)\"!==state.tokens.next.id)break}}function isInfix(token){return token.infix||!token.identifier&&!token.template&&!!token.led}function isEndOfExpr(){var curr=state.tokens.curr,next=state.tokens.next;return\";\"===next.id||\"}\"===next.id||\":\"===next.id?!0:isInfix(next)===isInfix(curr)||\"yield\"===curr.id&&state.inMoz()?curr.line!==startLine(next):!1}function isBeginOfExpr(prev){return!prev.left&&\"unary\"!==prev.arity}function expression(rbp,initial){var left,isArray=!1,isObject=!1,isLetExpr=!1;state.nameStack.push(),initial||\"let\"!==state.tokens.next.value||\"(\"!==peek(0).value||(state.inMoz()||warning(\"W118\",state.tokens.next,\"let expressions\"),isLetExpr=!0,state.funct[\"(scope)\"].stack(),advance(\"let\"),advance(\"(\"),state.tokens.prev.fud(),advance(\")\")),\"(end)\"===state.tokens.next.id&&error(\"E006\",state.tokens.curr);var isDangerous=state.option.asi&&state.tokens.prev.line!==startLine(state.tokens.curr)&&_.contains([\"]\",\")\"],state.tokens.prev.id)&&_.contains([\"[\",\"(\"],state.tokens.curr.id);if(isDangerous&&warning(\"W014\",state.tokens.curr,state.tokens.curr.id),advance(),initial&&(state.funct[\"(verb)\"]=state.tokens.curr.value,state.tokens.curr.beginsStmt=!0),initial===!0&&state.tokens.curr.fud)left=state.tokens.curr.fud();else for(state.tokens.curr.nud?left=state.tokens.curr.nud():error(\"E030\",state.tokens.curr,state.tokens.curr.id);(state.tokens.next.lbp>rbp||\"(template)\"===state.tokens.next.type)&&!isEndOfExpr();)isArray=\"Array\"===state.tokens.curr.value,isObject=\"Object\"===state.tokens.curr.value,left&&(left.value||left.first&&left.first.value)&&(\"new\"!==left.value||left.first&&left.first.value&&\".\"===left.first.value)&&(isArray=!1,left.value!==state.tokens.curr.value&&(isObject=!1)),advance(),isArray&&\"(\"===state.tokens.curr.id&&\")\"===state.tokens.next.id&&warning(\"W009\",state.tokens.curr),isObject&&\"(\"===state.tokens.curr.id&&\")\"===state.tokens.next.id&&warning(\"W010\",state.tokens.curr),left&&state.tokens.curr.led?left=state.tokens.curr.led(left):error(\"E033\",state.tokens.curr,state.tokens.curr.id);return isLetExpr&&state.funct[\"(scope)\"].unstack(),state.nameStack.pop(),left}function startLine(token){return token.startLine||token.line}function nobreaknonadjacent(left,right){left=left||state.tokens.curr,right=right||state.tokens.next,state.option.laxbreak||left.line===startLine(right)||warning(\"W014\",right,right.value)}function nolinebreak(t){t=t||state.tokens.curr,t.line!==startLine(state.tokens.next)&&warning(\"E022\",t,t.value)}function nobreakcomma(left,right){left.line!==startLine(right)&&(state.option.laxcomma||(comma.first&&(warning(\"I001\"),comma.first=!1),warning(\"W014\",left,right.value)))}function comma(opts){if(opts=opts||{},opts.peek?nobreakcomma(state.tokens.prev,state.tokens.curr):(nobreakcomma(state.tokens.curr,state.tokens.next),advance(\",\")),state.tokens.next.identifier&&(!opts.property||!state.inES5()))switch(state.tokens.next.value){case\"break\":case\"case\":case\"catch\":case\"continue\":case\"default\":case\"do\":case\"else\":case\"finally\":case\"for\":case\"if\":case\"in\":case\"instanceof\":case\"return\":case\"switch\":case\"throw\":case\"try\":case\"var\":case\"let\":case\"while\":case\"with\":return error(\"E024\",state.tokens.next,state.tokens.next.value),!1}if(\"(punctuator)\"===state.tokens.next.type)switch(state.tokens.next.value){case\"}\":case\"]\":case\",\":if(opts.allowTrailing)return!0;case\")\":return error(\"E024\",state.tokens.next,state.tokens.next.value),!1}return!0}function symbol(s,p){var x=state.syntax[s];return x&&\"object\"==typeof x||(state.syntax[s]=x={id:s,lbp:p,value:s}),x}function delim(s){var x=symbol(s,0);return x.delim=!0,x}function stmt(s,f){var x=delim(s);return x.identifier=x.reserved=!0,x.fud=f,x}function blockstmt(s,f){var x=stmt(s,f);return x.block=!0,x}function reserveName(x){var c=x.id.charAt(0);return(c>=\"a\"&&\"z\">=c||c>=\"A\"&&\"Z\">=c)&&(x.identifier=x.reserved=!0),x}function prefix(s,f){var x=symbol(s,150);return reserveName(x),x.nud=\"function\"==typeof f?f:function(){return this.arity=\"unary\",this.right=expression(150),(\"++\"===this.id||\"--\"===this.id)&&(state.option.plusplus?warning(\"W016\",this,this.id):!this.right||this.right.identifier&&!isReserved(this.right)||\".\"===this.right.id||\"[\"===this.right.id||warning(\"W017\",this),this.right&&this.right.isMetaProperty?error(\"E031\",this):this.right&&this.right.identifier&&state.funct[\"(scope)\"].block.modify(this.right.value,this)),this},x}function type(s,f){var x=delim(s);return x.type=s,x.nud=f,x}function reserve(name,func){var x=type(name,func);return x.identifier=!0,x.reserved=!0,x}function FutureReservedWord(name,meta){var x=type(name,meta&&meta.nud||function(){return this});return meta=meta||{},meta.isFutureReservedWord=!0,x.value=name,x.identifier=!0,x.reserved=!0,x.meta=meta,x}function reservevar(s,v){return reserve(s,function(){return\"function\"==typeof v&&v(this),this})}function infix(s,f,p,w){var x=symbol(s,p);return reserveName(x),x.infix=!0,x.led=function(left){return w||nobreaknonadjacent(state.tokens.prev,state.tokens.curr),\"in\"!==s&&\"instanceof\"!==s||\"!\"!==left.id||warning(\"W018\",left,\"!\"),\"function\"==typeof f?f(left,this):(this.left=left,this.right=expression(p),this)},x}function application(s){var x=symbol(s,42);return x.led=function(left){return nobreaknonadjacent(state.tokens.prev,state.tokens.curr),this.left=left,this.right=doFunction({type:\"arrow\",loneArg:left}),this},x}function relation(s,f){var x=symbol(s,100);return x.led=function(left){nobreaknonadjacent(state.tokens.prev,state.tokens.curr),this.left=left;var right=this.right=expression(100);return isIdentifier(left,\"NaN\")||isIdentifier(right,\"NaN\")?warning(\"W019\",this):f&&f.apply(this,[left,right]),left&&right||quit(\"E041\",state.tokens.curr.line),\"!\"===left.id&&warning(\"W018\",left,\"!\"),\"!\"===right.id&&warning(\"W018\",right,\"!\"),this},x}function isPoorRelation(node){return node&&(\"(number)\"===node.type&&0===+node.value||\"(string)\"===node.type&&\"\"===node.value||\"null\"===node.type&&!state.option.eqnull||\"true\"===node.type||\"false\"===node.type||\"undefined\"===node.type)}function isTypoTypeof(left,right,state){var values;return state.option.notypeof?!1:left&&right?(values=state.inES6()?typeofValues.es6:typeofValues.es3,\"(identifier)\"===right.type&&\"typeof\"===right.value&&\"(string)\"===left.type?!_.contains(values,left.value):!1):!1}function isGlobalEval(left,state){var isGlobal=!1;return\"this\"===left.type&&null===state.funct[\"(context)\"]?isGlobal=!0:\"(identifier)\"===left.type&&(state.option.node&&\"global\"===left.value?isGlobal=!0:!state.option.browser||\"window\"!==left.value&&\"document\"!==left.value||(isGlobal=!0)),isGlobal}function findNativePrototype(left){function walkPrototype(obj){return\"object\"==typeof obj?\"prototype\"===obj.right?obj:walkPrototype(obj.left):void 0}function walkNative(obj){for(;!obj.identifier&&\"object\"==typeof obj.left;)obj=obj.left;return obj.identifier&&natives.indexOf(obj.value)>=0?obj.value:void 0}var natives=[\"Array\",\"ArrayBuffer\",\"Boolean\",\"Collator\",\"DataView\",\"Date\",\"DateTimeFormat\",\"Error\",\"EvalError\",\"Float32Array\",\"Float64Array\",\"Function\",\"Infinity\",\"Intl\",\"Int16Array\",\"Int32Array\",\"Int8Array\",\"Iterator\",\"Number\",\"NumberFormat\",\"Object\",\"RangeError\",\"ReferenceError\",\"RegExp\",\"StopIteration\",\"String\",\"SyntaxError\",\"TypeError\",\"Uint16Array\",\"Uint32Array\",\"Uint8Array\",\"Uint8ClampedArray\",\"URIError\"],prototype=walkPrototype(left);return prototype?walkNative(prototype):void 0}function checkLeftSideAssign(left,assignToken,options){var allowDestructuring=options&&options.allowDestructuring;if(assignToken=assignToken||left,state.option.freeze){var nativeObject=findNativePrototype(left);nativeObject&&warning(\"W121\",left,nativeObject)}return left.identifier&&!left.isMetaProperty&&state.funct[\"(scope)\"].block.reassign(left.value,left),\".\"===left.id?((!left.left||\"arguments\"===left.left.value&&!state.isStrict())&&warning(\"E031\",assignToken),state.nameStack.set(state.tokens.prev),!0):\"{\"===left.id||\"[\"===left.id?(allowDestructuring&&state.tokens.curr.left.destructAssign?state.tokens.curr.left.destructAssign.forEach(function(t){t.id&&state.funct[\"(scope)\"].block.modify(t.id,t.token)}):\"{\"!==left.id&&left.left?\"arguments\"!==left.left.value||state.isStrict()||warning(\"E031\",assignToken):warning(\"E031\",assignToken),\"[\"===left.id&&state.nameStack.set(left.right),!0):left.isMetaProperty?(error(\"E031\",assignToken),!0):left.identifier&&!isReserved(left)?(\"exception\"===state.funct[\"(scope)\"].labeltype(left.value)&&warning(\"W022\",left),state.nameStack.set(left),!0):(left===state.syntax[\"function\"]&&warning(\"W023\",state.tokens.curr),!1)}function assignop(s,f,p){var x=infix(s,\"function\"==typeof f?f:function(left,that){return that.left=left,left&&checkLeftSideAssign(left,that,{allowDestructuring:!0})?(that.right=expression(10),that):(error(\"E031\",that),void 0)},p);return x.exps=!0,x.assign=!0,x}function bitwise(s,f,p){var x=symbol(s,p);return reserveName(x),x.led=\"function\"==typeof f?f:function(left){return state.option.bitwise&&warning(\"W016\",this,this.id),this.left=left,this.right=expression(p),this},x}function bitwiseassignop(s){return assignop(s,function(left,that){return state.option.bitwise&&warning(\"W016\",that,that.id),left&&checkLeftSideAssign(left,that)?(that.right=expression(10),that):(error(\"E031\",that),void 0)},20)}function suffix(s){var x=symbol(s,150);return x.led=function(left){return state.option.plusplus?warning(\"W016\",this,this.id):left.identifier&&!isReserved(left)||\".\"===left.id||\"[\"===left.id||warning(\"W017\",this),left.isMetaProperty?error(\"E031\",this):left&&left.identifier&&state.funct[\"(scope)\"].block.modify(left.value,left),this.left=left,this},x}function optionalidentifier(fnparam,prop,preserve){if(state.tokens.next.identifier){preserve||advance();var curr=state.tokens.curr,val=state.tokens.curr.value;return isReserved(curr)?prop&&state.inES5()?val:fnparam&&\"undefined\"===val?val:(warning(\"W024\",state.tokens.curr,state.tokens.curr.id),val):val}}function identifier(fnparam,prop){var i=optionalidentifier(fnparam,prop,!1);if(i)return i;if(\"...\"===state.tokens.next.value){if(state.inES6(!0)||warning(\"W119\",state.tokens.next,\"spread/rest operator\",\"6\"),advance(),checkPunctuator(state.tokens.next,\"...\"))for(warning(\"E024\",state.tokens.next,\"...\");checkPunctuator(state.tokens.next,\"...\");)advance();return state.tokens.next.identifier?identifier(fnparam,prop):(warning(\"E024\",state.tokens.curr,\"...\"),void 0)}error(\"E030\",state.tokens.next,state.tokens.next.value),\";\"!==state.tokens.next.id&&advance()}function reachable(controlToken){var t,i=0;if(\";\"===state.tokens.next.id&&!controlToken.inBracelessBlock)for(;;){do t=peek(i),i+=1;while(\"(end)\"!==t.id&&\"(comment)\"===t.id);if(t.reach)return;if(\"(endline)\"!==t.id){if(\"function\"===t.id){state.option.latedef===!0&&warning(\"W026\",t);break}warning(\"W027\",t,t.value,controlToken.value);break}}}function parseFinalSemicolon(){if(\";\"!==state.tokens.next.id){if(state.tokens.next.isUnclosed)return advance();var sameLine=startLine(state.tokens.next)===state.tokens.curr.line&&\"(end)\"!==state.tokens.next.id,blockEnd=checkPunctuator(state.tokens.next,\"}\");sameLine&&!blockEnd?errorAt(\"E058\",state.tokens.curr.line,state.tokens.curr.character):state.option.asi||(blockEnd&&!state.option.lastsemic||!sameLine)&&warningAt(\"W033\",state.tokens.curr.line,state.tokens.curr.character)}else advance(\";\")}function statement(){var r,i=indent,t=state.tokens.next,hasOwnScope=!1;if(\";\"===t.id)return advance(\";\"),void 0;var res=isReserved(t);if(res&&t.meta&&t.meta.isFutureReservedWord&&\":\"===peek().id&&(warning(\"W024\",t,t.id),res=!1),t.identifier&&!res&&\":\"===peek().id&&(advance(),advance(\":\"),hasOwnScope=!0,state.funct[\"(scope)\"].stack(),state.funct[\"(scope)\"].block.addBreakLabel(t.value,{token:state.tokens.curr}),state.tokens.next.labelled||\"{\"===state.tokens.next.value||warning(\"W028\",state.tokens.next,t.value,state.tokens.next.value),state.tokens.next.label=t.value,t=state.tokens.next),\"{\"===t.id){var iscase=\"case\"===state.funct[\"(verb)\"]&&\":\"===state.tokens.curr.value;return block(!0,!0,!1,!1,iscase),void 0}return r=expression(0,!0),!r||r.identifier&&\"function\"===r.value||\"(punctuator)\"===r.type&&r.left&&r.left.identifier&&\"function\"===r.left.value||state.isStrict()||\"global\"!==state.option.strict||warning(\"E007\"),t.block||(state.option.expr||r&&r.exps?state.option.nonew&&r&&r.left&&\"(\"===r.id&&\"new\"===r.left.id&&warning(\"W031\",t):warning(\"W030\",state.tokens.curr),parseFinalSemicolon()),indent=i,hasOwnScope&&state.funct[\"(scope)\"].unstack(),r}function statements(){for(var p,a=[];!state.tokens.next.reach&&\"(end)\"!==state.tokens.next.id;)\";\"===state.tokens.next.id?(p=peek(),(!p||\"(\"!==p.id&&\"[\"!==p.id)&&warning(\"W032\"),advance(\";\")):a.push(statement());return a}function directives(){for(var i,p,pn;\"(string)\"===state.tokens.next.id;){if(p=peek(0),\"(endline)\"===p.id){i=1;do pn=peek(i++);while(\"(endline)\"===pn.id);if(\";\"===pn.id)p=pn;else{if(\"[\"===pn.value||\".\"===pn.value)break;state.option.asi&&\"(\"!==pn.value||warning(\"W033\",state.tokens.next)}}else{if(\".\"===p.id||\"[\"===p.id)break;\";\"!==p.id&&warning(\"W033\",p)}advance();var directive=state.tokens.curr.value;(state.directive[directive]||\"use strict\"===directive&&\"implied\"===state.option.strict)&&warning(\"W034\",state.tokens.curr,directive),state.directive[directive]=!0,\";\"===p.id&&advance(\";\")}state.isStrict()&&(state.option[\"(explicitNewcap)\"]||(state.option.newcap=!0),state.option.undef=!0)}function block(ordinary,stmt,isfunc,isfatarrow,iscase){var a,m,t,line,d,b=inblock,old_indent=indent;inblock=ordinary,t=state.tokens.next;var metrics=state.funct[\"(metrics)\"];if(metrics.nestedBlockDepth+=1,metrics.verifyMaxNestedBlockDepthPerFunction(),\"{\"===state.tokens.next.id){if(advance(\"{\"),state.funct[\"(scope)\"].stack(),line=state.tokens.curr.line,\"}\"!==state.tokens.next.id){for(indent+=state.option.indent;!ordinary&&state.tokens.next.from>indent;)indent+=state.option.indent;if(isfunc){m={};for(d in state.directive)_.has(state.directive,d)&&(m[d]=state.directive[d]);directives(),state.option.strict&&state.funct[\"(context)\"][\"(global)\"]&&(m[\"use strict\"]||state.isStrict()||warning(\"E007\"))}a=statements(),metrics.statementCount+=a.length,indent-=state.option.indent}advance(\"}\",t),isfunc&&(state.funct[\"(scope)\"].validateParams(),m&&(state.directive=m)),state.funct[\"(scope)\"].unstack(),indent=old_indent}else if(ordinary)state.funct[\"(noblockscopedvar)\"]=\"for\"!==state.tokens.next.id,state.funct[\"(scope)\"].stack(),(!stmt||state.option.curly)&&warning(\"W116\",state.tokens.next,\"{\",state.tokens.next.value),state.tokens.next.inBracelessBlock=!0,indent+=state.option.indent,a=[statement()],indent-=state.option.indent,state.funct[\"(scope)\"].unstack(),delete state.funct[\"(noblockscopedvar)\"];else if(isfunc){if(state.funct[\"(scope)\"].stack(),m={},!stmt||isfatarrow||state.inMoz()||error(\"W118\",state.tokens.curr,\"function closure expressions\"),!stmt)for(d in state.directive)_.has(state.directive,d)&&(m[d]=state.directive[d]);expression(10),state.option.strict&&state.funct[\"(context)\"][\"(global)\"]&&(m[\"use strict\"]||state.isStrict()||warning(\"E007\")),state.funct[\"(scope)\"].unstack()}else error(\"E021\",state.tokens.next,\"{\",state.tokens.next.value);switch(state.funct[\"(verb)\"]){case\"break\":case\"continue\":case\"return\":case\"throw\":if(iscase)break;default:state.funct[\"(verb)\"]=null}return inblock=b,!ordinary||!state.option.noempty||a&&0!==a.length||warning(\"W035\",state.tokens.prev),metrics.nestedBlockDepth-=1,a}function countMember(m){membersOnly&&\"boolean\"!=typeof membersOnly[m]&&warning(\"W036\",state.tokens.curr,m),\"number\"==typeof member[m]?member[m]+=1:member[m]=1}function comprehensiveArrayExpression(){var res={};res.exps=!0,state.funct[\"(comparray)\"].stack();var reversed=!1;return\"for\"!==state.tokens.next.value&&(reversed=!0,state.inMoz()||warning(\"W116\",state.tokens.next,\"for\",state.tokens.next.value),state.funct[\"(comparray)\"].setState(\"use\"),res.right=expression(10)),advance(\"for\"),\"each\"===state.tokens.next.value&&(advance(\"each\"),state.inMoz()||warning(\"W118\",state.tokens.curr,\"for each\")),advance(\"(\"),state.funct[\"(comparray)\"].setState(\"define\"),res.left=expression(130),_.contains([\"in\",\"of\"],state.tokens.next.value)?advance():error(\"E045\",state.tokens.curr),state.funct[\"(comparray)\"].setState(\"generate\"),expression(10),advance(\")\"),\"if\"===state.tokens.next.value&&(advance(\"if\"),advance(\"(\"),state.funct[\"(comparray)\"].setState(\"filter\"),res.filter=expression(10),advance(\")\")),reversed||(state.funct[\"(comparray)\"].setState(\"use\"),res.right=expression(10)),advance(\"]\"),state.funct[\"(comparray)\"].unstack(),res}function isMethod(){return state.funct[\"(statement)\"]&&\"class\"===state.funct[\"(statement)\"].type||state.funct[\"(context)\"]&&\"class\"===state.funct[\"(context)\"][\"(verb)\"]}function isPropertyName(token){return token.identifier||\"(string)\"===token.id||\"(number)\"===token.id}function propertyName(preserveOrToken){var id,preserve=!0;return\"object\"==typeof preserveOrToken?id=preserveOrToken:(preserve=preserveOrToken,id=optionalidentifier(!1,!0,preserve)),id?\"object\"==typeof id&&(\"(string)\"===id.id||\"(identifier)\"===id.id?id=id.value:\"(number)\"===id.id&&(id=\"\"+id.value)):\"(string)\"===state.tokens.next.id?(id=state.tokens.next.value,preserve||advance()):\"(number)\"===state.tokens.next.id&&(id=\"\"+state.tokens.next.value,preserve||advance()),\"hasOwnProperty\"===id&&warning(\"W001\"),id}function functionparams(options){function addParam(addParamArgs){state.funct[\"(scope)\"].addParam.apply(state.funct[\"(scope)\"],addParamArgs)}var next,ident,t,paramsIds=[],tokens=[],pastDefault=!1,pastRest=!1,arity=0,loneArg=options&&options.loneArg;if(loneArg&&loneArg.identifier===!0)return state.funct[\"(scope)\"].addParam(loneArg.value,loneArg),{arity:1,params:[loneArg.value]};if(next=state.tokens.next,options&&options.parsedOpening||advance(\"(\"),\")\"===state.tokens.next.id)return advance(\")\"),void 0;for(;;){arity++;var currentParams=[];if(_.contains([\"{\",\"[\"],state.tokens.next.id)){tokens=destructuringPattern();for(t in tokens)t=tokens[t],t.id&&(paramsIds.push(t.id),currentParams.push([t.id,t.token]))}else if(checkPunctuator(state.tokens.next,\"...\")&&(pastRest=!0),ident=identifier(!0))paramsIds.push(ident),currentParams.push([ident,state.tokens.curr]);else for(;!checkPunctuators(state.tokens.next,[\",\",\")\"]);)advance();if(pastDefault&&\"=\"!==state.tokens.next.id&&error(\"W138\",state.tokens.current),\"=\"===state.tokens.next.id&&(state.inES6()||warning(\"W119\",state.tokens.next,\"default parameters\",\"6\"),advance(\"=\"),pastDefault=!0,expression(10)),currentParams.forEach(addParam),\",\"!==state.tokens.next.id)return advance(\")\",next),{arity:arity,params:paramsIds};pastRest&&warning(\"W131\",state.tokens.next),comma()}}function functor(name,token,overwrites){var funct={\"(name)\":name,\"(breakage)\":0,\"(loopage)\":0,\"(tokens)\":{},\"(properties)\":{},\"(catch)\":!1,\"(global)\":!1,\"(line)\":null,\"(character)\":null,\"(metrics)\":null,\"(statement)\":null,\"(context)\":null,\"(scope)\":null,\"(comparray)\":null,\"(generator)\":null,\"(arrow)\":null,\"(params)\":null};return token&&_.extend(funct,{\"(line)\":token.line,\"(character)\":token.character,\"(metrics)\":createMetrics(token)}),_.extend(funct,overwrites),funct[\"(context)\"]&&(funct[\"(scope)\"]=funct[\"(context)\"][\"(scope)\"],funct[\"(comparray)\"]=funct[\"(context)\"][\"(comparray)\"]),funct}function isFunctor(token){return\"(scope)\"in token}function hasParsedCode(funct){return funct[\"(global)\"]&&!funct[\"(verb)\"]}function doTemplateLiteral(left){function end(){if(state.tokens.curr.template&&state.tokens.curr.tail&&state.tokens.curr.context===ctx)return!0;var complete=state.tokens.next.template&&state.tokens.next.tail&&state.tokens.next.context===ctx;return complete&&advance(),complete||state.tokens.next.isUnclosed}var ctx=this.context,noSubst=this.noSubst,depth=this.depth;if(!noSubst)for(;!end();)!state.tokens.next.template||state.tokens.next.depth>depth?expression(0):advance();return{id:\"(template)\",type:\"(template)\",tag:left}}function doFunction(options){var f,token,name,statement,classExprBinding,isGenerator,isArrow,ignoreLoopFunc,oldOption=state.option,oldIgnored=state.ignored;options&&(name=options.name,statement=options.statement,classExprBinding=options.classExprBinding,isGenerator=\"generator\"===options.type,isArrow=\"arrow\"===options.type,ignoreLoopFunc=options.ignoreLoopFunc),state.option=Object.create(state.option),state.ignored=Object.create(state.ignored),state.funct=functor(name||state.nameStack.infer(),state.tokens.next,{\"(statement)\":statement,\"(context)\":state.funct,\"(arrow)\":isArrow,\"(generator)\":isGenerator}),f=state.funct,token=state.tokens.curr,token.funct=state.funct,functions.push(state.funct),state.funct[\"(scope)\"].stack(\"functionouter\");var internallyAccessibleName=name||classExprBinding;internallyAccessibleName&&state.funct[\"(scope)\"].block.add(internallyAccessibleName,classExprBinding?\"class\":\"function\",state.tokens.curr,!1),state.funct[\"(scope)\"].stack(\"functionparams\");var paramsInfo=functionparams(options);return paramsInfo?(state.funct[\"(params)\"]=paramsInfo.params,state.funct[\"(metrics)\"].arity=paramsInfo.arity,state.funct[\"(metrics)\"].verifyMaxParametersPerFunction()):state.funct[\"(metrics)\"].arity=0,isArrow&&(state.inES6(!0)||warning(\"W119\",state.tokens.curr,\"arrow function syntax (=>)\",\"6\"),options.loneArg||advance(\"=>\")),block(!1,!0,!0,isArrow),!state.option.noyield&&isGenerator&&\"yielded\"!==state.funct[\"(generator)\"]&&warning(\"W124\",state.tokens.curr),state.funct[\"(metrics)\"].verifyMaxStatementsPerFunction(),state.funct[\"(metrics)\"].verifyMaxComplexityPerFunction(),state.funct[\"(unusedOption)\"]=state.option.unused,state.option=oldOption,state.ignored=oldIgnored,state.funct[\"(last)\"]=state.tokens.curr.line,state.funct[\"(lastcharacter)\"]=state.tokens.curr.character,state.funct[\"(scope)\"].unstack(),state.funct[\"(scope)\"].unstack(),state.funct=state.funct[\"(context)\"],ignoreLoopFunc||state.option.loopfunc||!state.funct[\"(loopage)\"]||f[\"(isCapturing)\"]&&warning(\"W083\",token),f}function createMetrics(functionStartToken){return{statementCount:0,nestedBlockDepth:-1,ComplexityCount:1,arity:0,verifyMaxStatementsPerFunction:function(){state.option.maxstatements&&this.statementCount>state.option.maxstatements&&warning(\"W071\",functionStartToken,this.statementCount)\n},verifyMaxParametersPerFunction:function(){_.isNumber(state.option.maxparams)&&this.arity>state.option.maxparams&&warning(\"W072\",functionStartToken,this.arity)},verifyMaxNestedBlockDepthPerFunction:function(){state.option.maxdepth&&this.nestedBlockDepth>0&&this.nestedBlockDepth===state.option.maxdepth+1&&warning(\"W073\",null,this.nestedBlockDepth)},verifyMaxComplexityPerFunction:function(){var max=state.option.maxcomplexity,cc=this.ComplexityCount;max&&cc>max&&warning(\"W074\",functionStartToken,cc)}}}function increaseComplexityCount(){state.funct[\"(metrics)\"].ComplexityCount+=1}function checkCondAssignment(expr){var id,paren;switch(expr&&(id=expr.id,paren=expr.paren,\",\"===id&&(expr=expr.exprs[expr.exprs.length-1])&&(id=expr.id,paren=paren||expr.paren)),id){case\"=\":case\"+=\":case\"-=\":case\"*=\":case\"%=\":case\"&=\":case\"|=\":case\"^=\":case\"/=\":paren||state.option.boss||warning(\"W084\")}}function checkProperties(props){if(state.inES5())for(var name in props)props[name]&&props[name].setterToken&&!props[name].getterToken&&warning(\"W078\",props[name].setterToken)}function metaProperty(name,c){if(checkPunctuator(state.tokens.next,\".\")){var left=state.tokens.curr.id;advance(\".\");var id=identifier();return state.tokens.curr.isMetaProperty=!0,name!==id?error(\"E057\",state.tokens.prev,left,id):c(),state.tokens.curr}}function destructuringPattern(options){var isAssignment=options&&options.assignment;return state.inES6()||warning(\"W104\",state.tokens.curr,isAssignment?\"destructuring assignment\":\"destructuring binding\",\"6\"),destructuringPatternRecursive(options)}function destructuringPatternRecursive(options){var ids,identifiers=[],openingParsed=options&&options.openingParsed,isAssignment=options&&options.assignment,recursiveOptions=isAssignment?{assignment:isAssignment}:null,firstToken=openingParsed?state.tokens.curr:state.tokens.next,nextInnerDE=function(){var ident;if(checkPunctuators(state.tokens.next,[\"[\",\"{\"])){ids=destructuringPatternRecursive(recursiveOptions);for(var id in ids)id=ids[id],identifiers.push({id:id.id,token:id.token})}else if(checkPunctuator(state.tokens.next,\",\"))identifiers.push({id:null,token:state.tokens.curr});else{if(!checkPunctuator(state.tokens.next,\"(\")){var is_rest=checkPunctuator(state.tokens.next,\"...\");if(isAssignment){var identifierToken=is_rest?peek(0):state.tokens.next;identifierToken.identifier||warning(\"E030\",identifierToken,identifierToken.value);var assignTarget=expression(155);assignTarget&&(checkLeftSideAssign(assignTarget),assignTarget.identifier&&(ident=assignTarget.value))}else ident=identifier();return ident&&identifiers.push({id:ident,token:state.tokens.curr}),is_rest}advance(\"(\"),nextInnerDE(),advance(\")\")}return!1},assignmentProperty=function(){var id;checkPunctuator(state.tokens.next,\"[\")?(advance(\"[\"),expression(10),advance(\"]\"),advance(\":\"),nextInnerDE()):\"(string)\"===state.tokens.next.id||\"(number)\"===state.tokens.next.id?(advance(),advance(\":\"),nextInnerDE()):(id=identifier(),checkPunctuator(state.tokens.next,\":\")?(advance(\":\"),nextInnerDE()):id&&(isAssignment&&checkLeftSideAssign(state.tokens.curr),identifiers.push({id:id,token:state.tokens.curr})))};if(checkPunctuator(firstToken,\"[\")){openingParsed||advance(\"[\"),checkPunctuator(state.tokens.next,\"]\")&&warning(\"W137\",state.tokens.curr);for(var element_after_rest=!1;!checkPunctuator(state.tokens.next,\"]\");)nextInnerDE()&&!element_after_rest&&checkPunctuator(state.tokens.next,\",\")&&(warning(\"W130\",state.tokens.next),element_after_rest=!0),checkPunctuator(state.tokens.next,\"=\")&&(checkPunctuator(state.tokens.prev,\"...\")?advance(\"]\"):advance(\"=\"),\"undefined\"===state.tokens.next.id&&warning(\"W080\",state.tokens.prev,state.tokens.prev.value),expression(10)),checkPunctuator(state.tokens.next,\"]\")||advance(\",\");advance(\"]\")}else if(checkPunctuator(firstToken,\"{\")){for(openingParsed||advance(\"{\"),checkPunctuator(state.tokens.next,\"}\")&&warning(\"W137\",state.tokens.curr);!checkPunctuator(state.tokens.next,\"}\")&&(assignmentProperty(),checkPunctuator(state.tokens.next,\"=\")&&(advance(\"=\"),\"undefined\"===state.tokens.next.id&&warning(\"W080\",state.tokens.prev,state.tokens.prev.value),expression(10)),checkPunctuator(state.tokens.next,\"}\")||(advance(\",\"),!checkPunctuator(state.tokens.next,\"}\"))););advance(\"}\")}return identifiers}function destructuringPatternMatch(tokens,value){var first=value.first;first&&_.zip(tokens,Array.isArray(first)?first:[first]).forEach(function(val){var token=val[0],value=val[1];token&&value?token.first=value:token&&token.first&&!value&&warning(\"W080\",token.first,token.first.value)})}function blockVariableStatement(type,statement,context){var tokens,lone,value,letblock,prefix=context&&context.prefix,inexport=context&&context.inexport,isLet=\"let\"===type,isConst=\"const\"===type;for(state.inES6()||warning(\"W104\",state.tokens.curr,type,\"6\"),isLet&&\"(\"===state.tokens.next.value?(state.inMoz()||warning(\"W118\",state.tokens.next,\"let block\"),advance(\"(\"),state.funct[\"(scope)\"].stack(),letblock=!0):state.funct[\"(noblockscopedvar)\"]&&error(\"E048\",state.tokens.curr,isConst?\"Const\":\"Let\"),statement.first=[];;){var names=[];_.contains([\"{\",\"[\"],state.tokens.next.value)?(tokens=destructuringPattern(),lone=!1):(tokens=[{id:identifier(),token:state.tokens.curr}],lone=!0),!prefix&&isConst&&\"=\"!==state.tokens.next.id&&warning(\"E012\",state.tokens.curr,state.tokens.curr.value);for(var t in tokens)tokens.hasOwnProperty(t)&&(t=tokens[t],state.funct[\"(scope)\"].block.isGlobal()&&predefined[t.id]===!1&&warning(\"W079\",t.token,t.id),t.id&&!state.funct[\"(noblockscopedvar)\"]&&(state.funct[\"(scope)\"].addlabel(t.id,{type:type,token:t.token}),names.push(t.token),lone&&inexport&&state.funct[\"(scope)\"].setExported(t.token.value,t.token)));if(\"=\"===state.tokens.next.id&&(advance(\"=\"),prefix||\"undefined\"!==state.tokens.next.id||warning(\"W080\",state.tokens.prev,state.tokens.prev.value),!prefix&&\"=\"===peek(0).id&&state.tokens.next.identifier&&warning(\"W120\",state.tokens.next,state.tokens.next.value),value=expression(prefix?120:10),lone?tokens[0].first=value:destructuringPatternMatch(names,value)),statement.first=statement.first.concat(names),\",\"!==state.tokens.next.id)break;comma()}return letblock&&(advance(\")\"),block(!0,!0),statement.block=!0,state.funct[\"(scope)\"].unstack()),statement}function classdef(isStatement){return state.inES6()||warning(\"W104\",state.tokens.curr,\"class\",\"6\"),isStatement?(this.name=identifier(),state.funct[\"(scope)\"].addlabel(this.name,{type:\"class\",token:state.tokens.curr})):state.tokens.next.identifier&&\"extends\"!==state.tokens.next.value?(this.name=identifier(),this.namedExpr=!0):this.name=state.nameStack.infer(),classtail(this),this}function classtail(c){var wasInClassBody=state.inClassBody;\"extends\"===state.tokens.next.value&&(advance(\"extends\"),c.heritage=expression(10)),state.inClassBody=!0,advance(\"{\"),c.body=classbody(c),advance(\"}\"),state.inClassBody=wasInClassBody}function classbody(c){for(var name,isStatic,isGenerator,getset,computed,props=Object.create(null),staticProps=Object.create(null),i=0;\"}\"!==state.tokens.next.id;++i)if(name=state.tokens.next,isStatic=!1,isGenerator=!1,getset=null,\";\"!==name.id){if(\"*\"===name.id&&(isGenerator=!0,advance(\"*\"),name=state.tokens.next),\"[\"===name.id)name=computedPropertyName(),computed=!0;else{if(!isPropertyName(name)){warning(\"W052\",state.tokens.next,state.tokens.next.value||state.tokens.next.type),advance();continue}advance(),computed=!1,name.identifier&&\"static\"===name.value&&(checkPunctuator(state.tokens.next,\"*\")&&(isGenerator=!0,advance(\"*\")),(isPropertyName(state.tokens.next)||\"[\"===state.tokens.next.id)&&(computed=\"[\"===state.tokens.next.id,isStatic=!0,name=state.tokens.next,\"[\"===state.tokens.next.id?name=computedPropertyName():advance())),!name.identifier||\"get\"!==name.value&&\"set\"!==name.value||(isPropertyName(state.tokens.next)||\"[\"===state.tokens.next.id)&&(computed=\"[\"===state.tokens.next.id,getset=name,name=state.tokens.next,\"[\"===state.tokens.next.id?name=computedPropertyName():advance())}if(!checkPunctuator(state.tokens.next,\"(\")){for(error(\"E054\",state.tokens.next,state.tokens.next.value);\"}\"!==state.tokens.next.id&&!checkPunctuator(state.tokens.next,\"(\");)advance();\"(\"!==state.tokens.next.value&&doFunction({statement:c})}if(computed||(getset?saveAccessor(getset.value,isStatic?staticProps:props,name.value,name,!0,isStatic):(\"constructor\"===name.value?state.nameStack.set(c):state.nameStack.set(name),saveProperty(isStatic?staticProps:props,name.value,name,!0,isStatic))),getset&&\"constructor\"===name.value){var propDesc=\"get\"===getset.value?\"class getter method\":\"class setter method\";error(\"E049\",name,propDesc,\"constructor\")}else\"prototype\"===name.value&&error(\"E049\",name,\"class method\",\"prototype\");propertyName(name),doFunction({statement:c,type:isGenerator?\"generator\":null,classExprBinding:c.namedExpr?c.name:null})}else warning(\"W032\"),advance(\";\");checkProperties(props)}function saveProperty(props,name,tkn,isClass,isStatic){var msg=[\"key\",\"class method\",\"static class method\"];msg=msg[(isClass||!1)+(isStatic||!1)],tkn.identifier&&(name=tkn.value),props[name]&&\"__proto__\"!==name?warning(\"W075\",state.tokens.next,msg,name):props[name]=Object.create(null),props[name].basic=!0,props[name].basictkn=tkn}function saveAccessor(accessorType,props,name,tkn,isClass,isStatic){var flagName=\"get\"===accessorType?\"getterToken\":\"setterToken\",msg=\"\";isClass?(isStatic&&(msg+=\"static \"),msg+=accessorType+\"ter method\"):msg=\"key\",state.tokens.curr.accessorType=accessorType,state.nameStack.set(tkn),props[name]?(props[name].basic||props[name][flagName])&&\"__proto__\"!==name&&warning(\"W075\",state.tokens.next,msg,name):props[name]=Object.create(null),props[name][flagName]=tkn}function computedPropertyName(){advance(\"[\"),state.inES6()||warning(\"W119\",state.tokens.curr,\"computed property names\",\"6\");var value=expression(10);return advance(\"]\"),value}function checkPunctuators(token,values){return\"(punctuator)\"===token.type?_.contains(values,token.value):!1}function checkPunctuator(token,value){return\"(punctuator)\"===token.type&&token.value===value}function destructuringAssignOrJsonValue(){var block=lookupBlockType();block.notJson?(!state.inES6()&&block.isDestAssign&&warning(\"W104\",state.tokens.curr,\"destructuring assignment\",\"6\"),statements()):(state.option.laxbreak=!0,state.jsonMode=!0,jsonValue())}function jsonValue(){function jsonObject(){var o={},t=state.tokens.next;if(advance(\"{\"),\"}\"!==state.tokens.next.id)for(;;){if(\"(end)\"===state.tokens.next.id)error(\"E026\",state.tokens.next,t.line);else{if(\"}\"===state.tokens.next.id){warning(\"W094\",state.tokens.curr);break}\",\"===state.tokens.next.id?error(\"E028\",state.tokens.next):\"(string)\"!==state.tokens.next.id&&warning(\"W095\",state.tokens.next,state.tokens.next.value)}if(o[state.tokens.next.value]===!0?warning(\"W075\",state.tokens.next,\"key\",state.tokens.next.value):\"__proto__\"===state.tokens.next.value&&!state.option.proto||\"__iterator__\"===state.tokens.next.value&&!state.option.iterator?warning(\"W096\",state.tokens.next,state.tokens.next.value):o[state.tokens.next.value]=!0,advance(),advance(\":\"),jsonValue(),\",\"!==state.tokens.next.id)break;advance(\",\")}advance(\"}\")}function jsonArray(){var t=state.tokens.next;if(advance(\"[\"),\"]\"!==state.tokens.next.id)for(;;){if(\"(end)\"===state.tokens.next.id)error(\"E027\",state.tokens.next,t.line);else{if(\"]\"===state.tokens.next.id){warning(\"W094\",state.tokens.curr);break}\",\"===state.tokens.next.id&&error(\"E028\",state.tokens.next)}if(jsonValue(),\",\"!==state.tokens.next.id)break;advance(\",\")}advance(\"]\")}switch(state.tokens.next.id){case\"{\":jsonObject();break;case\"[\":jsonArray();break;case\"true\":case\"false\":case\"null\":case\"(number)\":case\"(string)\":advance();break;case\"-\":advance(\"-\"),advance(\"(number)\");break;default:error(\"E003\",state.tokens.next)}}var api,declared,functions,inblock,indent,lookahead,lex,member,membersOnly,predefined,stack,urls,bang={\"<\":!0,\"<=\":!0,\"==\":!0,\"===\":!0,\"!==\":!0,\"!=\":!0,\">\":!0,\">=\":!0,\"+\":!0,\"-\":!0,\"*\":!0,\"/\":!0,\"%\":!0},functionicity=[\"closure\",\"exception\",\"global\",\"label\",\"outer\",\"unused\",\"var\"],extraModules=[],emitter=new events.EventEmitter,typeofValues={};typeofValues.legacy=[\"xml\",\"unknown\"],typeofValues.es3=[\"undefined\",\"boolean\",\"number\",\"string\",\"function\",\"object\"],typeofValues.es3=typeofValues.es3.concat(typeofValues.legacy),typeofValues.es6=typeofValues.es3.concat(\"symbol\"),type(\"(number)\",function(){return this}),type(\"(string)\",function(){return this}),state.syntax[\"(identifier)\"]={type:\"(identifier)\",lbp:0,identifier:!0,nud:function(){var v=this.value;return\"=>\"===state.tokens.next.id?this:(state.funct[\"(comparray)\"].check(v)||state.funct[\"(scope)\"].block.use(v,state.tokens.curr),this)},led:function(){error(\"E033\",state.tokens.next,state.tokens.next.value)}};var baseTemplateSyntax={lbp:0,identifier:!1,template:!0};state.syntax[\"(template)\"]=_.extend({type:\"(template)\",nud:doTemplateLiteral,led:doTemplateLiteral,noSubst:!1},baseTemplateSyntax),state.syntax[\"(template middle)\"]=_.extend({type:\"(template middle)\",middle:!0,noSubst:!1},baseTemplateSyntax),state.syntax[\"(template tail)\"]=_.extend({type:\"(template tail)\",tail:!0,noSubst:!1},baseTemplateSyntax),state.syntax[\"(no subst template)\"]=_.extend({type:\"(template)\",nud:doTemplateLiteral,led:doTemplateLiteral,noSubst:!0,tail:!0},baseTemplateSyntax),type(\"(regexp)\",function(){return this}),delim(\"(endline)\"),delim(\"(begin)\"),delim(\"(end)\").reach=!0,delim(\"(error)\").reach=!0,delim(\"}\").reach=!0,delim(\")\"),delim(\"]\"),delim('\"').reach=!0,delim(\"'\").reach=!0,delim(\";\"),delim(\":\").reach=!0,delim(\"#\"),reserve(\"else\"),reserve(\"case\").reach=!0,reserve(\"catch\"),reserve(\"default\").reach=!0,reserve(\"finally\"),reservevar(\"arguments\",function(x){state.isStrict()&&state.funct[\"(global)\"]&&warning(\"E008\",x)}),reservevar(\"eval\"),reservevar(\"false\"),reservevar(\"Infinity\"),reservevar(\"null\"),reservevar(\"this\",function(x){state.isStrict()&&!isMethod()&&!state.option.validthis&&(state.funct[\"(statement)\"]&&state.funct[\"(name)\"].charAt(0)>\"Z\"||state.funct[\"(global)\"])&&warning(\"W040\",x)}),reservevar(\"true\"),reservevar(\"undefined\"),assignop(\"=\",\"assign\",20),assignop(\"+=\",\"assignadd\",20),assignop(\"-=\",\"assignsub\",20),assignop(\"*=\",\"assignmult\",20),assignop(\"/=\",\"assigndiv\",20).nud=function(){error(\"E014\")},assignop(\"%=\",\"assignmod\",20),bitwiseassignop(\"&=\"),bitwiseassignop(\"|=\"),bitwiseassignop(\"^=\"),bitwiseassignop(\"<<=\"),bitwiseassignop(\">>=\"),bitwiseassignop(\">>>=\"),infix(\",\",function(left,that){var expr;if(that.exprs=[left],state.option.nocomma&&warning(\"W127\"),!comma({peek:!0}))return that;for(;;){if(!(expr=expression(10)))break;if(that.exprs.push(expr),\",\"!==state.tokens.next.value||!comma())break}return that},10,!0),infix(\"?\",function(left,that){return increaseComplexityCount(),that.left=left,that.right=expression(10),advance(\":\"),that[\"else\"]=expression(10),that},30);var orPrecendence=40;infix(\"||\",function(left,that){return increaseComplexityCount(),that.left=left,that.right=expression(orPrecendence),that},orPrecendence),infix(\"&&\",\"and\",50),bitwise(\"|\",\"bitor\",70),bitwise(\"^\",\"bitxor\",80),bitwise(\"&\",\"bitand\",90),relation(\"==\",function(left,right){var eqnull=state.option.eqnull&&(\"null\"===(left&&left.value)||\"null\"===(right&&right.value));switch(!0){case!eqnull&&state.option.eqeqeq:this.from=this.character,warning(\"W116\",this,\"===\",\"==\");break;case isPoorRelation(left):warning(\"W041\",this,\"===\",left.value);break;case isPoorRelation(right):warning(\"W041\",this,\"===\",right.value);break;case isTypoTypeof(right,left,state):warning(\"W122\",this,right.value);break;case isTypoTypeof(left,right,state):warning(\"W122\",this,left.value)}return this}),relation(\"===\",function(left,right){return isTypoTypeof(right,left,state)?warning(\"W122\",this,right.value):isTypoTypeof(left,right,state)&&warning(\"W122\",this,left.value),this}),relation(\"!=\",function(left,right){var eqnull=state.option.eqnull&&(\"null\"===(left&&left.value)||\"null\"===(right&&right.value));return!eqnull&&state.option.eqeqeq?(this.from=this.character,warning(\"W116\",this,\"!==\",\"!=\")):isPoorRelation(left)?warning(\"W041\",this,\"!==\",left.value):isPoorRelation(right)?warning(\"W041\",this,\"!==\",right.value):isTypoTypeof(right,left,state)?warning(\"W122\",this,right.value):isTypoTypeof(left,right,state)&&warning(\"W122\",this,left.value),this}),relation(\"!==\",function(left,right){return isTypoTypeof(right,left,state)?warning(\"W122\",this,right.value):isTypoTypeof(left,right,state)&&warning(\"W122\",this,left.value),this}),relation(\"<\"),relation(\">\"),relation(\"<=\"),relation(\">=\"),bitwise(\"<<\",\"shiftleft\",120),bitwise(\">>\",\"shiftright\",120),bitwise(\">>>\",\"shiftrightunsigned\",120),infix(\"in\",\"in\",120),infix(\"instanceof\",\"instanceof\",120),infix(\"+\",function(left,that){var right;return that.left=left,that.right=right=expression(130),left&&right&&\"(string)\"===left.id&&\"(string)\"===right.id?(left.value+=right.value,left.character=right.character,!state.option.scripturl&&reg.javascriptURL.test(left.value)&&warning(\"W050\",left),left):that},130),prefix(\"+\",\"num\"),prefix(\"+++\",function(){return warning(\"W007\"),this.arity=\"unary\",this.right=expression(150),this}),infix(\"+++\",function(left){return warning(\"W007\"),this.left=left,this.right=expression(130),this},130),infix(\"-\",\"sub\",130),prefix(\"-\",\"neg\"),prefix(\"---\",function(){return warning(\"W006\"),this.arity=\"unary\",this.right=expression(150),this}),infix(\"---\",function(left){return warning(\"W006\"),this.left=left,this.right=expression(130),this},130),infix(\"*\",\"mult\",140),infix(\"/\",\"div\",140),infix(\"%\",\"mod\",140),suffix(\"++\"),prefix(\"++\",\"preinc\"),state.syntax[\"++\"].exps=!0,suffix(\"--\"),prefix(\"--\",\"predec\"),state.syntax[\"--\"].exps=!0,prefix(\"delete\",function(){var p=expression(10);return p?(\".\"!==p.id&&\"[\"!==p.id&&warning(\"W051\"),this.first=p,p.identifier&&!state.isStrict()&&(p.forgiveUndef=!0),this):this}).exps=!0,prefix(\"~\",function(){return state.option.bitwise&&warning(\"W016\",this,\"~\"),this.arity=\"unary\",this.right=expression(150),this}),prefix(\"...\",function(){return state.inES6(!0)||warning(\"W119\",this,\"spread/rest operator\",\"6\"),state.tokens.next.identifier||\"(string)\"===state.tokens.next.type||checkPunctuators(state.tokens.next,[\"[\",\"(\"])||error(\"E030\",state.tokens.next,state.tokens.next.value),expression(150),this}),prefix(\"!\",function(){return this.arity=\"unary\",this.right=expression(150),this.right||quit(\"E041\",this.line||0),bang[this.right.id]===!0&&warning(\"W018\",this,\"!\"),this}),prefix(\"typeof\",function(){var p=expression(150);return this.first=this.right=p,p||quit(\"E041\",this.line||0,this.character||0),p.identifier&&(p.forgiveUndef=!0),this}),prefix(\"new\",function(){var mp=metaProperty(\"target\",function(){state.inES6(!0)||warning(\"W119\",state.tokens.prev,\"new.target\",\"6\");for(var inFunction,c=state.funct;c&&(inFunction=!c[\"(global)\"],c[\"(arrow)\"]);)c=c[\"(context)\"];inFunction||warning(\"W136\",state.tokens.prev,\"new.target\")});if(mp)return mp;var i,c=expression(155);if(c&&\"function\"!==c.id)if(c.identifier)switch(c[\"new\"]=!0,c.value){case\"Number\":case\"String\":case\"Boolean\":case\"Math\":case\"JSON\":warning(\"W053\",state.tokens.prev,c.value);break;case\"Symbol\":state.inES6()&&warning(\"W053\",state.tokens.prev,c.value);break;case\"Function\":state.option.evil||warning(\"W054\");break;case\"Date\":case\"RegExp\":case\"this\":break;default:\"function\"!==c.id&&(i=c.value.substr(0,1),state.option.newcap&&(\"A\">i||i>\"Z\")&&!state.funct[\"(scope)\"].isPredefined(c.value)&&warning(\"W055\",state.tokens.curr))}else\".\"!==c.id&&\"[\"!==c.id&&\"(\"!==c.id&&warning(\"W056\",state.tokens.curr);else state.option.supernew||warning(\"W057\",this);return\"(\"===state.tokens.next.id||state.option.supernew||warning(\"W058\",state.tokens.curr,state.tokens.curr.value),this.first=this.right=c,this}),state.syntax[\"new\"].exps=!0,prefix(\"void\").exps=!0,infix(\".\",function(left,that){var m=identifier(!1,!0);return\"string\"==typeof m&&countMember(m),that.left=left,that.right=m,m&&\"hasOwnProperty\"===m&&\"=\"===state.tokens.next.value&&warning(\"W001\"),!left||\"arguments\"!==left.value||\"callee\"!==m&&\"caller\"!==m?state.option.evil||!left||\"document\"!==left.value||\"write\"!==m&&\"writeln\"!==m||warning(\"W060\",left):state.option.noarg?warning(\"W059\",left,m):state.isStrict()&&error(\"E008\"),state.option.evil||\"eval\"!==m&&\"execScript\"!==m||isGlobalEval(left,state)&&warning(\"W061\"),that},160,!0),infix(\"(\",function(left,that){state.option.immed&&left&&!left.immed&&\"function\"===left.id&&warning(\"W062\");var n=0,p=[];if(left&&\"(identifier)\"===left.type&&left.value.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)&&-1===\"Array Number String Boolean Date Object Error Symbol\".indexOf(left.value)&&(\"Math\"===left.value?warning(\"W063\",left):state.option.newcap&&warning(\"W064\",left)),\")\"!==state.tokens.next.id)for(;p[p.length]=expression(10),n+=1,\",\"===state.tokens.next.id;)comma();return advance(\")\"),\"object\"==typeof left&&(state.inES5()||\"parseInt\"!==left.value||1!==n||warning(\"W065\",state.tokens.curr),state.option.evil||(\"eval\"===left.value||\"Function\"===left.value||\"execScript\"===left.value?(warning(\"W061\",left),p[0]&&\"(string)\"===[0].id&&addInternalSrc(left,p[0].value)):!p[0]||\"(string)\"!==p[0].id||\"setTimeout\"!==left.value&&\"setInterval\"!==left.value?!p[0]||\"(string)\"!==p[0].id||\".\"!==left.value||\"window\"!==left.left.value||\"setTimeout\"!==left.right&&\"setInterval\"!==left.right||(warning(\"W066\",left),addInternalSrc(left,p[0].value)):(warning(\"W066\",left),addInternalSrc(left,p[0].value))),left.identifier||\".\"===left.id||\"[\"===left.id||\"=>\"===left.id||\"(\"===left.id||\"&&\"===left.id||\"||\"===left.id||\"?\"===left.id||state.inES6()&&left[\"(name)\"]||warning(\"W067\",that)),that.left=left,that},155,!0).exps=!0,prefix(\"(\",function(){var pn1,ret,triggerFnExpr,first,last,pn=state.tokens.next,i=-1,parens=1,opening=state.tokens.curr,preceeding=state.tokens.prev,isNecessary=!state.option.singleGroups;do\"(\"===pn.value?parens+=1:\")\"===pn.value&&(parens-=1),i+=1,pn1=pn,pn=peek(i);while((0!==parens||\")\"!==pn1.value)&&\";\"!==pn.value&&\"(end)\"!==pn.type);if(\"function\"===state.tokens.next.id&&(triggerFnExpr=state.tokens.next.immed=!0),\"=>\"===pn.value)return doFunction({type:\"arrow\",parsedOpening:!0});var exprs=[];if(\")\"!==state.tokens.next.id)for(;exprs.push(expression(10)),\",\"===state.tokens.next.id;)state.option.nocomma&&warning(\"W127\"),comma();return advance(\")\",this),state.option.immed&&exprs[0]&&\"function\"===exprs[0].id&&\"(\"!==state.tokens.next.id&&\".\"!==state.tokens.next.id&&\"[\"!==state.tokens.next.id&&warning(\"W068\",this),exprs.length?(exprs.length>1?(ret=Object.create(state.syntax[\",\"]),ret.exprs=exprs,first=exprs[0],last=exprs[exprs.length-1],isNecessary||(isNecessary=preceeding.assign||preceeding.delim)):(ret=first=last=exprs[0],isNecessary||(isNecessary=opening.beginsStmt&&(\"{\"===ret.id||triggerFnExpr||isFunctor(ret))||triggerFnExpr&&(!isEndOfExpr()||\"}\"!==state.tokens.prev.id)||isFunctor(ret)&&!isEndOfExpr()||\"{\"===ret.id&&\"=>\"===preceeding.id||\"(number)\"===ret.type&&checkPunctuator(pn,\".\")&&/^\\d+$/.test(ret.value))),ret&&(!isNecessary&&(first.left||first.right||ret.exprs)&&(isNecessary=!isBeginOfExpr(preceeding)&&first.lbp<=preceeding.lbp||!isEndOfExpr()&&last.lbp<state.tokens.next.lbp),isNecessary||warning(\"W126\",opening),ret.paren=!0),ret):void 0}),application(\"=>\"),infix(\"[\",function(left,that){var s,e=expression(10);return e&&\"(string)\"===e.type&&(state.option.evil||\"eval\"!==e.value&&\"execScript\"!==e.value||isGlobalEval(left,state)&&warning(\"W061\"),countMember(e.value),!state.option.sub&&reg.identifier.test(e.value)&&(s=state.syntax[e.value],s&&isReserved(s)||warning(\"W069\",state.tokens.prev,e.value))),advance(\"]\",that),e&&\"hasOwnProperty\"===e.value&&\"=\"===state.tokens.next.value&&warning(\"W001\"),that.left=left,that.right=e,that},160,!0),prefix(\"[\",function(){var blocktype=lookupBlockType();if(blocktype.isCompArray)return state.option.esnext||state.inMoz()||warning(\"W118\",state.tokens.curr,\"array comprehension\"),comprehensiveArrayExpression();if(blocktype.isDestAssign)return this.destructAssign=destructuringPattern({openingParsed:!0,assignment:!0}),this;var b=state.tokens.curr.line!==startLine(state.tokens.next);for(this.first=[],b&&(indent+=state.option.indent,state.tokens.next.from===indent+state.option.indent&&(indent+=state.option.indent));\"(end)\"!==state.tokens.next.id;){for(;\",\"===state.tokens.next.id;){if(!state.option.elision){if(state.inES5()){warning(\"W128\");do advance(\",\");while(\",\"===state.tokens.next.id);continue}warning(\"W070\")}advance(\",\")}if(\"]\"===state.tokens.next.id)break;if(this.first.push(expression(10)),\",\"!==state.tokens.next.id)break;if(comma({allowTrailing:!0}),\"]\"===state.tokens.next.id&&!state.inES5()){warning(\"W070\",state.tokens.curr);break}}return b&&(indent-=state.option.indent),advance(\"]\",this),this}),function(x){x.nud=function(){var b,f,i,p,t,nextVal,isGeneratorMethod=!1,props=Object.create(null);b=state.tokens.curr.line!==startLine(state.tokens.next),b&&(indent+=state.option.indent,state.tokens.next.from===indent+state.option.indent&&(indent+=state.option.indent));var blocktype=lookupBlockType();if(blocktype.isDestAssign)return this.destructAssign=destructuringPattern({openingParsed:!0,assignment:!0}),this;for(;\"}\"!==state.tokens.next.id;){if(nextVal=state.tokens.next.value,!state.tokens.next.identifier||\",\"!==peekIgnoreEOL().id&&\"}\"!==peekIgnoreEOL().id)if(\":\"===peek().id||\"get\"!==nextVal&&\"set\"!==nextVal){if(\"*\"===state.tokens.next.value&&\"(punctuator)\"===state.tokens.next.type?(state.inES6()||warning(\"W104\",state.tokens.next,\"generator functions\",\"6\"),advance(\"*\"),isGeneratorMethod=!0):isGeneratorMethod=!1,\"[\"===state.tokens.next.id)i=computedPropertyName(),state.nameStack.set(i);else if(state.nameStack.set(state.tokens.next),i=propertyName(),saveProperty(props,i,state.tokens.next),\"string\"!=typeof i)break;\"(\"===state.tokens.next.value?(state.inES6()||warning(\"W104\",state.tokens.curr,\"concise methods\",\"6\"),doFunction({type:isGeneratorMethod?\"generator\":null})):(advance(\":\"),expression(10))}else advance(nextVal),state.inES5()||error(\"E034\"),i=propertyName(),i||state.inES6()||error(\"E035\"),i&&saveAccessor(nextVal,props,i,state.tokens.curr),t=state.tokens.next,f=doFunction(),p=f[\"(params)\"],\"get\"===nextVal&&i&&p?warning(\"W076\",t,p[0],i):\"set\"!==nextVal||!i||p&&1===p.length||warning(\"W077\",t,i);else state.inES6()||warning(\"W104\",state.tokens.next,\"object short notation\",\"6\"),i=propertyName(!0),saveProperty(props,i,state.tokens.next),expression(10);if(countMember(i),\",\"!==state.tokens.next.id)break;comma({allowTrailing:!0,property:!0}),\",\"===state.tokens.next.id?warning(\"W070\",state.tokens.curr):\"}\"!==state.tokens.next.id||state.inES5()||warning(\"W070\",state.tokens.curr)}return b&&(indent-=state.option.indent),advance(\"}\",this),checkProperties(props),this},x.fud=function(){error(\"E036\",state.tokens.curr)}}(delim(\"{\"));var conststatement=stmt(\"const\",function(context){return blockVariableStatement(\"const\",this,context)});conststatement.exps=!0;var letstatement=stmt(\"let\",function(context){return blockVariableStatement(\"let\",this,context)});letstatement.exps=!0;var varstatement=stmt(\"var\",function(context){var tokens,lone,value,prefix=context&&context.prefix,inexport=context&&context.inexport,implied=context&&context.implied,report=!(context&&context.ignore);for(this.first=[];;){var names=[];_.contains([\"{\",\"[\"],state.tokens.next.value)?(tokens=destructuringPattern(),lone=!1):(tokens=[{id:identifier(),token:state.tokens.curr}],lone=!0),prefix&&implied||!report||!state.option.varstmt||warning(\"W132\",this),this.first=this.first.concat(names);for(var t in tokens)tokens.hasOwnProperty(t)&&(t=tokens[t],!implied&&state.funct[\"(global)\"]&&(predefined[t.id]===!1?warning(\"W079\",t.token,t.id):state.option.futurehostile===!1&&(!state.inES5()&&vars.ecmaIdentifiers[5][t.id]===!1||!state.inES6()&&vars.ecmaIdentifiers[6][t.id]===!1)&&warning(\"W129\",t.token,t.id)),t.id&&(\"for\"===implied?(state.funct[\"(scope)\"].has(t.id)||report&&warning(\"W088\",t.token,t.id),state.funct[\"(scope)\"].block.use(t.id,t.token)):(state.funct[\"(scope)\"].addlabel(t.id,{type:\"var\",token:t.token}),lone&&inexport&&state.funct[\"(scope)\"].setExported(t.id,t.token)),names.push(t.token)));if(\"=\"===state.tokens.next.id&&(state.nameStack.set(state.tokens.curr),advance(\"=\"),prefix||!report||state.funct[\"(loopage)\"]||\"undefined\"!==state.tokens.next.id||warning(\"W080\",state.tokens.prev,state.tokens.prev.value),\"=\"===peek(0).id&&state.tokens.next.identifier&&(!prefix&&report&&!state.funct[\"(params)\"]||-1===state.funct[\"(params)\"].indexOf(state.tokens.next.value))&&warning(\"W120\",state.tokens.next,state.tokens.next.value),value=expression(prefix?120:10),lone?tokens[0].first=value:destructuringPatternMatch(names,value)),\",\"!==state.tokens.next.id)break;comma()}return this});varstatement.exps=!0,blockstmt(\"class\",function(){return classdef.call(this,!0)}),blockstmt(\"function\",function(context){var inexport=context&&context.inexport,generator=!1;\"*\"===state.tokens.next.value&&(advance(\"*\"),state.inES6({strict:!0})?generator=!0:warning(\"W119\",state.tokens.curr,\"function*\",\"6\")),inblock&&warning(\"W082\",state.tokens.curr);var i=optionalidentifier();return state.funct[\"(scope)\"].addlabel(i,{type:\"function\",token:state.tokens.curr}),void 0===i?warning(\"W025\"):inexport&&state.funct[\"(scope)\"].setExported(i,state.tokens.prev),doFunction({name:i,statement:this,type:generator?\"generator\":null,ignoreLoopFunc:inblock}),\"(\"===state.tokens.next.id&&state.tokens.next.line===state.tokens.curr.line&&error(\"E039\"),this}),prefix(\"function\",function(){var generator=!1;\"*\"===state.tokens.next.value&&(state.inES6()||warning(\"W119\",state.tokens.curr,\"function*\",\"6\"),advance(\"*\"),generator=!0);var i=optionalidentifier();return doFunction({name:i,type:generator?\"generator\":null}),this}),blockstmt(\"if\",function(){var t=state.tokens.next;increaseComplexityCount(),state.condition=!0,advance(\"(\");var expr=expression(0);checkCondAssignment(expr);var forinifcheck=null;state.option.forin&&state.forinifcheckneeded&&(state.forinifcheckneeded=!1,forinifcheck=state.forinifchecks[state.forinifchecks.length-1],forinifcheck.type=\"(punctuator)\"===expr.type&&\"!\"===expr.value?\"(negative)\":\"(positive)\"),advance(\")\",t),state.condition=!1;var s=block(!0,!0);return forinifcheck&&\"(negative)\"===forinifcheck.type&&s&&s[0]&&\"(identifier)\"===s[0].type&&\"continue\"===s[0].value&&(forinifcheck.type=\"(negative-with-continue)\"),\"else\"===state.tokens.next.id&&(advance(\"else\"),\"if\"===state.tokens.next.id||\"switch\"===state.tokens.next.id?statement():block(!0,!0)),this}),blockstmt(\"try\",function(){function doCatch(){if(advance(\"catch\"),advance(\"(\"),state.funct[\"(scope)\"].stack(\"catchparams\"),checkPunctuators(state.tokens.next,[\"[\",\"{\"])){var tokens=destructuringPattern();_.each(tokens,function(token){token.id&&state.funct[\"(scope)\"].addParam(token.id,token,\"exception\")})}else\"(identifier)\"!==state.tokens.next.type?warning(\"E030\",state.tokens.next,state.tokens.next.value):state.funct[\"(scope)\"].addParam(identifier(),state.tokens.curr,\"exception\");\"if\"===state.tokens.next.value&&(state.inMoz()||warning(\"W118\",state.tokens.curr,\"catch filter\"),advance(\"if\"),expression(0)),advance(\")\"),block(!1),state.funct[\"(scope)\"].unstack()}var b;for(block(!0);\"catch\"===state.tokens.next.id;)increaseComplexityCount(),b&&!state.inMoz()&&warning(\"W118\",state.tokens.next,\"multiple catch blocks\"),doCatch(),b=!0;return\"finally\"===state.tokens.next.id?(advance(\"finally\"),block(!0),void 0):(b||error(\"E021\",state.tokens.next,\"catch\",state.tokens.next.value),this)}),blockstmt(\"while\",function(){var t=state.tokens.next;return state.funct[\"(breakage)\"]+=1,state.funct[\"(loopage)\"]+=1,increaseComplexityCount(),advance(\"(\"),checkCondAssignment(expression(0)),advance(\")\",t),block(!0,!0),state.funct[\"(breakage)\"]-=1,state.funct[\"(loopage)\"]-=1,this}).labelled=!0,blockstmt(\"with\",function(){var t=state.tokens.next;return state.isStrict()?error(\"E010\",state.tokens.curr):state.option.withstmt||warning(\"W085\",state.tokens.curr),advance(\"(\"),expression(0),advance(\")\",t),block(!0,!0),this}),blockstmt(\"switch\",function(){var t=state.tokens.next,g=!1,noindent=!1;\nfor(state.funct[\"(breakage)\"]+=1,advance(\"(\"),checkCondAssignment(expression(0)),advance(\")\",t),t=state.tokens.next,advance(\"{\"),state.tokens.next.from===indent&&(noindent=!0),noindent||(indent+=state.option.indent),this.cases=[];;)switch(state.tokens.next.id){case\"case\":switch(state.funct[\"(verb)\"]){case\"yield\":case\"break\":case\"case\":case\"continue\":case\"return\":case\"switch\":case\"throw\":break;default:state.tokens.curr.caseFallsThrough||warning(\"W086\",state.tokens.curr,\"case\")}advance(\"case\"),this.cases.push(expression(0)),increaseComplexityCount(),g=!0,advance(\":\"),state.funct[\"(verb)\"]=\"case\";break;case\"default\":switch(state.funct[\"(verb)\"]){case\"yield\":case\"break\":case\"continue\":case\"return\":case\"throw\":break;default:this.cases.length&&(state.tokens.curr.caseFallsThrough||warning(\"W086\",state.tokens.curr,\"default\"))}advance(\"default\"),g=!0,advance(\":\");break;case\"}\":return noindent||(indent-=state.option.indent),advance(\"}\",t),state.funct[\"(breakage)\"]-=1,state.funct[\"(verb)\"]=void 0,void 0;case\"(end)\":return error(\"E023\",state.tokens.next,\"}\"),void 0;default:if(indent+=state.option.indent,g)switch(state.tokens.curr.id){case\",\":return error(\"E040\"),void 0;case\":\":g=!1,statements();break;default:return error(\"E025\",state.tokens.curr),void 0}else{if(\":\"!==state.tokens.curr.id)return error(\"E021\",state.tokens.next,\"case\",state.tokens.next.value),void 0;advance(\":\"),error(\"E024\",state.tokens.curr,\":\"),statements()}indent-=state.option.indent}return this}).labelled=!0,stmt(\"debugger\",function(){return state.option.debug||warning(\"W087\",this),this}).exps=!0,function(){var x=stmt(\"do\",function(){state.funct[\"(breakage)\"]+=1,state.funct[\"(loopage)\"]+=1,increaseComplexityCount(),this.first=block(!0,!0),advance(\"while\");var t=state.tokens.next;return advance(\"(\"),checkCondAssignment(expression(0)),advance(\")\",t),state.funct[\"(breakage)\"]-=1,state.funct[\"(loopage)\"]-=1,this});x.labelled=!0,x.exps=!0}(),blockstmt(\"for\",function(){var s,t=state.tokens.next,letscope=!1,foreachtok=null;\"each\"===t.value&&(foreachtok=t,advance(\"each\"),state.inMoz()||warning(\"W118\",state.tokens.curr,\"for each\")),increaseComplexityCount(),advance(\"(\");var nextop,comma,initializer,i=0,inof=[\"in\",\"of\"],level=0;checkPunctuators(state.tokens.next,[\"{\",\"[\"])&&++level;do{if(nextop=peek(i),++i,checkPunctuators(nextop,[\"{\",\"[\"])?++level:checkPunctuators(nextop,[\"}\",\"]\"])&&--level,0>level)break;0===level&&(!comma&&checkPunctuator(nextop,\",\")?comma=nextop:!initializer&&checkPunctuator(nextop,\"=\")&&(initializer=nextop))}while(level>0||!_.contains(inof,nextop.value)&&\";\"!==nextop.value&&\"(end)\"!==nextop.type);if(_.contains(inof,nextop.value)){state.inES6()||\"of\"!==nextop.value||warning(\"W104\",nextop,\"for of\",\"6\");var ok=!(initializer||comma);if(initializer&&error(\"W133\",comma,nextop.value,\"initializer is forbidden\"),comma&&error(\"W133\",comma,nextop.value,\"more than one ForBinding\"),\"var\"===state.tokens.next.id?(advance(\"var\"),state.tokens.curr.fud({prefix:!0})):\"let\"===state.tokens.next.id||\"const\"===state.tokens.next.id?(advance(state.tokens.next.id),letscope=!0,state.funct[\"(scope)\"].stack(),state.tokens.curr.fud({prefix:!0})):Object.create(varstatement).fud({prefix:!0,implied:\"for\",ignore:!ok}),advance(nextop.value),expression(20),advance(\")\",t),\"in\"===nextop.value&&state.option.forin&&(state.forinifcheckneeded=!0,void 0===state.forinifchecks&&(state.forinifchecks=[]),state.forinifchecks.push({type:\"(none)\"})),state.funct[\"(breakage)\"]+=1,state.funct[\"(loopage)\"]+=1,s=block(!0,!0),\"in\"===nextop.value&&state.option.forin){if(state.forinifchecks&&state.forinifchecks.length>0){var check=state.forinifchecks.pop();(s&&s.length>0&&(\"object\"!=typeof s[0]||\"if\"!==s[0].value)||\"(positive)\"===check.type&&s.length>1||\"(negative)\"===check.type)&&warning(\"W089\",this)}state.forinifcheckneeded=!1}state.funct[\"(breakage)\"]-=1,state.funct[\"(loopage)\"]-=1}else{if(foreachtok&&error(\"E045\",foreachtok),\";\"!==state.tokens.next.id)if(\"var\"===state.tokens.next.id)advance(\"var\"),state.tokens.curr.fud();else if(\"let\"===state.tokens.next.id)advance(\"let\"),letscope=!0,state.funct[\"(scope)\"].stack(),state.tokens.curr.fud();else for(;expression(0,\"for\"),\",\"===state.tokens.next.id;)comma();if(nolinebreak(state.tokens.curr),advance(\";\"),state.funct[\"(loopage)\"]+=1,\";\"!==state.tokens.next.id&&checkCondAssignment(expression(0)),nolinebreak(state.tokens.curr),advance(\";\"),\";\"===state.tokens.next.id&&error(\"E021\",state.tokens.next,\")\",\";\"),\")\"!==state.tokens.next.id)for(;expression(0,\"for\"),\",\"===state.tokens.next.id;)comma();advance(\")\",t),state.funct[\"(breakage)\"]+=1,block(!0,!0),state.funct[\"(breakage)\"]-=1,state.funct[\"(loopage)\"]-=1}return letscope&&state.funct[\"(scope)\"].unstack(),this}).labelled=!0,stmt(\"break\",function(){var v=state.tokens.next.value;return state.option.asi||nolinebreak(this),\";\"===state.tokens.next.id||state.tokens.next.reach||state.tokens.curr.line!==startLine(state.tokens.next)?0===state.funct[\"(breakage)\"]&&warning(\"W052\",state.tokens.next,this.value):(state.funct[\"(scope)\"].funct.hasBreakLabel(v)||warning(\"W090\",state.tokens.next,v),this.first=state.tokens.next,advance()),reachable(this),this}).exps=!0,stmt(\"continue\",function(){var v=state.tokens.next.value;return 0===state.funct[\"(breakage)\"]&&warning(\"W052\",state.tokens.next,this.value),state.funct[\"(loopage)\"]||warning(\"W052\",state.tokens.next,this.value),state.option.asi||nolinebreak(this),\";\"===state.tokens.next.id||state.tokens.next.reach||state.tokens.curr.line===startLine(state.tokens.next)&&(state.funct[\"(scope)\"].funct.hasBreakLabel(v)||warning(\"W090\",state.tokens.next,v),this.first=state.tokens.next,advance()),reachable(this),this}).exps=!0,stmt(\"return\",function(){return this.line===startLine(state.tokens.next)?\";\"===state.tokens.next.id||state.tokens.next.reach||(this.first=expression(0),!this.first||\"(punctuator)\"!==this.first.type||\"=\"!==this.first.value||this.first.paren||state.option.boss||warningAt(\"W093\",this.first.line,this.first.character)):\"(punctuator)\"===state.tokens.next.type&&[\"[\",\"{\",\"+\",\"-\"].indexOf(state.tokens.next.value)>-1&&nolinebreak(this),reachable(this),this}).exps=!0,function(x){x.exps=!0,x.lbp=25}(prefix(\"yield\",function(){var prev=state.tokens.prev;state.inES6(!0)&&!state.funct[\"(generator)\"]?\"(catch)\"===state.funct[\"(name)\"]&&state.funct[\"(context)\"][\"(generator)\"]||error(\"E046\",state.tokens.curr,\"yield\"):state.inES6()||warning(\"W104\",state.tokens.curr,\"yield\",\"6\"),state.funct[\"(generator)\"]=\"yielded\";var delegatingYield=!1;return\"*\"===state.tokens.next.value&&(delegatingYield=!0,advance(\"*\")),this.line!==startLine(state.tokens.next)&&state.inMoz()?state.option.asi||nolinebreak(this):((delegatingYield||\";\"!==state.tokens.next.id&&!state.option.asi&&!state.tokens.next.reach&&state.tokens.next.nud)&&(nobreaknonadjacent(state.tokens.curr,state.tokens.next),this.first=expression(10),\"(punctuator)\"!==this.first.type||\"=\"!==this.first.value||this.first.paren||state.option.boss||warningAt(\"W093\",this.first.line,this.first.character)),state.inMoz()&&\")\"!==state.tokens.next.id&&(prev.lbp>30||!prev.assign&&!isEndOfExpr()||\"yield\"===prev.id)&&error(\"E050\",this)),this})),stmt(\"throw\",function(){return nolinebreak(this),this.first=expression(20),reachable(this),this}).exps=!0,stmt(\"import\",function(){if(state.inES6()||warning(\"W119\",state.tokens.curr,\"import\",\"6\"),\"(string)\"===state.tokens.next.type)return advance(\"(string)\"),this;if(state.tokens.next.identifier){if(this.name=identifier(),state.funct[\"(scope)\"].addlabel(this.name,{type:\"const\",token:state.tokens.curr}),\",\"!==state.tokens.next.value)return advance(\"from\"),advance(\"(string)\"),this;advance(\",\")}if(\"*\"===state.tokens.next.id)advance(\"*\"),advance(\"as\"),state.tokens.next.identifier&&(this.name=identifier(),state.funct[\"(scope)\"].addlabel(this.name,{type:\"const\",token:state.tokens.curr}));else for(advance(\"{\");;){if(\"}\"===state.tokens.next.value){advance(\"}\");break}var importName;if(\"default\"===state.tokens.next.type?(importName=\"default\",advance(\"default\")):importName=identifier(),\"as\"===state.tokens.next.value&&(advance(\"as\"),importName=identifier()),state.funct[\"(scope)\"].addlabel(importName,{type:\"const\",token:state.tokens.curr}),\",\"!==state.tokens.next.value){if(\"}\"===state.tokens.next.value){advance(\"}\");break}error(\"E024\",state.tokens.next,state.tokens.next.value);break}advance(\",\")}return advance(\"from\"),advance(\"(string)\"),this}).exps=!0,stmt(\"export\",function(){var token,identifier,ok=!0;if(state.inES6()||(warning(\"W119\",state.tokens.curr,\"export\",\"6\"),ok=!1),state.funct[\"(scope)\"].block.isGlobal()||(error(\"E053\",state.tokens.curr),ok=!1),\"*\"===state.tokens.next.value)return advance(\"*\"),advance(\"from\"),advance(\"(string)\"),this;if(\"default\"===state.tokens.next.type){state.nameStack.set(state.tokens.next),advance(\"default\");var exportType=state.tokens.next.id;return(\"function\"===exportType||\"class\"===exportType)&&(this.block=!0),token=peek(),expression(10),identifier=token.value,this.block&&(state.funct[\"(scope)\"].addlabel(identifier,{type:exportType,token:token}),state.funct[\"(scope)\"].setExported(identifier,token)),this}if(\"{\"===state.tokens.next.value){advance(\"{\");for(var exportedTokens=[];;){if(state.tokens.next.identifier||error(\"E030\",state.tokens.next,state.tokens.next.value),advance(),exportedTokens.push(state.tokens.curr),\"as\"===state.tokens.next.value&&(advance(\"as\"),state.tokens.next.identifier||error(\"E030\",state.tokens.next,state.tokens.next.value),advance()),\",\"!==state.tokens.next.value){if(\"}\"===state.tokens.next.value){advance(\"}\");break}error(\"E024\",state.tokens.next,state.tokens.next.value);break}advance(\",\")}return\"from\"===state.tokens.next.value?(advance(\"from\"),advance(\"(string)\")):ok&&exportedTokens.forEach(function(token){state.funct[\"(scope)\"].setExported(token.value,token)}),this}if(\"var\"===state.tokens.next.id)advance(\"var\"),state.tokens.curr.fud({inexport:!0});else if(\"let\"===state.tokens.next.id)advance(\"let\"),state.tokens.curr.fud({inexport:!0});else if(\"const\"===state.tokens.next.id)advance(\"const\"),state.tokens.curr.fud({inexport:!0});else if(\"function\"===state.tokens.next.id)this.block=!0,advance(\"function\"),state.syntax[\"function\"].fud({inexport:!0});else if(\"class\"===state.tokens.next.id){this.block=!0,advance(\"class\");var classNameToken=state.tokens.next;state.syntax[\"class\"].fud(),state.funct[\"(scope)\"].setExported(classNameToken.value,classNameToken)}else error(\"E024\",state.tokens.next,state.tokens.next.value);return this}).exps=!0,FutureReservedWord(\"abstract\"),FutureReservedWord(\"boolean\"),FutureReservedWord(\"byte\"),FutureReservedWord(\"char\"),FutureReservedWord(\"class\",{es5:!0,nud:classdef}),FutureReservedWord(\"double\"),FutureReservedWord(\"enum\",{es5:!0}),FutureReservedWord(\"export\",{es5:!0}),FutureReservedWord(\"extends\",{es5:!0}),FutureReservedWord(\"final\"),FutureReservedWord(\"float\"),FutureReservedWord(\"goto\"),FutureReservedWord(\"implements\",{es5:!0,strictOnly:!0}),FutureReservedWord(\"import\",{es5:!0}),FutureReservedWord(\"int\"),FutureReservedWord(\"interface\",{es5:!0,strictOnly:!0}),FutureReservedWord(\"long\"),FutureReservedWord(\"native\"),FutureReservedWord(\"package\",{es5:!0,strictOnly:!0}),FutureReservedWord(\"private\",{es5:!0,strictOnly:!0}),FutureReservedWord(\"protected\",{es5:!0,strictOnly:!0}),FutureReservedWord(\"public\",{es5:!0,strictOnly:!0}),FutureReservedWord(\"short\"),FutureReservedWord(\"static\",{es5:!0,strictOnly:!0}),FutureReservedWord(\"super\",{es5:!0}),FutureReservedWord(\"synchronized\"),FutureReservedWord(\"transient\"),FutureReservedWord(\"volatile\");var lookupBlockType=function(){var pn,pn1,prev,i=-1,bracketStack=0,ret={};checkPunctuators(state.tokens.curr,[\"[\",\"{\"])&&(bracketStack+=1);do{if(prev=-1===i?state.tokens.curr:pn,pn=-1===i?state.tokens.next:peek(i),pn1=peek(i+1),i+=1,checkPunctuators(pn,[\"[\",\"{\"])?bracketStack+=1:checkPunctuators(pn,[\"]\",\"}\"])&&(bracketStack-=1),1===bracketStack&&pn.identifier&&\"for\"===pn.value&&!checkPunctuator(prev,\".\")){ret.isCompArray=!0,ret.notJson=!0;break}if(0===bracketStack&&checkPunctuators(pn,[\"}\",\"]\"])){if(\"=\"===pn1.value){ret.isDestAssign=!0,ret.notJson=!0;break}if(\".\"===pn1.value){ret.notJson=!0;break}}checkPunctuator(pn,\";\")&&(ret.isBlock=!0,ret.notJson=!0)}while(bracketStack>0&&\"(end)\"!==pn.id);return ret},arrayComprehension=function(){function declare(v){var l=_current.variables.filter(function(elt){return elt.value===v?(elt.undef=!1,v):void 0}).length;return 0!==l}function use(v){var l=_current.variables.filter(function(elt){return elt.value!==v||elt.undef?void 0:(elt.unused===!0&&(elt.unused=!1),v)}).length;return 0===l}var _current,CompArray=function(){this.mode=\"use\",this.variables=[]},_carrays=[];return{stack:function(){_current=new CompArray,_carrays.push(_current)},unstack:function(){_current.variables.filter(function(v){v.unused&&warning(\"W098\",v.token,v.raw_text||v.value),v.undef&&state.funct[\"(scope)\"].block.use(v.value,v.token)}),_carrays.splice(-1,1),_current=_carrays[_carrays.length-1]},setState:function(s){_.contains([\"use\",\"define\",\"generate\",\"filter\"],s)&&(_current.mode=s)},check:function(v){return _current?_current&&\"use\"===_current.mode?(use(v)&&_current.variables.push({funct:state.funct,token:state.tokens.curr,value:v,undef:!0,unused:!1}),!0):_current&&\"define\"===_current.mode?(declare(v)||_current.variables.push({funct:state.funct,token:state.tokens.curr,value:v,undef:!1,unused:!0}),!0):_current&&\"generate\"===_current.mode?(state.funct[\"(scope)\"].block.use(v,state.tokens.curr),!0):_current&&\"filter\"===_current.mode?(use(v)&&state.funct[\"(scope)\"].block.use(v,state.tokens.curr),!0):!1:void 0}}},escapeRegex=function(str){return str.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g,\"\\\\$&\")},itself=function(s,o,g){function each(obj,cb){obj&&(Array.isArray(obj)||\"object\"!=typeof obj||(obj=Object.keys(obj)),obj.forEach(cb))}var i,k,x,reIgnoreStr,reIgnore,optionKeys,newOptionObj={},newIgnoredObj={};o=_.clone(o),state.reset(),o&&o.scope?JSHINT.scope=o.scope:(JSHINT.errors=[],JSHINT.undefs=[],JSHINT.internals=[],JSHINT.blacklist={},JSHINT.scope=\"(main)\"),predefined=Object.create(null),combine(predefined,vars.ecmaIdentifiers[3]),combine(predefined,vars.reservedVars),combine(predefined,g||{}),declared=Object.create(null);var exported=Object.create(null);if(o)for(each(o.predef||null,function(item){var slice,prop;\"-\"===item[0]?(slice=item.slice(1),JSHINT.blacklist[slice]=slice,delete predefined[slice]):(prop=Object.getOwnPropertyDescriptor(o.predef,item),predefined[item]=prop?prop.value:!1)}),each(o.exported||null,function(item){exported[item]=!0}),delete o.predef,delete o.exported,optionKeys=Object.keys(o),x=0;optionKeys.length>x;x++)if(/^-W\\d{3}$/g.test(optionKeys[x]))newIgnoredObj[optionKeys[x].slice(1)]=!0;else{var optionKey=optionKeys[x];newOptionObj[optionKey]=o[optionKey],(\"esversion\"===optionKey&&5===o[optionKey]||\"es5\"===optionKey&&o[optionKey])&&warning(\"I003\"),\"newcap\"===optionKeys[x]&&o[optionKey]===!1&&(newOptionObj[\"(explicitNewcap)\"]=!0)}state.option=newOptionObj,state.ignored=newIgnoredObj,state.option.indent=state.option.indent||4,state.option.maxerr=state.option.maxerr||50,indent=1;var scopeManagerInst=scopeManager(state,predefined,exported,declared);if(scopeManagerInst.on(\"warning\",function(ev){warning.apply(null,[ev.code,ev.token].concat(ev.data))}),scopeManagerInst.on(\"error\",function(ev){error.apply(null,[ev.code,ev.token].concat(ev.data))}),state.funct=functor(\"(global)\",null,{\"(global)\":!0,\"(scope)\":scopeManagerInst,\"(comparray)\":arrayComprehension(),\"(metrics)\":createMetrics(state.tokens.next)}),functions=[state.funct],urls=[],stack=null,member={},membersOnly=null,inblock=!1,lookahead=[],!isString(s)&&!Array.isArray(s))return errorAt(\"E004\",0),!1;api={get isJSON(){return state.jsonMode},getOption:function(name){return state.option[name]||null},getCache:function(name){return state.cache[name]},setCache:function(name,value){state.cache[name]=value},warn:function(code,data){warningAt.apply(null,[code,data.line,data.char].concat(data.data))},on:function(names,listener){names.split(\" \").forEach(function(name){emitter.on(name,listener)}.bind(this))}},emitter.removeAllListeners(),(extraModules||[]).forEach(function(func){func(api)}),state.tokens.prev=state.tokens.curr=state.tokens.next=state.syntax[\"(begin)\"],o&&o.ignoreDelimiters&&(Array.isArray(o.ignoreDelimiters)||(o.ignoreDelimiters=[o.ignoreDelimiters]),o.ignoreDelimiters.forEach(function(delimiterPair){delimiterPair.start&&delimiterPair.end&&(reIgnoreStr=escapeRegex(delimiterPair.start)+\"[\\\\s\\\\S]*?\"+escapeRegex(delimiterPair.end),reIgnore=RegExp(reIgnoreStr,\"ig\"),s=s.replace(reIgnore,function(match){return match.replace(/./g,\" \")}))})),lex=new Lexer(s),lex.on(\"warning\",function(ev){warningAt.apply(null,[ev.code,ev.line,ev.character].concat(ev.data))}),lex.on(\"error\",function(ev){errorAt.apply(null,[ev.code,ev.line,ev.character].concat(ev.data))}),lex.on(\"fatal\",function(ev){quit(\"E041\",ev.line,ev.from)}),lex.on(\"Identifier\",function(ev){emitter.emit(\"Identifier\",ev)}),lex.on(\"String\",function(ev){emitter.emit(\"String\",ev)}),lex.on(\"Number\",function(ev){emitter.emit(\"Number\",ev)}),lex.start();for(var name in o)_.has(o,name)&&checkOption(name,state.tokens.curr);assume(),combine(predefined,g||{}),comma.first=!0;try{switch(advance(),state.tokens.next.id){case\"{\":case\"[\":destructuringAssignOrJsonValue();break;default:directives(),state.directive[\"use strict\"]&&\"global\"!==state.option.strict&&warning(\"W097\",state.tokens.prev),statements()}\"(end)\"!==state.tokens.next.id&&quit(\"E041\",state.tokens.curr.line),state.funct[\"(scope)\"].unstack()}catch(err){if(!err||\"JSHintError\"!==err.name)throw err;var nt=state.tokens.next||{};JSHINT.errors.push({scope:\"(main)\",raw:err.raw,code:err.code,reason:err.message,line:err.line||nt.line,character:err.character||nt.from},null)}if(\"(main)\"===JSHINT.scope)for(o=o||{},i=0;JSHINT.internals.length>i;i+=1)k=JSHINT.internals[i],o.scope=k.elem,itself(k.value,o,g);return 0===JSHINT.errors.length};return itself.addModule=function(func){extraModules.push(func)},itself.addModule(style.register),itself.data=function(){var fu,f,i,j,n,globals,data={functions:[],options:state.option};itself.errors.length&&(data.errors=itself.errors),state.jsonMode&&(data.json=!0);var impliedGlobals=state.funct[\"(scope)\"].getImpliedGlobals();for(impliedGlobals.length>0&&(data.implieds=impliedGlobals),urls.length>0&&(data.urls=urls),globals=state.funct[\"(scope)\"].getUsedOrDefinedGlobals(),globals.length>0&&(data.globals=globals),i=1;functions.length>i;i+=1){for(f=functions[i],fu={},j=0;functionicity.length>j;j+=1)fu[functionicity[j]]=[];for(j=0;functionicity.length>j;j+=1)0===fu[functionicity[j]].length&&delete fu[functionicity[j]];fu.name=f[\"(name)\"],fu.param=f[\"(params)\"],fu.line=f[\"(line)\"],fu.character=f[\"(character)\"],fu.last=f[\"(last)\"],fu.lastcharacter=f[\"(lastcharacter)\"],fu.metrics={complexity:f[\"(metrics)\"].ComplexityCount,parameters:f[\"(metrics)\"].arity,statements:f[\"(metrics)\"].statementCount},data.functions.push(fu)}var unuseds=state.funct[\"(scope)\"].getUnuseds();unuseds.length>0&&(data.unused=unuseds);for(n in member)if(\"number\"==typeof member[n]){data.member=member;break}return data},itself.jshint=itself,itself}();\"object\"==typeof exports&&exports&&(exports.JSHINT=JSHINT)},{\"../lodash\":\"/node_modules/jshint/lodash.js\",\"./lex.js\":\"/node_modules/jshint/src/lex.js\",\"./messages.js\":\"/node_modules/jshint/src/messages.js\",\"./options.js\":\"/node_modules/jshint/src/options.js\",\"./reg.js\":\"/node_modules/jshint/src/reg.js\",\"./scope-manager.js\":\"/node_modules/jshint/src/scope-manager.js\",\"./state.js\":\"/node_modules/jshint/src/state.js\",\"./style.js\":\"/node_modules/jshint/src/style.js\",\"./vars.js\":\"/node_modules/jshint/src/vars.js\",events:\"/node_modules/browserify/node_modules/events/events.js\"}],\"/node_modules/jshint/src/lex.js\":[function(_dereq_,module,exports){\"use strict\";function asyncTrigger(){var _checks=[];return{push:function(fn){_checks.push(fn)},check:function(){for(var check=0;_checks.length>check;++check)_checks[check]();_checks.splice(0,_checks.length)}}}function Lexer(source){var lines=source;\"string\"==typeof lines&&(lines=lines.replace(/\\r\\n/g,\"\\n\").replace(/\\r/g,\"\\n\").split(\"\\n\")),lines[0]&&\"#!\"===lines[0].substr(0,2)&&(-1!==lines[0].indexOf(\"node\")&&(state.option.node=!0),lines[0]=\"\"),this.emitter=new events.EventEmitter,this.source=source,this.setLines(lines),this.prereg=!0,this.line=0,this.char=1,this.from=1,this.input=\"\",this.inComment=!1,this.context=[],this.templateStarts=[];for(var i=0;state.option.indent>i;i+=1)state.tab+=\" \";this.ignoreLinterErrors=!1}var _=_dereq_(\"../lodash\"),events=_dereq_(\"events\"),reg=_dereq_(\"./reg.js\"),state=_dereq_(\"./state.js\").state,unicodeData=_dereq_(\"../data/ascii-identifier-data.js\"),asciiIdentifierStartTable=unicodeData.asciiIdentifierStartTable,asciiIdentifierPartTable=unicodeData.asciiIdentifierPartTable,Token={Identifier:1,Punctuator:2,NumericLiteral:3,StringLiteral:4,Comment:5,Keyword:6,NullLiteral:7,BooleanLiteral:8,RegExp:9,TemplateHead:10,TemplateMiddle:11,TemplateTail:12,NoSubstTemplate:13},Context={Block:1,Template:2};Lexer.prototype={_lines:[],inContext:function(ctxType){return this.context.length>0&&this.context[this.context.length-1].type===ctxType},pushContext:function(ctxType){this.context.push({type:ctxType})},popContext:function(){return this.context.pop()},isContext:function(context){return this.context.length>0&&this.context[this.context.length-1]===context},currentContext:function(){return this.context.length>0&&this.context[this.context.length-1]},getLines:function(){return this._lines=state.lines,this._lines},setLines:function(val){this._lines=val,state.lines=this._lines},peek:function(i){return this.input.charAt(i||0)},skip:function(i){i=i||1,this.char+=i,this.input=this.input.slice(i)},on:function(names,listener){names.split(\" \").forEach(function(name){this.emitter.on(name,listener)}.bind(this))},trigger:function(){this.emitter.emit.apply(this.emitter,Array.prototype.slice.call(arguments))},triggerAsync:function(type,args,checks,fn){checks.push(function(){fn()&&this.trigger(type,args)}.bind(this))},scanPunctuator:function(){var ch2,ch3,ch4,ch1=this.peek();switch(ch1){case\".\":if(/^[0-9]$/.test(this.peek(1)))return null;if(\".\"===this.peek(1)&&\".\"===this.peek(2))return{type:Token.Punctuator,value:\"...\"};case\"(\":case\")\":case\";\":case\",\":case\"[\":case\"]\":case\":\":case\"~\":case\"?\":return{type:Token.Punctuator,value:ch1};case\"{\":return this.pushContext(Context.Block),{type:Token.Punctuator,value:ch1};case\"}\":return this.inContext(Context.Block)&&this.popContext(),{type:Token.Punctuator,value:ch1};case\"#\":return{type:Token.Punctuator,value:ch1};case\"\":return null}return ch2=this.peek(1),ch3=this.peek(2),ch4=this.peek(3),\">\"===ch1&&\">\"===ch2&&\">\"===ch3&&\"=\"===ch4?{type:Token.Punctuator,value:\">>>=\"}:\"=\"===ch1&&\"=\"===ch2&&\"=\"===ch3?{type:Token.Punctuator,value:\"===\"}:\"!\"===ch1&&\"=\"===ch2&&\"=\"===ch3?{type:Token.Punctuator,value:\"!==\"}:\">\"===ch1&&\">\"===ch2&&\">\"===ch3?{type:Token.Punctuator,value:\">>>\"}:\"<\"===ch1&&\"<\"===ch2&&\"=\"===ch3?{type:Token.Punctuator,value:\"<<=\"}:\">\"===ch1&&\">\"===ch2&&\"=\"===ch3?{type:Token.Punctuator,value:\">>=\"}:\"=\"===ch1&&\">\"===ch2?{type:Token.Punctuator,value:ch1+ch2}:ch1===ch2&&\"+-<>&|\".indexOf(ch1)>=0?{type:Token.Punctuator,value:ch1+ch2}:\"<>=!+-*%&|^\".indexOf(ch1)>=0?\"=\"===ch2?{type:Token.Punctuator,value:ch1+ch2}:{type:Token.Punctuator,value:ch1}:\"/\"===ch1?\"=\"===ch2?{type:Token.Punctuator,value:\"/=\"}:{type:Token.Punctuator,value:\"/\"}:null},scanComments:function(){function commentToken(label,body,opt){var special=[\"jshint\",\"jslint\",\"members\",\"member\",\"globals\",\"global\",\"exported\"],isSpecial=!1,value=label+body,commentType=\"plain\";return opt=opt||{},opt.isMultiline&&(value+=\"*/\"),body=body.replace(/\\n/g,\" \"),\"/*\"===label&&reg.fallsThrough.test(body)&&(isSpecial=!0,commentType=\"falls through\"),special.forEach(function(str){if(!isSpecial&&(\"//\"!==label||\"jshint\"===str)&&(\" \"===body.charAt(str.length)&&body.substr(0,str.length)===str&&(isSpecial=!0,label+=str,body=body.substr(str.length)),isSpecial||\" \"!==body.charAt(0)||\" \"!==body.charAt(str.length+1)||body.substr(1,str.length)!==str||(isSpecial=!0,label=label+\" \"+str,body=body.substr(str.length+1)),isSpecial))switch(str){case\"member\":commentType=\"members\";break;case\"global\":commentType=\"globals\";break;default:var options=body.split(\":\").map(function(v){return v.replace(/^\\s+/,\"\").replace(/\\s+$/,\"\")});if(2===options.length)switch(options[0]){case\"ignore\":switch(options[1]){case\"start\":self.ignoringLinterErrors=!0,isSpecial=!1;break;case\"end\":self.ignoringLinterErrors=!1,isSpecial=!1}}commentType=str}}),{type:Token.Comment,commentType:commentType,value:value,body:body,isSpecial:isSpecial,isMultiline:opt.isMultiline||!1,isMalformed:opt.isMalformed||!1}}var ch1=this.peek(),ch2=this.peek(1),rest=this.input.substr(2),startLine=this.line,startChar=this.char,self=this;if(\"*\"===ch1&&\"/\"===ch2)return this.trigger(\"error\",{code:\"E018\",line:startLine,character:startChar}),this.skip(2),null;if(\"/\"!==ch1||\"*\"!==ch2&&\"/\"!==ch2)return null;if(\"/\"===ch2)return this.skip(this.input.length),commentToken(\"//\",rest);var body=\"\";if(\"*\"===ch2){for(this.inComment=!0,this.skip(2);\"*\"!==this.peek()||\"/\"!==this.peek(1);)if(\"\"===this.peek()){if(body+=\"\\n\",!this.nextLine())return this.trigger(\"error\",{code:\"E017\",line:startLine,character:startChar}),this.inComment=!1,commentToken(\"/*\",body,{isMultiline:!0,isMalformed:!0})}else body+=this.peek(),this.skip();return this.skip(2),this.inComment=!1,commentToken(\"/*\",body,{isMultiline:!0})}},scanKeyword:function(){var result=/^[a-zA-Z_$][a-zA-Z0-9_$]*/.exec(this.input),keywords=[\"if\",\"in\",\"do\",\"var\",\"for\",\"new\",\"try\",\"let\",\"this\",\"else\",\"case\",\"void\",\"with\",\"enum\",\"while\",\"break\",\"catch\",\"throw\",\"const\",\"yield\",\"class\",\"super\",\"return\",\"typeof\",\"delete\",\"switch\",\"export\",\"import\",\"default\",\"finally\",\"extends\",\"function\",\"continue\",\"debugger\",\"instanceof\"];return result&&keywords.indexOf(result[0])>=0?{type:Token.Keyword,value:result[0]}:null},scanIdentifier:function(){function isNonAsciiIdentifierStart(code){return code>256}function isNonAsciiIdentifierPart(code){return code>256}function isHexDigit(str){return/^[0-9a-fA-F]$/.test(str)}function removeEscapeSequences(id){return id.replace(/\\\\u([0-9a-fA-F]{4})/g,function(m0,codepoint){return String.fromCharCode(parseInt(codepoint,16))})}var type,char,id=\"\",index=0,readUnicodeEscapeSequence=function(){if(index+=1,\"u\"!==this.peek(index))return null;var code,ch1=this.peek(index+1),ch2=this.peek(index+2),ch3=this.peek(index+3),ch4=this.peek(index+4);return isHexDigit(ch1)&&isHexDigit(ch2)&&isHexDigit(ch3)&&isHexDigit(ch4)?(code=parseInt(ch1+ch2+ch3+ch4,16),asciiIdentifierPartTable[code]||isNonAsciiIdentifierPart(code)?(index+=5,\"\\\\u\"+ch1+ch2+ch3+ch4):null):null}.bind(this),getIdentifierStart=function(){var chr=this.peek(index),code=chr.charCodeAt(0);return 92===code?readUnicodeEscapeSequence():128>code?asciiIdentifierStartTable[code]?(index+=1,chr):null:isNonAsciiIdentifierStart(code)?(index+=1,chr):null}.bind(this),getIdentifierPart=function(){var chr=this.peek(index),code=chr.charCodeAt(0);return 92===code?readUnicodeEscapeSequence():128>code?asciiIdentifierPartTable[code]?(index+=1,chr):null:isNonAsciiIdentifierPart(code)?(index+=1,chr):null}.bind(this);if(char=getIdentifierStart(),null===char)return null;for(id=char;char=getIdentifierPart(),null!==char;)id+=char;switch(id){case\"true\":case\"false\":type=Token.BooleanLiteral;break;case\"null\":type=Token.NullLiteral;break;default:type=Token.Identifier}return{type:type,value:removeEscapeSequences(id),text:id,tokenLength:id.length}},scanNumericLiteral:function(){function isDecimalDigit(str){return/^[0-9]$/.test(str)}function isOctalDigit(str){return/^[0-7]$/.test(str)}function isBinaryDigit(str){return/^[01]$/.test(str)}function isHexDigit(str){return/^[0-9a-fA-F]$/.test(str)}function isIdentifierStart(ch){return\"$\"===ch||\"_\"===ch||\"\\\\\"===ch||ch>=\"a\"&&\"z\">=ch||ch>=\"A\"&&\"Z\">=ch}var bad,index=0,value=\"\",length=this.input.length,char=this.peek(index),isAllowedDigit=isDecimalDigit,base=10,isLegacy=!1;if(\".\"!==char&&!isDecimalDigit(char))return null;if(\".\"!==char){for(value=this.peek(index),index+=1,char=this.peek(index),\"0\"===value&&((\"x\"===char||\"X\"===char)&&(isAllowedDigit=isHexDigit,base=16,index+=1,value+=char),(\"o\"===char||\"O\"===char)&&(isAllowedDigit=isOctalDigit,base=8,state.inES6(!0)||this.trigger(\"warning\",{code:\"W119\",line:this.line,character:this.char,data:[\"Octal integer literal\",\"6\"]}),index+=1,value+=char),(\"b\"===char||\"B\"===char)&&(isAllowedDigit=isBinaryDigit,base=2,state.inES6(!0)||this.trigger(\"warning\",{code:\"W119\",line:this.line,character:this.char,data:[\"Binary integer literal\",\"6\"]}),index+=1,value+=char),isOctalDigit(char)&&(isAllowedDigit=isOctalDigit,base=8,isLegacy=!0,bad=!1,index+=1,value+=char),!isOctalDigit(char)&&isDecimalDigit(char)&&(index+=1,value+=char));length>index;){if(char=this.peek(index),isLegacy&&isDecimalDigit(char))bad=!0;else if(!isAllowedDigit(char))break;value+=char,index+=1}if(isAllowedDigit!==isDecimalDigit)return!isLegacy&&2>=value.length?{type:Token.NumericLiteral,value:value,isMalformed:!0}:length>index&&(char=this.peek(index),isIdentifierStart(char))?null:{type:Token.NumericLiteral,value:value,base:base,isLegacy:isLegacy,isMalformed:!1}}if(\".\"===char)for(value+=char,index+=1;length>index&&(char=this.peek(index),isDecimalDigit(char));)value+=char,index+=1;if(\"e\"===char||\"E\"===char){if(value+=char,index+=1,char=this.peek(index),(\"+\"===char||\"-\"===char)&&(value+=this.peek(index),index+=1),char=this.peek(index),!isDecimalDigit(char))return null;for(value+=char,index+=1;length>index&&(char=this.peek(index),isDecimalDigit(char));)value+=char,index+=1}return length>index&&(char=this.peek(index),isIdentifierStart(char))?null:{type:Token.NumericLiteral,value:value,base:base,isMalformed:!isFinite(value)}},scanEscapeSequence:function(checks){var allowNewLine=!1,jump=1;this.skip();var char=this.peek();switch(char){case\"'\":this.triggerAsync(\"warning\",{code:\"W114\",line:this.line,character:this.char,data:[\"\\\\'\"]},checks,function(){return state.jsonMode});break;case\"b\":char=\"\\\\b\";break;case\"f\":char=\"\\\\f\";break;case\"n\":char=\"\\\\n\";break;case\"r\":char=\"\\\\r\";break;case\"t\":char=\"\\\\t\";break;case\"0\":char=\"\\\\0\";var n=parseInt(this.peek(1),10);this.triggerAsync(\"warning\",{code:\"W115\",line:this.line,character:this.char},checks,function(){return n>=0&&7>=n&&state.isStrict()});break;case\"u\":var hexCode=this.input.substr(1,4),code=parseInt(hexCode,16);isNaN(code)&&this.trigger(\"warning\",{code:\"W052\",line:this.line,character:this.char,data:[\"u\"+hexCode]}),char=String.fromCharCode(code),jump=5;break;case\"v\":this.triggerAsync(\"warning\",{code:\"W114\",line:this.line,character:this.char,data:[\"\\\\v\"]},checks,function(){return state.jsonMode}),char=\"\u000b\";break;case\"x\":var x=parseInt(this.input.substr(1,2),16);this.triggerAsync(\"warning\",{code:\"W114\",line:this.line,character:this.char,data:[\"\\\\x-\"]},checks,function(){return state.jsonMode}),char=String.fromCharCode(x),jump=3;break;case\"\\\\\":char=\"\\\\\\\\\";break;case'\"':char='\\\\\"';break;case\"/\":break;case\"\":allowNewLine=!0,char=\"\"}return{\"char\":char,jump:jump,allowNewLine:allowNewLine}},scanTemplateLiteral:function(checks){var tokenType,ch,value=\"\",startLine=this.line,startChar=this.char,depth=this.templateStarts.length;if(!state.inES6(!0))return null;if(\"`\"===this.peek())tokenType=Token.TemplateHead,this.templateStarts.push({line:this.line,\"char\":this.char}),depth=this.templateStarts.length,this.skip(1),this.pushContext(Context.Template);else{if(!this.inContext(Context.Template)||\"}\"!==this.peek())return null;tokenType=Token.TemplateMiddle}for(;\"`\"!==this.peek();){for(;\"\"===(ch=this.peek());)if(value+=\"\\n\",!this.nextLine()){var startPos=this.templateStarts.pop();return this.trigger(\"error\",{code:\"E052\",line:startPos.line,character:startPos.char}),{type:tokenType,value:value,startLine:startLine,startChar:startChar,isUnclosed:!0,depth:depth,context:this.popContext()}}if(\"$\"===ch&&\"{\"===this.peek(1))return value+=\"${\",this.skip(2),{type:tokenType,value:value,startLine:startLine,startChar:startChar,isUnclosed:!1,depth:depth,context:this.currentContext()};\nif(\"\\\\\"===ch){var escape=this.scanEscapeSequence(checks);value+=escape.char,this.skip(escape.jump)}else\"`\"!==ch&&(value+=ch,this.skip(1))}return tokenType=tokenType===Token.TemplateHead?Token.NoSubstTemplate:Token.TemplateTail,this.skip(1),this.templateStarts.pop(),{type:tokenType,value:value,startLine:startLine,startChar:startChar,isUnclosed:!1,depth:depth,context:this.popContext()}},scanStringLiteral:function(checks){var quote=this.peek();if('\"'!==quote&&\"'\"!==quote)return null;this.triggerAsync(\"warning\",{code:\"W108\",line:this.line,character:this.char},checks,function(){return state.jsonMode&&'\"'!==quote});var value=\"\",startLine=this.line,startChar=this.char,allowNewLine=!1;for(this.skip();this.peek()!==quote;)if(\"\"===this.peek()){if(allowNewLine?(allowNewLine=!1,this.triggerAsync(\"warning\",{code:\"W043\",line:this.line,character:this.char},checks,function(){return!state.option.multistr}),this.triggerAsync(\"warning\",{code:\"W042\",line:this.line,character:this.char},checks,function(){return state.jsonMode&&state.option.multistr})):this.trigger(\"warning\",{code:\"W112\",line:this.line,character:this.char}),!this.nextLine())return this.trigger(\"error\",{code:\"E029\",line:startLine,character:startChar}),{type:Token.StringLiteral,value:value,startLine:startLine,startChar:startChar,isUnclosed:!0,quote:quote}}else{allowNewLine=!1;var char=this.peek(),jump=1;if(\" \">char&&this.trigger(\"warning\",{code:\"W113\",line:this.line,character:this.char,data:[\"<non-printable>\"]}),\"\\\\\"===char){var parsed=this.scanEscapeSequence(checks);char=parsed.char,jump=parsed.jump,allowNewLine=parsed.allowNewLine}value+=char,this.skip(jump)}return this.skip(),{type:Token.StringLiteral,value:value,startLine:startLine,startChar:startChar,isUnclosed:!1,quote:quote}},scanRegExp:function(){var terminated,index=0,length=this.input.length,char=this.peek(),value=char,body=\"\",flags=[],malformed=!1,isCharSet=!1,scanUnexpectedChars=function(){\" \">char&&(malformed=!0,this.trigger(\"warning\",{code:\"W048\",line:this.line,character:this.char})),\"<\"===char&&(malformed=!0,this.trigger(\"warning\",{code:\"W049\",line:this.line,character:this.char,data:[char]}))}.bind(this);if(!this.prereg||\"/\"!==char)return null;for(index+=1,terminated=!1;length>index;)if(char=this.peek(index),value+=char,body+=char,isCharSet)\"]\"===char&&(\"\\\\\"!==this.peek(index-1)||\"\\\\\"===this.peek(index-2))&&(isCharSet=!1),\"\\\\\"===char&&(index+=1,char=this.peek(index),body+=char,value+=char,scanUnexpectedChars()),index+=1;else{if(\"\\\\\"===char){if(index+=1,char=this.peek(index),body+=char,value+=char,scanUnexpectedChars(),\"/\"===char){index+=1;continue}if(\"[\"===char){index+=1;continue}}if(\"[\"!==char){if(\"/\"===char){body=body.substr(0,body.length-1),terminated=!0,index+=1;break}index+=1}else isCharSet=!0,index+=1}if(!terminated)return this.trigger(\"error\",{code:\"E015\",line:this.line,character:this.from}),void this.trigger(\"fatal\",{line:this.line,from:this.from});for(;length>index&&(char=this.peek(index),/[gim]/.test(char));)flags.push(char),value+=char,index+=1;try{RegExp(body,flags.join(\"\"))}catch(err){malformed=!0,this.trigger(\"error\",{code:\"E016\",line:this.line,character:this.char,data:[err.message]})}return{type:Token.RegExp,value:value,flags:flags,isMalformed:malformed}},scanNonBreakingSpaces:function(){return state.option.nonbsp?this.input.search(/(\\u00A0)/):-1},scanUnsafeChars:function(){return this.input.search(reg.unsafeChars)},next:function(checks){this.from=this.char;var start;if(/\\s/.test(this.peek()))for(start=this.char;/\\s/.test(this.peek());)this.from+=1,this.skip();var match=this.scanComments()||this.scanStringLiteral(checks)||this.scanTemplateLiteral(checks);return match?match:(match=this.scanRegExp()||this.scanPunctuator()||this.scanKeyword()||this.scanIdentifier()||this.scanNumericLiteral(),match?(this.skip(match.tokenLength||match.value.length),match):null)},nextLine:function(){var char;if(this.line>=this.getLines().length)return!1;this.input=this.getLines()[this.line],this.line+=1,this.char=1,this.from=1;var inputTrimmed=this.input.trim(),startsWith=function(){return _.some(arguments,function(prefix){return 0===inputTrimmed.indexOf(prefix)})},endsWith=function(){return _.some(arguments,function(suffix){return-1!==inputTrimmed.indexOf(suffix,inputTrimmed.length-suffix.length)})};if(this.ignoringLinterErrors===!0&&(startsWith(\"/*\",\"//\")||this.inComment&&endsWith(\"*/\")||(this.input=\"\")),char=this.scanNonBreakingSpaces(),char>=0&&this.trigger(\"warning\",{code:\"W125\",line:this.line,character:char+1}),this.input=this.input.replace(/\\t/g,state.tab),char=this.scanUnsafeChars(),char>=0&&this.trigger(\"warning\",{code:\"W100\",line:this.line,character:char}),!this.ignoringLinterErrors&&state.option.maxlen&&state.option.maxlen<this.input.length){var inComment=this.inComment||startsWith.call(inputTrimmed,\"//\")||startsWith.call(inputTrimmed,\"/*\"),shouldTriggerError=!inComment||!reg.maxlenException.test(inputTrimmed);shouldTriggerError&&this.trigger(\"warning\",{code:\"W101\",line:this.line,character:this.input.length})}return!0},start:function(){this.nextLine()},token:function(){function isReserved(token,isProperty){if(!token.reserved)return!1;var meta=token.meta;if(meta&&meta.isFutureReservedWord&&state.inES5()){if(!meta.es5)return!1;if(meta.strictOnly&&!state.option.strict&&!state.isStrict())return!1;if(isProperty)return!1}return!0}for(var token,checks=asyncTrigger(),create=function(type,value,isProperty,token){var obj;if(\"(endline)\"!==type&&\"(end)\"!==type&&(this.prereg=!1),\"(punctuator)\"===type){switch(value){case\".\":case\")\":case\"~\":case\"#\":case\"]\":case\"++\":case\"--\":this.prereg=!1;break;default:this.prereg=!0}obj=Object.create(state.syntax[value]||state.syntax[\"(error)\"])}return\"(identifier)\"===type&&((\"return\"===value||\"case\"===value||\"typeof\"===value)&&(this.prereg=!0),_.has(state.syntax,value)&&(obj=Object.create(state.syntax[value]||state.syntax[\"(error)\"]),isReserved(obj,isProperty&&\"(identifier)\"===type)||(obj=null))),obj||(obj=Object.create(state.syntax[type])),obj.identifier=\"(identifier)\"===type,obj.type=obj.type||type,obj.value=value,obj.line=this.line,obj.character=this.char,obj.from=this.from,obj.identifier&&token&&(obj.raw_text=token.text||token.value),token&&token.startLine&&token.startLine!==this.line&&(obj.startLine=token.startLine),token&&token.context&&(obj.context=token.context),token&&token.depth&&(obj.depth=token.depth),token&&token.isUnclosed&&(obj.isUnclosed=token.isUnclosed),isProperty&&obj.identifier&&(obj.isProperty=isProperty),obj.check=checks.check,obj}.bind(this);;){if(!this.input.length)return this.nextLine()?create(\"(endline)\",\"\"):this.exhausted?null:(this.exhausted=!0,create(\"(end)\",\"\"));if(token=this.next(checks))switch(token.type){case Token.StringLiteral:return this.triggerAsync(\"String\",{line:this.line,\"char\":this.char,from:this.from,startLine:token.startLine,startChar:token.startChar,value:token.value,quote:token.quote},checks,function(){return!0}),create(\"(string)\",token.value,null,token);case Token.TemplateHead:return this.trigger(\"TemplateHead\",{line:this.line,\"char\":this.char,from:this.from,startLine:token.startLine,startChar:token.startChar,value:token.value}),create(\"(template)\",token.value,null,token);case Token.TemplateMiddle:return this.trigger(\"TemplateMiddle\",{line:this.line,\"char\":this.char,from:this.from,startLine:token.startLine,startChar:token.startChar,value:token.value}),create(\"(template middle)\",token.value,null,token);case Token.TemplateTail:return this.trigger(\"TemplateTail\",{line:this.line,\"char\":this.char,from:this.from,startLine:token.startLine,startChar:token.startChar,value:token.value}),create(\"(template tail)\",token.value,null,token);case Token.NoSubstTemplate:return this.trigger(\"NoSubstTemplate\",{line:this.line,\"char\":this.char,from:this.from,startLine:token.startLine,startChar:token.startChar,value:token.value}),create(\"(no subst template)\",token.value,null,token);case Token.Identifier:this.triggerAsync(\"Identifier\",{line:this.line,\"char\":this.char,from:this.form,name:token.value,raw_name:token.text,isProperty:\".\"===state.tokens.curr.id},checks,function(){return!0});case Token.Keyword:case Token.NullLiteral:case Token.BooleanLiteral:return create(\"(identifier)\",token.value,\".\"===state.tokens.curr.id,token);case Token.NumericLiteral:return token.isMalformed&&this.trigger(\"warning\",{code:\"W045\",line:this.line,character:this.char,data:[token.value]}),this.triggerAsync(\"warning\",{code:\"W114\",line:this.line,character:this.char,data:[\"0x-\"]},checks,function(){return 16===token.base&&state.jsonMode}),this.triggerAsync(\"warning\",{code:\"W115\",line:this.line,character:this.char},checks,function(){return state.isStrict()&&8===token.base&&token.isLegacy}),this.trigger(\"Number\",{line:this.line,\"char\":this.char,from:this.from,value:token.value,base:token.base,isMalformed:token.malformed}),create(\"(number)\",token.value);case Token.RegExp:return create(\"(regexp)\",token.value);case Token.Comment:if(state.tokens.curr.comment=!0,token.isSpecial)return{id:\"(comment)\",value:token.value,body:token.body,type:token.commentType,isSpecial:token.isSpecial,line:this.line,character:this.char,from:this.from};break;case\"\":break;default:return create(\"(punctuator)\",token.value)}else this.input.length&&(this.trigger(\"error\",{code:\"E024\",line:this.line,character:this.char,data:[this.peek()]}),this.input=\"\")}}},exports.Lexer=Lexer,exports.Context=Context},{\"../data/ascii-identifier-data.js\":\"/node_modules/jshint/data/ascii-identifier-data.js\",\"../lodash\":\"/node_modules/jshint/lodash.js\",\"./reg.js\":\"/node_modules/jshint/src/reg.js\",\"./state.js\":\"/node_modules/jshint/src/state.js\",events:\"/node_modules/browserify/node_modules/events/events.js\"}],\"/node_modules/jshint/src/messages.js\":[function(_dereq_,module,exports){\"use strict\";var _=_dereq_(\"../lodash\"),errors={E001:\"Bad option: '{a}'.\",E002:\"Bad option value.\",E003:\"Expected a JSON value.\",E004:\"Input is neither a string nor an array of strings.\",E005:\"Input is empty.\",E006:\"Unexpected early end of program.\",E007:'Missing \"use strict\" statement.',E008:\"Strict violation.\",E009:\"Option 'validthis' can't be used in a global scope.\",E010:\"'with' is not allowed in strict mode.\",E011:\"'{a}' has already been declared.\",E012:\"const '{a}' is initialized to 'undefined'.\",E013:\"Attempting to override '{a}' which is a constant.\",E014:\"A regular expression literal can be confused with '/='.\",E015:\"Unclosed regular expression.\",E016:\"Invalid regular expression.\",E017:\"Unclosed comment.\",E018:\"Unbegun comment.\",E019:\"Unmatched '{a}'.\",E020:\"Expected '{a}' to match '{b}' from line {c} and instead saw '{d}'.\",E021:\"Expected '{a}' and instead saw '{b}'.\",E022:\"Line breaking error '{a}'.\",E023:\"Missing '{a}'.\",E024:\"Unexpected '{a}'.\",E025:\"Missing ':' on a case clause.\",E026:\"Missing '}' to match '{' from line {a}.\",E027:\"Missing ']' to match '[' from line {a}.\",E028:\"Illegal comma.\",E029:\"Unclosed string.\",E030:\"Expected an identifier and instead saw '{a}'.\",E031:\"Bad assignment.\",E032:\"Expected a small integer or 'false' and instead saw '{a}'.\",E033:\"Expected an operator and instead saw '{a}'.\",E034:\"get/set are ES5 features.\",E035:\"Missing property name.\",E036:\"Expected to see a statement and instead saw a block.\",E037:null,E038:null,E039:\"Function declarations are not invocable. Wrap the whole function invocation in parens.\",E040:\"Each value should have its own case label.\",E041:\"Unrecoverable syntax error.\",E042:\"Stopping.\",E043:\"Too many errors.\",E044:null,E045:\"Invalid for each loop.\",E046:\"A yield statement shall be within a generator function (with syntax: `function*`)\",E047:null,E048:\"{a} declaration not directly within block.\",E049:\"A {a} cannot be named '{b}'.\",E050:\"Mozilla acequires the yield expression to be parenthesized here.\",E051:null,E052:\"Unclosed template literal.\",E053:\"Export declaration must be in global scope.\",E054:\"Class properties must be methods. Expected '(' but instead saw '{a}'.\",E055:\"The '{a}' option cannot be set after any executable code.\",E056:\"'{a}' was used before it was declared, which is illegal for '{b}' variables.\",E057:\"Invalid meta property: '{a}.{b}'.\",E058:\"Missing semicolon.\"},warnings={W001:\"'hasOwnProperty' is a really bad name.\",W002:\"Value of '{a}' may be overwritten in IE 8 and earlier.\",W003:\"'{a}' was used before it was defined.\",W004:\"'{a}' is already defined.\",W005:\"A dot following a number can be confused with a decimal point.\",W006:\"Confusing minuses.\",W007:\"Confusing plusses.\",W008:\"A leading decimal point can be confused with a dot: '{a}'.\",W009:\"The array literal notation [] is preferable.\",W010:\"The object literal notation {} is preferable.\",W011:null,W012:null,W013:null,W014:\"Bad line breaking before '{a}'.\",W015:null,W016:\"Unexpected use of '{a}'.\",W017:\"Bad operand.\",W018:\"Confusing use of '{a}'.\",W019:\"Use the isNaN function to compare with NaN.\",W020:\"Read only.\",W021:\"Reassignment of '{a}', which is is a {b}. Use 'var' or 'let' to declare bindings that may change.\",W022:\"Do not assign to the exception parameter.\",W023:\"Expected an identifier in an assignment and instead saw a function invocation.\",W024:\"Expected an identifier and instead saw '{a}' (a reserved word).\",W025:\"Missing name in function declaration.\",W026:\"Inner functions should be listed at the top of the outer function.\",W027:\"Unreachable '{a}' after '{b}'.\",W028:\"Label '{a}' on {b} statement.\",W030:\"Expected an assignment or function call and instead saw an expression.\",W031:\"Do not use 'new' for side effects.\",W032:\"Unnecessary semicolon.\",W033:\"Missing semicolon.\",W034:'Unnecessary directive \"{a}\".',W035:\"Empty block.\",W036:\"Unexpected /*member '{a}'.\",W037:\"'{a}' is a statement label.\",W038:\"'{a}' used out of scope.\",W039:\"'{a}' is not allowed.\",W040:\"Possible strict violation.\",W041:\"Use '{a}' to compare with '{b}'.\",W042:\"Avoid EOL escaping.\",W043:\"Bad escaping of EOL. Use option multistr if needed.\",W044:\"Bad or unnecessary escaping.\",W045:\"Bad number '{a}'.\",W046:\"Don't use extra leading zeros '{a}'.\",W047:\"A trailing decimal point can be confused with a dot: '{a}'.\",W048:\"Unexpected control character in regular expression.\",W049:\"Unexpected escaped character '{a}' in regular expression.\",W050:\"JavaScript URL.\",W051:\"Variables should not be deleted.\",W052:\"Unexpected '{a}'.\",W053:\"Do not use {a} as a constructor.\",W054:\"The Function constructor is a form of eval.\",W055:\"A constructor name should start with an uppercase letter.\",W056:\"Bad constructor.\",W057:\"Weird construction. Is 'new' necessary?\",W058:\"Missing '()' invoking a constructor.\",W059:\"Avoid arguments.{a}.\",W060:\"document.write can be a form of eval.\",W061:\"eval can be harmful.\",W062:\"Wrap an immediate function invocation in parens to assist the reader in understanding that the expression is the result of a function, and not the function itself.\",W063:\"Math is not a function.\",W064:\"Missing 'new' prefix when invoking a constructor.\",W065:\"Missing radix parameter.\",W066:\"Implied eval. Consider passing a function instead of a string.\",W067:\"Bad invocation.\",W068:\"Wrapping non-IIFE function literals in parens is unnecessary.\",W069:\"['{a}'] is better written in dot notation.\",W070:\"Extra comma. (it breaks older versions of IE)\",W071:\"This function has too many statements. ({a})\",W072:\"This function has too many parameters. ({a})\",W073:\"Blocks are nested too deeply. ({a})\",W074:\"This function's cyclomatic complexity is too high. ({a})\",W075:\"Duplicate {a} '{b}'.\",W076:\"Unexpected parameter '{a}' in get {b} function.\",W077:\"Expected a single parameter in set {a} function.\",W078:\"Setter is defined without getter.\",W079:\"Redefinition of '{a}'.\",W080:\"It's not necessary to initialize '{a}' to 'undefined'.\",W081:null,W082:\"Function declarations should not be placed in blocks. Use a function expression or move the statement to the top of the outer function.\",W083:\"Don't make functions within a loop.\",W084:\"Assignment in conditional expression\",W085:\"Don't use 'with'.\",W086:\"Expected a 'break' statement before '{a}'.\",W087:\"Forgotten 'debugger' statement?\",W088:\"Creating global 'for' variable. Should be 'for (var {a} ...'.\",W089:\"The body of a for in should be wrapped in an if statement to filter unwanted properties from the prototype.\",W090:\"'{a}' is not a statement label.\",W091:null,W093:\"Did you mean to return a conditional instead of an assignment?\",W094:\"Unexpected comma.\",W095:\"Expected a string and instead saw {a}.\",W096:\"The '{a}' key may produce unexpected results.\",W097:'Use the function form of \"use strict\".',W098:\"'{a}' is defined but never used.\",W099:null,W100:\"This character may get silently deleted by one or more browsers.\",W101:\"Line is too long.\",W102:null,W103:\"The '{a}' property is deprecated.\",W104:\"'{a}' is available in ES{b} (use 'esversion: {b}') or Mozilla JS extensions (use moz).\",W105:\"Unexpected {a} in '{b}'.\",W106:\"Identifier '{a}' is not in camel case.\",W107:\"Script URL.\",W108:\"Strings must use doublequote.\",W109:\"Strings must use singlequote.\",W110:\"Mixed double and single quotes.\",W112:\"Unclosed string.\",W113:\"Control character in string: {a}.\",W114:\"Avoid {a}.\",W115:\"Octal literals are not allowed in strict mode.\",W116:\"Expected '{a}' and instead saw '{b}'.\",W117:\"'{a}' is not defined.\",W118:\"'{a}' is only available in Mozilla JavaScript extensions (use moz option).\",W119:\"'{a}' is only available in ES{b} (use 'esversion: {b}').\",W120:\"You might be leaking a variable ({a}) here.\",W121:\"Extending prototype of native object: '{a}'.\",W122:\"Invalid typeof value '{a}'\",W123:\"'{a}' is already defined in outer scope.\",W124:\"A generator function shall contain a yield statement.\",W125:\"This line contains non-breaking spaces: http://jshint.com/doc/options/#nonbsp\",W126:\"Unnecessary grouping operator.\",W127:\"Unexpected use of a comma operator.\",W128:\"Empty array elements acequire elision=true.\",W129:\"'{a}' is defined in a future version of JavaScript. Use a different variable name to avoid migration issues.\",W130:\"Invalid element after rest element.\",W131:\"Invalid parameter after rest parameter.\",W132:\"`var` declarations are forbidden. Use `let` or `const` instead.\",W133:\"Invalid for-{a} loop left-hand-side: {b}.\",W134:\"The '{a}' option is only available when linting ECMAScript {b} code.\",W135:\"{a} may not be supported by non-browser environments.\",W136:\"'{a}' must be in function scope.\",W137:\"Empty destructuring.\",W138:\"Regular parameters should not come after default parameters.\"},info={I001:\"Comma warnings can be turned off with 'laxcomma'.\",I002:null,I003:\"ES5 option is now set per default\"};exports.errors={},exports.warnings={},exports.info={},_.each(errors,function(desc,code){exports.errors[code]={code:code,desc:desc}}),_.each(warnings,function(desc,code){exports.warnings[code]={code:code,desc:desc}}),_.each(info,function(desc,code){exports.info[code]={code:code,desc:desc}})},{\"../lodash\":\"/node_modules/jshint/lodash.js\"}],\"/node_modules/jshint/src/name-stack.js\":[function(_dereq_,module){\"use strict\";function NameStack(){this._stack=[]}Object.defineProperty(NameStack.prototype,\"length\",{get:function(){return this._stack.length}}),NameStack.prototype.push=function(){this._stack.push(null)},NameStack.prototype.pop=function(){this._stack.pop()},NameStack.prototype.set=function(token){this._stack[this.length-1]=token},NameStack.prototype.infer=function(){var type,nameToken=this._stack[this.length-1],prefix=\"\";return nameToken&&\"class\"!==nameToken.type||(nameToken=this._stack[this.length-2]),nameToken?(type=nameToken.type,\"(string)\"!==type&&\"(number)\"!==type&&\"(identifier)\"!==type&&\"default\"!==type?\"(expression)\":(nameToken.accessorType&&(prefix=nameToken.accessorType+\" \"),prefix+nameToken.value)):\"(empty)\"},module.exports=NameStack},{}],\"/node_modules/jshint/src/options.js\":[function(_dereq_,module,exports){\"use strict\";exports.bool={enforcing:{bitwise:!0,freeze:!0,camelcase:!0,curly:!0,eqeqeq:!0,futurehostile:!0,notypeof:!0,es3:!0,es5:!0,forin:!0,funcscope:!0,immed:!0,iterator:!0,newcap:!0,noarg:!0,nocomma:!0,noempty:!0,nonbsp:!0,nonew:!0,undef:!0,singleGroups:!1,varstmt:!1,enforceall:!1},relaxing:{asi:!0,multistr:!0,debug:!0,boss:!0,evil:!0,globalstrict:!0,plusplus:!0,proto:!0,scripturl:!0,sub:!0,supernew:!0,laxbreak:!0,laxcomma:!0,validthis:!0,withstmt:!0,moz:!0,noyield:!0,eqnull:!0,lastsemic:!0,loopfunc:!0,expr:!0,esnext:!0,elision:!0},environments:{mootools:!0,couch:!0,jasmine:!0,jquery:!0,node:!0,qunit:!0,rhino:!0,shelljs:!0,prototypejs:!0,yui:!0,mocha:!0,module:!0,wsh:!0,worker:!0,nonstandard:!0,browser:!0,browserify:!0,devel:!0,dojo:!0,typed:!0,phantom:!0},obsolete:{onecase:!0,regexp:!0,regexdash:!0}},exports.val={maxlen:!1,indent:!1,maxerr:!1,predef:!1,globals:!1,quotmark:!1,scope:!1,maxstatements:!1,maxdepth:!1,maxparams:!1,maxcomplexity:!1,shadow:!1,strict:!0,unused:!0,latedef:!1,ignore:!1,ignoreDelimiters:!1,esversion:5},exports.inverted={bitwise:!0,forin:!0,newcap:!0,plusplus:!0,regexp:!0,undef:!0,eqeqeq:!0,strict:!0},exports.validNames=Object.keys(exports.val).concat(Object.keys(exports.bool.relaxing)).concat(Object.keys(exports.bool.enforcing)).concat(Object.keys(exports.bool.obsolete)).concat(Object.keys(exports.bool.environments)),exports.renamed={eqeq:\"eqeqeq\",windows:\"wsh\",sloppy:\"strict\"},exports.removed={nomen:!0,onevar:!0,passfail:!0,white:!0,gcl:!0,smarttabs:!0,trailing:!0},exports.noenforceall={varstmt:!0,strict:!0}},{}],\"/node_modules/jshint/src/reg.js\":[function(_dereq_,module,exports){\"use strict\";exports.unsafeString=/@cc|<\\/?|script|\\]\\s*\\]|<\\s*!|&lt/i,exports.unsafeChars=/[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/,exports.needEsc=/[\\u0000-\\u001f&<\"\\/\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/,exports.needEscGlobal=/[\\u0000-\\u001f&<\"\\/\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,exports.starSlash=/\\*\\//,exports.identifier=/^([a-zA-Z_$][a-zA-Z0-9_$]*)$/,exports.javascriptURL=/^(?:javascript|jscript|ecmascript|vbscript|livescript)\\s*:/i,exports.fallsThrough=/^\\s*falls?\\sthrough\\s*$/,exports.maxlenException=/^(?:(?:\\/\\/|\\/\\*|\\*) ?)?[^ ]+$/},{}],\"/node_modules/jshint/src/scope-manager.js\":[function(_dereq_,module){\"use strict\";var _=_dereq_(\"../lodash\"),events=_dereq_(\"events\"),marker={},scopeManager=function(state,predefined,exported,declared){function _newScope(type){_current={\"(labels)\":Object.create(null),\"(usages)\":Object.create(null),\"(breakLabels)\":Object.create(null),\"(parent)\":_current,\"(type)\":type,\"(params)\":\"functionparams\"===type||\"catchparams\"===type?[]:null},_scopeStack.push(_current)}function warning(code,token){emitter.emit(\"warning\",{code:code,token:token,data:_.slice(arguments,2)})}function error(code,token){emitter.emit(\"warning\",{code:code,token:token,data:_.slice(arguments,2)})}function _setupUsages(labelName){_current[\"(usages)\"][labelName]||(_current[\"(usages)\"][labelName]={\"(modified)\":[],\"(reassigned)\":[],\"(tokens)\":[]})}function _checkForUnused(){if(\"functionparams\"===_current[\"(type)\"])return _checkParams(),void 0;var curentLabels=_current[\"(labels)\"];for(var labelName in curentLabels)curentLabels[labelName]&&\"exception\"!==curentLabels[labelName][\"(type)\"]&&curentLabels[labelName][\"(unused)\"]&&_warnUnused(labelName,curentLabels[labelName][\"(token)\"],\"var\")}function _checkParams(){var params=_current[\"(params)\"];if(params)for(var unused_opt,param=params.pop();param;){var label=_current[\"(labels)\"][param];if(unused_opt=_getUnusedOption(state.funct[\"(unusedOption)\"]),\"undefined\"===param)return;if(label[\"(unused)\"])_warnUnused(param,label[\"(token)\"],\"param\",state.funct[\"(unusedOption)\"]);else if(\"last-param\"===unused_opt)return;param=params.pop()}}function _getLabel(labelName){for(var i=_scopeStack.length-1;i>=0;--i){var scopeLabels=_scopeStack[i][\"(labels)\"];if(scopeLabels[labelName])return scopeLabels}}function usedSoFarInCurrentFunction(labelName){for(var i=_scopeStack.length-1;i>=0;i--){var current=_scopeStack[i];if(current[\"(usages)\"][labelName])return current[\"(usages)\"][labelName];if(current===_currentFunctBody)break}return!1}function _checkOuterShadow(labelName,token){if(\"outer\"===state.option.shadow)for(var isGlobal=\"global\"===_currentFunctBody[\"(type)\"],isNewFunction=\"functionparams\"===_current[\"(type)\"],outsideCurrentFunction=!isGlobal,i=0;_scopeStack.length>i;i++){var stackItem=_scopeStack[i];isNewFunction||_scopeStack[i+1]!==_currentFunctBody||(outsideCurrentFunction=!1),outsideCurrentFunction&&stackItem[\"(labels)\"][labelName]&&warning(\"W123\",token,labelName),stackItem[\"(breakLabels)\"][labelName]&&warning(\"W123\",token,labelName)}}function _latedefWarning(type,labelName,token){state.option.latedef&&(state.option.latedef===!0&&\"function\"===type||\"function\"!==type)&&warning(\"W003\",token,labelName)}var _current,_scopeStack=[];_newScope(\"global\"),_current[\"(predefined)\"]=predefined;var _currentFunctBody=_current,usedPredefinedAndGlobals=Object.create(null),impliedGlobals=Object.create(null),unuseds=[],emitter=new events.EventEmitter,_getUnusedOption=function(unused_opt){return void 0===unused_opt&&(unused_opt=state.option.unused),unused_opt===!0&&(unused_opt=\"last-param\"),unused_opt},_warnUnused=function(name,tkn,type,unused_opt){var line=tkn.line,chr=tkn.from,raw_name=tkn.raw_text||name;unused_opt=_getUnusedOption(unused_opt);var warnable_types={vars:[\"var\"],\"last-param\":[\"var\",\"param\"],strict:[\"var\",\"param\",\"last-param\"]};unused_opt&&warnable_types[unused_opt]&&-1!==warnable_types[unused_opt].indexOf(type)&&warning(\"W098\",{line:line,from:chr},raw_name),(unused_opt||\"var\"===type)&&unuseds.push({name:name,line:line,character:chr})},scopeManagerInst={on:function(names,listener){names.split(\" \").forEach(function(name){emitter.on(name,listener)})},isPredefined:function(labelName){return!this.has(labelName)&&_.has(_scopeStack[0][\"(predefined)\"],labelName)},stack:function(type){var previousScope=_current;_newScope(type),type||\"functionparams\"!==previousScope[\"(type)\"]||(_current[\"(isFuncBody)\"]=!0,_current[\"(context)\"]=_currentFunctBody,_currentFunctBody=_current)},unstack:function(){var i,j,subScope=_scopeStack.length>1?_scopeStack[_scopeStack.length-2]:null,isUnstackingFunctionBody=_current===_currentFunctBody,isUnstackingFunctionParams=\"functionparams\"===_current[\"(type)\"],isUnstackingFunctionOuter=\"functionouter\"===_current[\"(type)\"],currentUsages=_current[\"(usages)\"],currentLabels=_current[\"(labels)\"],usedLabelNameList=Object.keys(currentUsages);for(currentUsages.__proto__&&-1===usedLabelNameList.indexOf(\"__proto__\")&&usedLabelNameList.push(\"__proto__\"),i=0;usedLabelNameList.length>i;i++){var usedLabelName=usedLabelNameList[i],usage=currentUsages[usedLabelName],usedLabel=currentLabels[usedLabelName];if(usedLabel){var usedLabelType=usedLabel[\"(type)\"];if(usedLabel[\"(useOutsideOfScope)\"]&&!state.option.funcscope){var usedTokens=usage[\"(tokens)\"];if(usedTokens)for(j=0;usedTokens.length>j;j++)usedLabel[\"(function)\"]===usedTokens[j][\"(function)\"]&&error(\"W038\",usedTokens[j],usedLabelName)}if(_current[\"(labels)\"][usedLabelName][\"(unused)\"]=!1,\"const\"===usedLabelType&&usage[\"(modified)\"])for(j=0;usage[\"(modified)\"].length>j;j++)error(\"E013\",usage[\"(modified)\"][j],usedLabelName);if((\"function\"===usedLabelType||\"class\"===usedLabelType)&&usage[\"(reassigned)\"])for(j=0;usage[\"(reassigned)\"].length>j;j++)error(\"W021\",usage[\"(reassigned)\"][j],usedLabelName,usedLabelType)}else if(isUnstackingFunctionOuter&&(state.funct[\"(isCapturing)\"]=!0),subScope)if(subScope[\"(usages)\"][usedLabelName]){var subScopeUsage=subScope[\"(usages)\"][usedLabelName];subScopeUsage[\"(modified)\"]=subScopeUsage[\"(modified)\"].concat(usage[\"(modified)\"]),subScopeUsage[\"(tokens)\"]=subScopeUsage[\"(tokens)\"].concat(usage[\"(tokens)\"]),subScopeUsage[\"(reassigned)\"]=subScopeUsage[\"(reassigned)\"].concat(usage[\"(reassigned)\"]),subScopeUsage[\"(onlyUsedSubFunction)\"]=!1}else subScope[\"(usages)\"][usedLabelName]=usage,isUnstackingFunctionBody&&(subScope[\"(usages)\"][usedLabelName][\"(onlyUsedSubFunction)\"]=!0);else if(\"boolean\"==typeof _current[\"(predefined)\"][usedLabelName]){if(delete declared[usedLabelName],usedPredefinedAndGlobals[usedLabelName]=marker,_current[\"(predefined)\"][usedLabelName]===!1&&usage[\"(reassigned)\"])for(j=0;usage[\"(reassigned)\"].length>j;j++)warning(\"W020\",usage[\"(reassigned)\"][j])}else if(usage[\"(tokens)\"])for(j=0;usage[\"(tokens)\"].length>j;j++){var undefinedToken=usage[\"(tokens)\"][j];undefinedToken.forgiveUndef||(state.option.undef&&!undefinedToken.ignoreUndef&&warning(\"W117\",undefinedToken,usedLabelName),impliedGlobals[usedLabelName]?impliedGlobals[usedLabelName].line.push(undefinedToken.line):impliedGlobals[usedLabelName]={name:usedLabelName,line:[undefinedToken.line]})}}if(subScope||Object.keys(declared).forEach(function(labelNotUsed){_warnUnused(labelNotUsed,declared[labelNotUsed],\"var\")}),subScope&&!isUnstackingFunctionBody&&!isUnstackingFunctionParams&&!isUnstackingFunctionOuter){var labelNames=Object.keys(currentLabels);for(i=0;labelNames.length>i;i++){var defLabelName=labelNames[i];currentLabels[defLabelName][\"(blockscoped)\"]||\"exception\"===currentLabels[defLabelName][\"(type)\"]||this.funct.has(defLabelName,{excludeCurrent:!0})||(subScope[\"(labels)\"][defLabelName]=currentLabels[defLabelName],\"global\"!==_currentFunctBody[\"(type)\"]&&(subScope[\"(labels)\"][defLabelName][\"(useOutsideOfScope)\"]=!0),delete currentLabels[defLabelName])}}_checkForUnused(),_scopeStack.pop(),isUnstackingFunctionBody&&(_currentFunctBody=_scopeStack[_.findLastIndex(_scopeStack,function(scope){return scope[\"(isFuncBody)\"]||\"global\"===scope[\"(type)\"]})]),_current=subScope},addParam:function(labelName,token,type){if(type=type||\"param\",\"exception\"===type){var previouslyDefinedLabelType=this.funct.labeltype(labelName);previouslyDefinedLabelType&&\"exception\"!==previouslyDefinedLabelType&&(state.option.node||warning(\"W002\",state.tokens.next,labelName))}if(_.has(_current[\"(labels)\"],labelName)?_current[\"(labels)\"][labelName].duplicated=!0:(_checkOuterShadow(labelName,token,type),_current[\"(labels)\"][labelName]={\"(type)\":type,\"(token)\":token,\"(unused)\":!0},_current[\"(params)\"].push(labelName)),_.has(_current[\"(usages)\"],labelName)){var usage=_current[\"(usages)\"][labelName];usage[\"(onlyUsedSubFunction)\"]?_latedefWarning(type,labelName,token):warning(\"E056\",token,labelName,type)}},validateParams:function(){if(\"global\"!==_currentFunctBody[\"(type)\"]){var isStrict=state.isStrict(),currentFunctParamScope=_currentFunctBody[\"(parent)\"];currentFunctParamScope[\"(params)\"]&&currentFunctParamScope[\"(params)\"].forEach(function(labelName){var label=currentFunctParamScope[\"(labels)\"][labelName];label&&label.duplicated&&(isStrict?warning(\"E011\",label[\"(token)\"],labelName):state.option.shadow!==!0&&warning(\"W004\",label[\"(token)\"],labelName))})}},getUsedOrDefinedGlobals:function(){var list=Object.keys(usedPredefinedAndGlobals);return usedPredefinedAndGlobals.__proto__===marker&&-1===list.indexOf(\"__proto__\")&&list.push(\"__proto__\"),list},getImpliedGlobals:function(){var values=_.values(impliedGlobals),hasProto=!1;return impliedGlobals.__proto__&&(hasProto=values.some(function(value){return\"__proto__\"===value.name}),hasProto||values.push(impliedGlobals.__proto__)),values},getUnuseds:function(){return unuseds},has:function(labelName){return Boolean(_getLabel(labelName))},labeltype:function(labelName){var scopeLabels=_getLabel(labelName);return scopeLabels?scopeLabels[labelName][\"(type)\"]:null},addExported:function(labelName){var globalLabels=_scopeStack[0][\"(labels)\"];if(_.has(declared,labelName))delete declared[labelName];else if(_.has(globalLabels,labelName))globalLabels[labelName][\"(unused)\"]=!1;else{for(var i=1;_scopeStack.length>i;i++){var scope=_scopeStack[i];if(scope[\"(type)\"])break;if(_.has(scope[\"(labels)\"],labelName)&&!scope[\"(labels)\"][labelName][\"(blockscoped)\"])return scope[\"(labels)\"][labelName][\"(unused)\"]=!1,void 0}exported[labelName]=!0}},setExported:function(labelName,token){this.block.use(labelName,token)\n},addlabel:function(labelName,opts){var type=opts.type,token=opts.token,isblockscoped=\"let\"===type||\"const\"===type||\"class\"===type,isexported=\"global\"===(isblockscoped?_current:_currentFunctBody)[\"(type)\"]&&_.has(exported,labelName);if(_checkOuterShadow(labelName,token,type),isblockscoped){var declaredInCurrentScope=_current[\"(labels)\"][labelName];if(declaredInCurrentScope||_current!==_currentFunctBody||\"global\"===_current[\"(type)\"]||(declaredInCurrentScope=!!_currentFunctBody[\"(parent)\"][\"(labels)\"][labelName]),!declaredInCurrentScope&&_current[\"(usages)\"][labelName]){var usage=_current[\"(usages)\"][labelName];usage[\"(onlyUsedSubFunction)\"]?_latedefWarning(type,labelName,token):warning(\"E056\",token,labelName,type)}declaredInCurrentScope?warning(\"E011\",token,labelName):\"outer\"===state.option.shadow&&scopeManagerInst.funct.has(labelName)&&warning(\"W004\",token,labelName),scopeManagerInst.block.add(labelName,type,token,!isexported)}else{var declaredInCurrentFunctionScope=scopeManagerInst.funct.has(labelName);!declaredInCurrentFunctionScope&&usedSoFarInCurrentFunction(labelName)&&_latedefWarning(type,labelName,token),scopeManagerInst.funct.has(labelName,{onlyBlockscoped:!0})?warning(\"E011\",token,labelName):state.option.shadow!==!0&&declaredInCurrentFunctionScope&&\"__proto__\"!==labelName&&\"global\"!==_currentFunctBody[\"(type)\"]&&warning(\"W004\",token,labelName),scopeManagerInst.funct.add(labelName,type,token,!isexported),\"global\"===_currentFunctBody[\"(type)\"]&&(usedPredefinedAndGlobals[labelName]=marker)}},funct:{labeltype:function(labelName,options){for(var onlyBlockscoped=options&&options.onlyBlockscoped,excludeParams=options&&options.excludeParams,currentScopeIndex=_scopeStack.length-(options&&options.excludeCurrent?2:1),i=currentScopeIndex;i>=0;i--){var current=_scopeStack[i];if(current[\"(labels)\"][labelName]&&(!onlyBlockscoped||current[\"(labels)\"][labelName][\"(blockscoped)\"]))return current[\"(labels)\"][labelName][\"(type)\"];var scopeCheck=excludeParams?_scopeStack[i-1]:current;if(scopeCheck&&\"functionparams\"===scopeCheck[\"(type)\"])return null}return null},hasBreakLabel:function(labelName){for(var i=_scopeStack.length-1;i>=0;i--){var current=_scopeStack[i];if(current[\"(breakLabels)\"][labelName])return!0;if(\"functionparams\"===current[\"(type)\"])return!1}return!1},has:function(labelName,options){return Boolean(this.labeltype(labelName,options))},add:function(labelName,type,tok,unused){_current[\"(labels)\"][labelName]={\"(type)\":type,\"(token)\":tok,\"(blockscoped)\":!1,\"(function)\":_currentFunctBody,\"(unused)\":unused}}},block:{isGlobal:function(){return\"global\"===_current[\"(type)\"]},use:function(labelName,token){var paramScope=_currentFunctBody[\"(parent)\"];paramScope&&paramScope[\"(labels)\"][labelName]&&\"param\"===paramScope[\"(labels)\"][labelName][\"(type)\"]&&(scopeManagerInst.funct.has(labelName,{excludeParams:!0,onlyBlockscoped:!0})||(paramScope[\"(labels)\"][labelName][\"(unused)\"]=!1)),token&&(state.ignored.W117||state.option.undef===!1)&&(token.ignoreUndef=!0),_setupUsages(labelName),token&&(token[\"(function)\"]=_currentFunctBody,_current[\"(usages)\"][labelName][\"(tokens)\"].push(token))},reassign:function(labelName,token){this.modify(labelName,token),_current[\"(usages)\"][labelName][\"(reassigned)\"].push(token)},modify:function(labelName,token){_setupUsages(labelName),_current[\"(usages)\"][labelName][\"(modified)\"].push(token)},add:function(labelName,type,tok,unused){_current[\"(labels)\"][labelName]={\"(type)\":type,\"(token)\":tok,\"(blockscoped)\":!0,\"(unused)\":unused}},addBreakLabel:function(labelName,opts){var token=opts.token;scopeManagerInst.funct.hasBreakLabel(labelName)?warning(\"E011\",token,labelName):\"outer\"===state.option.shadow&&(scopeManagerInst.funct.has(labelName)?warning(\"W004\",token,labelName):_checkOuterShadow(labelName,token)),_current[\"(breakLabels)\"][labelName]=token}}};return scopeManagerInst};module.exports=scopeManager},{\"../lodash\":\"/node_modules/jshint/lodash.js\",events:\"/node_modules/browserify/node_modules/events/events.js\"}],\"/node_modules/jshint/src/state.js\":[function(_dereq_,module,exports){\"use strict\";var NameStack=_dereq_(\"./name-stack.js\"),state={syntax:{},isStrict:function(){return this.directive[\"use strict\"]||this.inClassBody||this.option.module||\"implied\"===this.option.strict},inMoz:function(){return this.option.moz},inES6:function(){return this.option.moz||this.option.esversion>=6},inES5:function(strict){return strict?!(this.option.esversion&&5!==this.option.esversion||this.option.moz):!this.option.esversion||this.option.esversion>=5||this.option.moz},reset:function(){this.tokens={prev:null,next:null,curr:null},this.option={},this.funct=null,this.ignored={},this.directive={},this.jsonMode=!1,this.jsonWarnings=[],this.lines=[],this.tab=\"\",this.cache={},this.ignoredLines={},this.forinifcheckneeded=!1,this.nameStack=new NameStack,this.inClassBody=!1}};exports.state=state},{\"./name-stack.js\":\"/node_modules/jshint/src/name-stack.js\"}],\"/node_modules/jshint/src/style.js\":[function(_dereq_,module,exports){\"use strict\";exports.register=function(linter){linter.on(\"Identifier\",function(data){linter.getOption(\"proto\")||\"__proto__\"===data.name&&linter.warn(\"W103\",{line:data.line,\"char\":data.char,data:[data.name,\"6\"]})}),linter.on(\"Identifier\",function(data){linter.getOption(\"iterator\")||\"__iterator__\"===data.name&&linter.warn(\"W103\",{line:data.line,\"char\":data.char,data:[data.name]})}),linter.on(\"Identifier\",function(data){linter.getOption(\"camelcase\")&&data.name.replace(/^_+|_+$/g,\"\").indexOf(\"_\")>-1&&!data.name.match(/^[A-Z0-9_]*$/)&&linter.warn(\"W106\",{line:data.line,\"char\":data.from,data:[data.name]})}),linter.on(\"String\",function(data){var code,quotmark=linter.getOption(\"quotmark\");quotmark&&(\"single\"===quotmark&&\"'\"!==data.quote&&(code=\"W109\"),\"double\"===quotmark&&'\"'!==data.quote&&(code=\"W108\"),quotmark===!0&&(linter.getCache(\"quotmark\")||linter.setCache(\"quotmark\",data.quote),linter.getCache(\"quotmark\")!==data.quote&&(code=\"W110\")),code&&linter.warn(code,{line:data.line,\"char\":data.char}))}),linter.on(\"Number\",function(data){\".\"===data.value.charAt(0)&&linter.warn(\"W008\",{line:data.line,\"char\":data.char,data:[data.value]}),\".\"===data.value.substr(data.value.length-1)&&linter.warn(\"W047\",{line:data.line,\"char\":data.char,data:[data.value]}),/^00+/.test(data.value)&&linter.warn(\"W046\",{line:data.line,\"char\":data.char,data:[data.value]})}),linter.on(\"String\",function(data){var re=/^(?:javascript|jscript|ecmascript|vbscript|livescript)\\s*:/i;linter.getOption(\"scripturl\")||re.test(data.value)&&linter.warn(\"W107\",{line:data.line,\"char\":data.char})})}},{}],\"/node_modules/jshint/src/vars.js\":[function(_dereq_,module,exports){\"use strict\";exports.reservedVars={arguments:!1,NaN:!1},exports.ecmaIdentifiers={3:{Array:!1,Boolean:!1,Date:!1,decodeURI:!1,decodeURIComponent:!1,encodeURI:!1,encodeURIComponent:!1,Error:!1,eval:!1,EvalError:!1,Function:!1,hasOwnProperty:!1,isFinite:!1,isNaN:!1,Math:!1,Number:!1,Object:!1,parseInt:!1,parseFloat:!1,RangeError:!1,ReferenceError:!1,RegExp:!1,String:!1,SyntaxError:!1,TypeError:!1,URIError:!1},5:{JSON:!1},6:{Map:!1,Promise:!1,Proxy:!1,Reflect:!1,Set:!1,Symbol:!1,WeakMap:!1,WeakSet:!1}},exports.browser={Audio:!1,Blob:!1,addEventListener:!1,applicationCache:!1,atob:!1,blur:!1,btoa:!1,cancelAnimationFrame:!1,CanvasGradient:!1,CanvasPattern:!1,CanvasRenderingContext2D:!1,CSS:!1,clearInterval:!1,clearTimeout:!1,close:!1,closed:!1,Comment:!1,CustomEvent:!1,DOMParser:!1,defaultStatus:!1,Document:!1,document:!1,DocumentFragment:!1,Element:!1,ElementTimeControl:!1,Event:!1,event:!1,fetch:!1,FileReader:!1,FormData:!1,focus:!1,frames:!1,getComputedStyle:!1,HTMLElement:!1,HTMLAnchorElement:!1,HTMLBaseElement:!1,HTMLBlockquoteElement:!1,HTMLBodyElement:!1,HTMLBRElement:!1,HTMLButtonElement:!1,HTMLCanvasElement:!1,HTMLCollection:!1,HTMLDirectoryElement:!1,HTMLDivElement:!1,HTMLDListElement:!1,HTMLFieldSetElement:!1,HTMLFontElement:!1,HTMLFormElement:!1,HTMLFrameElement:!1,HTMLFrameSetElement:!1,HTMLHeadElement:!1,HTMLHeadingElement:!1,HTMLHRElement:!1,HTMLHtmlElement:!1,HTMLIFrameElement:!1,HTMLImageElement:!1,HTMLInputElement:!1,HTMLIsIndexElement:!1,HTMLLabelElement:!1,HTMLLayerElement:!1,HTMLLegendElement:!1,HTMLLIElement:!1,HTMLLinkElement:!1,HTMLMapElement:!1,HTMLMenuElement:!1,HTMLMetaElement:!1,HTMLModElement:!1,HTMLObjectElement:!1,HTMLOListElement:!1,HTMLOptGroupElement:!1,HTMLOptionElement:!1,HTMLParagraphElement:!1,HTMLParamElement:!1,HTMLPreElement:!1,HTMLQuoteElement:!1,HTMLScriptElement:!1,HTMLSelectElement:!1,HTMLStyleElement:!1,HTMLTableCaptionElement:!1,HTMLTableCellElement:!1,HTMLTableColElement:!1,HTMLTableElement:!1,HTMLTableRowElement:!1,HTMLTableSectionElement:!1,HTMLTemplateElement:!1,HTMLTextAreaElement:!1,HTMLTitleElement:!1,HTMLUListElement:!1,HTMLVideoElement:!1,history:!1,Image:!1,Intl:!1,length:!1,localStorage:!1,location:!1,matchMedia:!1,MessageChannel:!1,MessageEvent:!1,MessagePort:!1,MouseEvent:!1,moveBy:!1,moveTo:!1,MutationObserver:!1,name:!1,Node:!1,NodeFilter:!1,NodeList:!1,Notification:!1,navigator:!1,onbeforeunload:!0,onblur:!0,onerror:!0,onfocus:!0,onload:!0,onresize:!0,onunload:!0,open:!1,openDatabase:!1,opener:!1,Option:!1,parent:!1,performance:!1,print:!1,Range:!1,requestAnimationFrame:!1,removeEventListener:!1,resizeBy:!1,resizeTo:!1,screen:!1,scroll:!1,scrollBy:!1,scrollTo:!1,sessionStorage:!1,setInterval:!1,setTimeout:!1,SharedWorker:!1,status:!1,SVGAElement:!1,SVGAltGlyphDefElement:!1,SVGAltGlyphElement:!1,SVGAltGlyphItemElement:!1,SVGAngle:!1,SVGAnimateColorElement:!1,SVGAnimateElement:!1,SVGAnimateMotionElement:!1,SVGAnimateTransformElement:!1,SVGAnimatedAngle:!1,SVGAnimatedBoolean:!1,SVGAnimatedEnumeration:!1,SVGAnimatedInteger:!1,SVGAnimatedLength:!1,SVGAnimatedLengthList:!1,SVGAnimatedNumber:!1,SVGAnimatedNumberList:!1,SVGAnimatedPathData:!1,SVGAnimatedPoints:!1,SVGAnimatedPreserveAspectRatio:!1,SVGAnimatedRect:!1,SVGAnimatedString:!1,SVGAnimatedTransformList:!1,SVGAnimationElement:!1,SVGCSSRule:!1,SVGCircleElement:!1,SVGClipPathElement:!1,SVGColor:!1,SVGColorProfileElement:!1,SVGColorProfileRule:!1,SVGComponentTransferFunctionElement:!1,SVGCursorElement:!1,SVGDefsElement:!1,SVGDescElement:!1,SVGDocument:!1,SVGElement:!1,SVGElementInstance:!1,SVGElementInstanceList:!1,SVGEllipseElement:!1,SVGExternalResourcesRequired:!1,SVGFEBlendElement:!1,SVGFEColorMatrixElement:!1,SVGFEComponentTransferElement:!1,SVGFECompositeElement:!1,SVGFEConvolveMatrixElement:!1,SVGFEDiffuseLightingElement:!1,SVGFEDisplacementMapElement:!1,SVGFEDistantLightElement:!1,SVGFEFloodElement:!1,SVGFEFuncAElement:!1,SVGFEFuncBElement:!1,SVGFEFuncGElement:!1,SVGFEFuncRElement:!1,SVGFEGaussianBlurElement:!1,SVGFEImageElement:!1,SVGFEMergeElement:!1,SVGFEMergeNodeElement:!1,SVGFEMorphologyElement:!1,SVGFEOffsetElement:!1,SVGFEPointLightElement:!1,SVGFESpecularLightingElement:!1,SVGFESpotLightElement:!1,SVGFETileElement:!1,SVGFETurbulenceElement:!1,SVGFilterElement:!1,SVGFilterPrimitiveStandardAttributes:!1,SVGFitToViewBox:!1,SVGFontElement:!1,SVGFontFaceElement:!1,SVGFontFaceFormatElement:!1,SVGFontFaceNameElement:!1,SVGFontFaceSrcElement:!1,SVGFontFaceUriElement:!1,SVGForeignObjectElement:!1,SVGGElement:!1,SVGGlyphElement:!1,SVGGlyphRefElement:!1,SVGGradientElement:!1,SVGHKernElement:!1,SVGICCColor:!1,SVGImageElement:!1,SVGLangSpace:!1,SVGLength:!1,SVGLengthList:!1,SVGLineElement:!1,SVGLinearGradientElement:!1,SVGLocatable:!1,SVGMPathElement:!1,SVGMarkerElement:!1,SVGMaskElement:!1,SVGMatrix:!1,SVGMetadataElement:!1,SVGMissingGlyphElement:!1,SVGNumber:!1,SVGNumberList:!1,SVGPaint:!1,SVGPathElement:!1,SVGPathSeg:!1,SVGPathSegArcAbs:!1,SVGPathSegArcRel:!1,SVGPathSegClosePath:!1,SVGPathSegCurvetoCubicAbs:!1,SVGPathSegCurvetoCubicRel:!1,SVGPathSegCurvetoCubicSmoothAbs:!1,SVGPathSegCurvetoCubicSmoothRel:!1,SVGPathSegCurvetoQuadraticAbs:!1,SVGPathSegCurvetoQuadraticRel:!1,SVGPathSegCurvetoQuadraticSmoothAbs:!1,SVGPathSegCurvetoQuadraticSmoothRel:!1,SVGPathSegLinetoAbs:!1,SVGPathSegLinetoHorizontalAbs:!1,SVGPathSegLinetoHorizontalRel:!1,SVGPathSegLinetoRel:!1,SVGPathSegLinetoVerticalAbs:!1,SVGPathSegLinetoVerticalRel:!1,SVGPathSegList:!1,SVGPathSegMovetoAbs:!1,SVGPathSegMovetoRel:!1,SVGPatternElement:!1,SVGPoint:!1,SVGPointList:!1,SVGPolygonElement:!1,SVGPolylineElement:!1,SVGPreserveAspectRatio:!1,SVGRadialGradientElement:!1,SVGRect:!1,SVGRectElement:!1,SVGRenderingIntent:!1,SVGSVGElement:!1,SVGScriptElement:!1,SVGSetElement:!1,SVGStopElement:!1,SVGStringList:!1,SVGStylable:!1,SVGStyleElement:!1,SVGSwitchElement:!1,SVGSymbolElement:!1,SVGTRefElement:!1,SVGTSpanElement:!1,SVGTests:!1,SVGTextContentElement:!1,SVGTextElement:!1,SVGTextPathElement:!1,SVGTextPositioningElement:!1,SVGTitleElement:!1,SVGTransform:!1,SVGTransformList:!1,SVGTransformable:!1,SVGURIReference:!1,SVGUnitTypes:!1,SVGUseElement:!1,SVGVKernElement:!1,SVGViewElement:!1,SVGViewSpec:!1,SVGZoomAndPan:!1,Text:!1,TextDecoder:!1,TextEncoder:!1,TimeEvent:!1,top:!1,URL:!1,WebGLActiveInfo:!1,WebGLBuffer:!1,WebGLContextEvent:!1,WebGLFramebuffer:!1,WebGLProgram:!1,WebGLRenderbuffer:!1,WebGLRenderingContext:!1,WebGLShader:!1,WebGLShaderPrecisionFormat:!1,WebGLTexture:!1,WebGLUniformLocation:!1,WebSocket:!1,window:!1,Window:!1,Worker:!1,XDomainRequest:!1,XMLHttpRequest:!1,XMLSerializer:!1,XPathEvaluator:!1,XPathException:!1,XPathExpression:!1,XPathNamespace:!1,XPathNSResolver:!1,XPathResult:!1},exports.devel={alert:!1,confirm:!1,console:!1,Debug:!1,opera:!1,prompt:!1},exports.worker={importScripts:!0,postMessage:!0,self:!0,FileReaderSync:!0},exports.nonstandard={escape:!1,unescape:!1},exports.couch={require:!1,respond:!1,getRow:!1,emit:!1,send:!1,start:!1,sum:!1,log:!1,exports:!1,module:!1,provides:!1},exports.node={__filename:!1,__dirname:!1,GLOBAL:!1,global:!1,module:!1,acequire:!1,Buffer:!0,console:!0,exports:!0,process:!0,setTimeout:!0,clearTimeout:!0,setInterval:!0,clearInterval:!0,setImmediate:!0,clearImmediate:!0},exports.browserify={__filename:!1,__dirname:!1,global:!1,module:!1,acequire:!1,Buffer:!0,exports:!0,process:!0},exports.phantom={phantom:!0,acequire:!0,WebPage:!0,console:!0,exports:!0},exports.qunit={asyncTest:!1,deepEqual:!1,equal:!1,expect:!1,module:!1,notDeepEqual:!1,notEqual:!1,notPropEqual:!1,notStrictEqual:!1,ok:!1,propEqual:!1,QUnit:!1,raises:!1,start:!1,stop:!1,strictEqual:!1,test:!1,\"throws\":!1},exports.rhino={defineClass:!1,deserialize:!1,gc:!1,help:!1,importClass:!1,importPackage:!1,java:!1,load:!1,loadClass:!1,Packages:!1,print:!1,quit:!1,readFile:!1,readUrl:!1,runCommand:!1,seal:!1,serialize:!1,spawn:!1,sync:!1,toint32:!1,version:!1},exports.shelljs={target:!1,echo:!1,exit:!1,cd:!1,pwd:!1,ls:!1,find:!1,cp:!1,rm:!1,mv:!1,mkdir:!1,test:!1,cat:!1,sed:!1,grep:!1,which:!1,dirs:!1,pushd:!1,popd:!1,env:!1,exec:!1,chmod:!1,config:!1,error:!1,tempdir:!1},exports.typed={ArrayBuffer:!1,ArrayBufferView:!1,DataView:!1,Float32Array:!1,Float64Array:!1,Int16Array:!1,Int32Array:!1,Int8Array:!1,Uint16Array:!1,Uint32Array:!1,Uint8Array:!1,Uint8ClampedArray:!1},exports.wsh={ActiveXObject:!0,Enumerator:!0,GetObject:!0,ScriptEngine:!0,ScriptEngineBuildVersion:!0,ScriptEngineMajorVersion:!0,ScriptEngineMinorVersion:!0,VBArray:!0,WSH:!0,WScript:!0,XDomainRequest:!0},exports.dojo={dojo:!1,dijit:!1,dojox:!1,define:!1,require:!1},exports.jquery={$:!1,jQuery:!1},exports.mootools={$:!1,$$:!1,Asset:!1,Browser:!1,Chain:!1,Class:!1,Color:!1,Cookie:!1,Core:!1,Document:!1,DomReady:!1,DOMEvent:!1,DOMReady:!1,Drag:!1,Element:!1,Elements:!1,Event:!1,Events:!1,Fx:!1,Group:!1,Hash:!1,HtmlTable:!1,IFrame:!1,IframeShim:!1,InputValidator:!1,instanceOf:!1,Keyboard:!1,Locale:!1,Mask:!1,MooTools:!1,Native:!1,Options:!1,OverText:!1,Request:!1,Scroller:!1,Slick:!1,Slider:!1,Sortables:!1,Spinner:!1,Swiff:!1,Tips:!1,Type:!1,typeOf:!1,URI:!1,Window:!1},exports.prototypejs={$:!1,$$:!1,$A:!1,$F:!1,$H:!1,$R:!1,$break:!1,$continue:!1,$w:!1,Abstract:!1,Ajax:!1,Class:!1,Enumerable:!1,Element:!1,Event:!1,Field:!1,Form:!1,Hash:!1,Insertion:!1,ObjectRange:!1,PeriodicalExecuter:!1,Position:!1,Prototype:!1,Selector:!1,Template:!1,Toggle:!1,Try:!1,Autocompleter:!1,Builder:!1,Control:!1,Draggable:!1,Draggables:!1,Droppables:!1,Effect:!1,Sortable:!1,SortableObserver:!1,Sound:!1,Scriptaculous:!1},exports.yui={YUI:!1,Y:!1,YUI_config:!1},exports.mocha={mocha:!1,describe:!1,xdescribe:!1,it:!1,xit:!1,context:!1,xcontext:!1,before:!1,after:!1,beforeEach:!1,afterEach:!1,suite:!1,test:!1,setup:!1,teardown:!1,suiteSetup:!1,suiteTeardown:!1},exports.jasmine={jasmine:!1,describe:!1,xdescribe:!1,it:!1,xit:!1,beforeEach:!1,afterEach:!1,setFixtures:!1,loadFixtures:!1,spyOn:!1,expect:!1,runs:!1,waitsFor:!1,waits:!1,beforeAll:!1,afterAll:!1,fail:!1,fdescribe:!1,fit:!1,pending:!1}},{}]},{},[\"/node_modules/jshint/src/jshint.js\"])}),ace.define(\"ace/mode/javascript_worker\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/worker/mirror\",\"ace/mode/javascript/jshint\"],function(acequire,exports,module){\"use strict\";function startRegex(arr){return RegExp(\"^(\"+arr.join(\"|\")+\")\")}var oop=acequire(\"../lib/oop\"),Mirror=acequire(\"../worker/mirror\").Mirror,lint=acequire(\"./javascript/jshint\").JSHINT,disabledWarningsRe=startRegex([\"Bad for in variable '(.+)'.\",'Missing \"use strict\"']),errorsRe=startRegex([\"Unexpected\",\"Expected \",\"Confusing (plus|minus)\",\"\\\\{a\\\\} unterminated regular expression\",\"Unclosed \",\"Unmatched \",\"Unbegun comment\",\"Bad invocation\",\"Missing space after\",\"Missing operator at\"]),infoRe=startRegex([\"Expected an assignment\",\"Bad escapement of EOL\",\"Unexpected comma\",\"Unexpected space\",\"Missing radix parameter.\",\"A leading decimal point can\",\"\\\\['{a}'\\\\] is better written in dot notation.\",\"'{a}' used out of scope\"]),JavaScriptWorker=exports.JavaScriptWorker=function(sender){Mirror.call(this,sender),this.setTimeout(500),this.setOptions()};oop.inherits(JavaScriptWorker,Mirror),function(){this.setOptions=function(options){this.options=options||{esnext:!0,moz:!0,devel:!0,browser:!0,node:!0,laxcomma:!0,laxbreak:!0,lastsemic:!0,onevar:!1,passfail:!1,maxerr:100,expr:!0,multistr:!0,globalstrict:!0},this.doc.getValue()&&this.deferredUpdate.schedule(100)},this.changeOptions=function(newOptions){oop.mixin(this.options,newOptions),this.doc.getValue()&&this.deferredUpdate.schedule(100)},this.isValidJS=function(str){try{eval(\"throw 0;\"+str)}catch(e){if(0===e)return!0}return!1},this.onUpdate=function(){var value=this.doc.getValue();if(value=value.replace(/^#!.*\\n/,\"\\n\"),!value)return this.sender.emit(\"annotate\",[]);var errors=[],maxErrorLevel=this.isValidJS(value)?\"warning\":\"error\";lint(value,this.options);for(var results=lint.errors,errorAdded=!1,i=0;results.length>i;i++){var error=results[i];if(error){var raw=error.raw,type=\"warning\";if(\"Missing semicolon.\"==raw){var str=error.evidence.substr(error.character);str=str.charAt(str.search(/\\S/)),\"error\"==maxErrorLevel&&str&&/[\\w\\d{(['\"]/.test(str)?(error.reason='Missing \";\" before statement',type=\"error\"):type=\"info\"}else{if(disabledWarningsRe.test(raw))continue;infoRe.test(raw)?type=\"info\":errorsRe.test(raw)?(errorAdded=!0,type=maxErrorLevel):\"'{a}' is not defined.\"==raw?type=\"warning\":\"'{a}' is defined but never used.\"==raw&&(type=\"info\")}errors.push({row:error.line-1,column:error.character-1,text:error.reason,type:type,raw:raw})}}this.sender.emit(\"annotate\",errors)}}.call(JavaScriptWorker.prototype)}),ace.define(\"ace/lib/es5-shim\",[\"require\",\"exports\",\"module\"],function(){function Empty(){}function doesDefinePropertyWork(object){try{return Object.defineProperty(object,\"sentinel\",{}),\"sentinel\"in object}catch(exception){}}function toInteger(n){return n=+n,n!==n?n=0:0!==n&&n!==1/0&&n!==-(1/0)&&(n=(n>0||-1)*Math.floor(Math.abs(n))),n}Function.prototype.bind||(Function.prototype.bind=function(that){var target=this;if(\"function\"!=typeof target)throw new TypeError(\"Function.prototype.bind called on incompatible \"+target);var args=slice.call(arguments,1),bound=function(){if(this instanceof bound){var result=target.apply(this,args.concat(slice.call(arguments)));return Object(result)===result?result:this}return target.apply(that,args.concat(slice.call(arguments)))};return target.prototype&&(Empty.prototype=target.prototype,bound.prototype=new Empty,Empty.prototype=null),bound});var defineGetter,defineSetter,lookupGetter,lookupSetter,supportsAccessors,call=Function.prototype.call,prototypeOfArray=Array.prototype,prototypeOfObject=Object.prototype,slice=prototypeOfArray.slice,_toString=call.bind(prototypeOfObject.toString),owns=call.bind(prototypeOfObject.hasOwnProperty);if((supportsAccessors=owns(prototypeOfObject,\"__defineGetter__\"))&&(defineGetter=call.bind(prototypeOfObject.__defineGetter__),defineSetter=call.bind(prototypeOfObject.__defineSetter__),lookupGetter=call.bind(prototypeOfObject.__lookupGetter__),lookupSetter=call.bind(prototypeOfObject.__lookupSetter__)),2!=[1,2].splice(0).length)if(function(){function makeArray(l){var a=Array(l+2);return a[0]=a[1]=0,a}var lengthBefore,array=[];return array.splice.apply(array,makeArray(20)),array.splice.apply(array,makeArray(26)),lengthBefore=array.length,array.splice(5,0,\"XXX\"),lengthBefore+1==array.length,lengthBefore+1==array.length?!0:void 0}()){var array_splice=Array.prototype.splice;Array.prototype.splice=function(start,deleteCount){return arguments.length?array_splice.apply(this,[void 0===start?0:start,void 0===deleteCount?this.length-start:deleteCount].concat(slice.call(arguments,2))):[]}}else Array.prototype.splice=function(pos,removeCount){var length=this.length;pos>0?pos>length&&(pos=length):void 0==pos?pos=0:0>pos&&(pos=Math.max(length+pos,0)),length>pos+removeCount||(removeCount=length-pos);var removed=this.slice(pos,pos+removeCount),insert=slice.call(arguments,2),add=insert.length;if(pos===length)add&&this.push.apply(this,insert);else{var remove=Math.min(removeCount,length-pos),tailOldPos=pos+remove,tailNewPos=tailOldPos+add-remove,tailCount=length-tailOldPos,lengthAfterRemove=length-remove;if(tailOldPos>tailNewPos)for(var i=0;tailCount>i;++i)this[tailNewPos+i]=this[tailOldPos+i];else if(tailNewPos>tailOldPos)for(i=tailCount;i--;)this[tailNewPos+i]=this[tailOldPos+i];if(add&&pos===lengthAfterRemove)this.length=lengthAfterRemove,this.push.apply(this,insert);else for(this.length=lengthAfterRemove+add,i=0;add>i;++i)this[pos+i]=insert[i]}return removed};Array.isArray||(Array.isArray=function(obj){return\"[object Array]\"==_toString(obj)});var boxedString=Object(\"a\"),splitString=\"a\"!=boxedString[0]||!(0 in boxedString);if(Array.prototype.forEach||(Array.prototype.forEach=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,thisp=arguments[1],i=-1,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError;for(;length>++i;)i in self&&fun.call(thisp,self[i],i,object)}),Array.prototype.map||(Array.prototype.map=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,result=Array(length),thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)i in self&&(result[i]=fun.call(thisp,self[i],i,object));return result}),Array.prototype.filter||(Array.prototype.filter=function(fun){var value,object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,result=[],thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)i in self&&(value=self[i],fun.call(thisp,value,i,object)&&result.push(value));return result}),Array.prototype.every||(Array.prototype.every=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)if(i in self&&!fun.call(thisp,self[i],i,object))return!1;return!0}),Array.prototype.some||(Array.prototype.some=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)if(i in self&&fun.call(thisp,self[i],i,object))return!0;return!1}),Array.prototype.reduce||(Array.prototype.reduce=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");if(!length&&1==arguments.length)throw new TypeError(\"reduce of empty array with no initial value\");var result,i=0;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i++];break}if(++i>=length)throw new TypeError(\"reduce of empty array with no initial value\")}for(;length>i;i++)i in self&&(result=fun.call(void 0,result,self[i],i,object));return result}),Array.prototype.reduceRight||(Array.prototype.reduceRight=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");if(!length&&1==arguments.length)throw new TypeError(\"reduceRight of empty array with no initial value\");var result,i=length-1;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i--];break}if(0>--i)throw new TypeError(\"reduceRight of empty array with no initial value\")}do i in this&&(result=fun.call(void 0,result,self[i],i,object));while(i--);return result}),Array.prototype.indexOf&&-1==[0,1].indexOf(1,2)||(Array.prototype.indexOf=function(sought){var self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):toObject(this),length=self.length>>>0;if(!length)return-1;var i=0;for(arguments.length>1&&(i=toInteger(arguments[1])),i=i>=0?i:Math.max(0,length+i);length>i;i++)if(i in self&&self[i]===sought)return i;return-1}),Array.prototype.lastIndexOf&&-1==[0,1].lastIndexOf(0,-3)||(Array.prototype.lastIndexOf=function(sought){var self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):toObject(this),length=self.length>>>0;if(!length)return-1;var i=length-1;for(arguments.length>1&&(i=Math.min(i,toInteger(arguments[1]))),i=i>=0?i:length-Math.abs(i);i>=0;i--)if(i in self&&sought===self[i])return i;return-1}),Object.getPrototypeOf||(Object.getPrototypeOf=function(object){return object.__proto__||(object.constructor?object.constructor.prototype:prototypeOfObject)}),!Object.getOwnPropertyDescriptor){var ERR_NON_OBJECT=\"Object.getOwnPropertyDescriptor called on a non-object: \";Object.getOwnPropertyDescriptor=function(object,property){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT+object);if(owns(object,property)){var descriptor,getter,setter;if(descriptor={enumerable:!0,configurable:!0},supportsAccessors){var prototype=object.__proto__;object.__proto__=prototypeOfObject;var getter=lookupGetter(object,property),setter=lookupSetter(object,property);if(object.__proto__=prototype,getter||setter)return getter&&(descriptor.get=getter),setter&&(descriptor.set=setter),descriptor}return descriptor.value=object[property],descriptor}}}if(Object.getOwnPropertyNames||(Object.getOwnPropertyNames=function(object){return Object.keys(object)}),!Object.create){var createEmpty;createEmpty=null===Object.prototype.__proto__?function(){return{__proto__:null}}:function(){var empty={};for(var i in empty)empty[i]=null;return empty.constructor=empty.hasOwnProperty=empty.propertyIsEnumerable=empty.isPrototypeOf=empty.toLocaleString=empty.toString=empty.valueOf=empty.__proto__=null,empty},Object.create=function(prototype,properties){var object;if(null===prototype)object=createEmpty();else{if(\"object\"!=typeof prototype)throw new TypeError(\"typeof prototype[\"+typeof prototype+\"] != 'object'\");var Type=function(){};Type.prototype=prototype,object=new Type,object.__proto__=prototype}return void 0!==properties&&Object.defineProperties(object,properties),object}}if(Object.defineProperty){var definePropertyWorksOnObject=doesDefinePropertyWork({}),definePropertyWorksOnDom=\"undefined\"==typeof document||doesDefinePropertyWork(document.createElement(\"div\"));if(!definePropertyWorksOnObject||!definePropertyWorksOnDom)var definePropertyFallback=Object.defineProperty}if(!Object.defineProperty||definePropertyFallback){var ERR_NON_OBJECT_DESCRIPTOR=\"Property description must be an object: \",ERR_NON_OBJECT_TARGET=\"Object.defineProperty called on non-object: \",ERR_ACCESSORS_NOT_SUPPORTED=\"getters & setters can not be defined on this javascript engine\";Object.defineProperty=function(object,property,descriptor){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT_TARGET+object);if(\"object\"!=typeof descriptor&&\"function\"!=typeof descriptor||null===descriptor)throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR+descriptor);if(definePropertyFallback)try{return definePropertyFallback.call(Object,object,property,descriptor)}catch(exception){}if(owns(descriptor,\"value\"))if(supportsAccessors&&(lookupGetter(object,property)||lookupSetter(object,property))){var prototype=object.__proto__;object.__proto__=prototypeOfObject,delete object[property],object[property]=descriptor.value,object.__proto__=prototype}else object[property]=descriptor.value;else{if(!supportsAccessors)throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);owns(descriptor,\"get\")&&defineGetter(object,property,descriptor.get),owns(descriptor,\"set\")&&defineSetter(object,property,descriptor.set)}return object}}Object.defineProperties||(Object.defineProperties=function(object,properties){for(var property in properties)owns(properties,property)&&Object.defineProperty(object,property,properties[property]);return object}),Object.seal||(Object.seal=function(object){return object}),Object.freeze||(Object.freeze=function(object){return object});try{Object.freeze(function(){})}catch(exception){Object.freeze=function(freezeObject){return function(object){return\"function\"==typeof object?object:freezeObject(object)}}(Object.freeze)}if(Object.preventExtensions||(Object.preventExtensions=function(object){return object}),Object.isSealed||(Object.isSealed=function(){return!1}),Object.isFrozen||(Object.isFrozen=function(){return!1}),Object.isExtensible||(Object.isExtensible=function(object){if(Object(object)===object)throw new TypeError;for(var name=\"\";owns(object,name);)name+=\"?\";object[name]=!0;var returnValue=owns(object,name);return delete object[name],returnValue}),!Object.keys){var hasDontEnumBug=!0,dontEnums=[\"toString\",\"toLocaleString\",\"valueOf\",\"hasOwnProperty\",\"isPrototypeOf\",\"propertyIsEnumerable\",\"constructor\"],dontEnumsLength=dontEnums.length;for(var key in{toString:null})hasDontEnumBug=!1;Object.keys=function(object){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(\"Object.keys called on a non-object\");var keys=[];for(var name in object)owns(object,name)&&keys.push(name);if(hasDontEnumBug)for(var i=0,ii=dontEnumsLength;ii>i;i++){var dontEnum=dontEnums[i];owns(object,dontEnum)&&keys.push(dontEnum)}return keys}}Date.now||(Date.now=function(){return(new Date).getTime()});var ws=\"\t\\n\u000b\\f\\r   ᠎             　\\u2028\\u2029﻿\";if(!String.prototype.trim||ws.trim()){ws=\"[\"+ws+\"]\";var trimBeginRegexp=RegExp(\"^\"+ws+ws+\"*\"),trimEndRegexp=RegExp(ws+ws+\"*$\");String.prototype.trim=function(){return(this+\"\").replace(trimBeginRegexp,\"\").replace(trimEndRegexp,\"\")}}var toObject=function(o){if(null==o)throw new TypeError(\"can't convert \"+o+\" to object\");return Object(o)}});";

/***/ },
/* 100 */
/***/ function(module, exports) {

	module.exports.id = 'ace/mode/xml_worker';
	module.exports.src = "\"no use strict\";(function(window){function resolveModuleId(id,paths){for(var testPath=id,tail=\"\";testPath;){var alias=paths[testPath];if(\"string\"==typeof alias)return alias+tail;if(alias)return alias.location.replace(/\\/*$/,\"/\")+(tail||alias.main||alias.name);if(alias===!1)return\"\";var i=testPath.lastIndexOf(\"/\");if(-1===i)break;tail=testPath.substr(i)+tail,testPath=testPath.slice(0,i)}return id}if(!(void 0!==window.window&&window.document||window.acequire&&window.define)){window.console||(window.console=function(){var msgs=Array.prototype.slice.call(arguments,0);postMessage({type:\"log\",data:msgs})},window.console.error=window.console.warn=window.console.log=window.console.trace=window.console),window.window=window,window.ace=window,window.onerror=function(message,file,line,col,err){postMessage({type:\"error\",data:{message:message,data:err.data,file:file,line:line,col:col,stack:err.stack}})},window.normalizeModule=function(parentId,moduleName){if(-1!==moduleName.indexOf(\"!\")){var chunks=moduleName.split(\"!\");return window.normalizeModule(parentId,chunks[0])+\"!\"+window.normalizeModule(parentId,chunks[1])}if(\".\"==moduleName.charAt(0)){var base=parentId.split(\"/\").slice(0,-1).join(\"/\");for(moduleName=(base?base+\"/\":\"\")+moduleName;-1!==moduleName.indexOf(\".\")&&previous!=moduleName;){var previous=moduleName;moduleName=moduleName.replace(/^\\.\\//,\"\").replace(/\\/\\.\\//,\"/\").replace(/[^\\/]+\\/\\.\\.\\//,\"\")}}return moduleName},window.acequire=function acequire(parentId,id){if(id||(id=parentId,parentId=null),!id.charAt)throw Error(\"worker.js acequire() accepts only (parentId, id) as arguments\");id=window.normalizeModule(parentId,id);var module=window.acequire.modules[id];if(module)return module.initialized||(module.initialized=!0,module.exports=module.factory().exports),module.exports;if(!window.acequire.tlns)return console.log(\"unable to load \"+id);var path=resolveModuleId(id,window.acequire.tlns);return\".js\"!=path.slice(-3)&&(path+=\".js\"),window.acequire.id=id,window.acequire.modules[id]={},importScripts(path),window.acequire(parentId,id)},window.acequire.modules={},window.acequire.tlns={},window.define=function(id,deps,factory){if(2==arguments.length?(factory=deps,\"string\"!=typeof id&&(deps=id,id=window.acequire.id)):1==arguments.length&&(factory=id,deps=[],id=window.acequire.id),\"function\"!=typeof factory)return window.acequire.modules[id]={exports:factory,initialized:!0},void 0;deps.length||(deps=[\"require\",\"exports\",\"module\"]);var req=function(childId){return window.acequire(id,childId)};window.acequire.modules[id]={exports:{},factory:function(){var module=this,returnExports=factory.apply(this,deps.map(function(dep){switch(dep){case\"require\":return req;case\"exports\":return module.exports;case\"module\":return module;default:return req(dep)}}));return returnExports&&(module.exports=returnExports),module}}},window.define.amd={},acequire.tlns={},window.initBaseUrls=function(topLevelNamespaces){for(var i in topLevelNamespaces)acequire.tlns[i]=topLevelNamespaces[i]},window.initSender=function(){var EventEmitter=window.acequire(\"ace/lib/event_emitter\").EventEmitter,oop=window.acequire(\"ace/lib/oop\"),Sender=function(){};return function(){oop.implement(this,EventEmitter),this.callback=function(data,callbackId){postMessage({type:\"call\",id:callbackId,data:data})},this.emit=function(name,data){postMessage({type:\"event\",name:name,data:data})}}.call(Sender.prototype),new Sender};var main=window.main=null,sender=window.sender=null;window.onmessage=function(e){var msg=e.data;if(msg.event&&sender)sender._signal(msg.event,msg.data);else if(msg.command)if(main[msg.command])main[msg.command].apply(main,msg.args);else{if(!window[msg.command])throw Error(\"Unknown command:\"+msg.command);window[msg.command].apply(window,msg.args)}else if(msg.init){window.initBaseUrls(msg.tlns),acequire(\"ace/lib/es5-shim\"),sender=window.sender=window.initSender();var clazz=acequire(msg.module)[msg.classname];main=window.main=new clazz(sender)}}}})(this),ace.define(\"ace/lib/oop\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";exports.inherits=function(ctor,superCtor){ctor.super_=superCtor,ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:!1,writable:!0,configurable:!0}})},exports.mixin=function(obj,mixin){for(var key in mixin)obj[key]=mixin[key];return obj},exports.implement=function(proto,mixin){exports.mixin(proto,mixin)}}),ace.define(\"ace/lib/lang\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";exports.last=function(a){return a[a.length-1]},exports.stringReverse=function(string){return string.split(\"\").reverse().join(\"\")},exports.stringRepeat=function(string,count){for(var result=\"\";count>0;)1&count&&(result+=string),(count>>=1)&&(string+=string);return result};var trimBeginRegexp=/^\\s\\s*/,trimEndRegexp=/\\s\\s*$/;exports.stringTrimLeft=function(string){return string.replace(trimBeginRegexp,\"\")},exports.stringTrimRight=function(string){return string.replace(trimEndRegexp,\"\")},exports.copyObject=function(obj){var copy={};for(var key in obj)copy[key]=obj[key];return copy},exports.copyArray=function(array){for(var copy=[],i=0,l=array.length;l>i;i++)copy[i]=array[i]&&\"object\"==typeof array[i]?this.copyObject(array[i]):array[i];return copy},exports.deepCopy=function deepCopy(obj){if(\"object\"!=typeof obj||!obj)return obj;var copy;if(Array.isArray(obj)){copy=[];for(var key=0;obj.length>key;key++)copy[key]=deepCopy(obj[key]);return copy}var cons=obj.constructor;if(cons===RegExp)return obj;copy=cons();for(var key in obj)copy[key]=deepCopy(obj[key]);return copy},exports.arrayToMap=function(arr){for(var map={},i=0;arr.length>i;i++)map[arr[i]]=1;return map},exports.createMap=function(props){var map=Object.create(null);for(var i in props)map[i]=props[i];return map},exports.arrayRemove=function(array,value){for(var i=0;array.length>=i;i++)value===array[i]&&array.splice(i,1)},exports.escapeRegExp=function(str){return str.replace(/([.*+?^${}()|[\\]\\/\\\\])/g,\"\\\\$1\")},exports.escapeHTML=function(str){return str.replace(/&/g,\"&#38;\").replace(/\"/g,\"&#34;\").replace(/'/g,\"&#39;\").replace(/</g,\"&#60;\")},exports.getMatchOffsets=function(string,regExp){var matches=[];return string.replace(regExp,function(str){matches.push({offset:arguments[arguments.length-2],length:str.length})}),matches},exports.deferredCall=function(fcn){var timer=null,callback=function(){timer=null,fcn()},deferred=function(timeout){return deferred.cancel(),timer=setTimeout(callback,timeout||0),deferred};return deferred.schedule=deferred,deferred.call=function(){return this.cancel(),fcn(),deferred},deferred.cancel=function(){return clearTimeout(timer),timer=null,deferred},deferred.isPending=function(){return timer},deferred},exports.delayedCall=function(fcn,defaultTimeout){var timer=null,callback=function(){timer=null,fcn()},_self=function(timeout){null==timer&&(timer=setTimeout(callback,timeout||defaultTimeout))};return _self.delay=function(timeout){timer&&clearTimeout(timer),timer=setTimeout(callback,timeout||defaultTimeout)},_self.schedule=_self,_self.call=function(){this.cancel(),fcn()},_self.cancel=function(){timer&&clearTimeout(timer),timer=null},_self.isPending=function(){return timer},_self}}),ace.define(\"ace/range\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";var comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},Range=function(startRow,startColumn,endRow,endColumn){this.start={row:startRow,column:startColumn},this.end={row:endRow,column:endColumn}};(function(){this.isEqual=function(range){return this.start.row===range.start.row&&this.end.row===range.end.row&&this.start.column===range.start.column&&this.end.column===range.end.column},this.toString=function(){return\"Range: [\"+this.start.row+\"/\"+this.start.column+\"] -> [\"+this.end.row+\"/\"+this.end.column+\"]\"},this.contains=function(row,column){return 0==this.compare(row,column)},this.compareRange=function(range){var cmp,end=range.end,start=range.start;return cmp=this.compare(end.row,end.column),1==cmp?(cmp=this.compare(start.row,start.column),1==cmp?2:0==cmp?1:0):-1==cmp?-2:(cmp=this.compare(start.row,start.column),-1==cmp?-1:1==cmp?42:0)},this.comparePoint=function(p){return this.compare(p.row,p.column)},this.containsRange=function(range){return 0==this.comparePoint(range.start)&&0==this.comparePoint(range.end)},this.intersects=function(range){var cmp=this.compareRange(range);return-1==cmp||0==cmp||1==cmp},this.isEnd=function(row,column){return this.end.row==row&&this.end.column==column},this.isStart=function(row,column){return this.start.row==row&&this.start.column==column},this.setStart=function(row,column){\"object\"==typeof row?(this.start.column=row.column,this.start.row=row.row):(this.start.row=row,this.start.column=column)},this.setEnd=function(row,column){\"object\"==typeof row?(this.end.column=row.column,this.end.row=row.row):(this.end.row=row,this.end.column=column)},this.inside=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)||this.isStart(row,column)?!1:!0:!1},this.insideStart=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)?!1:!0:!1},this.insideEnd=function(row,column){return 0==this.compare(row,column)?this.isStart(row,column)?!1:!0:!1},this.compare=function(row,column){return this.isMultiLine()||row!==this.start.row?this.start.row>row?-1:row>this.end.row?1:this.start.row===row?column>=this.start.column?0:-1:this.end.row===row?this.end.column>=column?0:1:0:this.start.column>column?-1:column>this.end.column?1:0},this.compareStart=function(row,column){return this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.compareEnd=function(row,column){return this.end.row==row&&this.end.column==column?1:this.compare(row,column)},this.compareInside=function(row,column){return this.end.row==row&&this.end.column==column?1:this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.clipRows=function(firstRow,lastRow){if(this.end.row>lastRow)var end={row:lastRow+1,column:0};else if(firstRow>this.end.row)var end={row:firstRow,column:0};if(this.start.row>lastRow)var start={row:lastRow+1,column:0};else if(firstRow>this.start.row)var start={row:firstRow,column:0};return Range.fromPoints(start||this.start,end||this.end)},this.extend=function(row,column){var cmp=this.compare(row,column);if(0==cmp)return this;if(-1==cmp)var start={row:row,column:column};else var end={row:row,column:column};return Range.fromPoints(start||this.start,end||this.end)},this.isEmpty=function(){return this.start.row===this.end.row&&this.start.column===this.end.column},this.isMultiLine=function(){return this.start.row!==this.end.row},this.clone=function(){return Range.fromPoints(this.start,this.end)},this.collapseRows=function(){return 0==this.end.column?new Range(this.start.row,0,Math.max(this.start.row,this.end.row-1),0):new Range(this.start.row,0,this.end.row,0)},this.toScreenRange=function(session){var screenPosStart=session.documentToScreenPosition(this.start),screenPosEnd=session.documentToScreenPosition(this.end);return new Range(screenPosStart.row,screenPosStart.column,screenPosEnd.row,screenPosEnd.column)},this.moveBy=function(row,column){this.start.row+=row,this.start.column+=column,this.end.row+=row,this.end.column+=column}}).call(Range.prototype),Range.fromPoints=function(start,end){return new Range(start.row,start.column,end.row,end.column)},Range.comparePoints=comparePoints,Range.comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},exports.Range=Range}),ace.define(\"ace/apply_delta\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";exports.applyDelta=function(docLines,delta){var row=delta.start.row,startColumn=delta.start.column,line=docLines[row]||\"\";switch(delta.action){case\"insert\":var lines=delta.lines;if(1===lines.length)docLines[row]=line.substring(0,startColumn)+delta.lines[0]+line.substring(startColumn);else{var args=[row,1].concat(delta.lines);docLines.splice.apply(docLines,args),docLines[row]=line.substring(0,startColumn)+docLines[row],docLines[row+delta.lines.length-1]+=line.substring(startColumn)}break;case\"remove\":var endColumn=delta.end.column,endRow=delta.end.row;row===endRow?docLines[row]=line.substring(0,startColumn)+line.substring(endColumn):docLines.splice(row,endRow-row+1,line.substring(0,startColumn)+docLines[endRow].substring(endColumn))}}}),ace.define(\"ace/lib/event_emitter\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";var EventEmitter={},stopPropagation=function(){this.propagationStopped=!0},preventDefault=function(){this.defaultPrevented=!0};EventEmitter._emit=EventEmitter._dispatchEvent=function(eventName,e){this._eventRegistry||(this._eventRegistry={}),this._defaultHandlers||(this._defaultHandlers={});var listeners=this._eventRegistry[eventName]||[],defaultHandler=this._defaultHandlers[eventName];if(listeners.length||defaultHandler){\"object\"==typeof e&&e||(e={}),e.type||(e.type=eventName),e.stopPropagation||(e.stopPropagation=stopPropagation),e.preventDefault||(e.preventDefault=preventDefault),listeners=listeners.slice();for(var i=0;listeners.length>i&&(listeners[i](e,this),!e.propagationStopped);i++);return defaultHandler&&!e.defaultPrevented?defaultHandler(e,this):void 0}},EventEmitter._signal=function(eventName,e){var listeners=(this._eventRegistry||{})[eventName];if(listeners){listeners=listeners.slice();for(var i=0;listeners.length>i;i++)listeners[i](e,this)}},EventEmitter.once=function(eventName,callback){var _self=this;callback&&this.addEventListener(eventName,function newCallback(){_self.removeEventListener(eventName,newCallback),callback.apply(null,arguments)})},EventEmitter.setDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers||(handlers=this._defaultHandlers={_disabled_:{}}),handlers[eventName]){var old=handlers[eventName],disabled=handlers._disabled_[eventName];disabled||(handlers._disabled_[eventName]=disabled=[]),disabled.push(old);var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}handlers[eventName]=callback},EventEmitter.removeDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers){var disabled=handlers._disabled_[eventName];if(handlers[eventName]==callback)handlers[eventName],disabled&&this.setDefaultHandler(eventName,disabled.pop());else if(disabled){var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}}},EventEmitter.on=EventEmitter.addEventListener=function(eventName,callback,capturing){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];return listeners||(listeners=this._eventRegistry[eventName]=[]),-1==listeners.indexOf(callback)&&listeners[capturing?\"unshift\":\"push\"](callback),callback},EventEmitter.off=EventEmitter.removeListener=EventEmitter.removeEventListener=function(eventName,callback){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];if(listeners){var index=listeners.indexOf(callback);-1!==index&&listeners.splice(index,1)}},EventEmitter.removeAllListeners=function(eventName){this._eventRegistry&&(this._eventRegistry[eventName]=[])},exports.EventEmitter=EventEmitter}),ace.define(\"ace/anchor\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\"],function(acequire,exports){\"use strict\";var oop=acequire(\"./lib/oop\"),EventEmitter=acequire(\"./lib/event_emitter\").EventEmitter,Anchor=exports.Anchor=function(doc,row,column){this.$onChange=this.onChange.bind(this),this.attach(doc),column===void 0?this.setPosition(row.row,row.column):this.setPosition(row,column)};(function(){function $pointsInOrder(point1,point2,equalPointsInOrder){var bColIsAfter=equalPointsInOrder?point1.column<=point2.column:point1.column<point2.column;return point1.row<point2.row||point1.row==point2.row&&bColIsAfter}function $getTransformedPoint(delta,point,moveIfEqual){var deltaIsInsert=\"insert\"==delta.action,deltaRowShift=(deltaIsInsert?1:-1)*(delta.end.row-delta.start.row),deltaColShift=(deltaIsInsert?1:-1)*(delta.end.column-delta.start.column),deltaStart=delta.start,deltaEnd=deltaIsInsert?deltaStart:delta.end;return $pointsInOrder(point,deltaStart,moveIfEqual)?{row:point.row,column:point.column}:$pointsInOrder(deltaEnd,point,!moveIfEqual)?{row:point.row+deltaRowShift,column:point.column+(point.row==deltaEnd.row?deltaColShift:0)}:{row:deltaStart.row,column:deltaStart.column}}oop.implement(this,EventEmitter),this.getPosition=function(){return this.$clipPositionToDocument(this.row,this.column)},this.getDocument=function(){return this.document},this.$insertRight=!1,this.onChange=function(delta){if(!(delta.start.row==delta.end.row&&delta.start.row!=this.row||delta.start.row>this.row)){var point=$getTransformedPoint(delta,{row:this.row,column:this.column},this.$insertRight);this.setPosition(point.row,point.column,!0)}},this.setPosition=function(row,column,noClip){var pos;if(pos=noClip?{row:row,column:column}:this.$clipPositionToDocument(row,column),this.row!=pos.row||this.column!=pos.column){var old={row:this.row,column:this.column};this.row=pos.row,this.column=pos.column,this._signal(\"change\",{old:old,value:pos})}},this.detach=function(){this.document.removeEventListener(\"change\",this.$onChange)},this.attach=function(doc){this.document=doc||this.document,this.document.on(\"change\",this.$onChange)},this.$clipPositionToDocument=function(row,column){var pos={};return row>=this.document.getLength()?(pos.row=Math.max(0,this.document.getLength()-1),pos.column=this.document.getLine(pos.row).length):0>row?(pos.row=0,pos.column=0):(pos.row=row,pos.column=Math.min(this.document.getLine(pos.row).length,Math.max(0,column))),0>column&&(pos.column=0),pos}}).call(Anchor.prototype)}),ace.define(\"ace/document\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/apply_delta\",\"ace/lib/event_emitter\",\"ace/range\",\"ace/anchor\"],function(acequire,exports){\"use strict\";var oop=acequire(\"./lib/oop\"),applyDelta=acequire(\"./apply_delta\").applyDelta,EventEmitter=acequire(\"./lib/event_emitter\").EventEmitter,Range=acequire(\"./range\").Range,Anchor=acequire(\"./anchor\").Anchor,Document=function(textOrLines){this.$lines=[\"\"],0===textOrLines.length?this.$lines=[\"\"]:Array.isArray(textOrLines)?this.insertMergedLines({row:0,column:0},textOrLines):this.insert({row:0,column:0},textOrLines)};(function(){oop.implement(this,EventEmitter),this.setValue=function(text){var len=this.getLength()-1;this.remove(new Range(0,0,len,this.getLine(len).length)),this.insert({row:0,column:0},text)},this.getValue=function(){return this.getAllLines().join(this.getNewLineCharacter())},this.createAnchor=function(row,column){return new Anchor(this,row,column)},this.$split=0===\"aaa\".split(/a/).length?function(text){return text.replace(/\\r\\n|\\r/g,\"\\n\").split(\"\\n\")}:function(text){return text.split(/\\r\\n|\\r|\\n/)},this.$detectNewLine=function(text){var match=text.match(/^.*?(\\r\\n|\\r|\\n)/m);this.$autoNewLine=match?match[1]:\"\\n\",this._signal(\"changeNewLineMode\")},this.getNewLineCharacter=function(){switch(this.$newLineMode){case\"windows\":return\"\\r\\n\";case\"unix\":return\"\\n\";default:return this.$autoNewLine||\"\\n\"}},this.$autoNewLine=\"\",this.$newLineMode=\"auto\",this.setNewLineMode=function(newLineMode){this.$newLineMode!==newLineMode&&(this.$newLineMode=newLineMode,this._signal(\"changeNewLineMode\"))},this.getNewLineMode=function(){return this.$newLineMode},this.isNewLine=function(text){return\"\\r\\n\"==text||\"\\r\"==text||\"\\n\"==text},this.getLine=function(row){return this.$lines[row]||\"\"},this.getLines=function(firstRow,lastRow){return this.$lines.slice(firstRow,lastRow+1)},this.getAllLines=function(){return this.getLines(0,this.getLength())},this.getLength=function(){return this.$lines.length},this.getTextRange=function(range){return this.getLinesForRange(range).join(this.getNewLineCharacter())},this.getLinesForRange=function(range){var lines;if(range.start.row===range.end.row)lines=[this.getLine(range.start.row).substring(range.start.column,range.end.column)];else{lines=this.getLines(range.start.row,range.end.row),lines[0]=(lines[0]||\"\").substring(range.start.column);var l=lines.length-1;range.end.row-range.start.row==l&&(lines[l]=lines[l].substring(0,range.end.column))}return lines},this.insertLines=function(row,lines){return console.warn(\"Use of document.insertLines is deprecated. Use the insertFullLines method instead.\"),this.insertFullLines(row,lines)},this.removeLines=function(firstRow,lastRow){return console.warn(\"Use of document.removeLines is deprecated. Use the removeFullLines method instead.\"),this.removeFullLines(firstRow,lastRow)},this.insertNewLine=function(position){return console.warn(\"Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.\"),this.insertMergedLines(position,[\"\",\"\"])},this.insert=function(position,text){return 1>=this.getLength()&&this.$detectNewLine(text),this.insertMergedLines(position,this.$split(text))},this.insertInLine=function(position,text){var start=this.clippedPos(position.row,position.column),end=this.pos(position.row,position.column+text.length);return this.applyDelta({start:start,end:end,action:\"insert\",lines:[text]},!0),this.clonePos(end)},this.clippedPos=function(row,column){var length=this.getLength();void 0===row?row=length:0>row?row=0:row>=length&&(row=length-1,column=void 0);var line=this.getLine(row);return void 0==column&&(column=line.length),column=Math.min(Math.max(column,0),line.length),{row:row,column:column}},this.clonePos=function(pos){return{row:pos.row,column:pos.column}},this.pos=function(row,column){return{row:row,column:column}},this.$clipPosition=function(position){var length=this.getLength();return position.row>=length?(position.row=Math.max(0,length-1),position.column=this.getLine(length-1).length):(position.row=Math.max(0,position.row),position.column=Math.min(Math.max(position.column,0),this.getLine(position.row).length)),position},this.insertFullLines=function(row,lines){row=Math.min(Math.max(row,0),this.getLength());var column=0;this.getLength()>row?(lines=lines.concat([\"\"]),column=0):(lines=[\"\"].concat(lines),row--,column=this.$lines[row].length),this.insertMergedLines({row:row,column:column},lines)},this.insertMergedLines=function(position,lines){var start=this.clippedPos(position.row,position.column),end={row:start.row+lines.length-1,column:(1==lines.length?start.column:0)+lines[lines.length-1].length};return this.applyDelta({start:start,end:end,action:\"insert\",lines:lines}),this.clonePos(end)},this.remove=function(range){var start=this.clippedPos(range.start.row,range.start.column),end=this.clippedPos(range.end.row,range.end.column);return this.applyDelta({start:start,end:end,action:\"remove\",lines:this.getLinesForRange({start:start,end:end})}),this.clonePos(start)},this.removeInLine=function(row,startColumn,endColumn){var start=this.clippedPos(row,startColumn),end=this.clippedPos(row,endColumn);return this.applyDelta({start:start,end:end,action:\"remove\",lines:this.getLinesForRange({start:start,end:end})},!0),this.clonePos(start)},this.removeFullLines=function(firstRow,lastRow){firstRow=Math.min(Math.max(0,firstRow),this.getLength()-1),lastRow=Math.min(Math.max(0,lastRow),this.getLength()-1);var deleteFirstNewLine=lastRow==this.getLength()-1&&firstRow>0,deleteLastNewLine=this.getLength()-1>lastRow,startRow=deleteFirstNewLine?firstRow-1:firstRow,startCol=deleteFirstNewLine?this.getLine(startRow).length:0,endRow=deleteLastNewLine?lastRow+1:lastRow,endCol=deleteLastNewLine?0:this.getLine(endRow).length,range=new Range(startRow,startCol,endRow,endCol),deletedLines=this.$lines.slice(firstRow,lastRow+1);return this.applyDelta({start:range.start,end:range.end,action:\"remove\",lines:this.getLinesForRange(range)}),deletedLines},this.removeNewLine=function(row){this.getLength()-1>row&&row>=0&&this.applyDelta({start:this.pos(row,this.getLine(row).length),end:this.pos(row+1,0),action:\"remove\",lines:[\"\",\"\"]})},this.replace=function(range,text){if(range instanceof Range||(range=Range.fromPoints(range.start,range.end)),0===text.length&&range.isEmpty())return range.start;if(text==this.getTextRange(range))return range.end;this.remove(range);var end;return end=text?this.insert(range.start,text):range.start},this.applyDeltas=function(deltas){for(var i=0;deltas.length>i;i++)this.applyDelta(deltas[i])},this.revertDeltas=function(deltas){for(var i=deltas.length-1;i>=0;i--)this.revertDelta(deltas[i])},this.applyDelta=function(delta,doNotValidate){var isInsert=\"insert\"==delta.action;(isInsert?1>=delta.lines.length&&!delta.lines[0]:!Range.comparePoints(delta.start,delta.end))||(isInsert&&delta.lines.length>2e4&&this.$splitAndapplyLargeDelta(delta,2e4),applyDelta(this.$lines,delta,doNotValidate),this._signal(\"change\",delta))},this.$splitAndapplyLargeDelta=function(delta,MAX){for(var lines=delta.lines,l=lines.length,row=delta.start.row,column=delta.start.column,from=0,to=0;;){from=to,to+=MAX-1;var chunk=lines.slice(from,to);if(to>l){delta.lines=chunk,delta.start.row=row+from,delta.start.column=column;break}chunk.push(\"\"),this.applyDelta({start:this.pos(row+from,column),end:this.pos(row+to,column=0),action:delta.action,lines:chunk},!0)}},this.revertDelta=function(delta){this.applyDelta({start:this.clonePos(delta.start),end:this.clonePos(delta.end),action:\"insert\"==delta.action?\"remove\":\"insert\",lines:delta.lines.slice()})},this.indexToPosition=function(index,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,i=startRow||0,l=lines.length;l>i;i++)if(index-=lines[i].length+newlineLength,0>index)return{row:i,column:index+lines[i].length+newlineLength};return{row:l-1,column:lines[l-1].length}},this.positionToIndex=function(pos,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,index=0,row=Math.min(pos.row,lines.length),i=startRow||0;row>i;++i)index+=lines[i].length+newlineLength;return index+pos.column}}).call(Document.prototype),exports.Document=Document}),ace.define(\"ace/worker/mirror\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/document\",\"ace/lib/lang\"],function(acequire,exports){\"use strict\";acequire(\"../range\").Range;var Document=acequire(\"../document\").Document,lang=acequire(\"../lib/lang\"),Mirror=exports.Mirror=function(sender){this.sender=sender;var doc=this.doc=new Document(\"\"),deferredUpdate=this.deferredUpdate=lang.delayedCall(this.onUpdate.bind(this)),_self=this;sender.on(\"change\",function(e){var data=e.data;if(data[0].start)doc.applyDeltas(data);else for(var i=0;data.length>i;i+=2){if(Array.isArray(data[i+1]))var d={action:\"insert\",start:data[i],lines:data[i+1]};else var d={action:\"remove\",start:data[i],end:data[i+1]};doc.applyDelta(d,!0)}return _self.$timeout?deferredUpdate.schedule(_self.$timeout):(_self.onUpdate(),void 0)})};(function(){this.$timeout=500,this.setTimeout=function(timeout){this.$timeout=timeout},this.setValue=function(value){this.doc.setValue(value),this.deferredUpdate.schedule(this.$timeout)},this.getValue=function(callbackId){this.sender.callback(this.doc.getValue(),callbackId)},this.onUpdate=function(){},this.isPending=function(){return this.deferredUpdate.isPending()}}).call(Mirror.prototype)}),ace.define(\"ace/mode/xml/sax\",[\"require\",\"exports\",\"module\"],function(){function XMLReader(){}function parse(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){function fixedFromCharCode(code){if(code>65535){code-=65536;var surrogate1=55296+(code>>10),surrogate2=56320+(1023&code);return String.fromCharCode(surrogate1,surrogate2)}return String.fromCharCode(code)}function entityReplacer(a){var k=a.slice(1,-1);return k in entityMap?entityMap[k]:\"#\"===k.charAt(0)?fixedFromCharCode(parseInt(k.substr(1).replace(\"x\",\"0x\"))):(errorHandler.error(\"entity not found:\"+a),a)}function appendText(end){var xt=source.substring(start,end).replace(/&#?\\w+;/g,entityReplacer);locator&&position(start),domBuilder.characters(xt,0,end-start),start=end}function position(start,m){for(;start>=endPos&&(m=linePattern.exec(source));)startPos=m.index,endPos=startPos+m[0].length,locator.lineNumber++;locator.columnNumber=start-startPos+1}for(var startPos=0,endPos=0,linePattern=/.+(?:\\r\\n?|\\n)|.*$/g,locator=domBuilder.locator,parseStack=[{currentNSMap:defaultNSMapCopy}],closeMap={},start=0;;){var i=source.indexOf(\"<\",start);if(0>i){if(!source.substr(start).match(/^\\s*$/)){var doc=domBuilder.document,text=doc.createTextNode(source.substr(start));doc.appendChild(text),domBuilder.currentElement=text}return}switch(i>start&&appendText(i),source.charAt(i+1)){case\"/\":var config,end=source.indexOf(\">\",i+3),tagName=source.substring(i+2,end);if(!(parseStack.length>1)){errorHandler.fatalError(\"end tag name not found for: \"+tagName);break}config=parseStack.pop();var localNSMap=config.localNSMap;if(config.tagName!=tagName&&errorHandler.fatalError(\"end tag name: \"+tagName+\" does not match the current start tagName: \"+config.tagName),domBuilder.endElement(config.uri,config.localName,tagName),localNSMap)for(var prefix in localNSMap)domBuilder.endPrefixMapping(prefix);end++;break;case\"?\":locator&&position(i),end=parseInstruction(source,i,domBuilder);break;case\"!\":locator&&position(i),end=parseDCC(source,i,domBuilder,errorHandler);break;default:try{locator&&position(i);var el=new ElementAttributes,end=parseElementStartPart(source,i,el,entityReplacer,errorHandler),len=el.length;if(len&&locator){for(var backup=copyLocator(locator,{}),i=0;len>i;i++){var a=el[i];position(a.offset),a.offset=copyLocator(locator,{})}copyLocator(backup,locator)}!el.closed&&fixSelfClosed(source,end,el.tagName,closeMap)&&(el.closed=!0,entityMap.nbsp||errorHandler.warning(\"unclosed xml attribute\")),appendElement(el,domBuilder,parseStack),\"http://www.w3.org/1999/xhtml\"!==el.uri||el.closed?end++:end=parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder)}catch(e){errorHandler.error(\"element parse error: \"+e),end=-1}}0>end?appendText(i+1):start=end}}function copyLocator(f,t){return t.lineNumber=f.lineNumber,t.columnNumber=f.columnNumber,t}function parseElementStartPart(source,start,el,entityReplacer,errorHandler){for(var attrName,value,p=++start,s=S_TAG;;){var c=source.charAt(p);switch(c){case\"=\":if(s===S_ATTR)attrName=source.slice(start,p),s=S_EQ;else{if(s!==S_ATTR_S)throw Error(\"attribute equal must after attrName\");s=S_EQ}break;case\"'\":case'\"':if(s===S_EQ){if(start=p+1,p=source.indexOf(c,start),!(p>0))throw Error(\"attribute value no end '\"+c+\"' match\");value=source.slice(start,p).replace(/&#?\\w+;/g,entityReplacer),el.add(attrName,value,start-1),s=S_E}else{if(s!=S_V)throw Error('attribute value must after \"=\"');value=source.slice(start,p).replace(/&#?\\w+;/g,entityReplacer),el.add(attrName,value,start),errorHandler.warning('attribute \"'+attrName+'\" missed start quot('+c+\")!!\"),start=p+1,s=S_E}break;case\"/\":switch(s){case S_TAG:el.setTagName(source.slice(start,p));case S_E:case S_S:case S_C:s=S_C,el.closed=!0;case S_V:case S_ATTR:case S_ATTR_S:break;default:throw Error(\"attribute invalid close char('/')\")}break;case\"\":errorHandler.error(\"unexpected end of input\");case\">\":switch(s){case S_TAG:el.setTagName(source.slice(start,p));case S_E:case S_S:case S_C:break;case S_V:case S_ATTR:value=source.slice(start,p),\"/\"===value.slice(-1)&&(el.closed=!0,value=value.slice(0,-1));case S_ATTR_S:s===S_ATTR_S&&(value=attrName),s==S_V?(errorHandler.warning('attribute \"'+value+'\" missed quot(\")!!'),el.add(attrName,value.replace(/&#?\\w+;/g,entityReplacer),start)):(errorHandler.warning('attribute \"'+value+'\" missed value!! \"'+value+'\" instead!!'),el.add(value,value,start));break;case S_EQ:throw Error(\"attribute value missed!!\")}return p;case\"\":c=\" \";default:if(\" \">=c)switch(s){case S_TAG:el.setTagName(source.slice(start,p)),s=S_S;break;case S_ATTR:attrName=source.slice(start,p),s=S_ATTR_S;break;case S_V:var value=source.slice(start,p).replace(/&#?\\w+;/g,entityReplacer);errorHandler.warning('attribute \"'+value+'\" missed quot(\")!!'),el.add(attrName,value,start);case S_E:s=S_S}else switch(s){case S_ATTR_S:errorHandler.warning('attribute \"'+attrName+'\" missed value!! \"'+attrName+'\" instead!!'),el.add(attrName,attrName,start),start=p,s=S_ATTR;\nbreak;case S_E:errorHandler.warning('attribute space is acequired\"'+attrName+'\"!!');case S_S:s=S_ATTR,start=p;break;case S_EQ:s=S_V,start=p;break;case S_C:throw Error(\"elements closed character '/' and '>' must be connected to\")}}p++}}function appendElement(el,domBuilder,parseStack){for(var tagName=el.tagName,localNSMap=null,currentNSMap=parseStack[parseStack.length-1].currentNSMap,i=el.length;i--;){var a=el[i],qName=a.qName,value=a.value,nsp=qName.indexOf(\":\");if(nsp>0)var prefix=a.prefix=qName.slice(0,nsp),localName=qName.slice(nsp+1),nsPrefix=\"xmlns\"===prefix&&localName;else localName=qName,prefix=null,nsPrefix=\"xmlns\"===qName&&\"\";a.localName=localName,nsPrefix!==!1&&(null==localNSMap&&(localNSMap={},_copy(currentNSMap,currentNSMap={})),currentNSMap[nsPrefix]=localNSMap[nsPrefix]=value,a.uri=\"http://www.w3.org/2000/xmlns/\",domBuilder.startPrefixMapping(nsPrefix,value))}for(var i=el.length;i--;){a=el[i];var prefix=a.prefix;prefix&&(\"xml\"===prefix&&(a.uri=\"http://www.w3.org/XML/1998/namespace\"),\"xmlns\"!==prefix&&(a.uri=currentNSMap[prefix]))}var nsp=tagName.indexOf(\":\");nsp>0?(prefix=el.prefix=tagName.slice(0,nsp),localName=el.localName=tagName.slice(nsp+1)):(prefix=null,localName=el.localName=tagName);var ns=el.uri=currentNSMap[prefix||\"\"];if(domBuilder.startElement(ns,localName,tagName,el),el.closed){if(domBuilder.endElement(ns,localName,tagName),localNSMap)for(prefix in localNSMap)domBuilder.endPrefixMapping(prefix)}else el.currentNSMap=currentNSMap,el.localNSMap=localNSMap,parseStack.push(el)}function parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){if(/^(?:script|textarea)$/i.test(tagName)){var elEndStart=source.indexOf(\"</\"+tagName+\">\",elStartEnd),text=source.substring(elStartEnd+1,elEndStart);if(/[&<]/.test(text))return/^script$/i.test(tagName)?(domBuilder.characters(text,0,text.length),elEndStart):(text=text.replace(/&#?\\w+;/g,entityReplacer),domBuilder.characters(text,0,text.length),elEndStart)}return elStartEnd+1}function fixSelfClosed(source,elStartEnd,tagName,closeMap){var pos=closeMap[tagName];return null==pos&&(pos=closeMap[tagName]=source.lastIndexOf(\"</\"+tagName+\">\")),elStartEnd>pos}function _copy(source,target){for(var n in source)target[n]=source[n]}function parseDCC(source,start,domBuilder,errorHandler){var next=source.charAt(start+2);switch(next){case\"-\":if(\"-\"===source.charAt(start+3)){var end=source.indexOf(\"-->\",start+4);return end>start?(domBuilder.comment(source,start+4,end-start-4),end+3):(errorHandler.error(\"Unclosed comment\"),-1)}return-1;default:if(\"CDATA[\"==source.substr(start+3,6)){var end=source.indexOf(\"]]>\",start+9);return domBuilder.startCDATA(),domBuilder.characters(source,start+9,end-start-9),domBuilder.endCDATA(),end+3}var matchs=split(source,start),len=matchs.length;if(len>1&&/!doctype/i.test(matchs[0][0])){var name=matchs[1][0],pubid=len>3&&/^public$/i.test(matchs[2][0])&&matchs[3][0],sysid=len>4&&matchs[4][0],lastMatch=matchs[len-1];return domBuilder.startDTD(name,pubid&&pubid.replace(/^(['\"])(.*?)\\1$/,\"$2\"),sysid&&sysid.replace(/^(['\"])(.*?)\\1$/,\"$2\")),domBuilder.endDTD(),lastMatch.index+lastMatch[0].length}}return-1}function parseInstruction(source,start,domBuilder){var end=source.indexOf(\"?>\",start);if(end){var match=source.substring(start,end).match(/^<\\?(\\S*)\\s*([\\s\\S]*?)\\s*$/);return match?(match[0].length,domBuilder.processingInstruction(match[1],match[2]),end+2):-1}return-1}function ElementAttributes(){}function _set_proto_(thiz,parent){return thiz.__proto__=parent,thiz}function split(source,start){var match,buf=[],reg=/'[^']+'|\"[^\"]+\"|[^\\s<>\\/=]+=?|(\\/?\\s*>|<)/g;for(reg.lastIndex=start,reg.exec(source);match=reg.exec(source);)if(buf.push(match),match[1])return buf}var nameStartChar=/[A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/,nameChar=RegExp(\"[\\\\-\\\\.0-9\"+nameStartChar.source.slice(1,-1)+\"·̀-ͯ\\\\ux203F-⁀]\"),tagNamePattern=RegExp(\"^\"+nameStartChar.source+nameChar.source+\"*(?::\"+nameStartChar.source+nameChar.source+\"*)?$\"),S_TAG=0,S_ATTR=1,S_ATTR_S=2,S_EQ=3,S_V=4,S_E=5,S_S=6,S_C=7;return XMLReader.prototype={parse:function(source,defaultNSMap,entityMap){var domBuilder=this.domBuilder;domBuilder.startDocument(),_copy(defaultNSMap,defaultNSMap={}),parse(source,defaultNSMap,entityMap,domBuilder,this.errorHandler),domBuilder.endDocument()}},ElementAttributes.prototype={setTagName:function(tagName){if(!tagNamePattern.test(tagName))throw Error(\"invalid tagName:\"+tagName);this.tagName=tagName},add:function(qName,value,offset){if(!tagNamePattern.test(qName))throw Error(\"invalid attribute:\"+qName);this[this.length++]={qName:qName,value:value,offset:offset}},length:0,getLocalName:function(i){return this[i].localName},getOffset:function(i){return this[i].offset},getQName:function(i){return this[i].qName},getURI:function(i){return this[i].uri},getValue:function(i){return this[i].value}},_set_proto_({},_set_proto_.prototype)instanceof _set_proto_||(_set_proto_=function(thiz,parent){function p(){}p.prototype=parent,p=new p;for(parent in thiz)p[parent]=thiz[parent];return p}),XMLReader}),ace.define(\"ace/mode/xml/dom\",[\"require\",\"exports\",\"module\"],function(){function copy(src,dest){for(var p in src)dest[p]=src[p]}function _extends(Class,Super){function t(){}var pt=Class.prototype;if(Object.create){var ppt=Object.create(Super.prototype);pt.__proto__=ppt}pt instanceof Super||(t.prototype=Super.prototype,t=new t,copy(pt,t),Class.prototype=pt=t),pt.constructor!=Class&&(\"function\"!=typeof Class&&console.error(\"unknow Class:\"+Class),pt.constructor=Class)}function DOMException(code,message){if(message instanceof Error)var error=message;else error=this,Error.call(this,ExceptionMessage[code]),this.message=ExceptionMessage[code],Error.captureStackTrace&&Error.captureStackTrace(this,DOMException);return error.code=code,message&&(this.message=this.message+\": \"+message),error}function NodeList(){}function LiveNodeList(node,refresh){this._node=node,this._refresh=refresh,_updateLiveList(this)}function _updateLiveList(list){var inc=list._node._inc||list._node.ownerDocument._inc;if(list._inc!=inc){var ls=list._refresh(list._node);__set__(list,\"length\",ls.length),copy(ls,list),list._inc=inc}}function NamedNodeMap(){}function _findNodeIndex(list,node){for(var i=list.length;i--;)if(list[i]===node)return i}function _addNamedNode(el,list,newAttr,oldAttr){if(oldAttr?list[_findNodeIndex(list,oldAttr)]=newAttr:list[list.length++]=newAttr,el){newAttr.ownerElement=el;var doc=el.ownerDocument;doc&&(oldAttr&&_onRemoveAttribute(doc,el,oldAttr),_onAddAttribute(doc,el,newAttr))}}function _removeNamedNode(el,list,attr){var i=_findNodeIndex(list,attr);if(!(i>=0))throw DOMException(NOT_FOUND_ERR,Error());for(var lastIndex=list.length-1;lastIndex>i;)list[i]=list[++i];if(list.length=lastIndex,el){var doc=el.ownerDocument;doc&&(_onRemoveAttribute(doc,el,attr),attr.ownerElement=null)}}function DOMImplementation(features){if(this._features={},features)for(var feature in features)this._features=features[feature]}function Node(){}function _xmlEncoder(c){return\"<\"==c&&\"&lt;\"||\">\"==c&&\"&gt;\"||\"&\"==c&&\"&amp;\"||'\"'==c&&\"&quot;\"||\"&#\"+c.charCodeAt()+\";\"}function _visitNode(node,callback){if(callback(node))return!0;if(node=node.firstChild)do if(_visitNode(node,callback))return!0;while(node=node.nextSibling)}function Document(){}function _onAddAttribute(doc,el,newAttr){doc&&doc._inc++;var ns=newAttr.namespaceURI;\"http://www.w3.org/2000/xmlns/\"==ns&&(el._nsMap[newAttr.prefix?newAttr.localName:\"\"]=newAttr.value)}function _onRemoveAttribute(doc,el,newAttr){doc&&doc._inc++;var ns=newAttr.namespaceURI;\"http://www.w3.org/2000/xmlns/\"==ns&&delete el._nsMap[newAttr.prefix?newAttr.localName:\"\"]}function _onUpdateChild(doc,el,newChild){if(doc&&doc._inc){doc._inc++;var cs=el.childNodes;if(newChild)cs[cs.length++]=newChild;else{for(var child=el.firstChild,i=0;child;)cs[i++]=child,child=child.nextSibling;cs.length=i}}}function _removeChild(parentNode,child){var previous=child.previousSibling,next=child.nextSibling;return previous?previous.nextSibling=next:parentNode.firstChild=next,next?next.previousSibling=previous:parentNode.lastChild=previous,_onUpdateChild(parentNode.ownerDocument,parentNode),child}function _insertBefore(parentNode,newChild,nextChild){var cp=newChild.parentNode;if(cp&&cp.removeChild(newChild),newChild.nodeType===DOCUMENT_FRAGMENT_NODE){var newFirst=newChild.firstChild;if(null==newFirst)return newChild;var newLast=newChild.lastChild}else newFirst=newLast=newChild;var pre=nextChild?nextChild.previousSibling:parentNode.lastChild;newFirst.previousSibling=pre,newLast.nextSibling=nextChild,pre?pre.nextSibling=newFirst:parentNode.firstChild=newFirst,null==nextChild?parentNode.lastChild=newLast:nextChild.previousSibling=newLast;do newFirst.parentNode=parentNode;while(newFirst!==newLast&&(newFirst=newFirst.nextSibling));return _onUpdateChild(parentNode.ownerDocument||parentNode,parentNode),newChild.nodeType==DOCUMENT_FRAGMENT_NODE&&(newChild.firstChild=newChild.lastChild=null),newChild}function _appendSingleChild(parentNode,newChild){var cp=newChild.parentNode;if(cp){var pre=parentNode.lastChild;cp.removeChild(newChild);var pre=parentNode.lastChild}var pre=parentNode.lastChild;return newChild.parentNode=parentNode,newChild.previousSibling=pre,newChild.nextSibling=null,pre?pre.nextSibling=newChild:parentNode.firstChild=newChild,parentNode.lastChild=newChild,_onUpdateChild(parentNode.ownerDocument,parentNode,newChild),newChild}function Element(){this._nsMap={}}function Attr(){}function CharacterData(){}function Text(){}function Comment(){}function CDATASection(){}function DocumentType(){}function Notation(){}function Entity(){}function EntityReference(){}function DocumentFragment(){}function ProcessingInstruction(){}function XMLSerializer(){}function serializeToString(node,buf){switch(node.nodeType){case ELEMENT_NODE:var attrs=node.attributes,len=attrs.length,child=node.firstChild,nodeName=node.tagName,isHTML=htmlns===node.namespaceURI;buf.push(\"<\",nodeName);for(var i=0;len>i;i++)serializeToString(attrs.item(i),buf,isHTML);if(child||isHTML&&!/^(?:meta|link|img|br|hr|input|button)$/i.test(nodeName)){if(buf.push(\">\"),isHTML&&/^script$/i.test(nodeName))child&&buf.push(child.data);else for(;child;)serializeToString(child,buf),child=child.nextSibling;buf.push(\"</\",nodeName,\">\")}else buf.push(\"/>\");return;case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:for(var child=node.firstChild;child;)serializeToString(child,buf),child=child.nextSibling;return;case ATTRIBUTE_NODE:return buf.push(\" \",node.name,'=\"',node.value.replace(/[<&\"]/g,_xmlEncoder),'\"');case TEXT_NODE:return buf.push(node.data.replace(/[<&]/g,_xmlEncoder));case CDATA_SECTION_NODE:return buf.push(\"<![CDATA[\",node.data,\"]]>\");case COMMENT_NODE:return buf.push(\"<!--\",node.data,\"-->\");case DOCUMENT_TYPE_NODE:var pubid=node.publicId,sysid=node.systemId;if(buf.push(\"<!DOCTYPE \",node.name),pubid)buf.push(' PUBLIC \"',pubid),sysid&&\".\"!=sysid&&buf.push('\" \"',sysid),buf.push('\">');else if(sysid&&\".\"!=sysid)buf.push(' SYSTEM \"',sysid,'\">');else{var sub=node.internalSubset;sub&&buf.push(\" [\",sub,\"]\"),buf.push(\">\")}return;case PROCESSING_INSTRUCTION_NODE:return buf.push(\"<?\",node.target,\" \",node.data,\"?>\");case ENTITY_REFERENCE_NODE:return buf.push(\"&\",node.nodeName,\";\");default:buf.push(\"??\",node.nodeName)}}function importNode(doc,node,deep){var node2;switch(node.nodeType){case ELEMENT_NODE:node2=node.cloneNode(!1),node2.ownerDocument=doc;case DOCUMENT_FRAGMENT_NODE:break;case ATTRIBUTE_NODE:deep=!0}if(node2||(node2=node.cloneNode(!1)),node2.ownerDocument=doc,node2.parentNode=null,deep)for(var child=node.firstChild;child;)node2.appendChild(importNode(doc,child,deep)),child=child.nextSibling;return node2}function cloneNode(doc,node,deep){var node2=new node.constructor;for(var n in node){var v=node[n];\"object\"!=typeof v&&v!=node2[n]&&(node2[n]=v)}switch(node.childNodes&&(node2.childNodes=new NodeList),node2.ownerDocument=doc,node2.nodeType){case ELEMENT_NODE:var attrs=node.attributes,attrs2=node2.attributes=new NamedNodeMap,len=attrs.length;attrs2._ownerElement=node2;for(var i=0;len>i;i++)node2.setAttributeNode(cloneNode(doc,attrs.item(i),!0));break;case ATTRIBUTE_NODE:deep=!0}if(deep)for(var child=node.firstChild;child;)node2.appendChild(cloneNode(doc,child,deep)),child=child.nextSibling;return node2}function __set__(object,key,value){object[key]=value}function getTextContent(node){switch(node.nodeType){case 1:case 11:var buf=[];for(node=node.firstChild;node;)7!==node.nodeType&&8!==node.nodeType&&buf.push(getTextContent(node)),node=node.nextSibling;return buf.join(\"\");default:return node.nodeValue}}var htmlns=\"http://www.w3.org/1999/xhtml\",NodeType={},ELEMENT_NODE=NodeType.ELEMENT_NODE=1,ATTRIBUTE_NODE=NodeType.ATTRIBUTE_NODE=2,TEXT_NODE=NodeType.TEXT_NODE=3,CDATA_SECTION_NODE=NodeType.CDATA_SECTION_NODE=4,ENTITY_REFERENCE_NODE=NodeType.ENTITY_REFERENCE_NODE=5,ENTITY_NODE=NodeType.ENTITY_NODE=6,PROCESSING_INSTRUCTION_NODE=NodeType.PROCESSING_INSTRUCTION_NODE=7,COMMENT_NODE=NodeType.COMMENT_NODE=8,DOCUMENT_NODE=NodeType.DOCUMENT_NODE=9,DOCUMENT_TYPE_NODE=NodeType.DOCUMENT_TYPE_NODE=10,DOCUMENT_FRAGMENT_NODE=NodeType.DOCUMENT_FRAGMENT_NODE=11,NOTATION_NODE=NodeType.NOTATION_NODE=12,ExceptionCode={},ExceptionMessage={};ExceptionCode.INDEX_SIZE_ERR=(ExceptionMessage[1]=\"Index size error\",1),ExceptionCode.DOMSTRING_SIZE_ERR=(ExceptionMessage[2]=\"DOMString size error\",2),ExceptionCode.HIERARCHY_REQUEST_ERR=(ExceptionMessage[3]=\"Hierarchy request error\",3),ExceptionCode.WRONG_DOCUMENT_ERR=(ExceptionMessage[4]=\"Wrong document\",4),ExceptionCode.INVALID_CHARACTER_ERR=(ExceptionMessage[5]=\"Invalid character\",5),ExceptionCode.NO_DATA_ALLOWED_ERR=(ExceptionMessage[6]=\"No data allowed\",6),ExceptionCode.NO_MODIFICATION_ALLOWED_ERR=(ExceptionMessage[7]=\"No modification allowed\",7);var NOT_FOUND_ERR=ExceptionCode.NOT_FOUND_ERR=(ExceptionMessage[8]=\"Not found\",8);ExceptionCode.NOT_SUPPORTED_ERR=(ExceptionMessage[9]=\"Not supported\",9);var INUSE_ATTRIBUTE_ERR=ExceptionCode.INUSE_ATTRIBUTE_ERR=(ExceptionMessage[10]=\"Attribute in use\",10);ExceptionCode.INVALID_STATE_ERR=(ExceptionMessage[11]=\"Invalid state\",11),ExceptionCode.SYNTAX_ERR=(ExceptionMessage[12]=\"Syntax error\",12),ExceptionCode.INVALID_MODIFICATION_ERR=(ExceptionMessage[13]=\"Invalid modification\",13),ExceptionCode.NAMESPACE_ERR=(ExceptionMessage[14]=\"Invalid namespace\",14),ExceptionCode.INVALID_ACCESS_ERR=(ExceptionMessage[15]=\"Invalid access\",15),DOMException.prototype=Error.prototype,copy(ExceptionCode,DOMException),NodeList.prototype={length:0,item:function(index){return this[index]||null}},LiveNodeList.prototype.item=function(i){return _updateLiveList(this),this[i]},_extends(LiveNodeList,NodeList),NamedNodeMap.prototype={length:0,item:NodeList.prototype.item,getNamedItem:function(key){for(var i=this.length;i--;){var attr=this[i];if(attr.nodeName==key)return attr}},setNamedItem:function(attr){var el=attr.ownerElement;if(el&&el!=this._ownerElement)throw new DOMException(INUSE_ATTRIBUTE_ERR);var oldAttr=this.getNamedItem(attr.nodeName);return _addNamedNode(this._ownerElement,this,attr,oldAttr),oldAttr},setNamedItemNS:function(attr){var oldAttr,el=attr.ownerElement;if(el&&el!=this._ownerElement)throw new DOMException(INUSE_ATTRIBUTE_ERR);return oldAttr=this.getNamedItemNS(attr.namespaceURI,attr.localName),_addNamedNode(this._ownerElement,this,attr,oldAttr),oldAttr},removeNamedItem:function(key){var attr=this.getNamedItem(key);return _removeNamedNode(this._ownerElement,this,attr),attr},removeNamedItemNS:function(namespaceURI,localName){var attr=this.getNamedItemNS(namespaceURI,localName);return _removeNamedNode(this._ownerElement,this,attr),attr},getNamedItemNS:function(namespaceURI,localName){for(var i=this.length;i--;){var node=this[i];if(node.localName==localName&&node.namespaceURI==namespaceURI)return node}return null}},DOMImplementation.prototype={hasFeature:function(feature,version){var versions=this._features[feature.toLowerCase()];return versions&&(!version||version in versions)?!0:!1},createDocument:function(namespaceURI,qualifiedName,doctype){var doc=new Document;if(doc.implementation=this,doc.childNodes=new NodeList,doc.doctype=doctype,doctype&&doc.appendChild(doctype),qualifiedName){var root=doc.createElementNS(namespaceURI,qualifiedName);doc.appendChild(root)}return doc},createDocumentType:function(qualifiedName,publicId,systemId){var node=new DocumentType;return node.name=qualifiedName,node.nodeName=qualifiedName,node.publicId=publicId,node.systemId=systemId,node}},Node.prototype={firstChild:null,lastChild:null,previousSibling:null,nextSibling:null,attributes:null,parentNode:null,childNodes:null,ownerDocument:null,nodeValue:null,namespaceURI:null,prefix:null,localName:null,insertBefore:function(newChild,refChild){return _insertBefore(this,newChild,refChild)},replaceChild:function(newChild,oldChild){this.insertBefore(newChild,oldChild),oldChild&&this.removeChild(oldChild)},removeChild:function(oldChild){return _removeChild(this,oldChild)},appendChild:function(newChild){return this.insertBefore(newChild,null)},hasChildNodes:function(){return null!=this.firstChild},cloneNode:function(deep){return cloneNode(this.ownerDocument||this,this,deep)},normalize:function(){for(var child=this.firstChild;child;){var next=child.nextSibling;next&&next.nodeType==TEXT_NODE&&child.nodeType==TEXT_NODE?(this.removeChild(next),child.appendData(next.data)):(child.normalize(),child=next)}},isSupported:function(feature,version){return this.ownerDocument.implementation.hasFeature(feature,version)},hasAttributes:function(){return this.attributes.length>0},lookupPrefix:function(namespaceURI){for(var el=this;el;){var map=el._nsMap;if(map)for(var n in map)if(map[n]==namespaceURI)return n;el=2==el.nodeType?el.ownerDocument:el.parentNode}return null},lookupNamespaceURI:function(prefix){for(var el=this;el;){var map=el._nsMap;if(map&&prefix in map)return map[prefix];el=2==el.nodeType?el.ownerDocument:el.parentNode}return null},isDefaultNamespace:function(namespaceURI){var prefix=this.lookupPrefix(namespaceURI);return null==prefix}},copy(NodeType,Node),copy(NodeType,Node.prototype),Document.prototype={nodeName:\"#document\",nodeType:DOCUMENT_NODE,doctype:null,documentElement:null,_inc:1,insertBefore:function(newChild,refChild){if(newChild.nodeType==DOCUMENT_FRAGMENT_NODE){for(var child=newChild.firstChild;child;){var next=child.nextSibling;this.insertBefore(child,refChild),child=next}return newChild}return null==this.documentElement&&1==newChild.nodeType&&(this.documentElement=newChild),_insertBefore(this,newChild,refChild),newChild.ownerDocument=this,newChild},removeChild:function(oldChild){return this.documentElement==oldChild&&(this.documentElement=null),_removeChild(this,oldChild)},importNode:function(importedNode,deep){return importNode(this,importedNode,deep)},getElementById:function(id){var rtv=null;return _visitNode(this.documentElement,function(node){return 1==node.nodeType&&node.getAttribute(\"id\")==id?(rtv=node,!0):void 0}),rtv},createElement:function(tagName){var node=new Element;node.ownerDocument=this,node.nodeName=tagName,node.tagName=tagName,node.childNodes=new NodeList;var attrs=node.attributes=new NamedNodeMap;return attrs._ownerElement=node,node},createDocumentFragment:function(){var node=new DocumentFragment;return node.ownerDocument=this,node.childNodes=new NodeList,node},createTextNode:function(data){var node=new Text;return node.ownerDocument=this,node.appendData(data),node},createComment:function(data){var node=new Comment;return node.ownerDocument=this,node.appendData(data),node},createCDATASection:function(data){var node=new CDATASection;return node.ownerDocument=this,node.appendData(data),node},createProcessingInstruction:function(target,data){var node=new ProcessingInstruction;return node.ownerDocument=this,node.tagName=node.target=target,node.nodeValue=node.data=data,node},createAttribute:function(name){var node=new Attr;return node.ownerDocument=this,node.name=name,node.nodeName=name,node.localName=name,node.specified=!0,node},createEntityReference:function(name){var node=new EntityReference;return node.ownerDocument=this,node.nodeName=name,node},createElementNS:function(namespaceURI,qualifiedName){var node=new Element,pl=qualifiedName.split(\":\"),attrs=node.attributes=new NamedNodeMap;return node.childNodes=new NodeList,node.ownerDocument=this,node.nodeName=qualifiedName,node.tagName=qualifiedName,node.namespaceURI=namespaceURI,2==pl.length?(node.prefix=pl[0],node.localName=pl[1]):node.localName=qualifiedName,attrs._ownerElement=node,node},createAttributeNS:function(namespaceURI,qualifiedName){var node=new Attr,pl=qualifiedName.split(\":\");return node.ownerDocument=this,node.nodeName=qualifiedName,node.name=qualifiedName,node.namespaceURI=namespaceURI,node.specified=!0,2==pl.length?(node.prefix=pl[0],node.localName=pl[1]):node.localName=qualifiedName,node}},_extends(Document,Node),Element.prototype={nodeType:ELEMENT_NODE,hasAttribute:function(name){return null!=this.getAttributeNode(name)},getAttribute:function(name){var attr=this.getAttributeNode(name);return attr&&attr.value||\"\"},getAttributeNode:function(name){return this.attributes.getNamedItem(name)},setAttribute:function(name,value){var attr=this.ownerDocument.createAttribute(name);attr.value=attr.nodeValue=\"\"+value,this.setAttributeNode(attr)},removeAttribute:function(name){var attr=this.getAttributeNode(name);attr&&this.removeAttributeNode(attr)},appendChild:function(newChild){return newChild.nodeType===DOCUMENT_FRAGMENT_NODE?this.insertBefore(newChild,null):_appendSingleChild(this,newChild)},setAttributeNode:function(newAttr){return this.attributes.setNamedItem(newAttr)},setAttributeNodeNS:function(newAttr){return this.attributes.setNamedItemNS(newAttr)},removeAttributeNode:function(oldAttr){return this.attributes.removeNamedItem(oldAttr.nodeName)},removeAttributeNS:function(namespaceURI,localName){var old=this.getAttributeNodeNS(namespaceURI,localName);old&&this.removeAttributeNode(old)},hasAttributeNS:function(namespaceURI,localName){return null!=this.getAttributeNodeNS(namespaceURI,localName)},getAttributeNS:function(namespaceURI,localName){var attr=this.getAttributeNodeNS(namespaceURI,localName);return attr&&attr.value||\"\"},setAttributeNS:function(namespaceURI,qualifiedName,value){var attr=this.ownerDocument.createAttributeNS(namespaceURI,qualifiedName);attr.value=attr.nodeValue=\"\"+value,this.setAttributeNode(attr)},getAttributeNodeNS:function(namespaceURI,localName){return this.attributes.getNamedItemNS(namespaceURI,localName)},getElementsByTagName:function(tagName){return new LiveNodeList(this,function(base){var ls=[];return _visitNode(base,function(node){node===base||node.nodeType!=ELEMENT_NODE||\"*\"!==tagName&&node.tagName!=tagName||ls.push(node)}),ls})},getElementsByTagNameNS:function(namespaceURI,localName){return new LiveNodeList(this,function(base){var ls=[];return _visitNode(base,function(node){node===base||node.nodeType!==ELEMENT_NODE||\"*\"!==namespaceURI&&node.namespaceURI!==namespaceURI||\"*\"!==localName&&node.localName!=localName||ls.push(node)}),ls})}},Document.prototype.getElementsByTagName=Element.prototype.getElementsByTagName,Document.prototype.getElementsByTagNameNS=Element.prototype.getElementsByTagNameNS,_extends(Element,Node),Attr.prototype.nodeType=ATTRIBUTE_NODE,_extends(Attr,Node),CharacterData.prototype={data:\"\",substringData:function(offset,count){return this.data.substring(offset,offset+count)},appendData:function(text){text=this.data+text,this.nodeValue=this.data=text,this.length=text.length},insertData:function(offset,text){this.replaceData(offset,0,text)},appendChild:function(){throw Error(ExceptionMessage[3])},deleteData:function(offset,count){this.replaceData(offset,count,\"\")},replaceData:function(offset,count,text){var start=this.data.substring(0,offset),end=this.data.substring(offset+count);text=start+text+end,this.nodeValue=this.data=text,this.length=text.length}},_extends(CharacterData,Node),Text.prototype={nodeName:\"#text\",nodeType:TEXT_NODE,splitText:function(offset){var text=this.data,newText=text.substring(offset);text=text.substring(0,offset),this.data=this.nodeValue=text,this.length=text.length;var newNode=this.ownerDocument.createTextNode(newText);return this.parentNode&&this.parentNode.insertBefore(newNode,this.nextSibling),newNode}},_extends(Text,CharacterData),Comment.prototype={nodeName:\"#comment\",nodeType:COMMENT_NODE},_extends(Comment,CharacterData),CDATASection.prototype={nodeName:\"#cdata-section\",nodeType:CDATA_SECTION_NODE},_extends(CDATASection,CharacterData),DocumentType.prototype.nodeType=DOCUMENT_TYPE_NODE,_extends(DocumentType,Node),Notation.prototype.nodeType=NOTATION_NODE,_extends(Notation,Node),Entity.prototype.nodeType=ENTITY_NODE,_extends(Entity,Node),EntityReference.prototype.nodeType=ENTITY_REFERENCE_NODE,_extends(EntityReference,Node),DocumentFragment.prototype.nodeName=\"#document-fragment\",DocumentFragment.prototype.nodeType=DOCUMENT_FRAGMENT_NODE,_extends(DocumentFragment,Node),ProcessingInstruction.prototype.nodeType=PROCESSING_INSTRUCTION_NODE,_extends(ProcessingInstruction,Node),XMLSerializer.prototype.serializeToString=function(node){var buf=[];return serializeToString(node,buf),buf.join(\"\")},Node.prototype.toString=function(){return XMLSerializer.prototype.serializeToString(this)};try{Object.defineProperty&&(Object.defineProperty(LiveNodeList.prototype,\"length\",{get:function(){return _updateLiveList(this),this.$$length}}),Object.defineProperty(Node.prototype,\"textContent\",{get:function(){return getTextContent(this)},set:function(data){switch(this.nodeType){case 1:case 11:for(;this.firstChild;)this.removeChild(this.firstChild);(data||data+\"\")&&this.appendChild(this.ownerDocument.createTextNode(data));break;default:this.data=data,this.value=value,this.nodeValue=data}}}),__set__=function(object,key,value){object[\"$$\"+key]=value})}catch(e){}return DOMImplementation}),ace.define(\"ace/mode/xml/dom-parser\",[\"require\",\"exports\",\"module\",\"ace/mode/xml/sax\",\"ace/mode/xml/dom\"],function(acequire){\"use strict\";function DOMParser(options){this.options=options||{locator:{}}}function buildErrorHandler(errorImpl,domBuilder,locator){function build(key){var fn=errorImpl[key];if(!fn)if(isCallback)fn=2==errorImpl.length?function(msg){errorImpl(key,msg)}:errorImpl;else for(var i=arguments.length;--i&&!(fn=errorImpl[arguments[i]]););errorHandler[key]=fn&&function(msg){fn(msg+_locator(locator),msg,locator)}||function(){}}if(!errorImpl){if(domBuilder instanceof DOMHandler)return domBuilder;errorImpl=domBuilder}var errorHandler={},isCallback=errorImpl instanceof Function;return locator=locator||{},build(\"warning\",\"warn\"),build(\"error\",\"warn\",\"warning\"),build(\"fatalError\",\"warn\",\"warning\",\"error\"),errorHandler}function DOMHandler(){this.cdata=!1}function position(locator,node){node.lineNumber=locator.lineNumber,node.columnNumber=locator.columnNumber}function _locator(l){return l?\"\\n@\"+(l.systemId||\"\")+\"#[line:\"+l.lineNumber+\",col:\"+l.columnNumber+\"]\":void 0}function _toString(chars,start,length){return\"string\"==typeof chars?chars.substr(start,length):chars.length>=start+length||start?new java.lang.String(chars,start,length)+\"\":chars}function appendElement(hander,node){hander.currentElement?hander.currentElement.appendChild(node):hander.document.appendChild(node)}var XMLReader=acequire(\"./sax\"),DOMImplementation=acequire(\"./dom\");return DOMParser.prototype.parseFromString=function(source,mimeType){var options=this.options,sax=new XMLReader,domBuilder=options.domBuilder||new DOMHandler,errorHandler=options.errorHandler,locator=options.locator,defaultNSMap=options.xmlns||{},entityMap={lt:\"<\",gt:\">\",amp:\"&\",quot:'\"',apos:\"'\"};return locator&&domBuilder.setDocumentLocator(locator),sax.errorHandler=buildErrorHandler(errorHandler,domBuilder,locator),sax.domBuilder=options.domBuilder||domBuilder,/\\/x?html?$/.test(mimeType)&&(entityMap.nbsp=\" \",entityMap.copy=\"©\",defaultNSMap[\"\"]=\"http://www.w3.org/1999/xhtml\"),source?sax.parse(source,defaultNSMap,entityMap):sax.errorHandler.error(\"invalid document source\"),domBuilder.document},DOMHandler.prototype={startDocument:function(){this.document=(new DOMImplementation).createDocument(null,null,null),this.locator&&(this.document.documentURI=this.locator.systemId)},startElement:function(namespaceURI,localName,qName,attrs){var doc=this.document,el=doc.createElementNS(namespaceURI,qName||localName),len=attrs.length;appendElement(this,el),this.currentElement=el,this.locator&&position(this.locator,el);for(var i=0;len>i;i++){var namespaceURI=attrs.getURI(i),value=attrs.getValue(i),qName=attrs.getQName(i),attr=doc.createAttributeNS(namespaceURI,qName);attr.getOffset&&position(attr.getOffset(1),attr),attr.value=attr.nodeValue=value,el.setAttributeNode(attr)}},endElement:function(){var current=this.currentElement;current.tagName,this.currentElement=current.parentNode},startPrefixMapping:function(){},endPrefixMapping:function(){},processingInstruction:function(target,data){var ins=this.document.createProcessingInstruction(target,data);this.locator&&position(this.locator,ins),appendElement(this,ins)},ignorableWhitespace:function(){},characters:function(chars){if(chars=_toString.apply(this,arguments),this.currentElement&&chars){if(this.cdata){var charNode=this.document.createCDATASection(chars);this.currentElement.appendChild(charNode)}else{var charNode=this.document.createTextNode(chars);this.currentElement.appendChild(charNode)}this.locator&&position(this.locator,charNode)}},skippedEntity:function(){},endDocument:function(){this.document.normalize()},setDocumentLocator:function(locator){(this.locator=locator)&&(locator.lineNumber=0)},comment:function(chars){chars=_toString.apply(this,arguments);var comm=this.document.createComment(chars);this.locator&&position(this.locator,comm),appendElement(this,comm)},startCDATA:function(){this.cdata=!0},endCDATA:function(){this.cdata=!1},startDTD:function(name,publicId,systemId){var impl=this.document.implementation;if(impl&&impl.createDocumentType){var dt=impl.createDocumentType(name,publicId,systemId);this.locator&&position(this.locator,dt),appendElement(this,dt)}},warning:function(error){console.warn(error,_locator(this.locator))},error:function(error){console.error(error,_locator(this.locator))},fatalError:function(error){throw console.error(error,_locator(this.locator)),error}},\"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl\".replace(/\\w+/g,function(key){DOMHandler.prototype[key]=function(){return null}}),{DOMParser:DOMParser}}),ace.define(\"ace/mode/xml_worker\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/worker/mirror\",\"ace/mode/xml/dom-parser\"],function(acequire,exports){\"use strict\";var oop=acequire(\"../lib/oop\");acequire(\"../lib/lang\");var Mirror=acequire(\"../worker/mirror\").Mirror,DOMParser=acequire(\"./xml/dom-parser\").DOMParser,Worker=exports.Worker=function(sender){Mirror.call(this,sender),this.setTimeout(400),this.context=null};oop.inherits(Worker,Mirror),function(){this.setOptions=function(options){this.context=options.context},this.onUpdate=function(){var value=this.doc.getValue();if(value){var parser=new DOMParser,errors=[];parser.options.errorHandler={fatalError:function(fullMsg,errorMsg,locator){errors.push({row:locator.lineNumber,column:locator.columnNumber,text:errorMsg,type:\"error\"})},error:function(fullMsg,errorMsg,locator){errors.push({row:locator.lineNumber,column:locator.columnNumber,text:errorMsg,type:\"error\"})},warning:function(fullMsg,errorMsg,locator){errors.push({row:locator.lineNumber,column:locator.columnNumber,text:errorMsg,type:\"warning\"})}},parser.parseFromString(value),this.sender.emit(\"error\",errors)}}}.call(Worker.prototype)}),ace.define(\"ace/lib/es5-shim\",[\"require\",\"exports\",\"module\"],function(){function Empty(){}function doesDefinePropertyWork(object){try{return Object.defineProperty(object,\"sentinel\",{}),\"sentinel\"in object\n}catch(exception){}}function toInteger(n){return n=+n,n!==n?n=0:0!==n&&n!==1/0&&n!==-(1/0)&&(n=(n>0||-1)*Math.floor(Math.abs(n))),n}Function.prototype.bind||(Function.prototype.bind=function(that){var target=this;if(\"function\"!=typeof target)throw new TypeError(\"Function.prototype.bind called on incompatible \"+target);var args=slice.call(arguments,1),bound=function(){if(this instanceof bound){var result=target.apply(this,args.concat(slice.call(arguments)));return Object(result)===result?result:this}return target.apply(that,args.concat(slice.call(arguments)))};return target.prototype&&(Empty.prototype=target.prototype,bound.prototype=new Empty,Empty.prototype=null),bound});var defineGetter,defineSetter,lookupGetter,lookupSetter,supportsAccessors,call=Function.prototype.call,prototypeOfArray=Array.prototype,prototypeOfObject=Object.prototype,slice=prototypeOfArray.slice,_toString=call.bind(prototypeOfObject.toString),owns=call.bind(prototypeOfObject.hasOwnProperty);if((supportsAccessors=owns(prototypeOfObject,\"__defineGetter__\"))&&(defineGetter=call.bind(prototypeOfObject.__defineGetter__),defineSetter=call.bind(prototypeOfObject.__defineSetter__),lookupGetter=call.bind(prototypeOfObject.__lookupGetter__),lookupSetter=call.bind(prototypeOfObject.__lookupSetter__)),2!=[1,2].splice(0).length)if(function(){function makeArray(l){var a=Array(l+2);return a[0]=a[1]=0,a}var lengthBefore,array=[];return array.splice.apply(array,makeArray(20)),array.splice.apply(array,makeArray(26)),lengthBefore=array.length,array.splice(5,0,\"XXX\"),lengthBefore+1==array.length,lengthBefore+1==array.length?!0:void 0}()){var array_splice=Array.prototype.splice;Array.prototype.splice=function(start,deleteCount){return arguments.length?array_splice.apply(this,[void 0===start?0:start,void 0===deleteCount?this.length-start:deleteCount].concat(slice.call(arguments,2))):[]}}else Array.prototype.splice=function(pos,removeCount){var length=this.length;pos>0?pos>length&&(pos=length):void 0==pos?pos=0:0>pos&&(pos=Math.max(length+pos,0)),length>pos+removeCount||(removeCount=length-pos);var removed=this.slice(pos,pos+removeCount),insert=slice.call(arguments,2),add=insert.length;if(pos===length)add&&this.push.apply(this,insert);else{var remove=Math.min(removeCount,length-pos),tailOldPos=pos+remove,tailNewPos=tailOldPos+add-remove,tailCount=length-tailOldPos,lengthAfterRemove=length-remove;if(tailOldPos>tailNewPos)for(var i=0;tailCount>i;++i)this[tailNewPos+i]=this[tailOldPos+i];else if(tailNewPos>tailOldPos)for(i=tailCount;i--;)this[tailNewPos+i]=this[tailOldPos+i];if(add&&pos===lengthAfterRemove)this.length=lengthAfterRemove,this.push.apply(this,insert);else for(this.length=lengthAfterRemove+add,i=0;add>i;++i)this[pos+i]=insert[i]}return removed};Array.isArray||(Array.isArray=function(obj){return\"[object Array]\"==_toString(obj)});var boxedString=Object(\"a\"),splitString=\"a\"!=boxedString[0]||!(0 in boxedString);if(Array.prototype.forEach||(Array.prototype.forEach=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,thisp=arguments[1],i=-1,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError;for(;length>++i;)i in self&&fun.call(thisp,self[i],i,object)}),Array.prototype.map||(Array.prototype.map=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,result=Array(length),thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)i in self&&(result[i]=fun.call(thisp,self[i],i,object));return result}),Array.prototype.filter||(Array.prototype.filter=function(fun){var value,object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,result=[],thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)i in self&&(value=self[i],fun.call(thisp,value,i,object)&&result.push(value));return result}),Array.prototype.every||(Array.prototype.every=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)if(i in self&&!fun.call(thisp,self[i],i,object))return!1;return!0}),Array.prototype.some||(Array.prototype.some=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)if(i in self&&fun.call(thisp,self[i],i,object))return!0;return!1}),Array.prototype.reduce||(Array.prototype.reduce=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");if(!length&&1==arguments.length)throw new TypeError(\"reduce of empty array with no initial value\");var result,i=0;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i++];break}if(++i>=length)throw new TypeError(\"reduce of empty array with no initial value\")}for(;length>i;i++)i in self&&(result=fun.call(void 0,result,self[i],i,object));return result}),Array.prototype.reduceRight||(Array.prototype.reduceRight=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");if(!length&&1==arguments.length)throw new TypeError(\"reduceRight of empty array with no initial value\");var result,i=length-1;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i--];break}if(0>--i)throw new TypeError(\"reduceRight of empty array with no initial value\")}do i in this&&(result=fun.call(void 0,result,self[i],i,object));while(i--);return result}),Array.prototype.indexOf&&-1==[0,1].indexOf(1,2)||(Array.prototype.indexOf=function(sought){var self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):toObject(this),length=self.length>>>0;if(!length)return-1;var i=0;for(arguments.length>1&&(i=toInteger(arguments[1])),i=i>=0?i:Math.max(0,length+i);length>i;i++)if(i in self&&self[i]===sought)return i;return-1}),Array.prototype.lastIndexOf&&-1==[0,1].lastIndexOf(0,-3)||(Array.prototype.lastIndexOf=function(sought){var self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):toObject(this),length=self.length>>>0;if(!length)return-1;var i=length-1;for(arguments.length>1&&(i=Math.min(i,toInteger(arguments[1]))),i=i>=0?i:length-Math.abs(i);i>=0;i--)if(i in self&&sought===self[i])return i;return-1}),Object.getPrototypeOf||(Object.getPrototypeOf=function(object){return object.__proto__||(object.constructor?object.constructor.prototype:prototypeOfObject)}),!Object.getOwnPropertyDescriptor){var ERR_NON_OBJECT=\"Object.getOwnPropertyDescriptor called on a non-object: \";Object.getOwnPropertyDescriptor=function(object,property){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT+object);if(owns(object,property)){var descriptor,getter,setter;if(descriptor={enumerable:!0,configurable:!0},supportsAccessors){var prototype=object.__proto__;object.__proto__=prototypeOfObject;var getter=lookupGetter(object,property),setter=lookupSetter(object,property);if(object.__proto__=prototype,getter||setter)return getter&&(descriptor.get=getter),setter&&(descriptor.set=setter),descriptor}return descriptor.value=object[property],descriptor}}}if(Object.getOwnPropertyNames||(Object.getOwnPropertyNames=function(object){return Object.keys(object)}),!Object.create){var createEmpty;createEmpty=null===Object.prototype.__proto__?function(){return{__proto__:null}}:function(){var empty={};for(var i in empty)empty[i]=null;return empty.constructor=empty.hasOwnProperty=empty.propertyIsEnumerable=empty.isPrototypeOf=empty.toLocaleString=empty.toString=empty.valueOf=empty.__proto__=null,empty},Object.create=function(prototype,properties){var object;if(null===prototype)object=createEmpty();else{if(\"object\"!=typeof prototype)throw new TypeError(\"typeof prototype[\"+typeof prototype+\"] != 'object'\");var Type=function(){};Type.prototype=prototype,object=new Type,object.__proto__=prototype}return void 0!==properties&&Object.defineProperties(object,properties),object}}if(Object.defineProperty){var definePropertyWorksOnObject=doesDefinePropertyWork({}),definePropertyWorksOnDom=\"undefined\"==typeof document||doesDefinePropertyWork(document.createElement(\"div\"));if(!definePropertyWorksOnObject||!definePropertyWorksOnDom)var definePropertyFallback=Object.defineProperty}if(!Object.defineProperty||definePropertyFallback){var ERR_NON_OBJECT_DESCRIPTOR=\"Property description must be an object: \",ERR_NON_OBJECT_TARGET=\"Object.defineProperty called on non-object: \",ERR_ACCESSORS_NOT_SUPPORTED=\"getters & setters can not be defined on this javascript engine\";Object.defineProperty=function(object,property,descriptor){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT_TARGET+object);if(\"object\"!=typeof descriptor&&\"function\"!=typeof descriptor||null===descriptor)throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR+descriptor);if(definePropertyFallback)try{return definePropertyFallback.call(Object,object,property,descriptor)}catch(exception){}if(owns(descriptor,\"value\"))if(supportsAccessors&&(lookupGetter(object,property)||lookupSetter(object,property))){var prototype=object.__proto__;object.__proto__=prototypeOfObject,delete object[property],object[property]=descriptor.value,object.__proto__=prototype}else object[property]=descriptor.value;else{if(!supportsAccessors)throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);owns(descriptor,\"get\")&&defineGetter(object,property,descriptor.get),owns(descriptor,\"set\")&&defineSetter(object,property,descriptor.set)}return object}}Object.defineProperties||(Object.defineProperties=function(object,properties){for(var property in properties)owns(properties,property)&&Object.defineProperty(object,property,properties[property]);return object}),Object.seal||(Object.seal=function(object){return object}),Object.freeze||(Object.freeze=function(object){return object});try{Object.freeze(function(){})}catch(exception){Object.freeze=function(freezeObject){return function(object){return\"function\"==typeof object?object:freezeObject(object)}}(Object.freeze)}if(Object.preventExtensions||(Object.preventExtensions=function(object){return object}),Object.isSealed||(Object.isSealed=function(){return!1}),Object.isFrozen||(Object.isFrozen=function(){return!1}),Object.isExtensible||(Object.isExtensible=function(object){if(Object(object)===object)throw new TypeError;for(var name=\"\";owns(object,name);)name+=\"?\";object[name]=!0;var returnValue=owns(object,name);return delete object[name],returnValue}),!Object.keys){var hasDontEnumBug=!0,dontEnums=[\"toString\",\"toLocaleString\",\"valueOf\",\"hasOwnProperty\",\"isPrototypeOf\",\"propertyIsEnumerable\",\"constructor\"],dontEnumsLength=dontEnums.length;for(var key in{toString:null})hasDontEnumBug=!1;Object.keys=function(object){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(\"Object.keys called on a non-object\");var keys=[];for(var name in object)owns(object,name)&&keys.push(name);if(hasDontEnumBug)for(var i=0,ii=dontEnumsLength;ii>i;i++){var dontEnum=dontEnums[i];owns(object,dontEnum)&&keys.push(dontEnum)}return keys}}Date.now||(Date.now=function(){return(new Date).getTime()});var ws=\"\t\\n\u000b\\f\\r   ᠎             　\\u2028\\u2029﻿\";if(!String.prototype.trim||ws.trim()){ws=\"[\"+ws+\"]\";var trimBeginRegexp=RegExp(\"^\"+ws+ws+\"*\"),trimEndRegexp=RegExp(ws+ws+\"*$\");String.prototype.trim=function(){return(this+\"\").replace(trimBeginRegexp,\"\").replace(trimEndRegexp,\"\")}}var toObject=function(o){if(null==o)throw new TypeError(\"can't convert \"+o+\" to object\");return Object(o)}});";

/***/ },
/* 101 */
/***/ function(module, exports) {

	module.exports.id = 'ace/mode/css_worker';
	module.exports.src = "\"no use strict\";(function(window){function resolveModuleId(id,paths){for(var testPath=id,tail=\"\";testPath;){var alias=paths[testPath];if(\"string\"==typeof alias)return alias+tail;if(alias)return alias.location.replace(/\\/*$/,\"/\")+(tail||alias.main||alias.name);if(alias===!1)return\"\";var i=testPath.lastIndexOf(\"/\");if(-1===i)break;tail=testPath.substr(i)+tail,testPath=testPath.slice(0,i)}return id}if(!(void 0!==window.window&&window.document||window.acequire&&window.define)){window.console||(window.console=function(){var msgs=Array.prototype.slice.call(arguments,0);postMessage({type:\"log\",data:msgs})},window.console.error=window.console.warn=window.console.log=window.console.trace=window.console),window.window=window,window.ace=window,window.onerror=function(message,file,line,col,err){postMessage({type:\"error\",data:{message:message,data:err.data,file:file,line:line,col:col,stack:err.stack}})},window.normalizeModule=function(parentId,moduleName){if(-1!==moduleName.indexOf(\"!\")){var chunks=moduleName.split(\"!\");return window.normalizeModule(parentId,chunks[0])+\"!\"+window.normalizeModule(parentId,chunks[1])}if(\".\"==moduleName.charAt(0)){var base=parentId.split(\"/\").slice(0,-1).join(\"/\");for(moduleName=(base?base+\"/\":\"\")+moduleName;-1!==moduleName.indexOf(\".\")&&previous!=moduleName;){var previous=moduleName;moduleName=moduleName.replace(/^\\.\\//,\"\").replace(/\\/\\.\\//,\"/\").replace(/[^\\/]+\\/\\.\\.\\//,\"\")}}return moduleName},window.acequire=function acequire(parentId,id){if(id||(id=parentId,parentId=null),!id.charAt)throw Error(\"worker.js acequire() accepts only (parentId, id) as arguments\");id=window.normalizeModule(parentId,id);var module=window.acequire.modules[id];if(module)return module.initialized||(module.initialized=!0,module.exports=module.factory().exports),module.exports;if(!window.acequire.tlns)return console.log(\"unable to load \"+id);var path=resolveModuleId(id,window.acequire.tlns);return\".js\"!=path.slice(-3)&&(path+=\".js\"),window.acequire.id=id,window.acequire.modules[id]={},importScripts(path),window.acequire(parentId,id)},window.acequire.modules={},window.acequire.tlns={},window.define=function(id,deps,factory){if(2==arguments.length?(factory=deps,\"string\"!=typeof id&&(deps=id,id=window.acequire.id)):1==arguments.length&&(factory=id,deps=[],id=window.acequire.id),\"function\"!=typeof factory)return window.acequire.modules[id]={exports:factory,initialized:!0},void 0;deps.length||(deps=[\"require\",\"exports\",\"module\"]);var req=function(childId){return window.acequire(id,childId)};window.acequire.modules[id]={exports:{},factory:function(){var module=this,returnExports=factory.apply(this,deps.map(function(dep){switch(dep){case\"require\":return req;case\"exports\":return module.exports;case\"module\":return module;default:return req(dep)}}));return returnExports&&(module.exports=returnExports),module}}},window.define.amd={},acequire.tlns={},window.initBaseUrls=function(topLevelNamespaces){for(var i in topLevelNamespaces)acequire.tlns[i]=topLevelNamespaces[i]},window.initSender=function(){var EventEmitter=window.acequire(\"ace/lib/event_emitter\").EventEmitter,oop=window.acequire(\"ace/lib/oop\"),Sender=function(){};return function(){oop.implement(this,EventEmitter),this.callback=function(data,callbackId){postMessage({type:\"call\",id:callbackId,data:data})},this.emit=function(name,data){postMessage({type:\"event\",name:name,data:data})}}.call(Sender.prototype),new Sender};var main=window.main=null,sender=window.sender=null;window.onmessage=function(e){var msg=e.data;if(msg.event&&sender)sender._signal(msg.event,msg.data);else if(msg.command)if(main[msg.command])main[msg.command].apply(main,msg.args);else{if(!window[msg.command])throw Error(\"Unknown command:\"+msg.command);window[msg.command].apply(window,msg.args)}else if(msg.init){window.initBaseUrls(msg.tlns),acequire(\"ace/lib/es5-shim\"),sender=window.sender=window.initSender();var clazz=acequire(msg.module)[msg.classname];main=window.main=new clazz(sender)}}}})(this),ace.define(\"ace/lib/oop\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";exports.inherits=function(ctor,superCtor){ctor.super_=superCtor,ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:!1,writable:!0,configurable:!0}})},exports.mixin=function(obj,mixin){for(var key in mixin)obj[key]=mixin[key];return obj},exports.implement=function(proto,mixin){exports.mixin(proto,mixin)}}),ace.define(\"ace/lib/lang\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";exports.last=function(a){return a[a.length-1]},exports.stringReverse=function(string){return string.split(\"\").reverse().join(\"\")},exports.stringRepeat=function(string,count){for(var result=\"\";count>0;)1&count&&(result+=string),(count>>=1)&&(string+=string);return result};var trimBeginRegexp=/^\\s\\s*/,trimEndRegexp=/\\s\\s*$/;exports.stringTrimLeft=function(string){return string.replace(trimBeginRegexp,\"\")},exports.stringTrimRight=function(string){return string.replace(trimEndRegexp,\"\")},exports.copyObject=function(obj){var copy={};for(var key in obj)copy[key]=obj[key];return copy},exports.copyArray=function(array){for(var copy=[],i=0,l=array.length;l>i;i++)copy[i]=array[i]&&\"object\"==typeof array[i]?this.copyObject(array[i]):array[i];return copy},exports.deepCopy=function deepCopy(obj){if(\"object\"!=typeof obj||!obj)return obj;var copy;if(Array.isArray(obj)){copy=[];for(var key=0;obj.length>key;key++)copy[key]=deepCopy(obj[key]);return copy}var cons=obj.constructor;if(cons===RegExp)return obj;copy=cons();for(var key in obj)copy[key]=deepCopy(obj[key]);return copy},exports.arrayToMap=function(arr){for(var map={},i=0;arr.length>i;i++)map[arr[i]]=1;return map},exports.createMap=function(props){var map=Object.create(null);for(var i in props)map[i]=props[i];return map},exports.arrayRemove=function(array,value){for(var i=0;array.length>=i;i++)value===array[i]&&array.splice(i,1)},exports.escapeRegExp=function(str){return str.replace(/([.*+?^${}()|[\\]\\/\\\\])/g,\"\\\\$1\")},exports.escapeHTML=function(str){return str.replace(/&/g,\"&#38;\").replace(/\"/g,\"&#34;\").replace(/'/g,\"&#39;\").replace(/</g,\"&#60;\")},exports.getMatchOffsets=function(string,regExp){var matches=[];return string.replace(regExp,function(str){matches.push({offset:arguments[arguments.length-2],length:str.length})}),matches},exports.deferredCall=function(fcn){var timer=null,callback=function(){timer=null,fcn()},deferred=function(timeout){return deferred.cancel(),timer=setTimeout(callback,timeout||0),deferred};return deferred.schedule=deferred,deferred.call=function(){return this.cancel(),fcn(),deferred},deferred.cancel=function(){return clearTimeout(timer),timer=null,deferred},deferred.isPending=function(){return timer},deferred},exports.delayedCall=function(fcn,defaultTimeout){var timer=null,callback=function(){timer=null,fcn()},_self=function(timeout){null==timer&&(timer=setTimeout(callback,timeout||defaultTimeout))};return _self.delay=function(timeout){timer&&clearTimeout(timer),timer=setTimeout(callback,timeout||defaultTimeout)},_self.schedule=_self,_self.call=function(){this.cancel(),fcn()},_self.cancel=function(){timer&&clearTimeout(timer),timer=null},_self.isPending=function(){return timer},_self}}),ace.define(\"ace/range\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";var comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},Range=function(startRow,startColumn,endRow,endColumn){this.start={row:startRow,column:startColumn},this.end={row:endRow,column:endColumn}};(function(){this.isEqual=function(range){return this.start.row===range.start.row&&this.end.row===range.end.row&&this.start.column===range.start.column&&this.end.column===range.end.column},this.toString=function(){return\"Range: [\"+this.start.row+\"/\"+this.start.column+\"] -> [\"+this.end.row+\"/\"+this.end.column+\"]\"},this.contains=function(row,column){return 0==this.compare(row,column)},this.compareRange=function(range){var cmp,end=range.end,start=range.start;return cmp=this.compare(end.row,end.column),1==cmp?(cmp=this.compare(start.row,start.column),1==cmp?2:0==cmp?1:0):-1==cmp?-2:(cmp=this.compare(start.row,start.column),-1==cmp?-1:1==cmp?42:0)},this.comparePoint=function(p){return this.compare(p.row,p.column)},this.containsRange=function(range){return 0==this.comparePoint(range.start)&&0==this.comparePoint(range.end)},this.intersects=function(range){var cmp=this.compareRange(range);return-1==cmp||0==cmp||1==cmp},this.isEnd=function(row,column){return this.end.row==row&&this.end.column==column},this.isStart=function(row,column){return this.start.row==row&&this.start.column==column},this.setStart=function(row,column){\"object\"==typeof row?(this.start.column=row.column,this.start.row=row.row):(this.start.row=row,this.start.column=column)},this.setEnd=function(row,column){\"object\"==typeof row?(this.end.column=row.column,this.end.row=row.row):(this.end.row=row,this.end.column=column)},this.inside=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)||this.isStart(row,column)?!1:!0:!1},this.insideStart=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)?!1:!0:!1},this.insideEnd=function(row,column){return 0==this.compare(row,column)?this.isStart(row,column)?!1:!0:!1},this.compare=function(row,column){return this.isMultiLine()||row!==this.start.row?this.start.row>row?-1:row>this.end.row?1:this.start.row===row?column>=this.start.column?0:-1:this.end.row===row?this.end.column>=column?0:1:0:this.start.column>column?-1:column>this.end.column?1:0},this.compareStart=function(row,column){return this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.compareEnd=function(row,column){return this.end.row==row&&this.end.column==column?1:this.compare(row,column)},this.compareInside=function(row,column){return this.end.row==row&&this.end.column==column?1:this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.clipRows=function(firstRow,lastRow){if(this.end.row>lastRow)var end={row:lastRow+1,column:0};else if(firstRow>this.end.row)var end={row:firstRow,column:0};if(this.start.row>lastRow)var start={row:lastRow+1,column:0};else if(firstRow>this.start.row)var start={row:firstRow,column:0};return Range.fromPoints(start||this.start,end||this.end)},this.extend=function(row,column){var cmp=this.compare(row,column);if(0==cmp)return this;if(-1==cmp)var start={row:row,column:column};else var end={row:row,column:column};return Range.fromPoints(start||this.start,end||this.end)},this.isEmpty=function(){return this.start.row===this.end.row&&this.start.column===this.end.column},this.isMultiLine=function(){return this.start.row!==this.end.row},this.clone=function(){return Range.fromPoints(this.start,this.end)},this.collapseRows=function(){return 0==this.end.column?new Range(this.start.row,0,Math.max(this.start.row,this.end.row-1),0):new Range(this.start.row,0,this.end.row,0)},this.toScreenRange=function(session){var screenPosStart=session.documentToScreenPosition(this.start),screenPosEnd=session.documentToScreenPosition(this.end);return new Range(screenPosStart.row,screenPosStart.column,screenPosEnd.row,screenPosEnd.column)},this.moveBy=function(row,column){this.start.row+=row,this.start.column+=column,this.end.row+=row,this.end.column+=column}}).call(Range.prototype),Range.fromPoints=function(start,end){return new Range(start.row,start.column,end.row,end.column)},Range.comparePoints=comparePoints,Range.comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},exports.Range=Range}),ace.define(\"ace/apply_delta\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";exports.applyDelta=function(docLines,delta){var row=delta.start.row,startColumn=delta.start.column,line=docLines[row]||\"\";switch(delta.action){case\"insert\":var lines=delta.lines;if(1===lines.length)docLines[row]=line.substring(0,startColumn)+delta.lines[0]+line.substring(startColumn);else{var args=[row,1].concat(delta.lines);docLines.splice.apply(docLines,args),docLines[row]=line.substring(0,startColumn)+docLines[row],docLines[row+delta.lines.length-1]+=line.substring(startColumn)}break;case\"remove\":var endColumn=delta.end.column,endRow=delta.end.row;row===endRow?docLines[row]=line.substring(0,startColumn)+line.substring(endColumn):docLines.splice(row,endRow-row+1,line.substring(0,startColumn)+docLines[endRow].substring(endColumn))}}}),ace.define(\"ace/lib/event_emitter\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";var EventEmitter={},stopPropagation=function(){this.propagationStopped=!0},preventDefault=function(){this.defaultPrevented=!0};EventEmitter._emit=EventEmitter._dispatchEvent=function(eventName,e){this._eventRegistry||(this._eventRegistry={}),this._defaultHandlers||(this._defaultHandlers={});var listeners=this._eventRegistry[eventName]||[],defaultHandler=this._defaultHandlers[eventName];if(listeners.length||defaultHandler){\"object\"==typeof e&&e||(e={}),e.type||(e.type=eventName),e.stopPropagation||(e.stopPropagation=stopPropagation),e.preventDefault||(e.preventDefault=preventDefault),listeners=listeners.slice();for(var i=0;listeners.length>i&&(listeners[i](e,this),!e.propagationStopped);i++);return defaultHandler&&!e.defaultPrevented?defaultHandler(e,this):void 0}},EventEmitter._signal=function(eventName,e){var listeners=(this._eventRegistry||{})[eventName];if(listeners){listeners=listeners.slice();for(var i=0;listeners.length>i;i++)listeners[i](e,this)}},EventEmitter.once=function(eventName,callback){var _self=this;callback&&this.addEventListener(eventName,function newCallback(){_self.removeEventListener(eventName,newCallback),callback.apply(null,arguments)})},EventEmitter.setDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers||(handlers=this._defaultHandlers={_disabled_:{}}),handlers[eventName]){var old=handlers[eventName],disabled=handlers._disabled_[eventName];disabled||(handlers._disabled_[eventName]=disabled=[]),disabled.push(old);var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}handlers[eventName]=callback},EventEmitter.removeDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers){var disabled=handlers._disabled_[eventName];if(handlers[eventName]==callback)handlers[eventName],disabled&&this.setDefaultHandler(eventName,disabled.pop());else if(disabled){var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}}},EventEmitter.on=EventEmitter.addEventListener=function(eventName,callback,capturing){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];return listeners||(listeners=this._eventRegistry[eventName]=[]),-1==listeners.indexOf(callback)&&listeners[capturing?\"unshift\":\"push\"](callback),callback},EventEmitter.off=EventEmitter.removeListener=EventEmitter.removeEventListener=function(eventName,callback){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];if(listeners){var index=listeners.indexOf(callback);-1!==index&&listeners.splice(index,1)}},EventEmitter.removeAllListeners=function(eventName){this._eventRegistry&&(this._eventRegistry[eventName]=[])},exports.EventEmitter=EventEmitter}),ace.define(\"ace/anchor\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\"],function(acequire,exports){\"use strict\";var oop=acequire(\"./lib/oop\"),EventEmitter=acequire(\"./lib/event_emitter\").EventEmitter,Anchor=exports.Anchor=function(doc,row,column){this.$onChange=this.onChange.bind(this),this.attach(doc),column===void 0?this.setPosition(row.row,row.column):this.setPosition(row,column)};(function(){function $pointsInOrder(point1,point2,equalPointsInOrder){var bColIsAfter=equalPointsInOrder?point1.column<=point2.column:point1.column<point2.column;return point1.row<point2.row||point1.row==point2.row&&bColIsAfter}function $getTransformedPoint(delta,point,moveIfEqual){var deltaIsInsert=\"insert\"==delta.action,deltaRowShift=(deltaIsInsert?1:-1)*(delta.end.row-delta.start.row),deltaColShift=(deltaIsInsert?1:-1)*(delta.end.column-delta.start.column),deltaStart=delta.start,deltaEnd=deltaIsInsert?deltaStart:delta.end;return $pointsInOrder(point,deltaStart,moveIfEqual)?{row:point.row,column:point.column}:$pointsInOrder(deltaEnd,point,!moveIfEqual)?{row:point.row+deltaRowShift,column:point.column+(point.row==deltaEnd.row?deltaColShift:0)}:{row:deltaStart.row,column:deltaStart.column}}oop.implement(this,EventEmitter),this.getPosition=function(){return this.$clipPositionToDocument(this.row,this.column)},this.getDocument=function(){return this.document},this.$insertRight=!1,this.onChange=function(delta){if(!(delta.start.row==delta.end.row&&delta.start.row!=this.row||delta.start.row>this.row)){var point=$getTransformedPoint(delta,{row:this.row,column:this.column},this.$insertRight);this.setPosition(point.row,point.column,!0)}},this.setPosition=function(row,column,noClip){var pos;if(pos=noClip?{row:row,column:column}:this.$clipPositionToDocument(row,column),this.row!=pos.row||this.column!=pos.column){var old={row:this.row,column:this.column};this.row=pos.row,this.column=pos.column,this._signal(\"change\",{old:old,value:pos})}},this.detach=function(){this.document.removeEventListener(\"change\",this.$onChange)},this.attach=function(doc){this.document=doc||this.document,this.document.on(\"change\",this.$onChange)},this.$clipPositionToDocument=function(row,column){var pos={};return row>=this.document.getLength()?(pos.row=Math.max(0,this.document.getLength()-1),pos.column=this.document.getLine(pos.row).length):0>row?(pos.row=0,pos.column=0):(pos.row=row,pos.column=Math.min(this.document.getLine(pos.row).length,Math.max(0,column))),0>column&&(pos.column=0),pos}}).call(Anchor.prototype)}),ace.define(\"ace/document\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/apply_delta\",\"ace/lib/event_emitter\",\"ace/range\",\"ace/anchor\"],function(acequire,exports){\"use strict\";var oop=acequire(\"./lib/oop\"),applyDelta=acequire(\"./apply_delta\").applyDelta,EventEmitter=acequire(\"./lib/event_emitter\").EventEmitter,Range=acequire(\"./range\").Range,Anchor=acequire(\"./anchor\").Anchor,Document=function(textOrLines){this.$lines=[\"\"],0===textOrLines.length?this.$lines=[\"\"]:Array.isArray(textOrLines)?this.insertMergedLines({row:0,column:0},textOrLines):this.insert({row:0,column:0},textOrLines)};(function(){oop.implement(this,EventEmitter),this.setValue=function(text){var len=this.getLength()-1;this.remove(new Range(0,0,len,this.getLine(len).length)),this.insert({row:0,column:0},text)},this.getValue=function(){return this.getAllLines().join(this.getNewLineCharacter())},this.createAnchor=function(row,column){return new Anchor(this,row,column)},this.$split=0===\"aaa\".split(/a/).length?function(text){return text.replace(/\\r\\n|\\r/g,\"\\n\").split(\"\\n\")}:function(text){return text.split(/\\r\\n|\\r|\\n/)},this.$detectNewLine=function(text){var match=text.match(/^.*?(\\r\\n|\\r|\\n)/m);this.$autoNewLine=match?match[1]:\"\\n\",this._signal(\"changeNewLineMode\")},this.getNewLineCharacter=function(){switch(this.$newLineMode){case\"windows\":return\"\\r\\n\";case\"unix\":return\"\\n\";default:return this.$autoNewLine||\"\\n\"}},this.$autoNewLine=\"\",this.$newLineMode=\"auto\",this.setNewLineMode=function(newLineMode){this.$newLineMode!==newLineMode&&(this.$newLineMode=newLineMode,this._signal(\"changeNewLineMode\"))},this.getNewLineMode=function(){return this.$newLineMode},this.isNewLine=function(text){return\"\\r\\n\"==text||\"\\r\"==text||\"\\n\"==text},this.getLine=function(row){return this.$lines[row]||\"\"},this.getLines=function(firstRow,lastRow){return this.$lines.slice(firstRow,lastRow+1)},this.getAllLines=function(){return this.getLines(0,this.getLength())},this.getLength=function(){return this.$lines.length},this.getTextRange=function(range){return this.getLinesForRange(range).join(this.getNewLineCharacter())},this.getLinesForRange=function(range){var lines;if(range.start.row===range.end.row)lines=[this.getLine(range.start.row).substring(range.start.column,range.end.column)];else{lines=this.getLines(range.start.row,range.end.row),lines[0]=(lines[0]||\"\").substring(range.start.column);var l=lines.length-1;range.end.row-range.start.row==l&&(lines[l]=lines[l].substring(0,range.end.column))}return lines},this.insertLines=function(row,lines){return console.warn(\"Use of document.insertLines is deprecated. Use the insertFullLines method instead.\"),this.insertFullLines(row,lines)},this.removeLines=function(firstRow,lastRow){return console.warn(\"Use of document.removeLines is deprecated. Use the removeFullLines method instead.\"),this.removeFullLines(firstRow,lastRow)},this.insertNewLine=function(position){return console.warn(\"Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.\"),this.insertMergedLines(position,[\"\",\"\"])},this.insert=function(position,text){return 1>=this.getLength()&&this.$detectNewLine(text),this.insertMergedLines(position,this.$split(text))},this.insertInLine=function(position,text){var start=this.clippedPos(position.row,position.column),end=this.pos(position.row,position.column+text.length);return this.applyDelta({start:start,end:end,action:\"insert\",lines:[text]},!0),this.clonePos(end)},this.clippedPos=function(row,column){var length=this.getLength();void 0===row?row=length:0>row?row=0:row>=length&&(row=length-1,column=void 0);var line=this.getLine(row);return void 0==column&&(column=line.length),column=Math.min(Math.max(column,0),line.length),{row:row,column:column}},this.clonePos=function(pos){return{row:pos.row,column:pos.column}},this.pos=function(row,column){return{row:row,column:column}},this.$clipPosition=function(position){var length=this.getLength();return position.row>=length?(position.row=Math.max(0,length-1),position.column=this.getLine(length-1).length):(position.row=Math.max(0,position.row),position.column=Math.min(Math.max(position.column,0),this.getLine(position.row).length)),position},this.insertFullLines=function(row,lines){row=Math.min(Math.max(row,0),this.getLength());var column=0;this.getLength()>row?(lines=lines.concat([\"\"]),column=0):(lines=[\"\"].concat(lines),row--,column=this.$lines[row].length),this.insertMergedLines({row:row,column:column},lines)},this.insertMergedLines=function(position,lines){var start=this.clippedPos(position.row,position.column),end={row:start.row+lines.length-1,column:(1==lines.length?start.column:0)+lines[lines.length-1].length};return this.applyDelta({start:start,end:end,action:\"insert\",lines:lines}),this.clonePos(end)},this.remove=function(range){var start=this.clippedPos(range.start.row,range.start.column),end=this.clippedPos(range.end.row,range.end.column);return this.applyDelta({start:start,end:end,action:\"remove\",lines:this.getLinesForRange({start:start,end:end})}),this.clonePos(start)},this.removeInLine=function(row,startColumn,endColumn){var start=this.clippedPos(row,startColumn),end=this.clippedPos(row,endColumn);return this.applyDelta({start:start,end:end,action:\"remove\",lines:this.getLinesForRange({start:start,end:end})},!0),this.clonePos(start)},this.removeFullLines=function(firstRow,lastRow){firstRow=Math.min(Math.max(0,firstRow),this.getLength()-1),lastRow=Math.min(Math.max(0,lastRow),this.getLength()-1);var deleteFirstNewLine=lastRow==this.getLength()-1&&firstRow>0,deleteLastNewLine=this.getLength()-1>lastRow,startRow=deleteFirstNewLine?firstRow-1:firstRow,startCol=deleteFirstNewLine?this.getLine(startRow).length:0,endRow=deleteLastNewLine?lastRow+1:lastRow,endCol=deleteLastNewLine?0:this.getLine(endRow).length,range=new Range(startRow,startCol,endRow,endCol),deletedLines=this.$lines.slice(firstRow,lastRow+1);return this.applyDelta({start:range.start,end:range.end,action:\"remove\",lines:this.getLinesForRange(range)}),deletedLines},this.removeNewLine=function(row){this.getLength()-1>row&&row>=0&&this.applyDelta({start:this.pos(row,this.getLine(row).length),end:this.pos(row+1,0),action:\"remove\",lines:[\"\",\"\"]})},this.replace=function(range,text){if(range instanceof Range||(range=Range.fromPoints(range.start,range.end)),0===text.length&&range.isEmpty())return range.start;if(text==this.getTextRange(range))return range.end;this.remove(range);var end;return end=text?this.insert(range.start,text):range.start},this.applyDeltas=function(deltas){for(var i=0;deltas.length>i;i++)this.applyDelta(deltas[i])},this.revertDeltas=function(deltas){for(var i=deltas.length-1;i>=0;i--)this.revertDelta(deltas[i])},this.applyDelta=function(delta,doNotValidate){var isInsert=\"insert\"==delta.action;(isInsert?1>=delta.lines.length&&!delta.lines[0]:!Range.comparePoints(delta.start,delta.end))||(isInsert&&delta.lines.length>2e4&&this.$splitAndapplyLargeDelta(delta,2e4),applyDelta(this.$lines,delta,doNotValidate),this._signal(\"change\",delta))},this.$splitAndapplyLargeDelta=function(delta,MAX){for(var lines=delta.lines,l=lines.length,row=delta.start.row,column=delta.start.column,from=0,to=0;;){from=to,to+=MAX-1;var chunk=lines.slice(from,to);if(to>l){delta.lines=chunk,delta.start.row=row+from,delta.start.column=column;break}chunk.push(\"\"),this.applyDelta({start:this.pos(row+from,column),end:this.pos(row+to,column=0),action:delta.action,lines:chunk},!0)}},this.revertDelta=function(delta){this.applyDelta({start:this.clonePos(delta.start),end:this.clonePos(delta.end),action:\"insert\"==delta.action?\"remove\":\"insert\",lines:delta.lines.slice()})},this.indexToPosition=function(index,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,i=startRow||0,l=lines.length;l>i;i++)if(index-=lines[i].length+newlineLength,0>index)return{row:i,column:index+lines[i].length+newlineLength};return{row:l-1,column:lines[l-1].length}},this.positionToIndex=function(pos,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,index=0,row=Math.min(pos.row,lines.length),i=startRow||0;row>i;++i)index+=lines[i].length+newlineLength;return index+pos.column}}).call(Document.prototype),exports.Document=Document}),ace.define(\"ace/worker/mirror\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/document\",\"ace/lib/lang\"],function(acequire,exports){\"use strict\";acequire(\"../range\").Range;var Document=acequire(\"../document\").Document,lang=acequire(\"../lib/lang\"),Mirror=exports.Mirror=function(sender){this.sender=sender;var doc=this.doc=new Document(\"\"),deferredUpdate=this.deferredUpdate=lang.delayedCall(this.onUpdate.bind(this)),_self=this;sender.on(\"change\",function(e){var data=e.data;if(data[0].start)doc.applyDeltas(data);else for(var i=0;data.length>i;i+=2){if(Array.isArray(data[i+1]))var d={action:\"insert\",start:data[i],lines:data[i+1]};else var d={action:\"remove\",start:data[i],end:data[i+1]};doc.applyDelta(d,!0)}return _self.$timeout?deferredUpdate.schedule(_self.$timeout):(_self.onUpdate(),void 0)})};(function(){this.$timeout=500,this.setTimeout=function(timeout){this.$timeout=timeout},this.setValue=function(value){this.doc.setValue(value),this.deferredUpdate.schedule(this.$timeout)},this.getValue=function(callbackId){this.sender.callback(this.doc.getValue(),callbackId)},this.onUpdate=function(){},this.isPending=function(){return this.deferredUpdate.isPending()}}).call(Mirror.prototype)}),ace.define(\"ace/mode/css/csslint\",[\"require\",\"exports\",\"module\"],function(acequire,exports,module){function objectToString(o){return Object.prototype.toString.call(o)}function clone(parent,circular,depth,prototype){function _clone(parent,depth){if(null===parent)return null;if(0==depth)return parent;var child;if(\"object\"!=typeof parent)return parent;if(util.isArray(parent))child=[];else if(util.isRegExp(parent))child=RegExp(parent.source,util.getRegExpFlags(parent)),parent.lastIndex&&(child.lastIndex=parent.lastIndex);else if(util.isDate(parent))child=new Date(parent.getTime());else{if(useBuffer&&Buffer.isBuffer(parent))return child=new Buffer(parent.length),parent.copy(child),child;child=prototype===void 0?Object.create(Object.getPrototypeOf(parent)):Object.create(prototype)}if(circular){var index=allParents.indexOf(parent);if(-1!=index)return allChildren[index];allParents.push(parent),allChildren.push(child)}for(var i in parent)child[i]=_clone(parent[i],depth-1);return child}var allParents=[],allChildren=[],useBuffer=\"undefined\"!=typeof Buffer;return circular===void 0&&(circular=!0),depth===void 0&&(depth=1/0),_clone(parent,depth)}function Reporter(lines,ruleset){this.messages=[],this.stats=[],this.lines=lines,this.ruleset=ruleset}var parserlib={};(function(){function EventTarget(){this._listeners={}}function StringReader(text){this._input=text.replace(/\\n\\r?/g,\"\\n\"),this._line=1,this._col=1,this._cursor=0}function SyntaxError(message,line,col){this.col=col,this.line=line,this.message=message}function SyntaxUnit(text,line,col,type){this.col=col,this.line=line,this.text=text,this.type=type}function TokenStreamBase(input,tokenData){this._reader=input?new StringReader(\"\"+input):null,this._token=null,this._tokenData=tokenData,this._lt=[],this._ltIndex=0,this._ltIndexCache=[]}EventTarget.prototype={constructor:EventTarget,addListener:function(type,listener){this._listeners[type]||(this._listeners[type]=[]),this._listeners[type].push(listener)},fire:function(event){if(\"string\"==typeof event&&(event={type:event}),event.target!==void 0&&(event.target=this),event.type===void 0)throw Error(\"Event object missing 'type' property.\");if(this._listeners[event.type])for(var listeners=this._listeners[event.type].concat(),i=0,len=listeners.length;len>i;i++)listeners[i].call(this,event)},removeListener:function(type,listener){if(this._listeners[type])for(var listeners=this._listeners[type],i=0,len=listeners.length;len>i;i++)if(listeners[i]===listener){listeners.splice(i,1);break}}},StringReader.prototype={constructor:StringReader,getCol:function(){return this._col},getLine:function(){return this._line},eof:function(){return this._cursor==this._input.length},peek:function(count){var c=null;return count=count===void 0?1:count,this._cursor<this._input.length&&(c=this._input.charAt(this._cursor+count-1)),c},read:function(){var c=null;return this._cursor<this._input.length&&(\"\\n\"==this._input.charAt(this._cursor)?(this._line++,this._col=1):this._col++,c=this._input.charAt(this._cursor++)),c},mark:function(){this._bookmark={cursor:this._cursor,line:this._line,col:this._col}},reset:function(){this._bookmark&&(this._cursor=this._bookmark.cursor,this._line=this._bookmark.line,this._col=this._bookmark.col,delete this._bookmark)},readTo:function(pattern){for(var c,buffer=\"\";buffer.length<pattern.length||buffer.lastIndexOf(pattern)!=buffer.length-pattern.length;){if(c=this.read(),!c)throw Error('Expected \"'+pattern+'\" at line '+this._line+\", col \"+this._col+\".\");buffer+=c}return buffer},readWhile:function(filter){for(var buffer=\"\",c=this.read();null!==c&&filter(c);)buffer+=c,c=this.read();return buffer},readMatch:function(matcher){var source=this._input.substring(this._cursor),value=null;return\"string\"==typeof matcher?0===source.indexOf(matcher)&&(value=this.readCount(matcher.length)):matcher instanceof RegExp&&matcher.test(source)&&(value=this.readCount(RegExp.lastMatch.length)),value},readCount:function(count){for(var buffer=\"\";count--;)buffer+=this.read();return buffer}},SyntaxError.prototype=Error(),SyntaxUnit.fromToken=function(token){return new SyntaxUnit(token.value,token.startLine,token.startCol)},SyntaxUnit.prototype={constructor:SyntaxUnit,valueOf:function(){return this.text},toString:function(){return this.text}},TokenStreamBase.createTokenData=function(tokens){var nameMap=[],typeMap={},tokenData=tokens.concat([]),i=0,len=tokenData.length+1;for(tokenData.UNKNOWN=-1,tokenData.unshift({name:\"EOF\"});len>i;i++)nameMap.push(tokenData[i].name),tokenData[tokenData[i].name]=i,tokenData[i].text&&(typeMap[tokenData[i].text]=i);return tokenData.name=function(tt){return nameMap[tt]},tokenData.type=function(c){return typeMap[c]},tokenData},TokenStreamBase.prototype={constructor:TokenStreamBase,match:function(tokenTypes,channel){tokenTypes instanceof Array||(tokenTypes=[tokenTypes]);\nfor(var tt=this.get(channel),i=0,len=tokenTypes.length;len>i;)if(tt==tokenTypes[i++])return!0;return this.unget(),!1},mustMatch:function(tokenTypes){var token;if(tokenTypes instanceof Array||(tokenTypes=[tokenTypes]),!this.match.apply(this,arguments))throw token=this.LT(1),new SyntaxError(\"Expected \"+this._tokenData[tokenTypes[0]].name+\" at line \"+token.startLine+\", col \"+token.startCol+\".\",token.startLine,token.startCol)},advance:function(tokenTypes,channel){for(;0!==this.LA(0)&&!this.match(tokenTypes,channel);)this.get();return this.LA(0)},get:function(channel){var token,info,tokenInfo=this._tokenData,i=(this._reader,0);if(tokenInfo.length,this._lt.length&&this._ltIndex>=0&&this._ltIndex<this._lt.length){for(i++,this._token=this._lt[this._ltIndex++],info=tokenInfo[this._token.type];void 0!==info.channel&&channel!==info.channel&&this._ltIndex<this._lt.length;)this._token=this._lt[this._ltIndex++],info=tokenInfo[this._token.type],i++;if((void 0===info.channel||channel===info.channel)&&this._ltIndex<=this._lt.length)return this._ltIndexCache.push(i),this._token.type}return token=this._getToken(),token.type>-1&&!tokenInfo[token.type].hide&&(token.channel=tokenInfo[token.type].channel,this._token=token,this._lt.push(token),this._ltIndexCache.push(this._lt.length-this._ltIndex+i),this._lt.length>5&&this._lt.shift(),this._ltIndexCache.length>5&&this._ltIndexCache.shift(),this._ltIndex=this._lt.length),info=tokenInfo[token.type],info&&(info.hide||void 0!==info.channel&&channel!==info.channel)?this.get(channel):token.type},LA:function(index){var tt,total=index;if(index>0){if(index>5)throw Error(\"Too much lookahead.\");for(;total;)tt=this.get(),total--;for(;index>total;)this.unget(),total++}else if(0>index){if(!this._lt[this._ltIndex+index])throw Error(\"Too much lookbehind.\");tt=this._lt[this._ltIndex+index].type}else tt=this._token.type;return tt},LT:function(index){return this.LA(index),this._lt[this._ltIndex+index-1]},peek:function(){return this.LA(1)},token:function(){return this._token},tokenName:function(tokenType){return 0>tokenType||tokenType>this._tokenData.length?\"UNKNOWN_TOKEN\":this._tokenData[tokenType].name},tokenType:function(tokenName){return this._tokenData[tokenName]||-1},unget:function(){if(!this._ltIndexCache.length)throw Error(\"Too much lookahead.\");this._ltIndex-=this._ltIndexCache.pop(),this._token=this._lt[this._ltIndex-1]}},parserlib.util={StringReader:StringReader,SyntaxError:SyntaxError,SyntaxUnit:SyntaxUnit,EventTarget:EventTarget,TokenStreamBase:TokenStreamBase}})(),function(){function Combinator(text,line,col){SyntaxUnit.call(this,text,line,col,Parser.COMBINATOR_TYPE),this.type=\"unknown\",/^\\s+$/.test(text)?this.type=\"descendant\":\">\"==text?this.type=\"child\":\"+\"==text?this.type=\"adjacent-sibling\":\"~\"==text&&(this.type=\"sibling\")}function MediaFeature(name,value){SyntaxUnit.call(this,\"(\"+name+(null!==value?\":\"+value:\"\")+\")\",name.startLine,name.startCol,Parser.MEDIA_FEATURE_TYPE),this.name=name,this.value=value}function MediaQuery(modifier,mediaType,features,line,col){SyntaxUnit.call(this,(modifier?modifier+\" \":\"\")+(mediaType?mediaType:\"\")+(mediaType&&features.length>0?\" and \":\"\")+features.join(\" and \"),line,col,Parser.MEDIA_QUERY_TYPE),this.modifier=modifier,this.mediaType=mediaType,this.features=features}function Parser(options){EventTarget.call(this),this.options=options||{},this._tokenStream=null}function PropertyName(text,hack,line,col){SyntaxUnit.call(this,text,line,col,Parser.PROPERTY_NAME_TYPE),this.hack=hack}function PropertyValue(parts,line,col){SyntaxUnit.call(this,parts.join(\" \"),line,col,Parser.PROPERTY_VALUE_TYPE),this.parts=parts}function PropertyValueIterator(value){this._i=0,this._parts=value.parts,this._marks=[],this.value=value}function PropertyValuePart(text,line,col){SyntaxUnit.call(this,text,line,col,Parser.PROPERTY_VALUE_PART_TYPE),this.type=\"unknown\";var temp;if(/^([+\\-]?[\\d\\.]+)([a-z]+)$/i.test(text))switch(this.type=\"dimension\",this.value=+RegExp.$1,this.units=RegExp.$2,this.units.toLowerCase()){case\"em\":case\"rem\":case\"ex\":case\"px\":case\"cm\":case\"mm\":case\"in\":case\"pt\":case\"pc\":case\"ch\":case\"vh\":case\"vw\":case\"vmax\":case\"vmin\":this.type=\"length\";break;case\"deg\":case\"rad\":case\"grad\":this.type=\"angle\";break;case\"ms\":case\"s\":this.type=\"time\";break;case\"hz\":case\"khz\":this.type=\"frequency\";break;case\"dpi\":case\"dpcm\":this.type=\"resolution\"}else/^([+\\-]?[\\d\\.]+)%$/i.test(text)?(this.type=\"percentage\",this.value=+RegExp.$1):/^([+\\-]?\\d+)$/i.test(text)?(this.type=\"integer\",this.value=+RegExp.$1):/^([+\\-]?[\\d\\.]+)$/i.test(text)?(this.type=\"number\",this.value=+RegExp.$1):/^#([a-f0-9]{3,6})/i.test(text)?(this.type=\"color\",temp=RegExp.$1,3==temp.length?(this.red=parseInt(temp.charAt(0)+temp.charAt(0),16),this.green=parseInt(temp.charAt(1)+temp.charAt(1),16),this.blue=parseInt(temp.charAt(2)+temp.charAt(2),16)):(this.red=parseInt(temp.substring(0,2),16),this.green=parseInt(temp.substring(2,4),16),this.blue=parseInt(temp.substring(4,6),16))):/^rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/i.test(text)?(this.type=\"color\",this.red=+RegExp.$1,this.green=+RegExp.$2,this.blue=+RegExp.$3):/^rgb\\(\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*\\)/i.test(text)?(this.type=\"color\",this.red=255*+RegExp.$1/100,this.green=255*+RegExp.$2/100,this.blue=255*+RegExp.$3/100):/^rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*([\\d\\.]+)\\s*\\)/i.test(text)?(this.type=\"color\",this.red=+RegExp.$1,this.green=+RegExp.$2,this.blue=+RegExp.$3,this.alpha=+RegExp.$4):/^rgba\\(\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*,\\s*([\\d\\.]+)\\s*\\)/i.test(text)?(this.type=\"color\",this.red=255*+RegExp.$1/100,this.green=255*+RegExp.$2/100,this.blue=255*+RegExp.$3/100,this.alpha=+RegExp.$4):/^hsl\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*\\)/i.test(text)?(this.type=\"color\",this.hue=+RegExp.$1,this.saturation=+RegExp.$2/100,this.lightness=+RegExp.$3/100):/^hsla\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*,\\s*([\\d\\.]+)\\s*\\)/i.test(text)?(this.type=\"color\",this.hue=+RegExp.$1,this.saturation=+RegExp.$2/100,this.lightness=+RegExp.$3/100,this.alpha=+RegExp.$4):/^url\\([\"']?([^\\)\"']+)[\"']?\\)/i.test(text)?(this.type=\"uri\",this.uri=RegExp.$1):/^([^\\(]+)\\(/i.test(text)?(this.type=\"function\",this.name=RegExp.$1,this.value=text):/^[\"'][^\"']*[\"']/.test(text)?(this.type=\"string\",this.value=eval(text)):Colors[text.toLowerCase()]?(this.type=\"color\",temp=Colors[text.toLowerCase()].substring(1),this.red=parseInt(temp.substring(0,2),16),this.green=parseInt(temp.substring(2,4),16),this.blue=parseInt(temp.substring(4,6),16)):/^[\\,\\/]$/.test(text)?(this.type=\"operator\",this.value=text):/^[a-z\\-_\\u0080-\\uFFFF][a-z0-9\\-_\\u0080-\\uFFFF]*$/i.test(text)&&(this.type=\"identifier\",this.value=text)}function Selector(parts,line,col){SyntaxUnit.call(this,parts.join(\" \"),line,col,Parser.SELECTOR_TYPE),this.parts=parts,this.specificity=Specificity.calculate(this)}function SelectorPart(elementName,modifiers,text,line,col){SyntaxUnit.call(this,text,line,col,Parser.SELECTOR_PART_TYPE),this.elementName=elementName,this.modifiers=modifiers}function SelectorSubPart(text,type,line,col){SyntaxUnit.call(this,text,line,col,Parser.SELECTOR_SUB_PART_TYPE),this.type=type,this.args=[]}function Specificity(a,b,c,d){this.a=a,this.b=b,this.c=c,this.d=d}function isHexDigit(c){return null!==c&&h.test(c)}function isDigit(c){return null!==c&&/\\d/.test(c)}function isWhitespace(c){return null!==c&&/\\s/.test(c)}function isNewLine(c){return null!==c&&nl.test(c)}function isNameStart(c){return null!==c&&/[a-z_\\u0080-\\uFFFF\\\\]/i.test(c)}function isNameChar(c){return null!==c&&(isNameStart(c)||/[0-9\\-\\\\]/.test(c))}function isIdentStart(c){return null!==c&&(isNameStart(c)||/\\-\\\\/.test(c))}function mix(receiver,supplier){for(var prop in supplier)supplier.hasOwnProperty(prop)&&(receiver[prop]=supplier[prop]);return receiver}function TokenStream(input){TokenStreamBase.call(this,input,Tokens)}function ValidationError(message,line,col){this.col=col,this.line=line,this.message=message}var EventTarget=parserlib.util.EventTarget,TokenStreamBase=parserlib.util.TokenStreamBase,StringReader=parserlib.util.StringReader,SyntaxError=parserlib.util.SyntaxError,SyntaxUnit=parserlib.util.SyntaxUnit,Colors={aliceblue:\"#f0f8ff\",antiquewhite:\"#faebd7\",aqua:\"#00ffff\",aquamarine:\"#7fffd4\",azure:\"#f0ffff\",beige:\"#f5f5dc\",bisque:\"#ffe4c4\",black:\"#000000\",blanchedalmond:\"#ffebcd\",blue:\"#0000ff\",blueviolet:\"#8a2be2\",brown:\"#a52a2a\",burlywood:\"#deb887\",cadetblue:\"#5f9ea0\",chartreuse:\"#7fff00\",chocolate:\"#d2691e\",coral:\"#ff7f50\",cornflowerblue:\"#6495ed\",cornsilk:\"#fff8dc\",crimson:\"#dc143c\",cyan:\"#00ffff\",darkblue:\"#00008b\",darkcyan:\"#008b8b\",darkgoldenrod:\"#b8860b\",darkgray:\"#a9a9a9\",darkgrey:\"#a9a9a9\",darkgreen:\"#006400\",darkkhaki:\"#bdb76b\",darkmagenta:\"#8b008b\",darkolivegreen:\"#556b2f\",darkorange:\"#ff8c00\",darkorchid:\"#9932cc\",darkred:\"#8b0000\",darksalmon:\"#e9967a\",darkseagreen:\"#8fbc8f\",darkslateblue:\"#483d8b\",darkslategray:\"#2f4f4f\",darkslategrey:\"#2f4f4f\",darkturquoise:\"#00ced1\",darkviolet:\"#9400d3\",deeppink:\"#ff1493\",deepskyblue:\"#00bfff\",dimgray:\"#696969\",dimgrey:\"#696969\",dodgerblue:\"#1e90ff\",firebrick:\"#b22222\",floralwhite:\"#fffaf0\",forestgreen:\"#228b22\",fuchsia:\"#ff00ff\",gainsboro:\"#dcdcdc\",ghostwhite:\"#f8f8ff\",gold:\"#ffd700\",goldenrod:\"#daa520\",gray:\"#808080\",grey:\"#808080\",green:\"#008000\",greenyellow:\"#adff2f\",honeydew:\"#f0fff0\",hotpink:\"#ff69b4\",indianred:\"#cd5c5c\",indigo:\"#4b0082\",ivory:\"#fffff0\",khaki:\"#f0e68c\",lavender:\"#e6e6fa\",lavenderblush:\"#fff0f5\",lawngreen:\"#7cfc00\",lemonchiffon:\"#fffacd\",lightblue:\"#add8e6\",lightcoral:\"#f08080\",lightcyan:\"#e0ffff\",lightgoldenrodyellow:\"#fafad2\",lightgray:\"#d3d3d3\",lightgrey:\"#d3d3d3\",lightgreen:\"#90ee90\",lightpink:\"#ffb6c1\",lightsalmon:\"#ffa07a\",lightseagreen:\"#20b2aa\",lightskyblue:\"#87cefa\",lightslategray:\"#778899\",lightslategrey:\"#778899\",lightsteelblue:\"#b0c4de\",lightyellow:\"#ffffe0\",lime:\"#00ff00\",limegreen:\"#32cd32\",linen:\"#faf0e6\",magenta:\"#ff00ff\",maroon:\"#800000\",mediumaquamarine:\"#66cdaa\",mediumblue:\"#0000cd\",mediumorchid:\"#ba55d3\",mediumpurple:\"#9370d8\",mediumseagreen:\"#3cb371\",mediumslateblue:\"#7b68ee\",mediumspringgreen:\"#00fa9a\",mediumturquoise:\"#48d1cc\",mediumvioletred:\"#c71585\",midnightblue:\"#191970\",mintcream:\"#f5fffa\",mistyrose:\"#ffe4e1\",moccasin:\"#ffe4b5\",navajowhite:\"#ffdead\",navy:\"#000080\",oldlace:\"#fdf5e6\",olive:\"#808000\",olivedrab:\"#6b8e23\",orange:\"#ffa500\",orangered:\"#ff4500\",orchid:\"#da70d6\",palegoldenrod:\"#eee8aa\",palegreen:\"#98fb98\",paleturquoise:\"#afeeee\",palevioletred:\"#d87093\",papayawhip:\"#ffefd5\",peachpuff:\"#ffdab9\",peru:\"#cd853f\",pink:\"#ffc0cb\",plum:\"#dda0dd\",powderblue:\"#b0e0e6\",purple:\"#800080\",red:\"#ff0000\",rosybrown:\"#bc8f8f\",royalblue:\"#4169e1\",saddlebrown:\"#8b4513\",salmon:\"#fa8072\",sandybrown:\"#f4a460\",seagreen:\"#2e8b57\",seashell:\"#fff5ee\",sienna:\"#a0522d\",silver:\"#c0c0c0\",skyblue:\"#87ceeb\",slateblue:\"#6a5acd\",slategray:\"#708090\",slategrey:\"#708090\",snow:\"#fffafa\",springgreen:\"#00ff7f\",steelblue:\"#4682b4\",tan:\"#d2b48c\",teal:\"#008080\",thistle:\"#d8bfd8\",tomato:\"#ff6347\",turquoise:\"#40e0d0\",violet:\"#ee82ee\",wheat:\"#f5deb3\",white:\"#ffffff\",whitesmoke:\"#f5f5f5\",yellow:\"#ffff00\",yellowgreen:\"#9acd32\",activeBorder:\"Active window border.\",activecaption:\"Active window caption.\",appworkspace:\"Background color of multiple document interface.\",background:\"Desktop background.\",buttonface:\"The face background color for 3-D elements that appear 3-D due to one layer of surrounding border.\",buttonhighlight:\"The color of the border facing the light source for 3-D elements that appear 3-D due to one layer of surrounding border.\",buttonshadow:\"The color of the border away from the light source for 3-D elements that appear 3-D due to one layer of surrounding border.\",buttontext:\"Text on push buttons.\",captiontext:\"Text in caption, size box, and scrollbar arrow box.\",graytext:\"Grayed (disabled) text. This color is set to #000 if the current display driver does not support a solid gray color.\",greytext:\"Greyed (disabled) text. This color is set to #000 if the current display driver does not support a solid grey color.\",highlight:\"Item(s) selected in a control.\",highlighttext:\"Text of item(s) selected in a control.\",inactiveborder:\"Inactive window border.\",inactivecaption:\"Inactive window caption.\",inactivecaptiontext:\"Color of text in an inactive caption.\",infobackground:\"Background color for tooltip controls.\",infotext:\"Text color for tooltip controls.\",menu:\"Menu background.\",menutext:\"Text in menus.\",scrollbar:\"Scroll bar gray area.\",threeddarkshadow:\"The color of the darker (generally outer) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\",threedface:\"The face background color for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\",threedhighlight:\"The color of the lighter (generally outer) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\",threedlightshadow:\"The color of the darker (generally inner) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\",threedshadow:\"The color of the lighter (generally inner) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\",window:\"Window background.\",windowframe:\"Window frame.\",windowtext:\"Text in windows.\"};Combinator.prototype=new SyntaxUnit,Combinator.prototype.constructor=Combinator,MediaFeature.prototype=new SyntaxUnit,MediaFeature.prototype.constructor=MediaFeature,MediaQuery.prototype=new SyntaxUnit,MediaQuery.prototype.constructor=MediaQuery,Parser.DEFAULT_TYPE=0,Parser.COMBINATOR_TYPE=1,Parser.MEDIA_FEATURE_TYPE=2,Parser.MEDIA_QUERY_TYPE=3,Parser.PROPERTY_NAME_TYPE=4,Parser.PROPERTY_VALUE_TYPE=5,Parser.PROPERTY_VALUE_PART_TYPE=6,Parser.SELECTOR_TYPE=7,Parser.SELECTOR_PART_TYPE=8,Parser.SELECTOR_SUB_PART_TYPE=9,Parser.prototype=function(){var prop,proto=new EventTarget,additions={constructor:Parser,DEFAULT_TYPE:0,COMBINATOR_TYPE:1,MEDIA_FEATURE_TYPE:2,MEDIA_QUERY_TYPE:3,PROPERTY_NAME_TYPE:4,PROPERTY_VALUE_TYPE:5,PROPERTY_VALUE_PART_TYPE:6,SELECTOR_TYPE:7,SELECTOR_PART_TYPE:8,SELECTOR_SUB_PART_TYPE:9,_stylesheet:function(){var count,token,tt,tokenStream=this._tokenStream;for(this.fire(\"startstylesheet\"),this._charset(),this._skipCruft();tokenStream.peek()==Tokens.IMPORT_SYM;)this._import(),this._skipCruft();for(;tokenStream.peek()==Tokens.NAMESPACE_SYM;)this._namespace(),this._skipCruft();for(tt=tokenStream.peek();tt>Tokens.EOF;){try{switch(tt){case Tokens.MEDIA_SYM:this._media(),this._skipCruft();break;case Tokens.PAGE_SYM:this._page(),this._skipCruft();break;case Tokens.FONT_FACE_SYM:this._font_face(),this._skipCruft();break;case Tokens.KEYFRAMES_SYM:this._keyframes(),this._skipCruft();break;case Tokens.VIEWPORT_SYM:this._viewport(),this._skipCruft();break;case Tokens.UNKNOWN_SYM:if(tokenStream.get(),this.options.strict)throw new SyntaxError(\"Unknown @ rule.\",tokenStream.LT(0).startLine,tokenStream.LT(0).startCol);for(this.fire({type:\"error\",error:null,message:\"Unknown @ rule: \"+tokenStream.LT(0).value+\".\",line:tokenStream.LT(0).startLine,col:tokenStream.LT(0).startCol}),count=0;tokenStream.advance([Tokens.LBRACE,Tokens.RBRACE])==Tokens.LBRACE;)count++;for(;count;)tokenStream.advance([Tokens.RBRACE]),count--;break;case Tokens.S:this._readWhitespace();break;default:if(!this._ruleset())switch(tt){case Tokens.CHARSET_SYM:throw token=tokenStream.LT(1),this._charset(!1),new SyntaxError(\"@charset not allowed here.\",token.startLine,token.startCol);case Tokens.IMPORT_SYM:throw token=tokenStream.LT(1),this._import(!1),new SyntaxError(\"@import not allowed here.\",token.startLine,token.startCol);case Tokens.NAMESPACE_SYM:throw token=tokenStream.LT(1),this._namespace(!1),new SyntaxError(\"@namespace not allowed here.\",token.startLine,token.startCol);default:tokenStream.get(),this._unexpectedToken(tokenStream.token())}}}catch(ex){if(!(ex instanceof SyntaxError)||this.options.strict)throw ex;this.fire({type:\"error\",error:ex,message:ex.message,line:ex.line,col:ex.col})}tt=tokenStream.peek()}tt!=Tokens.EOF&&this._unexpectedToken(tokenStream.token()),this.fire(\"endstylesheet\")},_charset:function(emit){var charset,token,line,col,tokenStream=this._tokenStream;tokenStream.match(Tokens.CHARSET_SYM)&&(line=tokenStream.token().startLine,col=tokenStream.token().startCol,this._readWhitespace(),tokenStream.mustMatch(Tokens.STRING),token=tokenStream.token(),charset=token.value,this._readWhitespace(),tokenStream.mustMatch(Tokens.SEMICOLON),emit!==!1&&this.fire({type:\"charset\",charset:charset,line:line,col:col}))},_import:function(emit){var uri,importToken,tokenStream=this._tokenStream,mediaList=[];tokenStream.mustMatch(Tokens.IMPORT_SYM),importToken=tokenStream.token(),this._readWhitespace(),tokenStream.mustMatch([Tokens.STRING,Tokens.URI]),uri=tokenStream.token().value.replace(/^(?:url\\()?[\"']?([^\"']+?)[\"']?\\)?$/,\"$1\"),this._readWhitespace(),mediaList=this._media_query_list(),tokenStream.mustMatch(Tokens.SEMICOLON),this._readWhitespace(),emit!==!1&&this.fire({type:\"import\",uri:uri,media:mediaList,line:importToken.startLine,col:importToken.startCol})},_namespace:function(emit){var line,col,prefix,uri,tokenStream=this._tokenStream;tokenStream.mustMatch(Tokens.NAMESPACE_SYM),line=tokenStream.token().startLine,col=tokenStream.token().startCol,this._readWhitespace(),tokenStream.match(Tokens.IDENT)&&(prefix=tokenStream.token().value,this._readWhitespace()),tokenStream.mustMatch([Tokens.STRING,Tokens.URI]),uri=tokenStream.token().value.replace(/(?:url\\()?[\"']([^\"']+)[\"']\\)?/,\"$1\"),this._readWhitespace(),tokenStream.mustMatch(Tokens.SEMICOLON),this._readWhitespace(),emit!==!1&&this.fire({type:\"namespace\",prefix:prefix,uri:uri,line:line,col:col})},_media:function(){var line,col,mediaList,tokenStream=this._tokenStream;for(tokenStream.mustMatch(Tokens.MEDIA_SYM),line=tokenStream.token().startLine,col=tokenStream.token().startCol,this._readWhitespace(),mediaList=this._media_query_list(),tokenStream.mustMatch(Tokens.LBRACE),this._readWhitespace(),this.fire({type:\"startmedia\",media:mediaList,line:line,col:col});;)if(tokenStream.peek()==Tokens.PAGE_SYM)this._page();else if(tokenStream.peek()==Tokens.FONT_FACE_SYM)this._font_face();else if(tokenStream.peek()==Tokens.VIEWPORT_SYM)this._viewport();else if(!this._ruleset())break;tokenStream.mustMatch(Tokens.RBRACE),this._readWhitespace(),this.fire({type:\"endmedia\",media:mediaList,line:line,col:col})},_media_query_list:function(){var tokenStream=this._tokenStream,mediaList=[];for(this._readWhitespace(),(tokenStream.peek()==Tokens.IDENT||tokenStream.peek()==Tokens.LPAREN)&&mediaList.push(this._media_query());tokenStream.match(Tokens.COMMA);)this._readWhitespace(),mediaList.push(this._media_query());return mediaList},_media_query:function(){var tokenStream=this._tokenStream,type=null,ident=null,token=null,expressions=[];if(tokenStream.match(Tokens.IDENT)&&(ident=tokenStream.token().value.toLowerCase(),\"only\"!=ident&&\"not\"!=ident?(tokenStream.unget(),ident=null):token=tokenStream.token()),this._readWhitespace(),tokenStream.peek()==Tokens.IDENT?(type=this._media_type(),null===token&&(token=tokenStream.token())):tokenStream.peek()==Tokens.LPAREN&&(null===token&&(token=tokenStream.LT(1)),expressions.push(this._media_expression())),null===type&&0===expressions.length)return null;for(this._readWhitespace();tokenStream.match(Tokens.IDENT);)\"and\"!=tokenStream.token().value.toLowerCase()&&this._unexpectedToken(tokenStream.token()),this._readWhitespace(),expressions.push(this._media_expression());return new MediaQuery(ident,type,expressions,token.startLine,token.startCol)},_media_type:function(){return this._media_feature()},_media_expression:function(){var token,tokenStream=this._tokenStream,feature=null,expression=null;return tokenStream.mustMatch(Tokens.LPAREN),feature=this._media_feature(),this._readWhitespace(),tokenStream.match(Tokens.COLON)&&(this._readWhitespace(),token=tokenStream.LT(1),expression=this._expression()),tokenStream.mustMatch(Tokens.RPAREN),this._readWhitespace(),new MediaFeature(feature,expression?new SyntaxUnit(expression,token.startLine,token.startCol):null)},_media_feature:function(){var tokenStream=this._tokenStream;return tokenStream.mustMatch(Tokens.IDENT),SyntaxUnit.fromToken(tokenStream.token())},_page:function(){var line,col,tokenStream=this._tokenStream,identifier=null,pseudoPage=null;tokenStream.mustMatch(Tokens.PAGE_SYM),line=tokenStream.token().startLine,col=tokenStream.token().startCol,this._readWhitespace(),tokenStream.match(Tokens.IDENT)&&(identifier=tokenStream.token().value,\"auto\"===identifier.toLowerCase()&&this._unexpectedToken(tokenStream.token())),tokenStream.peek()==Tokens.COLON&&(pseudoPage=this._pseudo_page()),this._readWhitespace(),this.fire({type:\"startpage\",id:identifier,pseudo:pseudoPage,line:line,col:col}),this._readDeclarations(!0,!0),this.fire({type:\"endpage\",id:identifier,pseudo:pseudoPage,line:line,col:col})},_margin:function(){var line,col,tokenStream=this._tokenStream,marginSym=this._margin_sym();return marginSym?(line=tokenStream.token().startLine,col=tokenStream.token().startCol,this.fire({type:\"startpagemargin\",margin:marginSym,line:line,col:col}),this._readDeclarations(!0),this.fire({type:\"endpagemargin\",margin:marginSym,line:line,col:col}),!0):!1},_margin_sym:function(){var tokenStream=this._tokenStream;return tokenStream.match([Tokens.TOPLEFTCORNER_SYM,Tokens.TOPLEFT_SYM,Tokens.TOPCENTER_SYM,Tokens.TOPRIGHT_SYM,Tokens.TOPRIGHTCORNER_SYM,Tokens.BOTTOMLEFTCORNER_SYM,Tokens.BOTTOMLEFT_SYM,Tokens.BOTTOMCENTER_SYM,Tokens.BOTTOMRIGHT_SYM,Tokens.BOTTOMRIGHTCORNER_SYM,Tokens.LEFTTOP_SYM,Tokens.LEFTMIDDLE_SYM,Tokens.LEFTBOTTOM_SYM,Tokens.RIGHTTOP_SYM,Tokens.RIGHTMIDDLE_SYM,Tokens.RIGHTBOTTOM_SYM])?SyntaxUnit.fromToken(tokenStream.token()):null},_pseudo_page:function(){var tokenStream=this._tokenStream;return tokenStream.mustMatch(Tokens.COLON),tokenStream.mustMatch(Tokens.IDENT),tokenStream.token().value},_font_face:function(){var line,col,tokenStream=this._tokenStream;tokenStream.mustMatch(Tokens.FONT_FACE_SYM),line=tokenStream.token().startLine,col=tokenStream.token().startCol,this._readWhitespace(),this.fire({type:\"startfontface\",line:line,col:col}),this._readDeclarations(!0),this.fire({type:\"endfontface\",line:line,col:col})},_viewport:function(){var line,col,tokenStream=this._tokenStream;tokenStream.mustMatch(Tokens.VIEWPORT_SYM),line=tokenStream.token().startLine,col=tokenStream.token().startCol,this._readWhitespace(),this.fire({type:\"startviewport\",line:line,col:col}),this._readDeclarations(!0),this.fire({type:\"endviewport\",line:line,col:col})},_operator:function(inFunction){var tokenStream=this._tokenStream,token=null;return(tokenStream.match([Tokens.SLASH,Tokens.COMMA])||inFunction&&tokenStream.match([Tokens.PLUS,Tokens.STAR,Tokens.MINUS]))&&(token=tokenStream.token(),this._readWhitespace()),token?PropertyValuePart.fromToken(token):null},_combinator:function(){var token,tokenStream=this._tokenStream,value=null;return tokenStream.match([Tokens.PLUS,Tokens.GREATER,Tokens.TILDE])&&(token=tokenStream.token(),value=new Combinator(token.value,token.startLine,token.startCol),this._readWhitespace()),value},_unary_operator:function(){var tokenStream=this._tokenStream;return tokenStream.match([Tokens.MINUS,Tokens.PLUS])?tokenStream.token().value:null},_property:function(){var tokenValue,token,line,col,tokenStream=this._tokenStream,value=null,hack=null;return tokenStream.peek()==Tokens.STAR&&this.options.starHack&&(tokenStream.get(),token=tokenStream.token(),hack=token.value,line=token.startLine,col=token.startCol),tokenStream.match(Tokens.IDENT)&&(token=tokenStream.token(),tokenValue=token.value,\"_\"==tokenValue.charAt(0)&&this.options.underscoreHack&&(hack=\"_\",tokenValue=tokenValue.substring(1)),value=new PropertyName(tokenValue,hack,line||token.startLine,col||token.startCol),this._readWhitespace()),value},_ruleset:function(){var tt,selectors,tokenStream=this._tokenStream;try{selectors=this._selectors_group()}catch(ex){if(!(ex instanceof SyntaxError)||this.options.strict)throw ex;if(this.fire({type:\"error\",error:ex,message:ex.message,line:ex.line,col:ex.col}),tt=tokenStream.advance([Tokens.RBRACE]),tt!=Tokens.RBRACE)throw ex;return!0}return selectors&&(this.fire({type:\"startrule\",selectors:selectors,line:selectors[0].line,col:selectors[0].col}),this._readDeclarations(!0),this.fire({type:\"endrule\",selectors:selectors,line:selectors[0].line,col:selectors[0].col})),selectors},_selectors_group:function(){var selector,tokenStream=this._tokenStream,selectors=[];if(selector=this._selector(),null!==selector)for(selectors.push(selector);tokenStream.match(Tokens.COMMA);)this._readWhitespace(),selector=this._selector(),null!==selector?selectors.push(selector):this._unexpectedToken(tokenStream.LT(1));return selectors.length?selectors:null},_selector:function(){var tokenStream=this._tokenStream,selector=[],nextSelector=null,combinator=null,ws=null;if(nextSelector=this._simple_selector_sequence(),null===nextSelector)return null;for(selector.push(nextSelector);;)if(combinator=this._combinator(),null!==combinator)selector.push(combinator),nextSelector=this._simple_selector_sequence(),null===nextSelector?this._unexpectedToken(tokenStream.LT(1)):selector.push(nextSelector);else{if(!this._readWhitespace())break;ws=new Combinator(tokenStream.token().value,tokenStream.token().startLine,tokenStream.token().startCol),combinator=this._combinator(),nextSelector=this._simple_selector_sequence(),null===nextSelector?null!==combinator&&this._unexpectedToken(tokenStream.LT(1)):(null!==combinator?selector.push(combinator):selector.push(ws),selector.push(nextSelector))}return new Selector(selector,selector[0].line,selector[0].col)},_simple_selector_sequence:function(){var line,col,tokenStream=this._tokenStream,elementName=null,modifiers=[],selectorText=\"\",components=[function(){return tokenStream.match(Tokens.HASH)?new SelectorSubPart(tokenStream.token().value,\"id\",tokenStream.token().startLine,tokenStream.token().startCol):null},this._class,this._attrib,this._pseudo,this._negation],i=0,len=components.length,component=null;for(line=tokenStream.LT(1).startLine,col=tokenStream.LT(1).startCol,elementName=this._type_selector(),elementName||(elementName=this._universal()),null!==elementName&&(selectorText+=elementName);;){if(tokenStream.peek()===Tokens.S)break;for(;len>i&&null===component;)component=components[i++].call(this);if(null===component){if(\"\"===selectorText)return null;break}i=0,modifiers.push(component),selectorText+=\"\"+component,component=null}return\"\"!==selectorText?new SelectorPart(elementName,modifiers,selectorText,line,col):null},_type_selector:function(){var tokenStream=this._tokenStream,ns=this._namespace_prefix(),elementName=this._element_name();return elementName?(ns&&(elementName.text=ns+elementName.text,elementName.col-=ns.length),elementName):(ns&&(tokenStream.unget(),ns.length>1&&tokenStream.unget()),null)},_class:function(){var token,tokenStream=this._tokenStream;return tokenStream.match(Tokens.DOT)?(tokenStream.mustMatch(Tokens.IDENT),token=tokenStream.token(),new SelectorSubPart(\".\"+token.value,\"class\",token.startLine,token.startCol-1)):null},_element_name:function(){var token,tokenStream=this._tokenStream;return tokenStream.match(Tokens.IDENT)?(token=tokenStream.token(),new SelectorSubPart(token.value,\"elementName\",token.startLine,token.startCol)):null},_namespace_prefix:function(){var tokenStream=this._tokenStream,value=\"\";return(tokenStream.LA(1)===Tokens.PIPE||tokenStream.LA(2)===Tokens.PIPE)&&(tokenStream.match([Tokens.IDENT,Tokens.STAR])&&(value+=tokenStream.token().value),tokenStream.mustMatch(Tokens.PIPE),value+=\"|\"),value.length?value:null},_universal:function(){var ns,tokenStream=this._tokenStream,value=\"\";return ns=this._namespace_prefix(),ns&&(value+=ns),tokenStream.match(Tokens.STAR)&&(value+=\"*\"),value.length?value:null},_attrib:function(){var ns,token,tokenStream=this._tokenStream,value=null;return tokenStream.match(Tokens.LBRACKET)?(token=tokenStream.token(),value=token.value,value+=this._readWhitespace(),ns=this._namespace_prefix(),ns&&(value+=ns),tokenStream.mustMatch(Tokens.IDENT),value+=tokenStream.token().value,value+=this._readWhitespace(),tokenStream.match([Tokens.PREFIXMATCH,Tokens.SUFFIXMATCH,Tokens.SUBSTRINGMATCH,Tokens.EQUALS,Tokens.INCLUDES,Tokens.DASHMATCH])&&(value+=tokenStream.token().value,value+=this._readWhitespace(),tokenStream.mustMatch([Tokens.IDENT,Tokens.STRING]),value+=tokenStream.token().value,value+=this._readWhitespace()),tokenStream.mustMatch(Tokens.RBRACKET),new SelectorSubPart(value+\"]\",\"attribute\",token.startLine,token.startCol)):null},_pseudo:function(){var line,col,tokenStream=this._tokenStream,pseudo=null,colons=\":\";return tokenStream.match(Tokens.COLON)&&(tokenStream.match(Tokens.COLON)&&(colons+=\":\"),tokenStream.match(Tokens.IDENT)?(pseudo=tokenStream.token().value,line=tokenStream.token().startLine,col=tokenStream.token().startCol-colons.length):tokenStream.peek()==Tokens.FUNCTION&&(line=tokenStream.LT(1).startLine,col=tokenStream.LT(1).startCol-colons.length,pseudo=this._functional_pseudo()),pseudo&&(pseudo=new SelectorSubPart(colons+pseudo,\"pseudo\",line,col))),pseudo},_functional_pseudo:function(){var tokenStream=this._tokenStream,value=null;return tokenStream.match(Tokens.FUNCTION)&&(value=tokenStream.token().value,value+=this._readWhitespace(),value+=this._expression(),tokenStream.mustMatch(Tokens.RPAREN),value+=\")\"),value},_expression:function(){for(var tokenStream=this._tokenStream,value=\"\";tokenStream.match([Tokens.PLUS,Tokens.MINUS,Tokens.DIMENSION,Tokens.NUMBER,Tokens.STRING,Tokens.IDENT,Tokens.LENGTH,Tokens.FREQ,Tokens.ANGLE,Tokens.TIME,Tokens.RESOLUTION,Tokens.SLASH]);)value+=tokenStream.token().value,value+=this._readWhitespace();return value.length?value:null},_negation:function(){var line,col,arg,tokenStream=this._tokenStream,value=\"\",subpart=null;return tokenStream.match(Tokens.NOT)&&(value=tokenStream.token().value,line=tokenStream.token().startLine,col=tokenStream.token().startCol,value+=this._readWhitespace(),arg=this._negation_arg(),value+=arg,value+=this._readWhitespace(),tokenStream.match(Tokens.RPAREN),value+=tokenStream.token().value,subpart=new SelectorSubPart(value,\"not\",line,col),subpart.args.push(arg)),subpart},_negation_arg:function(){var line,col,part,tokenStream=this._tokenStream,args=[this._type_selector,this._universal,function(){return tokenStream.match(Tokens.HASH)?new SelectorSubPart(tokenStream.token().value,\"id\",tokenStream.token().startLine,tokenStream.token().startCol):null},this._class,this._attrib,this._pseudo],arg=null,i=0,len=args.length;for(line=tokenStream.LT(1).startLine,col=tokenStream.LT(1).startCol;len>i&&null===arg;)arg=args[i].call(this),i++;return null===arg&&this._unexpectedToken(tokenStream.LT(1)),part=\"elementName\"==arg.type?new SelectorPart(arg,[],\"\"+arg,line,col):new SelectorPart(null,[arg],\"\"+arg,line,col)},_declaration:function(){var tokenStream=this._tokenStream,property=null,expr=null,prio=null,invalid=null,propertyName=\"\";if(property=this._property(),null!==property){tokenStream.mustMatch(Tokens.COLON),this._readWhitespace(),expr=this._expr(),expr&&0!==expr.length||this._unexpectedToken(tokenStream.LT(1)),prio=this._prio(),propertyName=\"\"+property,(this.options.starHack&&\"*\"==property.hack||this.options.underscoreHack&&\"_\"==property.hack)&&(propertyName=property.text);try{this._validateProperty(propertyName,expr)}catch(ex){invalid=ex}return this.fire({type:\"property\",property:property,value:expr,important:prio,line:property.line,col:property.col,invalid:invalid}),!0}return!1},_prio:function(){var tokenStream=this._tokenStream,result=tokenStream.match(Tokens.IMPORTANT_SYM);return this._readWhitespace(),result},_expr:function(inFunction){var values=(this._tokenStream,[]),value=null,operator=null;if(value=this._term(inFunction),null!==value)for(values.push(value);;){if(operator=this._operator(inFunction),operator&&values.push(operator),value=this._term(inFunction),null===value)break;\nvalues.push(value)}return values.length>0?new PropertyValue(values,values[0].line,values[0].col):null},_term:function(inFunction){var token,line,col,tokenStream=this._tokenStream,unary=null,value=null,endChar=null;return unary=this._unary_operator(),null!==unary&&(line=tokenStream.token().startLine,col=tokenStream.token().startCol),tokenStream.peek()==Tokens.IE_FUNCTION&&this.options.ieFilters?(value=this._ie_function(),null===unary&&(line=tokenStream.token().startLine,col=tokenStream.token().startCol)):inFunction&&tokenStream.match([Tokens.LPAREN,Tokens.LBRACE,Tokens.LBRACKET])?(token=tokenStream.token(),endChar=token.endChar,value=token.value+this._expr(inFunction).text,null===unary&&(line=tokenStream.token().startLine,col=tokenStream.token().startCol),tokenStream.mustMatch(Tokens.type(endChar)),value+=endChar,this._readWhitespace()):tokenStream.match([Tokens.NUMBER,Tokens.PERCENTAGE,Tokens.LENGTH,Tokens.ANGLE,Tokens.TIME,Tokens.FREQ,Tokens.STRING,Tokens.IDENT,Tokens.URI,Tokens.UNICODE_RANGE])?(value=tokenStream.token().value,null===unary&&(line=tokenStream.token().startLine,col=tokenStream.token().startCol),this._readWhitespace()):(token=this._hexcolor(),null===token?(null===unary&&(line=tokenStream.LT(1).startLine,col=tokenStream.LT(1).startCol),null===value&&(value=tokenStream.LA(3)==Tokens.EQUALS&&this.options.ieFilters?this._ie_function():this._function())):(value=token.value,null===unary&&(line=token.startLine,col=token.startCol))),null!==value?new PropertyValuePart(null!==unary?unary+value:value,line,col):null},_function:function(){var lt,tokenStream=this._tokenStream,functionText=null,expr=null;if(tokenStream.match(Tokens.FUNCTION)){if(functionText=tokenStream.token().value,this._readWhitespace(),expr=this._expr(!0),functionText+=expr,this.options.ieFilters&&tokenStream.peek()==Tokens.EQUALS)do for(this._readWhitespace()&&(functionText+=tokenStream.token().value),tokenStream.LA(0)==Tokens.COMMA&&(functionText+=tokenStream.token().value),tokenStream.match(Tokens.IDENT),functionText+=tokenStream.token().value,tokenStream.match(Tokens.EQUALS),functionText+=tokenStream.token().value,lt=tokenStream.peek();lt!=Tokens.COMMA&&lt!=Tokens.S&&lt!=Tokens.RPAREN;)tokenStream.get(),functionText+=tokenStream.token().value,lt=tokenStream.peek();while(tokenStream.match([Tokens.COMMA,Tokens.S]));tokenStream.match(Tokens.RPAREN),functionText+=\")\",this._readWhitespace()}return functionText},_ie_function:function(){var lt,tokenStream=this._tokenStream,functionText=null;if(tokenStream.match([Tokens.IE_FUNCTION,Tokens.FUNCTION])){functionText=tokenStream.token().value;do for(this._readWhitespace()&&(functionText+=tokenStream.token().value),tokenStream.LA(0)==Tokens.COMMA&&(functionText+=tokenStream.token().value),tokenStream.match(Tokens.IDENT),functionText+=tokenStream.token().value,tokenStream.match(Tokens.EQUALS),functionText+=tokenStream.token().value,lt=tokenStream.peek();lt!=Tokens.COMMA&&lt!=Tokens.S&&lt!=Tokens.RPAREN;)tokenStream.get(),functionText+=tokenStream.token().value,lt=tokenStream.peek();while(tokenStream.match([Tokens.COMMA,Tokens.S]));tokenStream.match(Tokens.RPAREN),functionText+=\")\",this._readWhitespace()}return functionText},_hexcolor:function(){var color,tokenStream=this._tokenStream,token=null;if(tokenStream.match(Tokens.HASH)){if(token=tokenStream.token(),color=token.value,!/#[a-f0-9]{3,6}/i.test(color))throw new SyntaxError(\"Expected a hex color but found '\"+color+\"' at line \"+token.startLine+\", col \"+token.startCol+\".\",token.startLine,token.startCol);this._readWhitespace()}return token},_keyframes:function(){var token,tt,name,tokenStream=this._tokenStream,prefix=\"\";for(tokenStream.mustMatch(Tokens.KEYFRAMES_SYM),token=tokenStream.token(),/^@\\-([^\\-]+)\\-/.test(token.value)&&(prefix=RegExp.$1),this._readWhitespace(),name=this._keyframe_name(),this._readWhitespace(),tokenStream.mustMatch(Tokens.LBRACE),this.fire({type:\"startkeyframes\",name:name,prefix:prefix,line:token.startLine,col:token.startCol}),this._readWhitespace(),tt=tokenStream.peek();tt==Tokens.IDENT||tt==Tokens.PERCENTAGE;)this._keyframe_rule(),this._readWhitespace(),tt=tokenStream.peek();this.fire({type:\"endkeyframes\",name:name,prefix:prefix,line:token.startLine,col:token.startCol}),this._readWhitespace(),tokenStream.mustMatch(Tokens.RBRACE)},_keyframe_name:function(){var tokenStream=this._tokenStream;return tokenStream.mustMatch([Tokens.IDENT,Tokens.STRING]),SyntaxUnit.fromToken(tokenStream.token())},_keyframe_rule:function(){var keyList=(this._tokenStream,this._key_list());this.fire({type:\"startkeyframerule\",keys:keyList,line:keyList[0].line,col:keyList[0].col}),this._readDeclarations(!0),this.fire({type:\"endkeyframerule\",keys:keyList,line:keyList[0].line,col:keyList[0].col})},_key_list:function(){var tokenStream=this._tokenStream,keyList=[];for(keyList.push(this._key()),this._readWhitespace();tokenStream.match(Tokens.COMMA);)this._readWhitespace(),keyList.push(this._key()),this._readWhitespace();return keyList},_key:function(){var token,tokenStream=this._tokenStream;if(tokenStream.match(Tokens.PERCENTAGE))return SyntaxUnit.fromToken(tokenStream.token());if(tokenStream.match(Tokens.IDENT)){if(token=tokenStream.token(),/from|to/i.test(token.value))return SyntaxUnit.fromToken(token);tokenStream.unget()}this._unexpectedToken(tokenStream.LT(1))},_skipCruft:function(){for(;this._tokenStream.match([Tokens.S,Tokens.CDO,Tokens.CDC]););},_readDeclarations:function(checkStart,readMargins){var tt,tokenStream=this._tokenStream;this._readWhitespace(),checkStart&&tokenStream.mustMatch(Tokens.LBRACE),this._readWhitespace();try{for(;;){if(tokenStream.match(Tokens.SEMICOLON)||readMargins&&this._margin());else{if(!this._declaration())break;if(!tokenStream.match(Tokens.SEMICOLON))break}this._readWhitespace()}tokenStream.mustMatch(Tokens.RBRACE),this._readWhitespace()}catch(ex){if(!(ex instanceof SyntaxError)||this.options.strict)throw ex;if(this.fire({type:\"error\",error:ex,message:ex.message,line:ex.line,col:ex.col}),tt=tokenStream.advance([Tokens.SEMICOLON,Tokens.RBRACE]),tt==Tokens.SEMICOLON)this._readDeclarations(!1,readMargins);else if(tt!=Tokens.RBRACE)throw ex}},_readWhitespace:function(){for(var tokenStream=this._tokenStream,ws=\"\";tokenStream.match(Tokens.S);)ws+=tokenStream.token().value;return ws},_unexpectedToken:function(token){throw new SyntaxError(\"Unexpected token '\"+token.value+\"' at line \"+token.startLine+\", col \"+token.startCol+\".\",token.startLine,token.startCol)},_verifyEnd:function(){this._tokenStream.LA(1)!=Tokens.EOF&&this._unexpectedToken(this._tokenStream.LT(1))},_validateProperty:function(property,value){Validation.validate(property,value)},parse:function(input){this._tokenStream=new TokenStream(input,Tokens),this._stylesheet()},parseStyleSheet:function(input){return this.parse(input)},parseMediaQuery:function(input){this._tokenStream=new TokenStream(input,Tokens);var result=this._media_query();return this._verifyEnd(),result},parsePropertyValue:function(input){this._tokenStream=new TokenStream(input,Tokens),this._readWhitespace();var result=this._expr();return this._readWhitespace(),this._verifyEnd(),result},parseRule:function(input){this._tokenStream=new TokenStream(input,Tokens),this._readWhitespace();var result=this._ruleset();return this._readWhitespace(),this._verifyEnd(),result},parseSelector:function(input){this._tokenStream=new TokenStream(input,Tokens),this._readWhitespace();var result=this._selector();return this._readWhitespace(),this._verifyEnd(),result},parseStyleAttribute:function(input){input+=\"}\",this._tokenStream=new TokenStream(input,Tokens),this._readDeclarations()}};for(prop in additions)additions.hasOwnProperty(prop)&&(proto[prop]=additions[prop]);return proto}();var Properties={\"align-items\":\"flex-start | flex-end | center | baseline | stretch\",\"align-content\":\"flex-start | flex-end | center | space-between | space-around | stretch\",\"align-self\":\"auto | flex-start | flex-end | center | baseline | stretch\",\"-webkit-align-items\":\"flex-start | flex-end | center | baseline | stretch\",\"-webkit-align-content\":\"flex-start | flex-end | center | space-between | space-around | stretch\",\"-webkit-align-self\":\"auto | flex-start | flex-end | center | baseline | stretch\",\"alignment-adjust\":\"auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical | <percentage> | <length>\",\"alignment-baseline\":\"baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical\",animation:1,\"animation-delay\":{multi:\"<time>\",comma:!0},\"animation-direction\":{multi:\"normal | alternate\",comma:!0},\"animation-duration\":{multi:\"<time>\",comma:!0},\"animation-fill-mode\":{multi:\"none | forwards | backwards | both\",comma:!0},\"animation-iteration-count\":{multi:\"<number> | infinite\",comma:!0},\"animation-name\":{multi:\"none | <ident>\",comma:!0},\"animation-play-state\":{multi:\"running | paused\",comma:!0},\"animation-timing-function\":1,\"-moz-animation-delay\":{multi:\"<time>\",comma:!0},\"-moz-animation-direction\":{multi:\"normal | alternate\",comma:!0},\"-moz-animation-duration\":{multi:\"<time>\",comma:!0},\"-moz-animation-iteration-count\":{multi:\"<number> | infinite\",comma:!0},\"-moz-animation-name\":{multi:\"none | <ident>\",comma:!0},\"-moz-animation-play-state\":{multi:\"running | paused\",comma:!0},\"-ms-animation-delay\":{multi:\"<time>\",comma:!0},\"-ms-animation-direction\":{multi:\"normal | alternate\",comma:!0},\"-ms-animation-duration\":{multi:\"<time>\",comma:!0},\"-ms-animation-iteration-count\":{multi:\"<number> | infinite\",comma:!0},\"-ms-animation-name\":{multi:\"none | <ident>\",comma:!0},\"-ms-animation-play-state\":{multi:\"running | paused\",comma:!0},\"-webkit-animation-delay\":{multi:\"<time>\",comma:!0},\"-webkit-animation-direction\":{multi:\"normal | alternate\",comma:!0},\"-webkit-animation-duration\":{multi:\"<time>\",comma:!0},\"-webkit-animation-fill-mode\":{multi:\"none | forwards | backwards | both\",comma:!0},\"-webkit-animation-iteration-count\":{multi:\"<number> | infinite\",comma:!0},\"-webkit-animation-name\":{multi:\"none | <ident>\",comma:!0},\"-webkit-animation-play-state\":{multi:\"running | paused\",comma:!0},\"-o-animation-delay\":{multi:\"<time>\",comma:!0},\"-o-animation-direction\":{multi:\"normal | alternate\",comma:!0},\"-o-animation-duration\":{multi:\"<time>\",comma:!0},\"-o-animation-iteration-count\":{multi:\"<number> | infinite\",comma:!0},\"-o-animation-name\":{multi:\"none | <ident>\",comma:!0},\"-o-animation-play-state\":{multi:\"running | paused\",comma:!0},appearance:\"icon | window | desktop | workspace | document | tooltip | dialog | button | push-button | hyperlink | radio-button | checkbox | menu-item | tab | menu | menubar | pull-down-menu | pop-up-menu | list-menu | radio-group | checkbox-group | outline-tree | range | field | combo-box | signature | password | normal | none | inherit\",azimuth:function(expression){var part,simple=\"<angle> | leftwards | rightwards | inherit\",direction=\"left-side | far-left | left | center-left | center | center-right | right | far-right | right-side\",behind=!1,valid=!1;if(ValidationTypes.isAny(expression,simple)||(ValidationTypes.isAny(expression,\"behind\")&&(behind=!0,valid=!0),ValidationTypes.isAny(expression,direction)&&(valid=!0,behind||ValidationTypes.isAny(expression,\"behind\"))),expression.hasNext())throw part=expression.next(),valid?new ValidationError(\"Expected end of value but found '\"+part+\"'.\",part.line,part.col):new ValidationError(\"Expected (<'azimuth'>) but found '\"+part+\"'.\",part.line,part.col)},\"backface-visibility\":\"visible | hidden\",background:1,\"background-attachment\":{multi:\"<attachment>\",comma:!0},\"background-clip\":{multi:\"<box>\",comma:!0},\"background-color\":\"<color> | inherit\",\"background-image\":{multi:\"<bg-image>\",comma:!0},\"background-origin\":{multi:\"<box>\",comma:!0},\"background-position\":{multi:\"<bg-position>\",comma:!0},\"background-repeat\":{multi:\"<repeat-style>\"},\"background-size\":{multi:\"<bg-size>\",comma:!0},\"baseline-shift\":\"baseline | sub | super | <percentage> | <length>\",behavior:1,binding:1,bleed:\"<length>\",\"bookmark-label\":\"<content> | <attr> | <string>\",\"bookmark-level\":\"none | <integer>\",\"bookmark-state\":\"open | closed\",\"bookmark-target\":\"none | <uri> | <attr>\",border:\"<border-width> || <border-style> || <color>\",\"border-bottom\":\"<border-width> || <border-style> || <color>\",\"border-bottom-color\":\"<color> | inherit\",\"border-bottom-left-radius\":\"<x-one-radius>\",\"border-bottom-right-radius\":\"<x-one-radius>\",\"border-bottom-style\":\"<border-style>\",\"border-bottom-width\":\"<border-width>\",\"border-collapse\":\"collapse | separate | inherit\",\"border-color\":{multi:\"<color> | inherit\",max:4},\"border-image\":1,\"border-image-outset\":{multi:\"<length> | <number>\",max:4},\"border-image-repeat\":{multi:\"stretch | repeat | round\",max:2},\"border-image-slice\":function(expression){var part,valid=!1,numeric=\"<number> | <percentage>\",fill=!1,count=0,max=4;for(ValidationTypes.isAny(expression,\"fill\")&&(fill=!0,valid=!0);expression.hasNext()&&max>count&&(valid=ValidationTypes.isAny(expression,numeric));)count++;if(fill?valid=!0:ValidationTypes.isAny(expression,\"fill\"),expression.hasNext())throw part=expression.next(),valid?new ValidationError(\"Expected end of value but found '\"+part+\"'.\",part.line,part.col):new ValidationError(\"Expected ([<number> | <percentage>]{1,4} && fill?) but found '\"+part+\"'.\",part.line,part.col)},\"border-image-source\":\"<image> | none\",\"border-image-width\":{multi:\"<length> | <percentage> | <number> | auto\",max:4},\"border-left\":\"<border-width> || <border-style> || <color>\",\"border-left-color\":\"<color> | inherit\",\"border-left-style\":\"<border-style>\",\"border-left-width\":\"<border-width>\",\"border-radius\":function(expression){for(var part,valid=!1,simple=\"<length> | <percentage> | inherit\",slash=!1,count=0,max=8;expression.hasNext()&&max>count;){if(valid=ValidationTypes.isAny(expression,simple),!valid){if(!(\"/\"==expression.peek()&&count>0)||slash)break;slash=!0,max=count+5,expression.next()}count++}if(expression.hasNext())throw part=expression.next(),valid?new ValidationError(\"Expected end of value but found '\"+part+\"'.\",part.line,part.col):new ValidationError(\"Expected (<'border-radius'>) but found '\"+part+\"'.\",part.line,part.col)},\"border-right\":\"<border-width> || <border-style> || <color>\",\"border-right-color\":\"<color> | inherit\",\"border-right-style\":\"<border-style>\",\"border-right-width\":\"<border-width>\",\"border-spacing\":{multi:\"<length> | inherit\",max:2},\"border-style\":{multi:\"<border-style>\",max:4},\"border-top\":\"<border-width> || <border-style> || <color>\",\"border-top-color\":\"<color> | inherit\",\"border-top-left-radius\":\"<x-one-radius>\",\"border-top-right-radius\":\"<x-one-radius>\",\"border-top-style\":\"<border-style>\",\"border-top-width\":\"<border-width>\",\"border-width\":{multi:\"<border-width>\",max:4},bottom:\"<margin-width> | inherit\",\"-moz-box-align\":\"start | end | center | baseline | stretch\",\"-moz-box-decoration-break\":\"slice |clone\",\"-moz-box-direction\":\"normal | reverse | inherit\",\"-moz-box-flex\":\"<number>\",\"-moz-box-flex-group\":\"<integer>\",\"-moz-box-lines\":\"single | multiple\",\"-moz-box-ordinal-group\":\"<integer>\",\"-moz-box-orient\":\"horizontal | vertical | inline-axis | block-axis | inherit\",\"-moz-box-pack\":\"start | end | center | justify\",\"-webkit-box-align\":\"start | end | center | baseline | stretch\",\"-webkit-box-decoration-break\":\"slice |clone\",\"-webkit-box-direction\":\"normal | reverse | inherit\",\"-webkit-box-flex\":\"<number>\",\"-webkit-box-flex-group\":\"<integer>\",\"-webkit-box-lines\":\"single | multiple\",\"-webkit-box-ordinal-group\":\"<integer>\",\"-webkit-box-orient\":\"horizontal | vertical | inline-axis | block-axis | inherit\",\"-webkit-box-pack\":\"start | end | center | justify\",\"box-shadow\":function(expression){var part;if(ValidationTypes.isAny(expression,\"none\")){if(expression.hasNext())throw part=expression.next(),new ValidationError(\"Expected end of value but found '\"+part+\"'.\",part.line,part.col)}else Validation.multiProperty(\"<shadow>\",expression,!0,1/0)},\"box-sizing\":\"content-box | border-box | inherit\",\"break-after\":\"auto | always | avoid | left | right | page | column | avoid-page | avoid-column\",\"break-before\":\"auto | always | avoid | left | right | page | column | avoid-page | avoid-column\",\"break-inside\":\"auto | avoid | avoid-page | avoid-column\",\"caption-side\":\"top | bottom | inherit\",clear:\"none | right | left | both | inherit\",clip:1,color:\"<color> | inherit\",\"color-profile\":1,\"column-count\":\"<integer> | auto\",\"column-fill\":\"auto | balance\",\"column-gap\":\"<length> | normal\",\"column-rule\":\"<border-width> || <border-style> || <color>\",\"column-rule-color\":\"<color>\",\"column-rule-style\":\"<border-style>\",\"column-rule-width\":\"<border-width>\",\"column-span\":\"none | all\",\"column-width\":\"<length> | auto\",columns:1,content:1,\"counter-increment\":1,\"counter-reset\":1,crop:\"<shape> | auto\",cue:\"cue-after | cue-before | inherit\",\"cue-after\":1,\"cue-before\":1,cursor:1,direction:\"ltr | rtl | inherit\",display:\"inline | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | grid | inline-grid | none | inherit | -moz-box | -moz-inline-block | -moz-inline-box | -moz-inline-grid | -moz-inline-stack | -moz-inline-table | -moz-grid | -moz-grid-group | -moz-grid-line | -moz-groupbox | -moz-deck | -moz-popup | -moz-stack | -moz-marker | -webkit-box | -webkit-inline-box | -ms-flexbox | -ms-inline-flexbox | flex | -webkit-flex | inline-flex | -webkit-inline-flex\",\"dominant-baseline\":1,\"drop-initial-after-adjust\":\"central | middle | after-edge | text-after-edge | ideographic | alphabetic | mathematical | <percentage> | <length>\",\"drop-initial-after-align\":\"baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical\",\"drop-initial-before-adjust\":\"before-edge | text-before-edge | central | middle | hanging | mathematical | <percentage> | <length>\",\"drop-initial-before-align\":\"caps-height | baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical\",\"drop-initial-size\":\"auto | line | <length> | <percentage>\",\"drop-initial-value\":\"initial | <integer>\",elevation:\"<angle> | below | level | above | higher | lower | inherit\",\"empty-cells\":\"show | hide | inherit\",filter:1,fit:\"fill | hidden | meet | slice\",\"fit-position\":1,flex:\"<flex>\",\"flex-basis\":\"<width>\",\"flex-direction\":\"row | row-reverse | column | column-reverse\",\"flex-flow\":\"<flex-direction> || <flex-wrap>\",\"flex-grow\":\"<number>\",\"flex-shrink\":\"<number>\",\"flex-wrap\":\"nowrap | wrap | wrap-reverse\",\"-webkit-flex\":\"<flex>\",\"-webkit-flex-basis\":\"<width>\",\"-webkit-flex-direction\":\"row | row-reverse | column | column-reverse\",\"-webkit-flex-flow\":\"<flex-direction> || <flex-wrap>\",\"-webkit-flex-grow\":\"<number>\",\"-webkit-flex-shrink\":\"<number>\",\"-webkit-flex-wrap\":\"nowrap | wrap | wrap-reverse\",\"-ms-flex\":\"<flex>\",\"-ms-flex-align\":\"start | end | center | stretch | baseline\",\"-ms-flex-direction\":\"row | row-reverse | column | column-reverse | inherit\",\"-ms-flex-order\":\"<number>\",\"-ms-flex-pack\":\"start | end | center | justify\",\"-ms-flex-wrap\":\"nowrap | wrap | wrap-reverse\",\"float\":\"left | right | none | inherit\",\"float-offset\":1,font:1,\"font-family\":1,\"font-size\":\"<absolute-size> | <relative-size> | <length> | <percentage> | inherit\",\"font-size-adjust\":\"<number> | none | inherit\",\"font-stretch\":\"normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | inherit\",\"font-style\":\"normal | italic | oblique | inherit\",\"font-variant\":\"normal | small-caps | inherit\",\"font-weight\":\"normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 | inherit\",\"grid-cell-stacking\":\"columns | rows | layer\",\"grid-column\":1,\"grid-columns\":1,\"grid-column-align\":\"start | end | center | stretch\",\"grid-column-sizing\":1,\"grid-column-span\":\"<integer>\",\"grid-flow\":\"none | rows | columns\",\"grid-layer\":\"<integer>\",\"grid-row\":1,\"grid-rows\":1,\"grid-row-align\":\"start | end | center | stretch\",\"grid-row-span\":\"<integer>\",\"grid-row-sizing\":1,\"hanging-punctuation\":1,height:\"<margin-width> | <content-sizing> | inherit\",\"hyphenate-after\":\"<integer> | auto\",\"hyphenate-before\":\"<integer> | auto\",\"hyphenate-character\":\"<string> | auto\",\"hyphenate-lines\":\"no-limit | <integer>\",\"hyphenate-resource\":1,hyphens:\"none | manual | auto\",icon:1,\"image-orientation\":\"angle | auto\",\"image-rendering\":1,\"image-resolution\":1,\"inline-box-align\":\"initial | last | <integer>\",\"justify-content\":\"flex-start | flex-end | center | space-between | space-around\",\"-webkit-justify-content\":\"flex-start | flex-end | center | space-between | space-around\",left:\"<margin-width> | inherit\",\"letter-spacing\":\"<length> | normal | inherit\",\"line-height\":\"<number> | <length> | <percentage> | normal | inherit\",\"line-break\":\"auto | loose | normal | strict\",\"line-stacking\":1,\"line-stacking-ruby\":\"exclude-ruby | include-ruby\",\"line-stacking-shift\":\"consider-shifts | disregard-shifts\",\"line-stacking-strategy\":\"inline-line-height | block-line-height | max-height | grid-height\",\"list-style\":1,\"list-style-image\":\"<uri> | none | inherit\",\"list-style-position\":\"inside | outside | inherit\",\"list-style-type\":\"disc | circle | square | decimal | decimal-leading-zero | lower-roman | upper-roman | lower-greek | lower-latin | upper-latin | armenian | georgian | lower-alpha | upper-alpha | none | inherit\",margin:{multi:\"<margin-width> | inherit\",max:4},\"margin-bottom\":\"<margin-width> | inherit\",\"margin-left\":\"<margin-width> | inherit\",\"margin-right\":\"<margin-width> | inherit\",\"margin-top\":\"<margin-width> | inherit\",mark:1,\"mark-after\":1,\"mark-before\":1,marks:1,\"marquee-direction\":1,\"marquee-play-count\":1,\"marquee-speed\":1,\"marquee-style\":1,\"max-height\":\"<length> | <percentage> | <content-sizing> | none | inherit\",\"max-width\":\"<length> | <percentage> | <content-sizing> | none | inherit\",\"min-height\":\"<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats | inherit\",\"min-width\":\"<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats | inherit\",\"move-to\":1,\"nav-down\":1,\"nav-index\":1,\"nav-left\":1,\"nav-right\":1,\"nav-up\":1,opacity:\"<number> | inherit\",order:\"<integer>\",\"-webkit-order\":\"<integer>\",orphans:\"<integer> | inherit\",outline:1,\"outline-color\":\"<color> | invert | inherit\",\"outline-offset\":1,\"outline-style\":\"<border-style> | inherit\",\"outline-width\":\"<border-width> | inherit\",overflow:\"visible | hidden | scroll | auto | inherit\",\"overflow-style\":1,\"overflow-wrap\":\"normal | break-word\",\"overflow-x\":1,\"overflow-y\":1,padding:{multi:\"<padding-width> | inherit\",max:4},\"padding-bottom\":\"<padding-width> | inherit\",\"padding-left\":\"<padding-width> | inherit\",\"padding-right\":\"<padding-width> | inherit\",\"padding-top\":\"<padding-width> | inherit\",page:1,\"page-break-after\":\"auto | always | avoid | left | right | inherit\",\"page-break-before\":\"auto | always | avoid | left | right | inherit\",\"page-break-inside\":\"auto | avoid | inherit\",\"page-policy\":1,pause:1,\"pause-after\":1,\"pause-before\":1,perspective:1,\"perspective-origin\":1,phonemes:1,pitch:1,\"pitch-range\":1,\"play-during\":1,\"pointer-events\":\"auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit\",position:\"static | relative | absolute | fixed | inherit\",\"presentation-level\":1,\"punctuation-trim\":1,quotes:1,\"rendering-intent\":1,resize:1,rest:1,\"rest-after\":1,\"rest-before\":1,richness:1,right:\"<margin-width> | inherit\",rotation:1,\"rotation-point\":1,\"ruby-align\":1,\"ruby-overhang\":1,\"ruby-position\":1,\"ruby-span\":1,size:1,speak:\"normal | none | spell-out | inherit\",\"speak-header\":\"once | always | inherit\",\"speak-numeral\":\"digits | continuous | inherit\",\"speak-punctuation\":\"code | none | inherit\",\"speech-rate\":1,src:1,stress:1,\"string-set\":1,\"table-layout\":\"auto | fixed | inherit\",\"tab-size\":\"<integer> | <length>\",target:1,\"target-name\":1,\"target-new\":1,\"target-position\":1,\"text-align\":\"left | right | center | justify | inherit\",\"text-align-last\":1,\"text-decoration\":1,\"text-emphasis\":1,\"text-height\":1,\"text-indent\":\"<length> | <percentage> | inherit\",\"text-justify\":\"auto | none | inter-word | inter-ideograph | inter-cluster | distribute | kashida\",\"text-outline\":1,\"text-overflow\":1,\"text-rendering\":\"auto | optimizeSpeed | optimizeLegibility | geometricPrecision | inherit\",\"text-shadow\":1,\"text-transform\":\"capitalize | uppercase | lowercase | none | inherit\",\"text-wrap\":\"normal | none | avoid\",top:\"<margin-width> | inherit\",\"-ms-touch-action\":\"auto | none | pan-x | pan-y\",\"touch-action\":\"auto | none | pan-x | pan-y\",transform:1,\"transform-origin\":1,\"transform-style\":1,transition:1,\"transition-delay\":1,\"transition-duration\":1,\"transition-property\":1,\"transition-timing-function\":1,\"unicode-bidi\":\"normal | embed | isolate | bidi-override | isolate-override | plaintext | inherit\",\"user-modify\":\"read-only | read-write | write-only | inherit\",\"user-select\":\"none | text | toggle | element | elements | all | inherit\",\"vertical-align\":\"auto | use-script | baseline | sub | super | top | text-top | central | middle | bottom | text-bottom | <percentage> | <length>\",visibility:\"visible | hidden | collapse | inherit\",\"voice-balance\":1,\"voice-duration\":1,\"voice-family\":1,\"voice-pitch\":1,\"voice-pitch-range\":1,\"voice-rate\":1,\"voice-stress\":1,\"voice-volume\":1,volume:1,\"white-space\":\"normal | pre | nowrap | pre-wrap | pre-line | inherit | -pre-wrap | -o-pre-wrap | -moz-pre-wrap | -hp-pre-wrap\",\"white-space-collapse\":1,widows:\"<integer> | inherit\",width:\"<length> | <percentage> | <content-sizing> | auto | inherit\",\"word-break\":\"normal | keep-all | break-all\",\"word-spacing\":\"<length> | normal | inherit\",\"word-wrap\":\"normal | break-word\",\"writing-mode\":\"horizontal-tb | vertical-rl | vertical-lr | lr-tb | rl-tb | tb-rl | bt-rl | tb-lr | bt-lr | lr-bt | rl-bt | lr | rl | tb | inherit\",\"z-index\":\"<integer> | auto | inherit\",zoom:\"<number> | <percentage> | normal\"};PropertyName.prototype=new SyntaxUnit,PropertyName.prototype.constructor=PropertyName,PropertyName.prototype.toString=function(){return(this.hack?this.hack:\"\")+this.text},PropertyValue.prototype=new SyntaxUnit,PropertyValue.prototype.constructor=PropertyValue,PropertyValueIterator.prototype.count=function(){return this._parts.length},PropertyValueIterator.prototype.isFirst=function(){return 0===this._i},PropertyValueIterator.prototype.hasNext=function(){return this._i<this._parts.length},PropertyValueIterator.prototype.mark=function(){this._marks.push(this._i)},PropertyValueIterator.prototype.peek=function(count){return this.hasNext()?this._parts[this._i+(count||0)]:null},PropertyValueIterator.prototype.next=function(){return this.hasNext()?this._parts[this._i++]:null},PropertyValueIterator.prototype.previous=function(){return this._i>0?this._parts[--this._i]:null},PropertyValueIterator.prototype.restore=function(){this._marks.length&&(this._i=this._marks.pop())},PropertyValuePart.prototype=new SyntaxUnit,PropertyValuePart.prototype.constructor=PropertyValuePart,PropertyValuePart.fromToken=function(token){return new PropertyValuePart(token.value,token.startLine,token.startCol)};var Pseudos={\":first-letter\":1,\":first-line\":1,\":before\":1,\":after\":1};Pseudos.ELEMENT=1,Pseudos.CLASS=2,Pseudos.isElement=function(pseudo){return 0===pseudo.indexOf(\"::\")||Pseudos[pseudo.toLowerCase()]==Pseudos.ELEMENT},Selector.prototype=new SyntaxUnit,Selector.prototype.constructor=Selector,SelectorPart.prototype=new SyntaxUnit,SelectorPart.prototype.constructor=SelectorPart,SelectorSubPart.prototype=new SyntaxUnit,SelectorSubPart.prototype.constructor=SelectorSubPart,Specificity.prototype={constructor:Specificity,compare:function(other){var i,len,comps=[\"a\",\"b\",\"c\",\"d\"];for(i=0,len=comps.length;len>i;i++){if(this[comps[i]]<other[comps[i]])return-1;if(this[comps[i]]>other[comps[i]])return 1}return 0},valueOf:function(){return 1e3*this.a+100*this.b+10*this.c+this.d},toString:function(){return this.a+\",\"+this.b+\",\"+this.c+\",\"+this.d}},Specificity.calculate=function(selector){function updateValues(part){var i,j,len,num,modifier,elementName=part.elementName?part.elementName.text:\"\";for(elementName&&\"*\"!=elementName.charAt(elementName.length-1)&&d++,i=0,len=part.modifiers.length;len>i;i++)switch(modifier=part.modifiers[i],modifier.type){case\"class\":case\"attribute\":c++;break;case\"id\":b++;break;case\"pseudo\":Pseudos.isElement(modifier.text)?d++:c++;break;case\"not\":for(j=0,num=modifier.args.length;num>j;j++)updateValues(modifier.args[j])}}var i,len,part,b=0,c=0,d=0;for(i=0,len=selector.parts.length;len>i;i++)part=selector.parts[i],part instanceof SelectorPart&&updateValues(part);return new Specificity(0,b,c,d)};var h=/^[0-9a-fA-F]$/,nonascii=/^[\\u0080-\\uFFFF]$/,nl=/\\n|\\r\\n|\\r|\\f/;TokenStream.prototype=mix(new TokenStreamBase,{_getToken:function(){var c,reader=this._reader,token=null,startLine=reader.getLine(),startCol=reader.getCol();for(c=reader.read();c;){switch(c){case\"/\":token=\"*\"==reader.peek()?this.commentToken(c,startLine,startCol):this.charToken(c,startLine,startCol);break;case\"|\":case\"~\":case\"^\":case\"$\":case\"*\":token=\"=\"==reader.peek()?this.comparisonToken(c,startLine,startCol):this.charToken(c,startLine,startCol);break;case'\"':case\"'\":token=this.stringToken(c,startLine,startCol);break;case\"#\":token=isNameChar(reader.peek())?this.hashToken(c,startLine,startCol):this.charToken(c,startLine,startCol);break;case\".\":token=isDigit(reader.peek())?this.numberToken(c,startLine,startCol):this.charToken(c,startLine,startCol);break;case\"-\":token=\"-\"==reader.peek()?this.htmlCommentEndToken(c,startLine,startCol):isNameStart(reader.peek())?this.identOrFunctionToken(c,startLine,startCol):this.charToken(c,startLine,startCol);break;case\"!\":token=this.importantToken(c,startLine,startCol);break;case\"@\":token=this.atRuleToken(c,startLine,startCol);break;case\":\":token=this.notToken(c,startLine,startCol);break;case\"<\":token=this.htmlCommentStartToken(c,startLine,startCol);break;case\"U\":case\"u\":if(\"+\"==reader.peek()){token=this.unicodeRangeToken(c,startLine,startCol);break}default:token=isDigit(c)?this.numberToken(c,startLine,startCol):isWhitespace(c)?this.whitespaceToken(c,startLine,startCol):isIdentStart(c)?this.identOrFunctionToken(c,startLine,startCol):this.charToken(c,startLine,startCol)}break}return token||null!==c||(token=this.createToken(Tokens.EOF,null,startLine,startCol)),token},createToken:function(tt,value,startLine,startCol,options){var reader=this._reader;return options=options||{},{value:value,type:tt,channel:options.channel,endChar:options.endChar,hide:options.hide||!1,startLine:startLine,startCol:startCol,endLine:reader.getLine(),endCol:reader.getCol()}},atRuleToken:function(first,startLine,startCol){var ident,rule=first,reader=this._reader,tt=Tokens.CHAR;return reader.mark(),ident=this.readName(),rule=first+ident,tt=Tokens.type(rule.toLowerCase()),(tt==Tokens.CHAR||tt==Tokens.UNKNOWN)&&(rule.length>1?tt=Tokens.UNKNOWN_SYM:(tt=Tokens.CHAR,rule=first,reader.reset())),this.createToken(tt,rule,startLine,startCol)},charToken:function(c,startLine,startCol){var tt=Tokens.type(c),opts={};return-1==tt?tt=Tokens.CHAR:opts.endChar=Tokens[tt].endChar,this.createToken(tt,c,startLine,startCol,opts)},commentToken:function(first,startLine,startCol){var comment=(this._reader,this.readComment(first));return this.createToken(Tokens.COMMENT,comment,startLine,startCol)},comparisonToken:function(c,startLine,startCol){var reader=this._reader,comparison=c+reader.read(),tt=Tokens.type(comparison)||Tokens.CHAR;return this.createToken(tt,comparison,startLine,startCol)},hashToken:function(first,startLine,startCol){var name=(this._reader,this.readName(first));return this.createToken(Tokens.HASH,name,startLine,startCol)\n},htmlCommentStartToken:function(first,startLine,startCol){var reader=this._reader,text=first;return reader.mark(),text+=reader.readCount(3),\"<!--\"==text?this.createToken(Tokens.CDO,text,startLine,startCol):(reader.reset(),this.charToken(first,startLine,startCol))},htmlCommentEndToken:function(first,startLine,startCol){var reader=this._reader,text=first;return reader.mark(),text+=reader.readCount(2),\"-->\"==text?this.createToken(Tokens.CDC,text,startLine,startCol):(reader.reset(),this.charToken(first,startLine,startCol))},identOrFunctionToken:function(first,startLine,startCol){var reader=this._reader,ident=this.readName(first),tt=Tokens.IDENT;return\"(\"==reader.peek()?(ident+=reader.read(),\"url(\"==ident.toLowerCase()?(tt=Tokens.URI,ident=this.readURI(ident),\"url(\"==ident.toLowerCase()&&(tt=Tokens.FUNCTION)):tt=Tokens.FUNCTION):\":\"==reader.peek()&&\"progid\"==ident.toLowerCase()&&(ident+=reader.readTo(\"(\"),tt=Tokens.IE_FUNCTION),this.createToken(tt,ident,startLine,startCol)},importantToken:function(first,startLine,startCol){var temp,c,reader=this._reader,important=first,tt=Tokens.CHAR;for(reader.mark(),c=reader.read();c;){if(\"/\"==c){if(\"*\"!=reader.peek())break;if(temp=this.readComment(c),\"\"===temp)break}else{if(!isWhitespace(c)){if(/i/i.test(c)){temp=reader.readCount(8),/mportant/i.test(temp)&&(important+=c+temp,tt=Tokens.IMPORTANT_SYM);break}break}important+=c+this.readWhitespace()}c=reader.read()}return tt==Tokens.CHAR?(reader.reset(),this.charToken(first,startLine,startCol)):this.createToken(tt,important,startLine,startCol)},notToken:function(first,startLine,startCol){var reader=this._reader,text=first;return reader.mark(),text+=reader.readCount(4),\":not(\"==text.toLowerCase()?this.createToken(Tokens.NOT,text,startLine,startCol):(reader.reset(),this.charToken(first,startLine,startCol))},numberToken:function(first,startLine,startCol){var ident,reader=this._reader,value=this.readNumber(first),tt=Tokens.NUMBER,c=reader.peek();return isIdentStart(c)?(ident=this.readName(reader.read()),value+=ident,tt=/^em$|^ex$|^px$|^gd$|^rem$|^vw$|^vh$|^vmax$|^vmin$|^ch$|^cm$|^mm$|^in$|^pt$|^pc$/i.test(ident)?Tokens.LENGTH:/^deg|^rad$|^grad$/i.test(ident)?Tokens.ANGLE:/^ms$|^s$/i.test(ident)?Tokens.TIME:/^hz$|^khz$/i.test(ident)?Tokens.FREQ:/^dpi$|^dpcm$/i.test(ident)?Tokens.RESOLUTION:Tokens.DIMENSION):\"%\"==c&&(value+=reader.read(),tt=Tokens.PERCENTAGE),this.createToken(tt,value,startLine,startCol)},stringToken:function(first,startLine,startCol){for(var delim=first,string=first,reader=this._reader,prev=first,tt=Tokens.STRING,c=reader.read();c&&(string+=c,c!=delim||\"\\\\\"==prev);){if(isNewLine(reader.peek())&&\"\\\\\"!=c){tt=Tokens.INVALID;break}prev=c,c=reader.read()}return null===c&&(tt=Tokens.INVALID),this.createToken(tt,string,startLine,startCol)},unicodeRangeToken:function(first,startLine,startCol){var temp,reader=this._reader,value=first,tt=Tokens.CHAR;return\"+\"==reader.peek()&&(reader.mark(),value+=reader.read(),value+=this.readUnicodeRangePart(!0),2==value.length?reader.reset():(tt=Tokens.UNICODE_RANGE,-1==value.indexOf(\"?\")&&\"-\"==reader.peek()&&(reader.mark(),temp=reader.read(),temp+=this.readUnicodeRangePart(!1),1==temp.length?reader.reset():value+=temp))),this.createToken(tt,value,startLine,startCol)},whitespaceToken:function(first,startLine,startCol){var value=(this._reader,first+this.readWhitespace());return this.createToken(Tokens.S,value,startLine,startCol)},readUnicodeRangePart:function(allowQuestionMark){for(var reader=this._reader,part=\"\",c=reader.peek();isHexDigit(c)&&6>part.length;)reader.read(),part+=c,c=reader.peek();if(allowQuestionMark)for(;\"?\"==c&&6>part.length;)reader.read(),part+=c,c=reader.peek();return part},readWhitespace:function(){for(var reader=this._reader,whitespace=\"\",c=reader.peek();isWhitespace(c);)reader.read(),whitespace+=c,c=reader.peek();return whitespace},readNumber:function(first){for(var reader=this._reader,number=first,hasDot=\".\"==first,c=reader.peek();c;){if(isDigit(c))number+=reader.read();else{if(\".\"!=c)break;if(hasDot)break;hasDot=!0,number+=reader.read()}c=reader.peek()}return number},readString:function(){for(var reader=this._reader,delim=reader.read(),string=delim,prev=delim,c=reader.peek();c&&(c=reader.read(),string+=c,c!=delim||\"\\\\\"==prev);){if(isNewLine(reader.peek())&&\"\\\\\"!=c){string=\"\";break}prev=c,c=reader.peek()}return null===c&&(string=\"\"),string},readURI:function(first){var reader=this._reader,uri=first,inner=\"\",c=reader.peek();for(reader.mark();c&&isWhitespace(c);)reader.read(),c=reader.peek();for(inner=\"'\"==c||'\"'==c?this.readString():this.readURL(),c=reader.peek();c&&isWhitespace(c);)reader.read(),c=reader.peek();return\"\"===inner||\")\"!=c?(uri=first,reader.reset()):uri+=inner+reader.read(),uri},readURL:function(){for(var reader=this._reader,url=\"\",c=reader.peek();/^[!#$%&\\\\*-~]$/.test(c);)url+=reader.read(),c=reader.peek();return url},readName:function(first){for(var reader=this._reader,ident=first||\"\",c=reader.peek();;)if(\"\\\\\"==c)ident+=this.readEscape(reader.read()),c=reader.peek();else{if(!c||!isNameChar(c))break;ident+=reader.read(),c=reader.peek()}return ident},readEscape:function(first){var reader=this._reader,cssEscape=first||\"\",i=0,c=reader.peek();if(isHexDigit(c))do cssEscape+=reader.read(),c=reader.peek();while(c&&isHexDigit(c)&&6>++i);return 3==cssEscape.length&&/\\s/.test(c)||7==cssEscape.length||1==cssEscape.length?reader.read():c=\"\",cssEscape+c},readComment:function(first){var reader=this._reader,comment=first||\"\",c=reader.read();if(\"*\"==c){for(;c;){if(comment+=c,comment.length>2&&\"*\"==c&&\"/\"==reader.peek()){comment+=reader.read();break}c=reader.read()}return comment}return\"\"}});var Tokens=[{name:\"CDO\"},{name:\"CDC\"},{name:\"S\",whitespace:!0},{name:\"COMMENT\",comment:!0,hide:!0,channel:\"comment\"},{name:\"INCLUDES\",text:\"~=\"},{name:\"DASHMATCH\",text:\"|=\"},{name:\"PREFIXMATCH\",text:\"^=\"},{name:\"SUFFIXMATCH\",text:\"$=\"},{name:\"SUBSTRINGMATCH\",text:\"*=\"},{name:\"STRING\"},{name:\"IDENT\"},{name:\"HASH\"},{name:\"IMPORT_SYM\",text:\"@import\"},{name:\"PAGE_SYM\",text:\"@page\"},{name:\"MEDIA_SYM\",text:\"@media\"},{name:\"FONT_FACE_SYM\",text:\"@font-face\"},{name:\"CHARSET_SYM\",text:\"@charset\"},{name:\"NAMESPACE_SYM\",text:\"@namespace\"},{name:\"VIEWPORT_SYM\",text:[\"@viewport\",\"@-ms-viewport\"]},{name:\"UNKNOWN_SYM\"},{name:\"KEYFRAMES_SYM\",text:[\"@keyframes\",\"@-webkit-keyframes\",\"@-moz-keyframes\",\"@-o-keyframes\"]},{name:\"IMPORTANT_SYM\"},{name:\"LENGTH\"},{name:\"ANGLE\"},{name:\"TIME\"},{name:\"FREQ\"},{name:\"DIMENSION\"},{name:\"PERCENTAGE\"},{name:\"NUMBER\"},{name:\"URI\"},{name:\"FUNCTION\"},{name:\"UNICODE_RANGE\"},{name:\"INVALID\"},{name:\"PLUS\",text:\"+\"},{name:\"GREATER\",text:\">\"},{name:\"COMMA\",text:\",\"},{name:\"TILDE\",text:\"~\"},{name:\"NOT\"},{name:\"TOPLEFTCORNER_SYM\",text:\"@top-left-corner\"},{name:\"TOPLEFT_SYM\",text:\"@top-left\"},{name:\"TOPCENTER_SYM\",text:\"@top-center\"},{name:\"TOPRIGHT_SYM\",text:\"@top-right\"},{name:\"TOPRIGHTCORNER_SYM\",text:\"@top-right-corner\"},{name:\"BOTTOMLEFTCORNER_SYM\",text:\"@bottom-left-corner\"},{name:\"BOTTOMLEFT_SYM\",text:\"@bottom-left\"},{name:\"BOTTOMCENTER_SYM\",text:\"@bottom-center\"},{name:\"BOTTOMRIGHT_SYM\",text:\"@bottom-right\"},{name:\"BOTTOMRIGHTCORNER_SYM\",text:\"@bottom-right-corner\"},{name:\"LEFTTOP_SYM\",text:\"@left-top\"},{name:\"LEFTMIDDLE_SYM\",text:\"@left-middle\"},{name:\"LEFTBOTTOM_SYM\",text:\"@left-bottom\"},{name:\"RIGHTTOP_SYM\",text:\"@right-top\"},{name:\"RIGHTMIDDLE_SYM\",text:\"@right-middle\"},{name:\"RIGHTBOTTOM_SYM\",text:\"@right-bottom\"},{name:\"RESOLUTION\",state:\"media\"},{name:\"IE_FUNCTION\"},{name:\"CHAR\"},{name:\"PIPE\",text:\"|\"},{name:\"SLASH\",text:\"/\"},{name:\"MINUS\",text:\"-\"},{name:\"STAR\",text:\"*\"},{name:\"LBRACE\",endChar:\"}\",text:\"{\"},{name:\"RBRACE\",text:\"}\"},{name:\"LBRACKET\",endChar:\"]\",text:\"[\"},{name:\"RBRACKET\",text:\"]\"},{name:\"EQUALS\",text:\"=\"},{name:\"COLON\",text:\":\"},{name:\"SEMICOLON\",text:\";\"},{name:\"LPAREN\",endChar:\")\",text:\"(\"},{name:\"RPAREN\",text:\")\"},{name:\"DOT\",text:\".\"}];(function(){var nameMap=[],typeMap={};Tokens.UNKNOWN=-1,Tokens.unshift({name:\"EOF\"});for(var i=0,len=Tokens.length;len>i;i++)if(nameMap.push(Tokens[i].name),Tokens[Tokens[i].name]=i,Tokens[i].text)if(Tokens[i].text instanceof Array)for(var j=0;Tokens[i].text.length>j;j++)typeMap[Tokens[i].text[j]]=i;else typeMap[Tokens[i].text]=i;Tokens.name=function(tt){return nameMap[tt]},Tokens.type=function(c){return typeMap[c]||-1}})();var Validation={validate:function(property,value){var name=(\"\"+property).toLowerCase(),expression=(value.parts,new PropertyValueIterator(value)),spec=Properties[name];if(spec)\"number\"!=typeof spec&&(\"string\"==typeof spec?spec.indexOf(\"||\")>-1?this.groupProperty(spec,expression):this.singleProperty(spec,expression,1):spec.multi?this.multiProperty(spec.multi,expression,spec.comma,spec.max||1/0):\"function\"==typeof spec&&spec(expression));else if(0!==name.indexOf(\"-\"))throw new ValidationError(\"Unknown property '\"+property+\"'.\",property.line,property.col)},singleProperty:function(types,expression,max){for(var part,result=!1,value=expression.value,count=0;expression.hasNext()&&max>count&&(result=ValidationTypes.isAny(expression,types));)count++;if(!result)throw expression.hasNext()&&!expression.isFirst()?(part=expression.peek(),new ValidationError(\"Expected end of value but found '\"+part+\"'.\",part.line,part.col)):new ValidationError(\"Expected (\"+types+\") but found '\"+value+\"'.\",value.line,value.col);if(expression.hasNext())throw part=expression.next(),new ValidationError(\"Expected end of value but found '\"+part+\"'.\",part.line,part.col)},multiProperty:function(types,expression,comma,max){for(var part,result=!1,value=expression.value,count=0;expression.hasNext()&&!result&&max>count&&ValidationTypes.isAny(expression,types);)if(count++,expression.hasNext()){if(comma){if(\",\"!=expression.peek())break;part=expression.next()}}else result=!0;if(!result)throw expression.hasNext()&&!expression.isFirst()?(part=expression.peek(),new ValidationError(\"Expected end of value but found '\"+part+\"'.\",part.line,part.col)):(part=expression.previous(),comma&&\",\"==part?new ValidationError(\"Expected end of value but found '\"+part+\"'.\",part.line,part.col):new ValidationError(\"Expected (\"+types+\") but found '\"+value+\"'.\",value.line,value.col));if(expression.hasNext())throw part=expression.next(),new ValidationError(\"Expected end of value but found '\"+part+\"'.\",part.line,part.col)},groupProperty:function(types,expression){for(var name,part,result=!1,value=expression.value,typeCount=types.split(\"||\").length,groups={count:0},partial=!1;expression.hasNext()&&!result&&(name=ValidationTypes.isAnyOfGroup(expression,types))&&!groups[name];)groups[name]=1,groups.count++,partial=!0,groups.count!=typeCount&&expression.hasNext()||(result=!0);if(!result)throw partial&&expression.hasNext()?(part=expression.peek(),new ValidationError(\"Expected end of value but found '\"+part+\"'.\",part.line,part.col)):new ValidationError(\"Expected (\"+types+\") but found '\"+value+\"'.\",value.line,value.col);if(expression.hasNext())throw part=expression.next(),new ValidationError(\"Expected end of value but found '\"+part+\"'.\",part.line,part.col)}};ValidationError.prototype=Error();var ValidationTypes={isLiteral:function(part,literals){var i,len,text=(\"\"+part.text).toLowerCase(),args=literals.split(\" | \"),found=!1;for(i=0,len=args.length;len>i&&!found;i++)text==args[i].toLowerCase()&&(found=!0);return found},isSimple:function(type){return!!this.simple[type]},isComplex:function(type){return!!this.complex[type]},isAny:function(expression,types){var i,len,args=types.split(\" | \"),found=!1;for(i=0,len=args.length;len>i&&!found&&expression.hasNext();i++)found=this.isType(expression,args[i]);return found},isAnyOfGroup:function(expression,types){var i,len,args=types.split(\" || \"),found=!1;for(i=0,len=args.length;len>i&&!found;i++)found=this.isType(expression,args[i]);return found?args[i-1]:!1},isType:function(expression,type){var part=expression.peek(),result=!1;return\"<\"!=type.charAt(0)?(result=this.isLiteral(part,type),result&&expression.next()):this.simple[type]?(result=this.simple[type](part),result&&expression.next()):result=this.complex[type](expression),result},simple:{\"<absolute-size>\":function(part){return ValidationTypes.isLiteral(part,\"xx-small | x-small | small | medium | large | x-large | xx-large\")},\"<attachment>\":function(part){return ValidationTypes.isLiteral(part,\"scroll | fixed | local\")},\"<attr>\":function(part){return\"function\"==part.type&&\"attr\"==part.name},\"<bg-image>\":function(part){return this[\"<image>\"](part)||this[\"<gradient>\"](part)||\"none\"==part},\"<gradient>\":function(part){return\"function\"==part.type&&/^(?:\\-(?:ms|moz|o|webkit)\\-)?(?:repeating\\-)?(?:radial\\-|linear\\-)?gradient/i.test(part)},\"<box>\":function(part){return ValidationTypes.isLiteral(part,\"padding-box | border-box | content-box\")},\"<content>\":function(part){return\"function\"==part.type&&\"content\"==part.name},\"<relative-size>\":function(part){return ValidationTypes.isLiteral(part,\"smaller | larger\")},\"<ident>\":function(part){return\"identifier\"==part.type},\"<length>\":function(part){return\"function\"==part.type&&/^(?:\\-(?:ms|moz|o|webkit)\\-)?calc/i.test(part)?!0:\"length\"==part.type||\"number\"==part.type||\"integer\"==part.type||\"0\"==part},\"<color>\":function(part){return\"color\"==part.type||\"transparent\"==part},\"<number>\":function(part){return\"number\"==part.type||this[\"<integer>\"](part)},\"<integer>\":function(part){return\"integer\"==part.type},\"<line>\":function(part){return\"integer\"==part.type},\"<angle>\":function(part){return\"angle\"==part.type},\"<uri>\":function(part){return\"uri\"==part.type},\"<image>\":function(part){return this[\"<uri>\"](part)},\"<percentage>\":function(part){return\"percentage\"==part.type||\"0\"==part},\"<border-width>\":function(part){return this[\"<length>\"](part)||ValidationTypes.isLiteral(part,\"thin | medium | thick\")},\"<border-style>\":function(part){return ValidationTypes.isLiteral(part,\"none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset\")},\"<content-sizing>\":function(part){return ValidationTypes.isLiteral(part,\"fill-available | -moz-available | -webkit-fill-available | max-content | -moz-max-content | -webkit-max-content | min-content | -moz-min-content | -webkit-min-content | fit-content | -moz-fit-content | -webkit-fit-content\")},\"<margin-width>\":function(part){return this[\"<length>\"](part)||this[\"<percentage>\"](part)||ValidationTypes.isLiteral(part,\"auto\")},\"<padding-width>\":function(part){return this[\"<length>\"](part)||this[\"<percentage>\"](part)},\"<shape>\":function(part){return\"function\"==part.type&&(\"rect\"==part.name||\"inset-rect\"==part.name)},\"<time>\":function(part){return\"time\"==part.type},\"<flex-grow>\":function(part){return this[\"<number>\"](part)},\"<flex-shrink>\":function(part){return this[\"<number>\"](part)},\"<width>\":function(part){return this[\"<margin-width>\"](part)},\"<flex-basis>\":function(part){return this[\"<width>\"](part)},\"<flex-direction>\":function(part){return ValidationTypes.isLiteral(part,\"row | row-reverse | column | column-reverse\")},\"<flex-wrap>\":function(part){return ValidationTypes.isLiteral(part,\"nowrap | wrap | wrap-reverse\")}},complex:{\"<bg-position>\":function(expression){for(var result=!1,numeric=\"<percentage> | <length>\",xDir=\"left | right\",yDir=\"top | bottom\",count=0;expression.peek(count)&&\",\"!=expression.peek(count);)count++;return 3>count?ValidationTypes.isAny(expression,xDir+\" | center | \"+numeric)?(result=!0,ValidationTypes.isAny(expression,yDir+\" | center | \"+numeric)):ValidationTypes.isAny(expression,yDir)&&(result=!0,ValidationTypes.isAny(expression,xDir+\" | center\")):ValidationTypes.isAny(expression,xDir)?ValidationTypes.isAny(expression,yDir)?(result=!0,ValidationTypes.isAny(expression,numeric)):ValidationTypes.isAny(expression,numeric)&&(ValidationTypes.isAny(expression,yDir)?(result=!0,ValidationTypes.isAny(expression,numeric)):ValidationTypes.isAny(expression,\"center\")&&(result=!0)):ValidationTypes.isAny(expression,yDir)?ValidationTypes.isAny(expression,xDir)?(result=!0,ValidationTypes.isAny(expression,numeric)):ValidationTypes.isAny(expression,numeric)&&(ValidationTypes.isAny(expression,xDir)?(result=!0,ValidationTypes.isAny(expression,numeric)):ValidationTypes.isAny(expression,\"center\")&&(result=!0)):ValidationTypes.isAny(expression,\"center\")&&ValidationTypes.isAny(expression,xDir+\" | \"+yDir)&&(result=!0,ValidationTypes.isAny(expression,numeric)),result},\"<bg-size>\":function(expression){var result=!1,numeric=\"<percentage> | <length> | auto\";return ValidationTypes.isAny(expression,\"cover | contain\")?result=!0:ValidationTypes.isAny(expression,numeric)&&(result=!0,ValidationTypes.isAny(expression,numeric)),result},\"<repeat-style>\":function(expression){var part,result=!1,values=\"repeat | space | round | no-repeat\";return expression.hasNext()&&(part=expression.next(),ValidationTypes.isLiteral(part,\"repeat-x | repeat-y\")?result=!0:ValidationTypes.isLiteral(part,values)&&(result=!0,expression.hasNext()&&ValidationTypes.isLiteral(expression.peek(),values)&&expression.next())),result},\"<shadow>\":function(expression){var result=!1,count=0,inset=!1,color=!1;if(expression.hasNext()){for(ValidationTypes.isAny(expression,\"inset\")&&(inset=!0),ValidationTypes.isAny(expression,\"<color>\")&&(color=!0);ValidationTypes.isAny(expression,\"<length>\")&&4>count;)count++;expression.hasNext()&&(color||ValidationTypes.isAny(expression,\"<color>\"),inset||ValidationTypes.isAny(expression,\"inset\")),result=count>=2&&4>=count}return result},\"<x-one-radius>\":function(expression){var result=!1,simple=\"<length> | <percentage> | inherit\";return ValidationTypes.isAny(expression,simple)&&(result=!0,ValidationTypes.isAny(expression,simple)),result},\"<flex>\":function(expression){var part,result=!1;if(ValidationTypes.isAny(expression,\"none | inherit\")?result=!0:ValidationTypes.isType(expression,\"<flex-grow>\")?expression.peek()?ValidationTypes.isType(expression,\"<flex-shrink>\")?result=expression.peek()?ValidationTypes.isType(expression,\"<flex-basis>\"):!0:ValidationTypes.isType(expression,\"<flex-basis>\")&&(result=null===expression.peek()):result=!0:ValidationTypes.isType(expression,\"<flex-basis>\")&&(result=!0),!result)throw part=expression.peek(),new ValidationError(\"Expected (none | [ <flex-grow> <flex-shrink>? || <flex-basis> ]) but found '\"+expression.value.text+\"'.\",part.line,part.col);return result}}};parserlib.css={Colors:Colors,Combinator:Combinator,Parser:Parser,PropertyName:PropertyName,PropertyValue:PropertyValue,PropertyValuePart:PropertyValuePart,MediaFeature:MediaFeature,MediaQuery:MediaQuery,Selector:Selector,SelectorPart:SelectorPart,SelectorSubPart:SelectorSubPart,Specificity:Specificity,TokenStream:TokenStream,Tokens:Tokens,ValidationError:ValidationError}}(),function(){for(var prop in parserlib)exports[prop]=parserlib[prop]}();var util={isArray:function(ar){return Array.isArray(ar)||\"object\"==typeof ar&&\"[object Array]\"===objectToString(ar)},isDate:function(d){return\"object\"==typeof d&&\"[object Date]\"===objectToString(d)},isRegExp:function(re){return\"object\"==typeof re&&\"[object RegExp]\"===objectToString(re)},getRegExpFlags:function(re){var flags=\"\";return re.global&&(flags+=\"g\"),re.ignoreCase&&(flags+=\"i\"),re.multiline&&(flags+=\"m\"),flags}};\"object\"==typeof module&&(module.exports=clone),clone.clonePrototype=function(parent){if(null===parent)return null;var c=function(){};return c.prototype=parent,new c};var CSSLint=function(){function applyEmbeddedRuleset(text,ruleset){var valueMap,embedded=text&&text.match(embeddedRuleset),rules=embedded&&embedded[1];return rules&&(valueMap={\"true\":2,\"\":1,\"false\":0,2:2,1:1,0:0},rules.toLowerCase().split(\",\").forEach(function(rule){var pair=rule.split(\":\"),property=pair[0]||\"\",value=pair[1]||\"\";ruleset[property.trim()]=valueMap[value.trim()]})),ruleset}var rules=[],formatters=[],embeddedRuleset=/\\/\\*csslint([^\\*]*)\\*\\//,api=new parserlib.util.EventTarget;return api.version=\"@VERSION@\",api.addRule=function(rule){rules.push(rule),rules[rule.id]=rule},api.clearRules=function(){rules=[]},api.getRules=function(){return[].concat(rules).sort(function(a,b){return a.id>b.id?1:0})},api.getRuleset=function(){for(var ruleset={},i=0,len=rules.length;len>i;)ruleset[rules[i++].id]=1;return ruleset},api.addFormatter=function(formatter){formatters[formatter.id]=formatter},api.getFormatter=function(formatId){return formatters[formatId]},api.format=function(results,filename,formatId,options){var formatter=this.getFormatter(formatId),result=null;return formatter&&(result=formatter.startFormat(),result+=formatter.formatResults(results,filename,options||{}),result+=formatter.endFormat()),result},api.hasFormat=function(formatId){return formatters.hasOwnProperty(formatId)},api.verify=function(text,ruleset){var reporter,lines,report,i=0,parser=new parserlib.css.Parser({starHack:!0,ieFilters:!0,underscoreHack:!0,strict:!1});lines=text.replace(/\\n\\r?/g,\"$split$\").split(\"$split$\"),ruleset||(ruleset=this.getRuleset()),embeddedRuleset.test(text)&&(ruleset=clone(ruleset),ruleset=applyEmbeddedRuleset(text,ruleset)),reporter=new Reporter(lines,ruleset),ruleset.errors=2;for(i in ruleset)ruleset.hasOwnProperty(i)&&ruleset[i]&&rules[i]&&rules[i].init(parser,reporter);try{parser.parse(text)}catch(ex){reporter.error(\"Fatal error, cannot continue: \"+ex.message,ex.line,ex.col,{})}return report={messages:reporter.messages,stats:reporter.stats,ruleset:reporter.ruleset},report.messages.sort(function(a,b){return a.rollup&&!b.rollup?1:!a.rollup&&b.rollup?-1:a.line-b.line}),report},api}();Reporter.prototype={constructor:Reporter,error:function(message,line,col,rule){this.messages.push({type:\"error\",line:line,col:col,message:message,evidence:this.lines[line-1],rule:rule||{}})},warn:function(message,line,col,rule){this.report(message,line,col,rule)},report:function(message,line,col,rule){this.messages.push({type:2===this.ruleset[rule.id]?\"error\":\"warning\",line:line,col:col,message:message,evidence:this.lines[line-1],rule:rule})},info:function(message,line,col,rule){this.messages.push({type:\"info\",line:line,col:col,message:message,evidence:this.lines[line-1],rule:rule})},rollupError:function(message,rule){this.messages.push({type:\"error\",rollup:!0,message:message,rule:rule})},rollupWarn:function(message,rule){this.messages.push({type:\"warning\",rollup:!0,message:message,rule:rule})},stat:function(name,value){this.stats[name]=value}},CSSLint._Reporter=Reporter,CSSLint.Util={mix:function(receiver,supplier){var prop;for(prop in supplier)supplier.hasOwnProperty(prop)&&(receiver[prop]=supplier[prop]);return prop},indexOf:function(values,value){if(values.indexOf)return values.indexOf(value);for(var i=0,len=values.length;len>i;i++)if(values[i]===value)return i;return-1},forEach:function(values,func){if(values.forEach)return values.forEach(func);for(var i=0,len=values.length;len>i;i++)func(values[i],i,values)}},CSSLint.addRule({id:\"adjoining-classes\",name:\"Disallow adjoining classes\",desc:\"Don't use adjoining classes.\",browsers:\"IE6\",init:function(parser,reporter){var rule=this;parser.addListener(\"startrule\",function(event){var selector,part,modifier,classCount,i,j,k,selectors=event.selectors;for(i=0;selectors.length>i;i++)for(selector=selectors[i],j=0;selector.parts.length>j;j++)if(part=selector.parts[j],part.type===parser.SELECTOR_PART_TYPE)for(classCount=0,k=0;part.modifiers.length>k;k++)modifier=part.modifiers[k],\"class\"===modifier.type&&classCount++,classCount>1&&reporter.report(\"Don't use adjoining classes.\",part.line,part.col,rule)})}}),CSSLint.addRule({id:\"box-model\",name:\"Beware of broken box size\",desc:\"Don't use width or height when using padding or border.\",browsers:\"All\",init:function(parser,reporter){function startRule(){properties={},boxSizing=!1}function endRule(){var prop,value;if(!boxSizing){if(properties.height)for(prop in heightProperties)heightProperties.hasOwnProperty(prop)&&properties[prop]&&(value=properties[prop].value,(\"padding\"!==prop||2!==value.parts.length||0!==value.parts[0].value)&&reporter.report(\"Using height with \"+prop+\" can sometimes make elements larger than you expect.\",properties[prop].line,properties[prop].col,rule));if(properties.width)for(prop in widthProperties)widthProperties.hasOwnProperty(prop)&&properties[prop]&&(value=properties[prop].value,(\"padding\"!==prop||2!==value.parts.length||0!==value.parts[1].value)&&reporter.report(\"Using width with \"+prop+\" can sometimes make elements larger than you expect.\",properties[prop].line,properties[prop].col,rule))}}var properties,rule=this,widthProperties={border:1,\"border-left\":1,\"border-right\":1,padding:1,\"padding-left\":1,\"padding-right\":1},heightProperties={border:1,\"border-bottom\":1,\"border-top\":1,padding:1,\"padding-bottom\":1,\"padding-top\":1},boxSizing=!1;parser.addListener(\"startrule\",startRule),parser.addListener(\"startfontface\",startRule),parser.addListener(\"startpage\",startRule),parser.addListener(\"startpagemargin\",startRule),parser.addListener(\"startkeyframerule\",startRule),parser.addListener(\"property\",function(event){var name=event.property.text.toLowerCase();heightProperties[name]||widthProperties[name]?/^0\\S*$/.test(event.value)||\"border\"===name&&\"none\"==\"\"+event.value||(properties[name]={line:event.property.line,col:event.property.col,value:event.value}):/^(width|height)/i.test(name)&&/^(length|percentage)/.test(event.value.parts[0].type)?properties[name]=1:\"box-sizing\"===name&&(boxSizing=!0)}),parser.addListener(\"endrule\",endRule),parser.addListener(\"endfontface\",endRule),parser.addListener(\"endpage\",endRule),parser.addListener(\"endpagemargin\",endRule),parser.addListener(\"endkeyframerule\",endRule)}}),CSSLint.addRule({id:\"box-sizing\",name:\"Disallow use of box-sizing\",desc:\"The box-sizing properties isn't supported in IE6 and IE7.\",browsers:\"IE6, IE7\",tags:[\"Compatibility\"],init:function(parser,reporter){var rule=this;parser.addListener(\"property\",function(event){var name=event.property.text.toLowerCase();\"box-sizing\"===name&&reporter.report(\"The box-sizing property isn't supported in IE6 and IE7.\",event.line,event.col,rule)})}}),CSSLint.addRule({id:\"bulletproof-font-face\",name:\"Use the bulletproof @font-face syntax\",desc:\"Use the bulletproof @font-face syntax to avoid 404's in old IE (http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax).\",browsers:\"All\",init:function(parser,reporter){var line,col,rule=this,fontFaceRule=!1,firstSrc=!0,ruleFailed=!1;parser.addListener(\"startfontface\",function(){fontFaceRule=!0}),parser.addListener(\"property\",function(event){if(fontFaceRule){var propertyName=(\"\"+event.property).toLowerCase(),value=\"\"+event.value;if(line=event.line,col=event.col,\"src\"===propertyName){var regex=/^\\s?url\\(['\"].+\\.eot\\?.*['\"]\\)\\s*format\\(['\"]embedded-opentype['\"]\\).*$/i;!value.match(regex)&&firstSrc?(ruleFailed=!0,firstSrc=!1):value.match(regex)&&!firstSrc&&(ruleFailed=!1)}}}),parser.addListener(\"endfontface\",function(){fontFaceRule=!1,ruleFailed&&reporter.report(\"@font-face declaration doesn't follow the fontspring bulletproof syntax.\",line,col,rule)})}}),CSSLint.addRule({id:\"compatible-vendor-prefixes\",name:\"Require compatible vendor prefixes\",desc:\"Include all compatible vendor prefixes to reach a wider range of users.\",browsers:\"All\",init:function(parser,reporter){var compatiblePrefixes,properties,prop,variations,prefixed,i,len,rule=this,inKeyFrame=!1,arrayPush=Array.prototype.push,applyTo=[];compatiblePrefixes={animation:\"webkit moz\",\"animation-delay\":\"webkit moz\",\"animation-direction\":\"webkit moz\",\"animation-duration\":\"webkit moz\",\"animation-fill-mode\":\"webkit moz\",\"animation-iteration-count\":\"webkit moz\",\"animation-name\":\"webkit moz\",\"animation-play-state\":\"webkit moz\",\"animation-timing-function\":\"webkit moz\",appearance:\"webkit moz\",\"border-end\":\"webkit moz\",\"border-end-color\":\"webkit moz\",\"border-end-style\":\"webkit moz\",\"border-end-width\":\"webkit moz\",\"border-image\":\"webkit moz o\",\"border-radius\":\"webkit\",\"border-start\":\"webkit moz\",\"border-start-color\":\"webkit moz\",\"border-start-style\":\"webkit moz\",\"border-start-width\":\"webkit moz\",\"box-align\":\"webkit moz ms\",\"box-direction\":\"webkit moz ms\",\"box-flex\":\"webkit moz ms\",\"box-lines\":\"webkit ms\",\"box-ordinal-group\":\"webkit moz ms\",\"box-orient\":\"webkit moz ms\",\"box-pack\":\"webkit moz ms\",\"box-sizing\":\"webkit moz\",\"box-shadow\":\"webkit moz\",\"column-count\":\"webkit moz ms\",\"column-gap\":\"webkit moz ms\",\"column-rule\":\"webkit moz ms\",\"column-rule-color\":\"webkit moz ms\",\"column-rule-style\":\"webkit moz ms\",\"column-rule-width\":\"webkit moz ms\",\"column-width\":\"webkit moz ms\",hyphens:\"epub moz\",\"line-break\":\"webkit ms\",\"margin-end\":\"webkit moz\",\"margin-start\":\"webkit moz\",\"marquee-speed\":\"webkit wap\",\"marquee-style\":\"webkit wap\",\"padding-end\":\"webkit moz\",\"padding-start\":\"webkit moz\",\"tab-size\":\"moz o\",\"text-size-adjust\":\"webkit ms\",transform:\"webkit moz ms o\",\"transform-origin\":\"webkit moz ms o\",transition:\"webkit moz o\",\"transition-delay\":\"webkit moz o\",\"transition-duration\":\"webkit moz o\",\"transition-property\":\"webkit moz o\",\"transition-timing-function\":\"webkit moz o\",\"user-modify\":\"webkit moz\",\"user-select\":\"webkit moz ms\",\"word-break\":\"epub ms\",\"writing-mode\":\"epub ms\"};for(prop in compatiblePrefixes)if(compatiblePrefixes.hasOwnProperty(prop)){for(variations=[],prefixed=compatiblePrefixes[prop].split(\" \"),i=0,len=prefixed.length;len>i;i++)variations.push(\"-\"+prefixed[i]+\"-\"+prop);compatiblePrefixes[prop]=variations,arrayPush.apply(applyTo,variations)}parser.addListener(\"startrule\",function(){properties=[]}),parser.addListener(\"startkeyframes\",function(event){inKeyFrame=event.prefix||!0}),parser.addListener(\"endkeyframes\",function(){inKeyFrame=!1}),parser.addListener(\"property\",function(event){var name=event.property;CSSLint.Util.indexOf(applyTo,name.text)>-1&&(inKeyFrame&&\"string\"==typeof inKeyFrame&&0===name.text.indexOf(\"-\"+inKeyFrame+\"-\")||properties.push(name))}),parser.addListener(\"endrule\",function(){if(properties.length){var i,len,name,prop,variations,value,full,actual,item,propertiesSpecified,propertyGroups={};for(i=0,len=properties.length;len>i;i++){name=properties[i];for(prop in compatiblePrefixes)compatiblePrefixes.hasOwnProperty(prop)&&(variations=compatiblePrefixes[prop],CSSLint.Util.indexOf(variations,name.text)>-1&&(propertyGroups[prop]||(propertyGroups[prop]={full:variations.slice(0),actual:[],actualNodes:[]}),-1===CSSLint.Util.indexOf(propertyGroups[prop].actual,name.text)&&(propertyGroups[prop].actual.push(name.text),propertyGroups[prop].actualNodes.push(name))))}for(prop in propertyGroups)if(propertyGroups.hasOwnProperty(prop)&&(value=propertyGroups[prop],full=value.full,actual=value.actual,full.length>actual.length))for(i=0,len=full.length;len>i;i++)item=full[i],-1===CSSLint.Util.indexOf(actual,item)&&(propertiesSpecified=1===actual.length?actual[0]:2===actual.length?actual.join(\" and \"):actual.join(\", \"),reporter.report(\"The property \"+item+\" is compatible with \"+propertiesSpecified+\" and should be included as well.\",value.actualNodes[0].line,value.actualNodes[0].col,rule))}})}}),CSSLint.addRule({id:\"display-property-grouping\",name:\"Require properties appropriate for display\",desc:\"Certain properties shouldn't be used with certain display property values.\",browsers:\"All\",init:function(parser,reporter){function reportProperty(name,display,msg){properties[name]&&(\"string\"!=typeof propertiesToCheck[name]||properties[name].value.toLowerCase()!==propertiesToCheck[name])&&reporter.report(msg||name+\" can't be used with display: \"+display+\".\",properties[name].line,properties[name].col,rule)}function startRule(){properties={}}function endRule(){var display=properties.display?properties.display.value:null;if(display)switch(display){case\"inline\":reportProperty(\"height\",display),reportProperty(\"width\",display),reportProperty(\"margin\",display),reportProperty(\"margin-top\",display),reportProperty(\"margin-bottom\",display),reportProperty(\"float\",display,\"display:inline has no effect on floated elements (but may be used to fix the IE6 double-margin bug).\");break;case\"block\":reportProperty(\"vertical-align\",display);break;case\"inline-block\":reportProperty(\"float\",display);break;default:0===display.indexOf(\"table-\")&&(reportProperty(\"margin\",display),reportProperty(\"margin-left\",display),reportProperty(\"margin-right\",display),reportProperty(\"margin-top\",display),reportProperty(\"margin-bottom\",display),reportProperty(\"float\",display))\n}}var properties,rule=this,propertiesToCheck={display:1,\"float\":\"none\",height:1,width:1,margin:1,\"margin-left\":1,\"margin-right\":1,\"margin-bottom\":1,\"margin-top\":1,padding:1,\"padding-left\":1,\"padding-right\":1,\"padding-bottom\":1,\"padding-top\":1,\"vertical-align\":1};parser.addListener(\"startrule\",startRule),parser.addListener(\"startfontface\",startRule),parser.addListener(\"startkeyframerule\",startRule),parser.addListener(\"startpagemargin\",startRule),parser.addListener(\"startpage\",startRule),parser.addListener(\"property\",function(event){var name=event.property.text.toLowerCase();propertiesToCheck[name]&&(properties[name]={value:event.value.text,line:event.property.line,col:event.property.col})}),parser.addListener(\"endrule\",endRule),parser.addListener(\"endfontface\",endRule),parser.addListener(\"endkeyframerule\",endRule),parser.addListener(\"endpagemargin\",endRule),parser.addListener(\"endpage\",endRule)}}),CSSLint.addRule({id:\"duplicate-background-images\",name:\"Disallow duplicate background images\",desc:\"Every background-image should be unique. Use a common class for e.g. sprites.\",browsers:\"All\",init:function(parser,reporter){var rule=this,stack={};parser.addListener(\"property\",function(event){var i,len,name=event.property.text,value=event.value;if(name.match(/background/i))for(i=0,len=value.parts.length;len>i;i++)\"uri\"===value.parts[i].type&&(stack[value.parts[i].uri]===void 0?stack[value.parts[i].uri]=event:reporter.report(\"Background image '\"+value.parts[i].uri+\"' was used multiple times, first declared at line \"+stack[value.parts[i].uri].line+\", col \"+stack[value.parts[i].uri].col+\".\",event.line,event.col,rule))})}}),CSSLint.addRule({id:\"duplicate-properties\",name:\"Disallow duplicate properties\",desc:\"Duplicate properties must appear one after the other.\",browsers:\"All\",init:function(parser,reporter){function startRule(){properties={}}var properties,lastProperty,rule=this;parser.addListener(\"startrule\",startRule),parser.addListener(\"startfontface\",startRule),parser.addListener(\"startpage\",startRule),parser.addListener(\"startpagemargin\",startRule),parser.addListener(\"startkeyframerule\",startRule),parser.addListener(\"property\",function(event){var property=event.property,name=property.text.toLowerCase();!properties[name]||lastProperty===name&&properties[name]!==event.value.text||reporter.report(\"Duplicate property '\"+event.property+\"' found.\",event.line,event.col,rule),properties[name]=event.value.text,lastProperty=name})}}),CSSLint.addRule({id:\"empty-rules\",name:\"Disallow empty rules\",desc:\"Rules without any properties specified should be removed.\",browsers:\"All\",init:function(parser,reporter){var rule=this,count=0;parser.addListener(\"startrule\",function(){count=0}),parser.addListener(\"property\",function(){count++}),parser.addListener(\"endrule\",function(event){var selectors=event.selectors;0===count&&reporter.report(\"Rule is empty.\",selectors[0].line,selectors[0].col,rule)})}}),CSSLint.addRule({id:\"errors\",name:\"Parsing Errors\",desc:\"This rule looks for recoverable syntax errors.\",browsers:\"All\",init:function(parser,reporter){var rule=this;parser.addListener(\"error\",function(event){reporter.error(event.message,event.line,event.col,rule)})}}),CSSLint.addRule({id:\"fallback-colors\",name:\"Require fallback colors\",desc:\"For older browsers that don't support RGBA, HSL, or HSLA, provide a fallback color.\",browsers:\"IE6,IE7,IE8\",init:function(parser,reporter){function startRule(){properties={},lastProperty=null}var lastProperty,properties,rule=this,propertiesToCheck={color:1,background:1,\"border-color\":1,\"border-top-color\":1,\"border-right-color\":1,\"border-bottom-color\":1,\"border-left-color\":1,border:1,\"border-top\":1,\"border-right\":1,\"border-bottom\":1,\"border-left\":1,\"background-color\":1};parser.addListener(\"startrule\",startRule),parser.addListener(\"startfontface\",startRule),parser.addListener(\"startpage\",startRule),parser.addListener(\"startpagemargin\",startRule),parser.addListener(\"startkeyframerule\",startRule),parser.addListener(\"property\",function(event){var property=event.property,name=property.text.toLowerCase(),parts=event.value.parts,i=0,colorType=\"\",len=parts.length;if(propertiesToCheck[name])for(;len>i;)\"color\"===parts[i].type&&(\"alpha\"in parts[i]||\"hue\"in parts[i]?(/([^\\)]+)\\(/.test(parts[i])&&(colorType=RegExp.$1.toUpperCase()),lastProperty&&lastProperty.property.text.toLowerCase()===name&&\"compat\"===lastProperty.colorType||reporter.report(\"Fallback \"+name+\" (hex or RGB) should precede \"+colorType+\" \"+name+\".\",event.line,event.col,rule)):event.colorType=\"compat\"),i++;lastProperty=event})}}),CSSLint.addRule({id:\"floats\",name:\"Disallow too many floats\",desc:\"This rule tests if the float property is used too many times\",browsers:\"All\",init:function(parser,reporter){var rule=this,count=0;parser.addListener(\"property\",function(event){\"float\"===event.property.text.toLowerCase()&&\"none\"!==event.value.text.toLowerCase()&&count++}),parser.addListener(\"endstylesheet\",function(){reporter.stat(\"floats\",count),count>=10&&reporter.rollupWarn(\"Too many floats (\"+count+\"), you're probably using them for layout. Consider using a grid system instead.\",rule)})}}),CSSLint.addRule({id:\"font-faces\",name:\"Don't use too many web fonts\",desc:\"Too many different web fonts in the same stylesheet.\",browsers:\"All\",init:function(parser,reporter){var rule=this,count=0;parser.addListener(\"startfontface\",function(){count++}),parser.addListener(\"endstylesheet\",function(){count>5&&reporter.rollupWarn(\"Too many @font-face declarations (\"+count+\").\",rule)})}}),CSSLint.addRule({id:\"font-sizes\",name:\"Disallow too many font sizes\",desc:\"Checks the number of font-size declarations.\",browsers:\"All\",init:function(parser,reporter){var rule=this,count=0;parser.addListener(\"property\",function(event){\"font-size\"==\"\"+event.property&&count++}),parser.addListener(\"endstylesheet\",function(){reporter.stat(\"font-sizes\",count),count>=10&&reporter.rollupWarn(\"Too many font-size declarations (\"+count+\"), abstraction needed.\",rule)})}}),CSSLint.addRule({id:\"gradients\",name:\"Require all gradient definitions\",desc:\"When using a vendor-prefixed gradient, make sure to use them all.\",browsers:\"All\",init:function(parser,reporter){var gradients,rule=this;parser.addListener(\"startrule\",function(){gradients={moz:0,webkit:0,oldWebkit:0,o:0}}),parser.addListener(\"property\",function(event){/\\-(moz|o|webkit)(?:\\-(?:linear|radial))\\-gradient/i.test(event.value)?gradients[RegExp.$1]=1:/\\-webkit\\-gradient/i.test(event.value)&&(gradients.oldWebkit=1)}),parser.addListener(\"endrule\",function(event){var missing=[];gradients.moz||missing.push(\"Firefox 3.6+\"),gradients.webkit||missing.push(\"Webkit (Safari 5+, Chrome)\"),gradients.oldWebkit||missing.push(\"Old Webkit (Safari 4+, Chrome)\"),gradients.o||missing.push(\"Opera 11.1+\"),missing.length&&4>missing.length&&reporter.report(\"Missing vendor-prefixed CSS gradients for \"+missing.join(\", \")+\".\",event.selectors[0].line,event.selectors[0].col,rule)})}}),CSSLint.addRule({id:\"ids\",name:\"Disallow IDs in selectors\",desc:\"Selectors should not contain IDs.\",browsers:\"All\",init:function(parser,reporter){var rule=this;parser.addListener(\"startrule\",function(event){var selector,part,modifier,idCount,i,j,k,selectors=event.selectors;for(i=0;selectors.length>i;i++){for(selector=selectors[i],idCount=0,j=0;selector.parts.length>j;j++)if(part=selector.parts[j],part.type===parser.SELECTOR_PART_TYPE)for(k=0;part.modifiers.length>k;k++)modifier=part.modifiers[k],\"id\"===modifier.type&&idCount++;1===idCount?reporter.report(\"Don't use IDs in selectors.\",selector.line,selector.col,rule):idCount>1&&reporter.report(idCount+\" IDs in the selector, really?\",selector.line,selector.col,rule)}})}}),CSSLint.addRule({id:\"import\",name:\"Disallow @import\",desc:\"Don't use @import, use <link> instead.\",browsers:\"All\",init:function(parser,reporter){var rule=this;parser.addListener(\"import\",function(event){reporter.report(\"@import prevents parallel downloads, use <link> instead.\",event.line,event.col,rule)})}}),CSSLint.addRule({id:\"important\",name:\"Disallow !important\",desc:\"Be careful when using !important declaration\",browsers:\"All\",init:function(parser,reporter){var rule=this,count=0;parser.addListener(\"property\",function(event){event.important===!0&&(count++,reporter.report(\"Use of !important\",event.line,event.col,rule))}),parser.addListener(\"endstylesheet\",function(){reporter.stat(\"important\",count),count>=10&&reporter.rollupWarn(\"Too many !important declarations (\"+count+\"), try to use less than 10 to avoid specificity issues.\",rule)})}}),CSSLint.addRule({id:\"known-properties\",name:\"Require use of known properties\",desc:\"Properties should be known (listed in CSS3 specification) or be a vendor-prefixed property.\",browsers:\"All\",init:function(parser,reporter){var rule=this;parser.addListener(\"property\",function(event){event.invalid&&reporter.report(event.invalid.message,event.line,event.col,rule)})}}),CSSLint.addRule({id:\"order-alphabetical\",name:\"Alphabetical order\",desc:\"Assure properties are in alphabetical order\",browsers:\"All\",init:function(parser,reporter){var properties,rule=this,startRule=function(){properties=[]};parser.addListener(\"startrule\",startRule),parser.addListener(\"startfontface\",startRule),parser.addListener(\"startpage\",startRule),parser.addListener(\"startpagemargin\",startRule),parser.addListener(\"startkeyframerule\",startRule),parser.addListener(\"property\",function(event){var name=event.property.text,lowerCasePrefixLessName=name.toLowerCase().replace(/^-.*?-/,\"\");properties.push(lowerCasePrefixLessName)}),parser.addListener(\"endrule\",function(event){var currentProperties=properties.join(\",\"),expectedProperties=properties.sort().join(\",\");currentProperties!==expectedProperties&&reporter.report(\"Rule doesn't have all its properties in alphabetical ordered.\",event.line,event.col,rule)})}}),CSSLint.addRule({id:\"outline-none\",name:\"Disallow outline: none\",desc:\"Use of outline: none or outline: 0 should be limited to :focus rules.\",browsers:\"All\",tags:[\"Accessibility\"],init:function(parser,reporter){function startRule(event){lastRule=event.selectors?{line:event.line,col:event.col,selectors:event.selectors,propCount:0,outline:!1}:null}function endRule(){lastRule&&lastRule.outline&&(-1===(\"\"+lastRule.selectors).toLowerCase().indexOf(\":focus\")?reporter.report(\"Outlines should only be modified using :focus.\",lastRule.line,lastRule.col,rule):1===lastRule.propCount&&reporter.report(\"Outlines shouldn't be hidden unless other visual changes are made.\",lastRule.line,lastRule.col,rule))}var lastRule,rule=this;parser.addListener(\"startrule\",startRule),parser.addListener(\"startfontface\",startRule),parser.addListener(\"startpage\",startRule),parser.addListener(\"startpagemargin\",startRule),parser.addListener(\"startkeyframerule\",startRule),parser.addListener(\"property\",function(event){var name=event.property.text.toLowerCase(),value=event.value;lastRule&&(lastRule.propCount++,\"outline\"!==name||\"none\"!=\"\"+value&&\"0\"!=\"\"+value||(lastRule.outline=!0))}),parser.addListener(\"endrule\",endRule),parser.addListener(\"endfontface\",endRule),parser.addListener(\"endpage\",endRule),parser.addListener(\"endpagemargin\",endRule),parser.addListener(\"endkeyframerule\",endRule)}}),CSSLint.addRule({id:\"overqualified-elements\",name:\"Disallow overqualified elements\",desc:\"Don't use classes or IDs with elements (a.foo or a#foo).\",browsers:\"All\",init:function(parser,reporter){var rule=this,classes={};parser.addListener(\"startrule\",function(event){var selector,part,modifier,i,j,k,selectors=event.selectors;for(i=0;selectors.length>i;i++)for(selector=selectors[i],j=0;selector.parts.length>j;j++)if(part=selector.parts[j],part.type===parser.SELECTOR_PART_TYPE)for(k=0;part.modifiers.length>k;k++)modifier=part.modifiers[k],part.elementName&&\"id\"===modifier.type?reporter.report(\"Element (\"+part+\") is overqualified, just use \"+modifier+\" without element name.\",part.line,part.col,rule):\"class\"===modifier.type&&(classes[modifier]||(classes[modifier]=[]),classes[modifier].push({modifier:modifier,part:part}))}),parser.addListener(\"endstylesheet\",function(){var prop;for(prop in classes)classes.hasOwnProperty(prop)&&1===classes[prop].length&&classes[prop][0].part.elementName&&reporter.report(\"Element (\"+classes[prop][0].part+\") is overqualified, just use \"+classes[prop][0].modifier+\" without element name.\",classes[prop][0].part.line,classes[prop][0].part.col,rule)})}}),CSSLint.addRule({id:\"qualified-headings\",name:\"Disallow qualified headings\",desc:\"Headings should not be qualified (namespaced).\",browsers:\"All\",init:function(parser,reporter){var rule=this;parser.addListener(\"startrule\",function(event){var selector,part,i,j,selectors=event.selectors;for(i=0;selectors.length>i;i++)for(selector=selectors[i],j=0;selector.parts.length>j;j++)part=selector.parts[j],part.type===parser.SELECTOR_PART_TYPE&&part.elementName&&/h[1-6]/.test(\"\"+part.elementName)&&j>0&&reporter.report(\"Heading (\"+part.elementName+\") should not be qualified.\",part.line,part.col,rule)})}}),CSSLint.addRule({id:\"regex-selectors\",name:\"Disallow selectors that look like regexs\",desc:\"Selectors that look like regular expressions are slow and should be avoided.\",browsers:\"All\",init:function(parser,reporter){var rule=this;parser.addListener(\"startrule\",function(event){var selector,part,modifier,i,j,k,selectors=event.selectors;for(i=0;selectors.length>i;i++)for(selector=selectors[i],j=0;selector.parts.length>j;j++)if(part=selector.parts[j],part.type===parser.SELECTOR_PART_TYPE)for(k=0;part.modifiers.length>k;k++)modifier=part.modifiers[k],\"attribute\"===modifier.type&&/([\\~\\|\\^\\$\\*]=)/.test(modifier)&&reporter.report(\"Attribute selectors with \"+RegExp.$1+\" are slow!\",modifier.line,modifier.col,rule)})}}),CSSLint.addRule({id:\"rules-count\",name:\"Rules Count\",desc:\"Track how many rules there are.\",browsers:\"All\",init:function(parser,reporter){var count=0;parser.addListener(\"startrule\",function(){count++}),parser.addListener(\"endstylesheet\",function(){reporter.stat(\"rule-count\",count)})}}),CSSLint.addRule({id:\"selector-max-approaching\",name:\"Warn when approaching the 4095 selector limit for IE\",desc:\"Will warn when selector count is >= 3800 selectors.\",browsers:\"IE\",init:function(parser,reporter){var rule=this,count=0;parser.addListener(\"startrule\",function(event){count+=event.selectors.length}),parser.addListener(\"endstylesheet\",function(){count>=3800&&reporter.report(\"You have \"+count+\" selectors. Internet Explorer supports a maximum of 4095 selectors per stylesheet. Consider refactoring.\",0,0,rule)})}}),CSSLint.addRule({id:\"selector-max\",name:\"Error when past the 4095 selector limit for IE\",desc:\"Will error when selector count is > 4095.\",browsers:\"IE\",init:function(parser,reporter){var rule=this,count=0;parser.addListener(\"startrule\",function(event){count+=event.selectors.length}),parser.addListener(\"endstylesheet\",function(){count>4095&&reporter.report(\"You have \"+count+\" selectors. Internet Explorer supports a maximum of 4095 selectors per stylesheet. Consider refactoring.\",0,0,rule)})}}),CSSLint.addRule({id:\"selector-newline\",name:\"Disallow new-line characters in selectors\",desc:\"New-line characters in selectors are usually a forgotten comma and not a descendant combinator.\",browsers:\"All\",init:function(parser,reporter){function startRule(event){var i,len,selector,p,n,pLen,part,part2,type,currentLine,nextLine,selectors=event.selectors;for(i=0,len=selectors.length;len>i;i++)for(selector=selectors[i],p=0,pLen=selector.parts.length;pLen>p;p++)for(n=p+1;pLen>n;n++)part=selector.parts[p],part2=selector.parts[n],type=part.type,currentLine=part.line,nextLine=part2.line,\"descendant\"===type&&nextLine>currentLine&&reporter.report(\"newline character found in selector (forgot a comma?)\",currentLine,selectors[i].parts[0].col,rule)}var rule=this;parser.addListener(\"startrule\",startRule)}}),CSSLint.addRule({id:\"shorthand\",name:\"Require shorthand properties\",desc:\"Use shorthand properties where possible.\",browsers:\"All\",init:function(parser,reporter){function startRule(){properties={}}function endRule(event){var prop,i,len,total;for(prop in mapping)if(mapping.hasOwnProperty(prop)){for(total=0,i=0,len=mapping[prop].length;len>i;i++)total+=properties[mapping[prop][i]]?1:0;total===mapping[prop].length&&reporter.report(\"The properties \"+mapping[prop].join(\", \")+\" can be replaced by \"+prop+\".\",event.line,event.col,rule)}}var prop,i,len,properties,rule=this,propertiesToCheck={},mapping={margin:[\"margin-top\",\"margin-bottom\",\"margin-left\",\"margin-right\"],padding:[\"padding-top\",\"padding-bottom\",\"padding-left\",\"padding-right\"]};for(prop in mapping)if(mapping.hasOwnProperty(prop))for(i=0,len=mapping[prop].length;len>i;i++)propertiesToCheck[mapping[prop][i]]=prop;parser.addListener(\"startrule\",startRule),parser.addListener(\"startfontface\",startRule),parser.addListener(\"property\",function(event){var name=(\"\"+event.property).toLowerCase();propertiesToCheck[name]&&(properties[name]=1)}),parser.addListener(\"endrule\",endRule),parser.addListener(\"endfontface\",endRule)}}),CSSLint.addRule({id:\"star-property-hack\",name:\"Disallow properties with a star prefix\",desc:\"Checks for the star property hack (targets IE6/7)\",browsers:\"All\",init:function(parser,reporter){var rule=this;parser.addListener(\"property\",function(event){var property=event.property;\"*\"===property.hack&&reporter.report(\"Property with star prefix found.\",event.property.line,event.property.col,rule)})}}),CSSLint.addRule({id:\"text-indent\",name:\"Disallow negative text-indent\",desc:\"Checks for text indent less than -99px\",browsers:\"All\",init:function(parser,reporter){function startRule(){textIndent=!1,direction=\"inherit\"}function endRule(){textIndent&&\"ltr\"!==direction&&reporter.report(\"Negative text-indent doesn't work well with RTL. If you use text-indent for image replacement explicitly set direction for that item to ltr.\",textIndent.line,textIndent.col,rule)}var textIndent,direction,rule=this;parser.addListener(\"startrule\",startRule),parser.addListener(\"startfontface\",startRule),parser.addListener(\"property\",function(event){var name=(\"\"+event.property).toLowerCase(),value=event.value;\"text-indent\"===name&&-99>value.parts[0].value?textIndent=event.property:\"direction\"===name&&\"ltr\"==\"\"+value&&(direction=\"ltr\")}),parser.addListener(\"endrule\",endRule),parser.addListener(\"endfontface\",endRule)}}),CSSLint.addRule({id:\"underscore-property-hack\",name:\"Disallow properties with an underscore prefix\",desc:\"Checks for the underscore property hack (targets IE6)\",browsers:\"All\",init:function(parser,reporter){var rule=this;parser.addListener(\"property\",function(event){var property=event.property;\"_\"===property.hack&&reporter.report(\"Property with underscore prefix found.\",event.property.line,event.property.col,rule)})}}),CSSLint.addRule({id:\"unique-headings\",name:\"Headings should only be defined once\",desc:\"Headings should be defined only once.\",browsers:\"All\",init:function(parser,reporter){var rule=this,headings={h1:0,h2:0,h3:0,h4:0,h5:0,h6:0};parser.addListener(\"startrule\",function(event){var selector,part,pseudo,i,j,selectors=event.selectors;for(i=0;selectors.length>i;i++)if(selector=selectors[i],part=selector.parts[selector.parts.length-1],part.elementName&&/(h[1-6])/i.test(\"\"+part.elementName)){for(j=0;part.modifiers.length>j;j++)if(\"pseudo\"===part.modifiers[j].type){pseudo=!0;break}pseudo||(headings[RegExp.$1]++,headings[RegExp.$1]>1&&reporter.report(\"Heading (\"+part.elementName+\") has already been defined.\",part.line,part.col,rule))}}),parser.addListener(\"endstylesheet\",function(){var prop,messages=[];for(prop in headings)headings.hasOwnProperty(prop)&&headings[prop]>1&&messages.push(headings[prop]+\" \"+prop+\"s\");messages.length&&reporter.rollupWarn(\"You have \"+messages.join(\", \")+\" defined in this stylesheet.\",rule)})}}),CSSLint.addRule({id:\"universal-selector\",name:\"Disallow universal selector\",desc:\"The universal selector (*) is known to be slow.\",browsers:\"All\",init:function(parser,reporter){var rule=this;parser.addListener(\"startrule\",function(event){var selector,part,i,selectors=event.selectors;for(i=0;selectors.length>i;i++)selector=selectors[i],part=selector.parts[selector.parts.length-1],\"*\"===part.elementName&&reporter.report(rule.desc,part.line,part.col,rule)})}}),CSSLint.addRule({id:\"unqualified-attributes\",name:\"Disallow unqualified attribute selectors\",desc:\"Unqualified attribute selectors are known to be slow.\",browsers:\"All\",init:function(parser,reporter){var rule=this;parser.addListener(\"startrule\",function(event){var selector,part,modifier,i,k,selectors=event.selectors;for(i=0;selectors.length>i;i++)if(selector=selectors[i],part=selector.parts[selector.parts.length-1],part.type===parser.SELECTOR_PART_TYPE)for(k=0;part.modifiers.length>k;k++)modifier=part.modifiers[k],\"attribute\"!==modifier.type||part.elementName&&\"*\"!==part.elementName||reporter.report(rule.desc,part.line,part.col,rule)})}}),CSSLint.addRule({id:\"vendor-prefix\",name:\"Require standard property with vendor prefix\",desc:\"When using a vendor-prefixed property, make sure to include the standard one.\",browsers:\"All\",init:function(parser,reporter){function startRule(){properties={},num=1}function endRule(){var prop,i,len,needed,actual,needsStandard=[];for(prop in properties)propertiesToCheck[prop]&&needsStandard.push({actual:prop,needed:propertiesToCheck[prop]});for(i=0,len=needsStandard.length;len>i;i++)needed=needsStandard[i].needed,actual=needsStandard[i].actual,properties[needed]?properties[needed][0].pos<properties[actual][0].pos&&reporter.report(\"Standard property '\"+needed+\"' should come after vendor-prefixed property '\"+actual+\"'.\",properties[actual][0].name.line,properties[actual][0].name.col,rule):reporter.report(\"Missing standard property '\"+needed+\"' to go along with '\"+actual+\"'.\",properties[actual][0].name.line,properties[actual][0].name.col,rule)}var properties,num,rule=this,propertiesToCheck={\"-webkit-border-radius\":\"border-radius\",\"-webkit-border-top-left-radius\":\"border-top-left-radius\",\"-webkit-border-top-right-radius\":\"border-top-right-radius\",\"-webkit-border-bottom-left-radius\":\"border-bottom-left-radius\",\"-webkit-border-bottom-right-radius\":\"border-bottom-right-radius\",\"-o-border-radius\":\"border-radius\",\"-o-border-top-left-radius\":\"border-top-left-radius\",\"-o-border-top-right-radius\":\"border-top-right-radius\",\"-o-border-bottom-left-radius\":\"border-bottom-left-radius\",\"-o-border-bottom-right-radius\":\"border-bottom-right-radius\",\"-moz-border-radius\":\"border-radius\",\"-moz-border-radius-topleft\":\"border-top-left-radius\",\"-moz-border-radius-topright\":\"border-top-right-radius\",\"-moz-border-radius-bottomleft\":\"border-bottom-left-radius\",\"-moz-border-radius-bottomright\":\"border-bottom-right-radius\",\"-moz-column-count\":\"column-count\",\"-webkit-column-count\":\"column-count\",\"-moz-column-gap\":\"column-gap\",\"-webkit-column-gap\":\"column-gap\",\"-moz-column-rule\":\"column-rule\",\"-webkit-column-rule\":\"column-rule\",\"-moz-column-rule-style\":\"column-rule-style\",\"-webkit-column-rule-style\":\"column-rule-style\",\"-moz-column-rule-color\":\"column-rule-color\",\"-webkit-column-rule-color\":\"column-rule-color\",\"-moz-column-rule-width\":\"column-rule-width\",\"-webkit-column-rule-width\":\"column-rule-width\",\"-moz-column-width\":\"column-width\",\"-webkit-column-width\":\"column-width\",\"-webkit-column-span\":\"column-span\",\"-webkit-columns\":\"columns\",\"-moz-box-shadow\":\"box-shadow\",\"-webkit-box-shadow\":\"box-shadow\",\"-moz-transform\":\"transform\",\"-webkit-transform\":\"transform\",\"-o-transform\":\"transform\",\"-ms-transform\":\"transform\",\"-moz-transform-origin\":\"transform-origin\",\"-webkit-transform-origin\":\"transform-origin\",\"-o-transform-origin\":\"transform-origin\",\"-ms-transform-origin\":\"transform-origin\",\"-moz-box-sizing\":\"box-sizing\",\"-webkit-box-sizing\":\"box-sizing\"};parser.addListener(\"startrule\",startRule),parser.addListener(\"startfontface\",startRule),parser.addListener(\"startpage\",startRule),parser.addListener(\"startpagemargin\",startRule),parser.addListener(\"startkeyframerule\",startRule),parser.addListener(\"property\",function(event){var name=event.property.text.toLowerCase();properties[name]||(properties[name]=[]),properties[name].push({name:event.property,value:event.value,pos:num++})}),parser.addListener(\"endrule\",endRule),parser.addListener(\"endfontface\",endRule),parser.addListener(\"endpage\",endRule),parser.addListener(\"endpagemargin\",endRule),parser.addListener(\"endkeyframerule\",endRule)}}),CSSLint.addRule({id:\"zero-units\",name:\"Disallow units for 0 values\",desc:\"You don't need to specify units when a value is 0.\",browsers:\"All\",init:function(parser,reporter){var rule=this;parser.addListener(\"property\",function(event){for(var parts=event.value.parts,i=0,len=parts.length;len>i;)!parts[i].units&&\"percentage\"!==parts[i].type||0!==parts[i].value||\"time\"===parts[i].type||reporter.report(\"Values of 0 shouldn't have units specified.\",parts[i].line,parts[i].col,rule),i++})}}),function(){var xmlEscape=function(str){return str&&str.constructor===String?str.replace(/[\\\"&><]/g,function(match){switch(match){case'\"':return\"&quot;\";case\"&\":return\"&amp;\";case\"<\":return\"&lt;\";case\">\":return\"&gt;\"}}):\"\"};CSSLint.addFormatter({id:\"checkstyle-xml\",name:\"Checkstyle XML format\",startFormat:function(){return'<?xml version=\"1.0\" encoding=\"utf-8\"?><checkstyle>'},endFormat:function(){return\"</checkstyle>\"},readError:function(filename,message){return'<file name=\"'+xmlEscape(filename)+'\"><error line=\"0\" column=\"0\" severty=\"error\" message=\"'+xmlEscape(message)+'\"></error></file>'},formatResults:function(results,filename){var messages=results.messages,output=[],generateSource=function(rule){return rule&&\"name\"in rule?\"net.csslint.\"+rule.name.replace(/\\s/g,\"\"):\"\"};return messages.length>0&&(output.push('<file name=\"'+filename+'\">'),CSSLint.Util.forEach(messages,function(message){message.rollup||output.push('<error line=\"'+message.line+'\" column=\"'+message.col+'\" severity=\"'+message.type+'\"'+' message=\"'+xmlEscape(message.message)+'\" source=\"'+generateSource(message.rule)+'\"/>')}),output.push(\"</file>\")),output.join(\"\")}})}(),CSSLint.addFormatter({id:\"compact\",name:\"Compact, 'porcelain' format\",startFormat:function(){return\"\"},endFormat:function(){return\"\"},formatResults:function(results,filename,options){var messages=results.messages,output=\"\";options=options||{};var capitalize=function(str){return str.charAt(0).toUpperCase()+str.slice(1)};return 0===messages.length?options.quiet?\"\":filename+\": Lint Free!\":(CSSLint.Util.forEach(messages,function(message){output+=message.rollup?filename+\": \"+capitalize(message.type)+\" - \"+message.message+\"\\n\":filename+\": \"+\"line \"+message.line+\", col \"+message.col+\", \"+capitalize(message.type)+\" - \"+message.message+\" (\"+message.rule.id+\")\\n\"}),output)}}),CSSLint.addFormatter({id:\"csslint-xml\",name:\"CSSLint XML format\",startFormat:function(){return'<?xml version=\"1.0\" encoding=\"utf-8\"?><csslint>'},endFormat:function(){return\"</csslint>\"},formatResults:function(results,filename){var messages=results.messages,output=[],escapeSpecialCharacters=function(str){return str&&str.constructor===String?str.replace(/\\\"/g,\"'\").replace(/&/g,\"&amp;\").replace(/</g,\"&lt;\").replace(/>/g,\"&gt;\"):\"\"};return messages.length>0&&(output.push('<file name=\"'+filename+'\">'),CSSLint.Util.forEach(messages,function(message){message.rollup?output.push('<issue severity=\"'+message.type+'\" reason=\"'+escapeSpecialCharacters(message.message)+'\" evidence=\"'+escapeSpecialCharacters(message.evidence)+'\"/>'):output.push('<issue line=\"'+message.line+'\" char=\"'+message.col+'\" severity=\"'+message.type+'\"'+' reason=\"'+escapeSpecialCharacters(message.message)+'\" evidence=\"'+escapeSpecialCharacters(message.evidence)+'\"/>')}),output.push(\"</file>\")),output.join(\"\")}}),CSSLint.addFormatter({id:\"junit-xml\",name:\"JUNIT XML format\",startFormat:function(){return'<?xml version=\"1.0\" encoding=\"utf-8\"?><testsuites>'},endFormat:function(){return\"</testsuites>\"},formatResults:function(results,filename){var messages=results.messages,output=[],tests={error:0,failure:0},generateSource=function(rule){return rule&&\"name\"in rule?\"net.csslint.\"+rule.name.replace(/\\s/g,\"\"):\"\"},escapeSpecialCharacters=function(str){return str&&str.constructor===String?str.replace(/\\\"/g,\"'\").replace(/</g,\"&lt;\").replace(/>/g,\"&gt;\"):\"\"};return messages.length>0&&(messages.forEach(function(message){var type=\"warning\"===message.type?\"error\":message.type;message.rollup||(output.push('<testcase time=\"0\" name=\"'+generateSource(message.rule)+'\">'),output.push(\"<\"+type+' message=\"'+escapeSpecialCharacters(message.message)+'\"><![CDATA['+message.line+\":\"+message.col+\":\"+escapeSpecialCharacters(message.evidence)+\"]]></\"+type+\">\"),output.push(\"</testcase>\"),tests[type]+=1)}),output.unshift('<testsuite time=\"0\" tests=\"'+messages.length+'\" skipped=\"0\" errors=\"'+tests.error+'\" failures=\"'+tests.failure+'\" package=\"net.csslint\" name=\"'+filename+'\">'),output.push(\"</testsuite>\")),output.join(\"\")}}),CSSLint.addFormatter({id:\"lint-xml\",name:\"Lint XML format\",startFormat:function(){return'<?xml version=\"1.0\" encoding=\"utf-8\"?><lint>'},endFormat:function(){return\"</lint>\"},formatResults:function(results,filename){var messages=results.messages,output=[],escapeSpecialCharacters=function(str){return str&&str.constructor===String?str.replace(/\\\"/g,\"'\").replace(/&/g,\"&amp;\").replace(/</g,\"&lt;\").replace(/>/g,\"&gt;\"):\"\"};return messages.length>0&&(output.push('<file name=\"'+filename+'\">'),CSSLint.Util.forEach(messages,function(message){message.rollup?output.push('<issue severity=\"'+message.type+'\" reason=\"'+escapeSpecialCharacters(message.message)+'\" evidence=\"'+escapeSpecialCharacters(message.evidence)+'\"/>'):output.push('<issue line=\"'+message.line+'\" char=\"'+message.col+'\" severity=\"'+message.type+'\"'+' reason=\"'+escapeSpecialCharacters(message.message)+'\" evidence=\"'+escapeSpecialCharacters(message.evidence)+'\"/>')}),output.push(\"</file>\")),output.join(\"\")}}),CSSLint.addFormatter({id:\"text\",name:\"Plain Text\",startFormat:function(){return\"\"},endFormat:function(){return\"\"},formatResults:function(results,filename,options){var messages=results.messages,output=\"\";if(options=options||{},0===messages.length)return options.quiet?\"\":\"\\n\\ncsslint: No errors in \"+filename+\".\";output=\"\\n\\ncsslint: There \",output+=1===messages.length?\"is 1 problem\":\"are \"+messages.length+\" problems\",output+=\" in \"+filename+\".\";var pos=filename.lastIndexOf(\"/\"),shortFilename=filename;return-1===pos&&(pos=filename.lastIndexOf(\"\\\\\")),pos>-1&&(shortFilename=filename.substring(pos+1)),CSSLint.Util.forEach(messages,function(message,i){output=output+\"\\n\\n\"+shortFilename,message.rollup?(output+=\"\\n\"+(i+1)+\": \"+message.type,output+=\"\\n\"+message.message):(output+=\"\\n\"+(i+1)+\": \"+message.type+\" at line \"+message.line+\", col \"+message.col,output+=\"\\n\"+message.message,output+=\"\\n\"+message.evidence)}),output}}),module.exports.CSSLint=CSSLint}),ace.define(\"ace/mode/css_worker\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/worker/mirror\",\"ace/mode/css/csslint\"],function(acequire,exports){\"use strict\";var oop=acequire(\"../lib/oop\"),lang=acequire(\"../lib/lang\"),Mirror=acequire(\"../worker/mirror\").Mirror,CSSLint=acequire(\"./css/csslint\").CSSLint,Worker=exports.Worker=function(sender){Mirror.call(this,sender),this.setTimeout(400),this.ruleset=null,this.setDisabledRules(\"ids|order-alphabetical\"),this.setInfoRules(\"adjoining-classes|qualified-headings|zero-units|gradients|import|outline-none|vendor-prefix\")};oop.inherits(Worker,Mirror),function(){this.setInfoRules=function(ruleNames){\"string\"==typeof ruleNames&&(ruleNames=ruleNames.split(\"|\")),this.infoRules=lang.arrayToMap(ruleNames),this.doc.getValue()&&this.deferredUpdate.schedule(100)},this.setDisabledRules=function(ruleNames){if(ruleNames){\"string\"==typeof ruleNames&&(ruleNames=ruleNames.split(\"|\"));var all={};CSSLint.getRules().forEach(function(x){all[x.id]=!0}),ruleNames.forEach(function(x){delete all[x]}),this.ruleset=all}else this.ruleset=null;this.doc.getValue()&&this.deferredUpdate.schedule(100)},this.onUpdate=function(){var value=this.doc.getValue();\nif(!value)return this.sender.emit(\"annotate\",[]);var infoRules=this.infoRules,result=CSSLint.verify(value,this.ruleset);this.sender.emit(\"annotate\",result.messages.map(function(msg){return{row:msg.line-1,column:msg.col-1,text:msg.message,type:infoRules[msg.rule.id]?\"info\":msg.type,rule:msg.rule.name}}))}}.call(Worker.prototype)}),ace.define(\"ace/lib/es5-shim\",[\"require\",\"exports\",\"module\"],function(){function Empty(){}function doesDefinePropertyWork(object){try{return Object.defineProperty(object,\"sentinel\",{}),\"sentinel\"in object}catch(exception){}}function toInteger(n){return n=+n,n!==n?n=0:0!==n&&n!==1/0&&n!==-(1/0)&&(n=(n>0||-1)*Math.floor(Math.abs(n))),n}Function.prototype.bind||(Function.prototype.bind=function(that){var target=this;if(\"function\"!=typeof target)throw new TypeError(\"Function.prototype.bind called on incompatible \"+target);var args=slice.call(arguments,1),bound=function(){if(this instanceof bound){var result=target.apply(this,args.concat(slice.call(arguments)));return Object(result)===result?result:this}return target.apply(that,args.concat(slice.call(arguments)))};return target.prototype&&(Empty.prototype=target.prototype,bound.prototype=new Empty,Empty.prototype=null),bound});var defineGetter,defineSetter,lookupGetter,lookupSetter,supportsAccessors,call=Function.prototype.call,prototypeOfArray=Array.prototype,prototypeOfObject=Object.prototype,slice=prototypeOfArray.slice,_toString=call.bind(prototypeOfObject.toString),owns=call.bind(prototypeOfObject.hasOwnProperty);if((supportsAccessors=owns(prototypeOfObject,\"__defineGetter__\"))&&(defineGetter=call.bind(prototypeOfObject.__defineGetter__),defineSetter=call.bind(prototypeOfObject.__defineSetter__),lookupGetter=call.bind(prototypeOfObject.__lookupGetter__),lookupSetter=call.bind(prototypeOfObject.__lookupSetter__)),2!=[1,2].splice(0).length)if(function(){function makeArray(l){var a=Array(l+2);return a[0]=a[1]=0,a}var lengthBefore,array=[];return array.splice.apply(array,makeArray(20)),array.splice.apply(array,makeArray(26)),lengthBefore=array.length,array.splice(5,0,\"XXX\"),lengthBefore+1==array.length,lengthBefore+1==array.length?!0:void 0}()){var array_splice=Array.prototype.splice;Array.prototype.splice=function(start,deleteCount){return arguments.length?array_splice.apply(this,[void 0===start?0:start,void 0===deleteCount?this.length-start:deleteCount].concat(slice.call(arguments,2))):[]}}else Array.prototype.splice=function(pos,removeCount){var length=this.length;pos>0?pos>length&&(pos=length):void 0==pos?pos=0:0>pos&&(pos=Math.max(length+pos,0)),length>pos+removeCount||(removeCount=length-pos);var removed=this.slice(pos,pos+removeCount),insert=slice.call(arguments,2),add=insert.length;if(pos===length)add&&this.push.apply(this,insert);else{var remove=Math.min(removeCount,length-pos),tailOldPos=pos+remove,tailNewPos=tailOldPos+add-remove,tailCount=length-tailOldPos,lengthAfterRemove=length-remove;if(tailOldPos>tailNewPos)for(var i=0;tailCount>i;++i)this[tailNewPos+i]=this[tailOldPos+i];else if(tailNewPos>tailOldPos)for(i=tailCount;i--;)this[tailNewPos+i]=this[tailOldPos+i];if(add&&pos===lengthAfterRemove)this.length=lengthAfterRemove,this.push.apply(this,insert);else for(this.length=lengthAfterRemove+add,i=0;add>i;++i)this[pos+i]=insert[i]}return removed};Array.isArray||(Array.isArray=function(obj){return\"[object Array]\"==_toString(obj)});var boxedString=Object(\"a\"),splitString=\"a\"!=boxedString[0]||!(0 in boxedString);if(Array.prototype.forEach||(Array.prototype.forEach=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,thisp=arguments[1],i=-1,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError;for(;length>++i;)i in self&&fun.call(thisp,self[i],i,object)}),Array.prototype.map||(Array.prototype.map=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,result=Array(length),thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)i in self&&(result[i]=fun.call(thisp,self[i],i,object));return result}),Array.prototype.filter||(Array.prototype.filter=function(fun){var value,object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,result=[],thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)i in self&&(value=self[i],fun.call(thisp,value,i,object)&&result.push(value));return result}),Array.prototype.every||(Array.prototype.every=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)if(i in self&&!fun.call(thisp,self[i],i,object))return!1;return!0}),Array.prototype.some||(Array.prototype.some=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)if(i in self&&fun.call(thisp,self[i],i,object))return!0;return!1}),Array.prototype.reduce||(Array.prototype.reduce=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");if(!length&&1==arguments.length)throw new TypeError(\"reduce of empty array with no initial value\");var result,i=0;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i++];break}if(++i>=length)throw new TypeError(\"reduce of empty array with no initial value\")}for(;length>i;i++)i in self&&(result=fun.call(void 0,result,self[i],i,object));return result}),Array.prototype.reduceRight||(Array.prototype.reduceRight=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");if(!length&&1==arguments.length)throw new TypeError(\"reduceRight of empty array with no initial value\");var result,i=length-1;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i--];break}if(0>--i)throw new TypeError(\"reduceRight of empty array with no initial value\")}do i in this&&(result=fun.call(void 0,result,self[i],i,object));while(i--);return result}),Array.prototype.indexOf&&-1==[0,1].indexOf(1,2)||(Array.prototype.indexOf=function(sought){var self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):toObject(this),length=self.length>>>0;if(!length)return-1;var i=0;for(arguments.length>1&&(i=toInteger(arguments[1])),i=i>=0?i:Math.max(0,length+i);length>i;i++)if(i in self&&self[i]===sought)return i;return-1}),Array.prototype.lastIndexOf&&-1==[0,1].lastIndexOf(0,-3)||(Array.prototype.lastIndexOf=function(sought){var self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):toObject(this),length=self.length>>>0;if(!length)return-1;var i=length-1;for(arguments.length>1&&(i=Math.min(i,toInteger(arguments[1]))),i=i>=0?i:length-Math.abs(i);i>=0;i--)if(i in self&&sought===self[i])return i;return-1}),Object.getPrototypeOf||(Object.getPrototypeOf=function(object){return object.__proto__||(object.constructor?object.constructor.prototype:prototypeOfObject)}),!Object.getOwnPropertyDescriptor){var ERR_NON_OBJECT=\"Object.getOwnPropertyDescriptor called on a non-object: \";Object.getOwnPropertyDescriptor=function(object,property){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT+object);if(owns(object,property)){var descriptor,getter,setter;if(descriptor={enumerable:!0,configurable:!0},supportsAccessors){var prototype=object.__proto__;object.__proto__=prototypeOfObject;var getter=lookupGetter(object,property),setter=lookupSetter(object,property);if(object.__proto__=prototype,getter||setter)return getter&&(descriptor.get=getter),setter&&(descriptor.set=setter),descriptor}return descriptor.value=object[property],descriptor}}}if(Object.getOwnPropertyNames||(Object.getOwnPropertyNames=function(object){return Object.keys(object)}),!Object.create){var createEmpty;createEmpty=null===Object.prototype.__proto__?function(){return{__proto__:null}}:function(){var empty={};for(var i in empty)empty[i]=null;return empty.constructor=empty.hasOwnProperty=empty.propertyIsEnumerable=empty.isPrototypeOf=empty.toLocaleString=empty.toString=empty.valueOf=empty.__proto__=null,empty},Object.create=function(prototype,properties){var object;if(null===prototype)object=createEmpty();else{if(\"object\"!=typeof prototype)throw new TypeError(\"typeof prototype[\"+typeof prototype+\"] != 'object'\");var Type=function(){};Type.prototype=prototype,object=new Type,object.__proto__=prototype}return void 0!==properties&&Object.defineProperties(object,properties),object}}if(Object.defineProperty){var definePropertyWorksOnObject=doesDefinePropertyWork({}),definePropertyWorksOnDom=\"undefined\"==typeof document||doesDefinePropertyWork(document.createElement(\"div\"));if(!definePropertyWorksOnObject||!definePropertyWorksOnDom)var definePropertyFallback=Object.defineProperty}if(!Object.defineProperty||definePropertyFallback){var ERR_NON_OBJECT_DESCRIPTOR=\"Property description must be an object: \",ERR_NON_OBJECT_TARGET=\"Object.defineProperty called on non-object: \",ERR_ACCESSORS_NOT_SUPPORTED=\"getters & setters can not be defined on this javascript engine\";Object.defineProperty=function(object,property,descriptor){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT_TARGET+object);if(\"object\"!=typeof descriptor&&\"function\"!=typeof descriptor||null===descriptor)throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR+descriptor);if(definePropertyFallback)try{return definePropertyFallback.call(Object,object,property,descriptor)}catch(exception){}if(owns(descriptor,\"value\"))if(supportsAccessors&&(lookupGetter(object,property)||lookupSetter(object,property))){var prototype=object.__proto__;object.__proto__=prototypeOfObject,delete object[property],object[property]=descriptor.value,object.__proto__=prototype}else object[property]=descriptor.value;else{if(!supportsAccessors)throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);owns(descriptor,\"get\")&&defineGetter(object,property,descriptor.get),owns(descriptor,\"set\")&&defineSetter(object,property,descriptor.set)}return object}}Object.defineProperties||(Object.defineProperties=function(object,properties){for(var property in properties)owns(properties,property)&&Object.defineProperty(object,property,properties[property]);return object}),Object.seal||(Object.seal=function(object){return object}),Object.freeze||(Object.freeze=function(object){return object});try{Object.freeze(function(){})}catch(exception){Object.freeze=function(freezeObject){return function(object){return\"function\"==typeof object?object:freezeObject(object)}}(Object.freeze)}if(Object.preventExtensions||(Object.preventExtensions=function(object){return object}),Object.isSealed||(Object.isSealed=function(){return!1}),Object.isFrozen||(Object.isFrozen=function(){return!1}),Object.isExtensible||(Object.isExtensible=function(object){if(Object(object)===object)throw new TypeError;for(var name=\"\";owns(object,name);)name+=\"?\";object[name]=!0;var returnValue=owns(object,name);return delete object[name],returnValue}),!Object.keys){var hasDontEnumBug=!0,dontEnums=[\"toString\",\"toLocaleString\",\"valueOf\",\"hasOwnProperty\",\"isPrototypeOf\",\"propertyIsEnumerable\",\"constructor\"],dontEnumsLength=dontEnums.length;for(var key in{toString:null})hasDontEnumBug=!1;Object.keys=function(object){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(\"Object.keys called on a non-object\");var keys=[];for(var name in object)owns(object,name)&&keys.push(name);if(hasDontEnumBug)for(var i=0,ii=dontEnumsLength;ii>i;i++){var dontEnum=dontEnums[i];owns(object,dontEnum)&&keys.push(dontEnum)}return keys}}Date.now||(Date.now=function(){return(new Date).getTime()});var ws=\"\t\\n\u000b\\f\\r   ᠎             　\\u2028\\u2029﻿\";if(!String.prototype.trim||ws.trim()){ws=\"[\"+ws+\"]\";var trimBeginRegexp=RegExp(\"^\"+ws+ws+\"*\"),trimEndRegexp=RegExp(ws+ws+\"*$\");String.prototype.trim=function(){return(this+\"\").replace(trimBeginRegexp,\"\").replace(trimEndRegexp,\"\")}}var toObject=function(o){if(null==o)throw new TypeError(\"can't convert \"+o+\" to object\");return Object(o)}});";

/***/ },
/* 102 */
/***/ function(module, exports) {

	module.exports.id = 'ace/mode/html_worker';
	module.exports.src = "\"no use strict\";(function(window){function resolveModuleId(id,paths){for(var testPath=id,tail=\"\";testPath;){var alias=paths[testPath];if(\"string\"==typeof alias)return alias+tail;if(alias)return alias.location.replace(/\\/*$/,\"/\")+(tail||alias.main||alias.name);if(alias===!1)return\"\";var i=testPath.lastIndexOf(\"/\");if(-1===i)break;tail=testPath.substr(i)+tail,testPath=testPath.slice(0,i)}return id}if(!(void 0!==window.window&&window.document||window.acequire&&window.define)){window.console||(window.console=function(){var msgs=Array.prototype.slice.call(arguments,0);postMessage({type:\"log\",data:msgs})},window.console.error=window.console.warn=window.console.log=window.console.trace=window.console),window.window=window,window.ace=window,window.onerror=function(message,file,line,col,err){postMessage({type:\"error\",data:{message:message,data:err.data,file:file,line:line,col:col,stack:err.stack}})},window.normalizeModule=function(parentId,moduleName){if(-1!==moduleName.indexOf(\"!\")){var chunks=moduleName.split(\"!\");return window.normalizeModule(parentId,chunks[0])+\"!\"+window.normalizeModule(parentId,chunks[1])}if(\".\"==moduleName.charAt(0)){var base=parentId.split(\"/\").slice(0,-1).join(\"/\");for(moduleName=(base?base+\"/\":\"\")+moduleName;-1!==moduleName.indexOf(\".\")&&previous!=moduleName;){var previous=moduleName;moduleName=moduleName.replace(/^\\.\\//,\"\").replace(/\\/\\.\\//,\"/\").replace(/[^\\/]+\\/\\.\\.\\//,\"\")}}return moduleName},window.acequire=function acequire(parentId,id){if(id||(id=parentId,parentId=null),!id.charAt)throw Error(\"worker.js acequire() accepts only (parentId, id) as arguments\");id=window.normalizeModule(parentId,id);var module=window.acequire.modules[id];if(module)return module.initialized||(module.initialized=!0,module.exports=module.factory().exports),module.exports;if(!window.acequire.tlns)return console.log(\"unable to load \"+id);var path=resolveModuleId(id,window.acequire.tlns);return\".js\"!=path.slice(-3)&&(path+=\".js\"),window.acequire.id=id,window.acequire.modules[id]={},importScripts(path),window.acequire(parentId,id)},window.acequire.modules={},window.acequire.tlns={},window.define=function(id,deps,factory){if(2==arguments.length?(factory=deps,\"string\"!=typeof id&&(deps=id,id=window.acequire.id)):1==arguments.length&&(factory=id,deps=[],id=window.acequire.id),\"function\"!=typeof factory)return window.acequire.modules[id]={exports:factory,initialized:!0},void 0;deps.length||(deps=[\"require\",\"exports\",\"module\"]);var req=function(childId){return window.acequire(id,childId)};window.acequire.modules[id]={exports:{},factory:function(){var module=this,returnExports=factory.apply(this,deps.map(function(dep){switch(dep){case\"require\":return req;case\"exports\":return module.exports;case\"module\":return module;default:return req(dep)}}));return returnExports&&(module.exports=returnExports),module}}},window.define.amd={},acequire.tlns={},window.initBaseUrls=function(topLevelNamespaces){for(var i in topLevelNamespaces)acequire.tlns[i]=topLevelNamespaces[i]},window.initSender=function(){var EventEmitter=window.acequire(\"ace/lib/event_emitter\").EventEmitter,oop=window.acequire(\"ace/lib/oop\"),Sender=function(){};return function(){oop.implement(this,EventEmitter),this.callback=function(data,callbackId){postMessage({type:\"call\",id:callbackId,data:data})},this.emit=function(name,data){postMessage({type:\"event\",name:name,data:data})}}.call(Sender.prototype),new Sender};var main=window.main=null,sender=window.sender=null;window.onmessage=function(e){var msg=e.data;if(msg.event&&sender)sender._signal(msg.event,msg.data);else if(msg.command)if(main[msg.command])main[msg.command].apply(main,msg.args);else{if(!window[msg.command])throw Error(\"Unknown command:\"+msg.command);window[msg.command].apply(window,msg.args)}else if(msg.init){window.initBaseUrls(msg.tlns),acequire(\"ace/lib/es5-shim\"),sender=window.sender=window.initSender();var clazz=acequire(msg.module)[msg.classname];main=window.main=new clazz(sender)}}}})(this),ace.define(\"ace/lib/oop\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";exports.inherits=function(ctor,superCtor){ctor.super_=superCtor,ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:!1,writable:!0,configurable:!0}})},exports.mixin=function(obj,mixin){for(var key in mixin)obj[key]=mixin[key];return obj},exports.implement=function(proto,mixin){exports.mixin(proto,mixin)}}),ace.define(\"ace/lib/lang\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";exports.last=function(a){return a[a.length-1]},exports.stringReverse=function(string){return string.split(\"\").reverse().join(\"\")},exports.stringRepeat=function(string,count){for(var result=\"\";count>0;)1&count&&(result+=string),(count>>=1)&&(string+=string);return result};var trimBeginRegexp=/^\\s\\s*/,trimEndRegexp=/\\s\\s*$/;exports.stringTrimLeft=function(string){return string.replace(trimBeginRegexp,\"\")},exports.stringTrimRight=function(string){return string.replace(trimEndRegexp,\"\")},exports.copyObject=function(obj){var copy={};for(var key in obj)copy[key]=obj[key];return copy},exports.copyArray=function(array){for(var copy=[],i=0,l=array.length;l>i;i++)copy[i]=array[i]&&\"object\"==typeof array[i]?this.copyObject(array[i]):array[i];return copy},exports.deepCopy=function deepCopy(obj){if(\"object\"!=typeof obj||!obj)return obj;var copy;if(Array.isArray(obj)){copy=[];for(var key=0;obj.length>key;key++)copy[key]=deepCopy(obj[key]);return copy}var cons=obj.constructor;if(cons===RegExp)return obj;copy=cons();for(var key in obj)copy[key]=deepCopy(obj[key]);return copy},exports.arrayToMap=function(arr){for(var map={},i=0;arr.length>i;i++)map[arr[i]]=1;return map},exports.createMap=function(props){var map=Object.create(null);for(var i in props)map[i]=props[i];return map},exports.arrayRemove=function(array,value){for(var i=0;array.length>=i;i++)value===array[i]&&array.splice(i,1)},exports.escapeRegExp=function(str){return str.replace(/([.*+?^${}()|[\\]\\/\\\\])/g,\"\\\\$1\")},exports.escapeHTML=function(str){return str.replace(/&/g,\"&#38;\").replace(/\"/g,\"&#34;\").replace(/'/g,\"&#39;\").replace(/</g,\"&#60;\")},exports.getMatchOffsets=function(string,regExp){var matches=[];return string.replace(regExp,function(str){matches.push({offset:arguments[arguments.length-2],length:str.length})}),matches},exports.deferredCall=function(fcn){var timer=null,callback=function(){timer=null,fcn()},deferred=function(timeout){return deferred.cancel(),timer=setTimeout(callback,timeout||0),deferred};return deferred.schedule=deferred,deferred.call=function(){return this.cancel(),fcn(),deferred},deferred.cancel=function(){return clearTimeout(timer),timer=null,deferred},deferred.isPending=function(){return timer},deferred},exports.delayedCall=function(fcn,defaultTimeout){var timer=null,callback=function(){timer=null,fcn()},_self=function(timeout){null==timer&&(timer=setTimeout(callback,timeout||defaultTimeout))};return _self.delay=function(timeout){timer&&clearTimeout(timer),timer=setTimeout(callback,timeout||defaultTimeout)},_self.schedule=_self,_self.call=function(){this.cancel(),fcn()},_self.cancel=function(){timer&&clearTimeout(timer),timer=null},_self.isPending=function(){return timer},_self}}),ace.define(\"ace/range\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";var comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},Range=function(startRow,startColumn,endRow,endColumn){this.start={row:startRow,column:startColumn},this.end={row:endRow,column:endColumn}};(function(){this.isEqual=function(range){return this.start.row===range.start.row&&this.end.row===range.end.row&&this.start.column===range.start.column&&this.end.column===range.end.column},this.toString=function(){return\"Range: [\"+this.start.row+\"/\"+this.start.column+\"] -> [\"+this.end.row+\"/\"+this.end.column+\"]\"},this.contains=function(row,column){return 0==this.compare(row,column)},this.compareRange=function(range){var cmp,end=range.end,start=range.start;return cmp=this.compare(end.row,end.column),1==cmp?(cmp=this.compare(start.row,start.column),1==cmp?2:0==cmp?1:0):-1==cmp?-2:(cmp=this.compare(start.row,start.column),-1==cmp?-1:1==cmp?42:0)},this.comparePoint=function(p){return this.compare(p.row,p.column)},this.containsRange=function(range){return 0==this.comparePoint(range.start)&&0==this.comparePoint(range.end)},this.intersects=function(range){var cmp=this.compareRange(range);return-1==cmp||0==cmp||1==cmp},this.isEnd=function(row,column){return this.end.row==row&&this.end.column==column},this.isStart=function(row,column){return this.start.row==row&&this.start.column==column},this.setStart=function(row,column){\"object\"==typeof row?(this.start.column=row.column,this.start.row=row.row):(this.start.row=row,this.start.column=column)},this.setEnd=function(row,column){\"object\"==typeof row?(this.end.column=row.column,this.end.row=row.row):(this.end.row=row,this.end.column=column)},this.inside=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)||this.isStart(row,column)?!1:!0:!1},this.insideStart=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)?!1:!0:!1},this.insideEnd=function(row,column){return 0==this.compare(row,column)?this.isStart(row,column)?!1:!0:!1},this.compare=function(row,column){return this.isMultiLine()||row!==this.start.row?this.start.row>row?-1:row>this.end.row?1:this.start.row===row?column>=this.start.column?0:-1:this.end.row===row?this.end.column>=column?0:1:0:this.start.column>column?-1:column>this.end.column?1:0},this.compareStart=function(row,column){return this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.compareEnd=function(row,column){return this.end.row==row&&this.end.column==column?1:this.compare(row,column)},this.compareInside=function(row,column){return this.end.row==row&&this.end.column==column?1:this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.clipRows=function(firstRow,lastRow){if(this.end.row>lastRow)var end={row:lastRow+1,column:0};else if(firstRow>this.end.row)var end={row:firstRow,column:0};if(this.start.row>lastRow)var start={row:lastRow+1,column:0};else if(firstRow>this.start.row)var start={row:firstRow,column:0};return Range.fromPoints(start||this.start,end||this.end)},this.extend=function(row,column){var cmp=this.compare(row,column);if(0==cmp)return this;if(-1==cmp)var start={row:row,column:column};else var end={row:row,column:column};return Range.fromPoints(start||this.start,end||this.end)},this.isEmpty=function(){return this.start.row===this.end.row&&this.start.column===this.end.column},this.isMultiLine=function(){return this.start.row!==this.end.row},this.clone=function(){return Range.fromPoints(this.start,this.end)},this.collapseRows=function(){return 0==this.end.column?new Range(this.start.row,0,Math.max(this.start.row,this.end.row-1),0):new Range(this.start.row,0,this.end.row,0)},this.toScreenRange=function(session){var screenPosStart=session.documentToScreenPosition(this.start),screenPosEnd=session.documentToScreenPosition(this.end);return new Range(screenPosStart.row,screenPosStart.column,screenPosEnd.row,screenPosEnd.column)},this.moveBy=function(row,column){this.start.row+=row,this.start.column+=column,this.end.row+=row,this.end.column+=column}}).call(Range.prototype),Range.fromPoints=function(start,end){return new Range(start.row,start.column,end.row,end.column)},Range.comparePoints=comparePoints,Range.comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},exports.Range=Range}),ace.define(\"ace/apply_delta\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";exports.applyDelta=function(docLines,delta){var row=delta.start.row,startColumn=delta.start.column,line=docLines[row]||\"\";switch(delta.action){case\"insert\":var lines=delta.lines;if(1===lines.length)docLines[row]=line.substring(0,startColumn)+delta.lines[0]+line.substring(startColumn);else{var args=[row,1].concat(delta.lines);docLines.splice.apply(docLines,args),docLines[row]=line.substring(0,startColumn)+docLines[row],docLines[row+delta.lines.length-1]+=line.substring(startColumn)}break;case\"remove\":var endColumn=delta.end.column,endRow=delta.end.row;row===endRow?docLines[row]=line.substring(0,startColumn)+line.substring(endColumn):docLines.splice(row,endRow-row+1,line.substring(0,startColumn)+docLines[endRow].substring(endColumn))}}}),ace.define(\"ace/lib/event_emitter\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";var EventEmitter={},stopPropagation=function(){this.propagationStopped=!0},preventDefault=function(){this.defaultPrevented=!0};EventEmitter._emit=EventEmitter._dispatchEvent=function(eventName,e){this._eventRegistry||(this._eventRegistry={}),this._defaultHandlers||(this._defaultHandlers={});var listeners=this._eventRegistry[eventName]||[],defaultHandler=this._defaultHandlers[eventName];if(listeners.length||defaultHandler){\"object\"==typeof e&&e||(e={}),e.type||(e.type=eventName),e.stopPropagation||(e.stopPropagation=stopPropagation),e.preventDefault||(e.preventDefault=preventDefault),listeners=listeners.slice();for(var i=0;listeners.length>i&&(listeners[i](e,this),!e.propagationStopped);i++);return defaultHandler&&!e.defaultPrevented?defaultHandler(e,this):void 0}},EventEmitter._signal=function(eventName,e){var listeners=(this._eventRegistry||{})[eventName];if(listeners){listeners=listeners.slice();for(var i=0;listeners.length>i;i++)listeners[i](e,this)}},EventEmitter.once=function(eventName,callback){var _self=this;callback&&this.addEventListener(eventName,function newCallback(){_self.removeEventListener(eventName,newCallback),callback.apply(null,arguments)})},EventEmitter.setDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers||(handlers=this._defaultHandlers={_disabled_:{}}),handlers[eventName]){var old=handlers[eventName],disabled=handlers._disabled_[eventName];disabled||(handlers._disabled_[eventName]=disabled=[]),disabled.push(old);var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}handlers[eventName]=callback},EventEmitter.removeDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers){var disabled=handlers._disabled_[eventName];if(handlers[eventName]==callback)handlers[eventName],disabled&&this.setDefaultHandler(eventName,disabled.pop());else if(disabled){var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}}},EventEmitter.on=EventEmitter.addEventListener=function(eventName,callback,capturing){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];return listeners||(listeners=this._eventRegistry[eventName]=[]),-1==listeners.indexOf(callback)&&listeners[capturing?\"unshift\":\"push\"](callback),callback},EventEmitter.off=EventEmitter.removeListener=EventEmitter.removeEventListener=function(eventName,callback){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];if(listeners){var index=listeners.indexOf(callback);-1!==index&&listeners.splice(index,1)}},EventEmitter.removeAllListeners=function(eventName){this._eventRegistry&&(this._eventRegistry[eventName]=[])},exports.EventEmitter=EventEmitter}),ace.define(\"ace/anchor\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\"],function(acequire,exports){\"use strict\";var oop=acequire(\"./lib/oop\"),EventEmitter=acequire(\"./lib/event_emitter\").EventEmitter,Anchor=exports.Anchor=function(doc,row,column){this.$onChange=this.onChange.bind(this),this.attach(doc),column===void 0?this.setPosition(row.row,row.column):this.setPosition(row,column)};(function(){function $pointsInOrder(point1,point2,equalPointsInOrder){var bColIsAfter=equalPointsInOrder?point1.column<=point2.column:point1.column<point2.column;return point1.row<point2.row||point1.row==point2.row&&bColIsAfter}function $getTransformedPoint(delta,point,moveIfEqual){var deltaIsInsert=\"insert\"==delta.action,deltaRowShift=(deltaIsInsert?1:-1)*(delta.end.row-delta.start.row),deltaColShift=(deltaIsInsert?1:-1)*(delta.end.column-delta.start.column),deltaStart=delta.start,deltaEnd=deltaIsInsert?deltaStart:delta.end;return $pointsInOrder(point,deltaStart,moveIfEqual)?{row:point.row,column:point.column}:$pointsInOrder(deltaEnd,point,!moveIfEqual)?{row:point.row+deltaRowShift,column:point.column+(point.row==deltaEnd.row?deltaColShift:0)}:{row:deltaStart.row,column:deltaStart.column}}oop.implement(this,EventEmitter),this.getPosition=function(){return this.$clipPositionToDocument(this.row,this.column)},this.getDocument=function(){return this.document},this.$insertRight=!1,this.onChange=function(delta){if(!(delta.start.row==delta.end.row&&delta.start.row!=this.row||delta.start.row>this.row)){var point=$getTransformedPoint(delta,{row:this.row,column:this.column},this.$insertRight);this.setPosition(point.row,point.column,!0)}},this.setPosition=function(row,column,noClip){var pos;if(pos=noClip?{row:row,column:column}:this.$clipPositionToDocument(row,column),this.row!=pos.row||this.column!=pos.column){var old={row:this.row,column:this.column};this.row=pos.row,this.column=pos.column,this._signal(\"change\",{old:old,value:pos})}},this.detach=function(){this.document.removeEventListener(\"change\",this.$onChange)},this.attach=function(doc){this.document=doc||this.document,this.document.on(\"change\",this.$onChange)},this.$clipPositionToDocument=function(row,column){var pos={};return row>=this.document.getLength()?(pos.row=Math.max(0,this.document.getLength()-1),pos.column=this.document.getLine(pos.row).length):0>row?(pos.row=0,pos.column=0):(pos.row=row,pos.column=Math.min(this.document.getLine(pos.row).length,Math.max(0,column))),0>column&&(pos.column=0),pos}}).call(Anchor.prototype)}),ace.define(\"ace/document\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/apply_delta\",\"ace/lib/event_emitter\",\"ace/range\",\"ace/anchor\"],function(acequire,exports){\"use strict\";var oop=acequire(\"./lib/oop\"),applyDelta=acequire(\"./apply_delta\").applyDelta,EventEmitter=acequire(\"./lib/event_emitter\").EventEmitter,Range=acequire(\"./range\").Range,Anchor=acequire(\"./anchor\").Anchor,Document=function(textOrLines){this.$lines=[\"\"],0===textOrLines.length?this.$lines=[\"\"]:Array.isArray(textOrLines)?this.insertMergedLines({row:0,column:0},textOrLines):this.insert({row:0,column:0},textOrLines)};(function(){oop.implement(this,EventEmitter),this.setValue=function(text){var len=this.getLength()-1;this.remove(new Range(0,0,len,this.getLine(len).length)),this.insert({row:0,column:0},text)},this.getValue=function(){return this.getAllLines().join(this.getNewLineCharacter())},this.createAnchor=function(row,column){return new Anchor(this,row,column)},this.$split=0===\"aaa\".split(/a/).length?function(text){return text.replace(/\\r\\n|\\r/g,\"\\n\").split(\"\\n\")}:function(text){return text.split(/\\r\\n|\\r|\\n/)},this.$detectNewLine=function(text){var match=text.match(/^.*?(\\r\\n|\\r|\\n)/m);this.$autoNewLine=match?match[1]:\"\\n\",this._signal(\"changeNewLineMode\")},this.getNewLineCharacter=function(){switch(this.$newLineMode){case\"windows\":return\"\\r\\n\";case\"unix\":return\"\\n\";default:return this.$autoNewLine||\"\\n\"}},this.$autoNewLine=\"\",this.$newLineMode=\"auto\",this.setNewLineMode=function(newLineMode){this.$newLineMode!==newLineMode&&(this.$newLineMode=newLineMode,this._signal(\"changeNewLineMode\"))},this.getNewLineMode=function(){return this.$newLineMode},this.isNewLine=function(text){return\"\\r\\n\"==text||\"\\r\"==text||\"\\n\"==text},this.getLine=function(row){return this.$lines[row]||\"\"},this.getLines=function(firstRow,lastRow){return this.$lines.slice(firstRow,lastRow+1)},this.getAllLines=function(){return this.getLines(0,this.getLength())},this.getLength=function(){return this.$lines.length},this.getTextRange=function(range){return this.getLinesForRange(range).join(this.getNewLineCharacter())},this.getLinesForRange=function(range){var lines;if(range.start.row===range.end.row)lines=[this.getLine(range.start.row).substring(range.start.column,range.end.column)];else{lines=this.getLines(range.start.row,range.end.row),lines[0]=(lines[0]||\"\").substring(range.start.column);var l=lines.length-1;range.end.row-range.start.row==l&&(lines[l]=lines[l].substring(0,range.end.column))}return lines},this.insertLines=function(row,lines){return console.warn(\"Use of document.insertLines is deprecated. Use the insertFullLines method instead.\"),this.insertFullLines(row,lines)},this.removeLines=function(firstRow,lastRow){return console.warn(\"Use of document.removeLines is deprecated. Use the removeFullLines method instead.\"),this.removeFullLines(firstRow,lastRow)},this.insertNewLine=function(position){return console.warn(\"Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.\"),this.insertMergedLines(position,[\"\",\"\"])},this.insert=function(position,text){return 1>=this.getLength()&&this.$detectNewLine(text),this.insertMergedLines(position,this.$split(text))},this.insertInLine=function(position,text){var start=this.clippedPos(position.row,position.column),end=this.pos(position.row,position.column+text.length);return this.applyDelta({start:start,end:end,action:\"insert\",lines:[text]},!0),this.clonePos(end)},this.clippedPos=function(row,column){var length=this.getLength();void 0===row?row=length:0>row?row=0:row>=length&&(row=length-1,column=void 0);var line=this.getLine(row);return void 0==column&&(column=line.length),column=Math.min(Math.max(column,0),line.length),{row:row,column:column}},this.clonePos=function(pos){return{row:pos.row,column:pos.column}},this.pos=function(row,column){return{row:row,column:column}},this.$clipPosition=function(position){var length=this.getLength();return position.row>=length?(position.row=Math.max(0,length-1),position.column=this.getLine(length-1).length):(position.row=Math.max(0,position.row),position.column=Math.min(Math.max(position.column,0),this.getLine(position.row).length)),position},this.insertFullLines=function(row,lines){row=Math.min(Math.max(row,0),this.getLength());var column=0;this.getLength()>row?(lines=lines.concat([\"\"]),column=0):(lines=[\"\"].concat(lines),row--,column=this.$lines[row].length),this.insertMergedLines({row:row,column:column},lines)},this.insertMergedLines=function(position,lines){var start=this.clippedPos(position.row,position.column),end={row:start.row+lines.length-1,column:(1==lines.length?start.column:0)+lines[lines.length-1].length};return this.applyDelta({start:start,end:end,action:\"insert\",lines:lines}),this.clonePos(end)},this.remove=function(range){var start=this.clippedPos(range.start.row,range.start.column),end=this.clippedPos(range.end.row,range.end.column);return this.applyDelta({start:start,end:end,action:\"remove\",lines:this.getLinesForRange({start:start,end:end})}),this.clonePos(start)},this.removeInLine=function(row,startColumn,endColumn){var start=this.clippedPos(row,startColumn),end=this.clippedPos(row,endColumn);return this.applyDelta({start:start,end:end,action:\"remove\",lines:this.getLinesForRange({start:start,end:end})},!0),this.clonePos(start)},this.removeFullLines=function(firstRow,lastRow){firstRow=Math.min(Math.max(0,firstRow),this.getLength()-1),lastRow=Math.min(Math.max(0,lastRow),this.getLength()-1);var deleteFirstNewLine=lastRow==this.getLength()-1&&firstRow>0,deleteLastNewLine=this.getLength()-1>lastRow,startRow=deleteFirstNewLine?firstRow-1:firstRow,startCol=deleteFirstNewLine?this.getLine(startRow).length:0,endRow=deleteLastNewLine?lastRow+1:lastRow,endCol=deleteLastNewLine?0:this.getLine(endRow).length,range=new Range(startRow,startCol,endRow,endCol),deletedLines=this.$lines.slice(firstRow,lastRow+1);return this.applyDelta({start:range.start,end:range.end,action:\"remove\",lines:this.getLinesForRange(range)}),deletedLines},this.removeNewLine=function(row){this.getLength()-1>row&&row>=0&&this.applyDelta({start:this.pos(row,this.getLine(row).length),end:this.pos(row+1,0),action:\"remove\",lines:[\"\",\"\"]})},this.replace=function(range,text){if(range instanceof Range||(range=Range.fromPoints(range.start,range.end)),0===text.length&&range.isEmpty())return range.start;if(text==this.getTextRange(range))return range.end;this.remove(range);var end;return end=text?this.insert(range.start,text):range.start},this.applyDeltas=function(deltas){for(var i=0;deltas.length>i;i++)this.applyDelta(deltas[i])},this.revertDeltas=function(deltas){for(var i=deltas.length-1;i>=0;i--)this.revertDelta(deltas[i])},this.applyDelta=function(delta,doNotValidate){var isInsert=\"insert\"==delta.action;(isInsert?1>=delta.lines.length&&!delta.lines[0]:!Range.comparePoints(delta.start,delta.end))||(isInsert&&delta.lines.length>2e4&&this.$splitAndapplyLargeDelta(delta,2e4),applyDelta(this.$lines,delta,doNotValidate),this._signal(\"change\",delta))},this.$splitAndapplyLargeDelta=function(delta,MAX){for(var lines=delta.lines,l=lines.length,row=delta.start.row,column=delta.start.column,from=0,to=0;;){from=to,to+=MAX-1;var chunk=lines.slice(from,to);if(to>l){delta.lines=chunk,delta.start.row=row+from,delta.start.column=column;break}chunk.push(\"\"),this.applyDelta({start:this.pos(row+from,column),end:this.pos(row+to,column=0),action:delta.action,lines:chunk},!0)}},this.revertDelta=function(delta){this.applyDelta({start:this.clonePos(delta.start),end:this.clonePos(delta.end),action:\"insert\"==delta.action?\"remove\":\"insert\",lines:delta.lines.slice()})},this.indexToPosition=function(index,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,i=startRow||0,l=lines.length;l>i;i++)if(index-=lines[i].length+newlineLength,0>index)return{row:i,column:index+lines[i].length+newlineLength};return{row:l-1,column:lines[l-1].length}},this.positionToIndex=function(pos,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,index=0,row=Math.min(pos.row,lines.length),i=startRow||0;row>i;++i)index+=lines[i].length+newlineLength;return index+pos.column}}).call(Document.prototype),exports.Document=Document}),ace.define(\"ace/worker/mirror\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/document\",\"ace/lib/lang\"],function(acequire,exports){\"use strict\";acequire(\"../range\").Range;var Document=acequire(\"../document\").Document,lang=acequire(\"../lib/lang\"),Mirror=exports.Mirror=function(sender){this.sender=sender;var doc=this.doc=new Document(\"\"),deferredUpdate=this.deferredUpdate=lang.delayedCall(this.onUpdate.bind(this)),_self=this;sender.on(\"change\",function(e){var data=e.data;if(data[0].start)doc.applyDeltas(data);else for(var i=0;data.length>i;i+=2){if(Array.isArray(data[i+1]))var d={action:\"insert\",start:data[i],lines:data[i+1]};else var d={action:\"remove\",start:data[i],end:data[i+1]};doc.applyDelta(d,!0)}return _self.$timeout?deferredUpdate.schedule(_self.$timeout):(_self.onUpdate(),void 0)})};(function(){this.$timeout=500,this.setTimeout=function(timeout){this.$timeout=timeout},this.setValue=function(value){this.doc.setValue(value),this.deferredUpdate.schedule(this.$timeout)},this.getValue=function(callbackId){this.sender.callback(this.doc.getValue(),callbackId)},this.onUpdate=function(){},this.isPending=function(){return this.deferredUpdate.isPending()}}).call(Mirror.prototype)}),ace.define(\"ace/mode/html/saxparser\",[\"require\",\"exports\",\"module\"],function(acequire,exports,module){module.exports=function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=\"function\"==typeof acequire&&acequire;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}for(var i=\"function\"==typeof acequire&&acequire,o=0;r.length>o;o++)s(r[o]);return s}({1:[function(_dereq_,module,exports){function isScopeMarker(node){return\"http://www.w3.org/1999/xhtml\"===node.namespaceURI?\"applet\"===node.localName||\"caption\"===node.localName||\"marquee\"===node.localName||\"object\"===node.localName||\"table\"===node.localName||\"td\"===node.localName||\"th\"===node.localName:\"http://www.w3.org/1998/Math/MathML\"===node.namespaceURI?\"mi\"===node.localName||\"mo\"===node.localName||\"mn\"===node.localName||\"ms\"===node.localName||\"mtext\"===node.localName||\"annotation-xml\"===node.localName:\"http://www.w3.org/2000/svg\"===node.namespaceURI?\"foreignObject\"===node.localName||\"desc\"===node.localName||\"title\"===node.localName:void 0}function isListItemScopeMarker(node){return isScopeMarker(node)||\"http://www.w3.org/1999/xhtml\"===node.namespaceURI&&\"ol\"===node.localName||\"http://www.w3.org/1999/xhtml\"===node.namespaceURI&&\"ul\"===node.localName}function isTableScopeMarker(node){return\"http://www.w3.org/1999/xhtml\"===node.namespaceURI&&\"table\"===node.localName||\"http://www.w3.org/1999/xhtml\"===node.namespaceURI&&\"html\"===node.localName}function isTableBodyScopeMarker(node){return\"http://www.w3.org/1999/xhtml\"===node.namespaceURI&&\"tbody\"===node.localName||\"http://www.w3.org/1999/xhtml\"===node.namespaceURI&&\"tfoot\"===node.localName||\"http://www.w3.org/1999/xhtml\"===node.namespaceURI&&\"thead\"===node.localName||\"http://www.w3.org/1999/xhtml\"===node.namespaceURI&&\"html\"===node.localName}function isTableRowScopeMarker(node){return\"http://www.w3.org/1999/xhtml\"===node.namespaceURI&&\"tr\"===node.localName||\"http://www.w3.org/1999/xhtml\"===node.namespaceURI&&\"html\"===node.localName}function isButtonScopeMarker(node){return isScopeMarker(node)||\"http://www.w3.org/1999/xhtml\"===node.namespaceURI&&\"button\"===node.localName}function isSelectScopeMarker(node){return!(\"http://www.w3.org/1999/xhtml\"===node.namespaceURI&&\"optgroup\"===node.localName||\"http://www.w3.org/1999/xhtml\"===node.namespaceURI&&\"option\"===node.localName)}function ElementStack(){this.elements=[],this.rootNode=null,this.headElement=null,this.bodyElement=null}ElementStack.prototype._inScope=function(localName,isMarker){for(var i=this.elements.length-1;i>=0;i--){var node=this.elements[i];if(node.localName===localName)return!0;if(isMarker(node))return!1}},ElementStack.prototype.push=function(item){this.elements.push(item)},ElementStack.prototype.pushHtmlElement=function(item){this.rootNode=item.node,this.push(item)},ElementStack.prototype.pushHeadElement=function(item){this.headElement=item.node,this.push(item)},ElementStack.prototype.pushBodyElement=function(item){this.bodyElement=item.node,this.push(item)},ElementStack.prototype.pop=function(){return this.elements.pop()},ElementStack.prototype.remove=function(item){this.elements.splice(this.elements.indexOf(item),1)},ElementStack.prototype.popUntilPopped=function(localName){var element;do element=this.pop();while(element.localName!=localName)},ElementStack.prototype.popUntilTableScopeMarker=function(){for(;!isTableScopeMarker(this.top);)this.pop()},ElementStack.prototype.popUntilTableBodyScopeMarker=function(){for(;!isTableBodyScopeMarker(this.top);)this.pop()},ElementStack.prototype.popUntilTableRowScopeMarker=function(){for(;!isTableRowScopeMarker(this.top);)this.pop()},ElementStack.prototype.item=function(index){return this.elements[index]},ElementStack.prototype.contains=function(element){return-1!==this.elements.indexOf(element)},ElementStack.prototype.inScope=function(localName){return this._inScope(localName,isScopeMarker)},ElementStack.prototype.inListItemScope=function(localName){return this._inScope(localName,isListItemScopeMarker)},ElementStack.prototype.inTableScope=function(localName){return this._inScope(localName,isTableScopeMarker)},ElementStack.prototype.inButtonScope=function(localName){return this._inScope(localName,isButtonScopeMarker)},ElementStack.prototype.inSelectScope=function(localName){return this._inScope(localName,isSelectScopeMarker)},ElementStack.prototype.hasNumberedHeaderElementInScope=function(){for(var i=this.elements.length-1;i>=0;i--){var node=this.elements[i];if(node.isNumberedHeader())return!0;if(isScopeMarker(node))return!1}},ElementStack.prototype.furthestBlockForFormattingElement=function(element){for(var furthestBlock=null,i=this.elements.length-1;i>=0;i--){var node=this.elements[i];\nif(node.node===element)break;node.isSpecial()&&(furthestBlock=node)}return furthestBlock},ElementStack.prototype.findIndex=function(localName){for(var i=this.elements.length-1;i>=0;i--)if(this.elements[i].localName==localName)return i;return-1},ElementStack.prototype.remove_openElements_until=function(callback){for(var element,finished=!1;!finished;)element=this.elements.pop(),finished=callback(element);return element},Object.defineProperty(ElementStack.prototype,\"top\",{get:function(){return this.elements[this.elements.length-1]}}),Object.defineProperty(ElementStack.prototype,\"length\",{get:function(){return this.elements.length}}),exports.ElementStack=ElementStack},{}],2:[function(_dereq_,module,exports){function isAlphaNumeric(c){return c>=\"0\"&&\"9\">=c||c>=\"a\"&&\"z\">=c||c>=\"A\"&&\"Z\">=c}function isHexDigit(c){return c>=\"0\"&&\"9\">=c||c>=\"a\"&&\"f\">=c||c>=\"A\"&&\"F\">=c}function isDecimalDigit(c){return c>=\"0\"&&\"9\">=c}var entities=_dereq_(\"html5-entities\"),InputStream=_dereq_(\"./InputStream\").InputStream,namedEntityPrefixes={};Object.keys(entities).forEach(function(entityKey){for(var i=0;entityKey.length>i;i++)namedEntityPrefixes[entityKey.substring(0,i+1)]=!0});var EntityParser={};EntityParser.consumeEntity=function(buffer,tokenizer,additionalAllowedCharacter){var decodedCharacter=\"\",consumedCharacters=\"\",ch=buffer.char();if(ch===InputStream.EOF)return!1;if(consumedCharacters+=ch,\"\t\"==ch||\"\\n\"==ch||\"\u000b\"==ch||\" \"==ch||\"<\"==ch||\"&\"==ch)return buffer.unget(consumedCharacters),!1;if(additionalAllowedCharacter===ch)return buffer.unget(consumedCharacters),!1;if(\"#\"==ch){if(ch=buffer.shift(1),ch===InputStream.EOF)return tokenizer._parseError(\"expected-numeric-entity-but-got-eof\"),buffer.unget(consumedCharacters),!1;consumedCharacters+=ch;var radix=10,isDigit=isDecimalDigit;if(\"x\"==ch||\"X\"==ch){if(radix=16,isDigit=isHexDigit,ch=buffer.shift(1),ch===InputStream.EOF)return tokenizer._parseError(\"expected-numeric-entity-but-got-eof\"),buffer.unget(consumedCharacters),!1;consumedCharacters+=ch}if(isDigit(ch)){for(var code=\"\";ch!==InputStream.EOF&&isDigit(ch);)code+=ch,ch=buffer.char();code=parseInt(code,radix);var replacement=this.replaceEntityNumbers(code);if(replacement&&(tokenizer._parseError(\"invalid-numeric-entity-replaced\"),code=replacement),code>65535&&1114111>=code){code-=65536;var first=((1047552&code)>>10)+55296,second=(1023&code)+56320;decodedCharacter=String.fromCharCode(first,second)}else decodedCharacter=String.fromCharCode(code);return\";\"!==ch&&(tokenizer._parseError(\"numeric-entity-without-semicolon\"),buffer.unget(ch)),decodedCharacter}return buffer.unget(consumedCharacters),tokenizer._parseError(\"expected-numeric-entity\"),!1}if(ch>=\"a\"&&\"z\">=ch||ch>=\"A\"&&\"Z\">=ch){for(var mostRecentMatch=\"\";namedEntityPrefixes[consumedCharacters]&&(entities[consumedCharacters]&&(mostRecentMatch=consumedCharacters),\";\"!=ch)&&(ch=buffer.char(),ch!==InputStream.EOF);)consumedCharacters+=ch;return mostRecentMatch?(decodedCharacter=entities[mostRecentMatch],\";\"===ch||!additionalAllowedCharacter||!isAlphaNumeric(ch)&&\"=\"!==ch?(consumedCharacters.length>mostRecentMatch.length&&buffer.unget(consumedCharacters.substring(mostRecentMatch.length)),\";\"!==ch&&tokenizer._parseError(\"named-entity-without-semicolon\"),decodedCharacter):(buffer.unget(consumedCharacters),!1)):(tokenizer._parseError(\"expected-named-entity\"),buffer.unget(consumedCharacters),!1)}},EntityParser.replaceEntityNumbers=function(c){switch(c){case 0:return 65533;case 19:return 16;case 128:return 8364;case 129:return 129;case 130:return 8218;case 131:return 402;case 132:return 8222;case 133:return 8230;case 134:return 8224;case 135:return 8225;case 136:return 710;case 137:return 8240;case 138:return 352;case 139:return 8249;case 140:return 338;case 141:return 141;case 142:return 381;case 143:return 143;case 144:return 144;case 145:return 8216;case 146:return 8217;case 147:return 8220;case 148:return 8221;case 149:return 8226;case 150:return 8211;case 151:return 8212;case 152:return 732;case 153:return 8482;case 154:return 353;case 155:return 8250;case 156:return 339;case 157:return 157;case 158:return 382;case 159:return 376;default:if(c>=55296&&57343>=c||c>1114111)return 65533;if(c>=1&&8>=c||c>=14&&31>=c||c>=127&&159>=c||c>=64976&&65007>=c||11==c||65534==c||131070==c||3145726==c||196607==c||262142==c||262143==c||327678==c||327679==c||393214==c||393215==c||458750==c||458751==c||524286==c||524287==c||589822==c||589823==c||655358==c||655359==c||720894==c||720895==c||786430==c||786431==c||851966==c||851967==c||917502==c||917503==c||983038==c||983039==c||1048574==c||1048575==c||1114110==c||1114111==c)return c}},exports.EntityParser=EntityParser},{\"./InputStream\":3,\"html5-entities\":12}],3:[function(_dereq_,module,exports){function InputStream(){this.data=\"\",this.start=0,this.committed=0,this.eof=!1,this.lastLocation={line:0,column:0}}InputStream.EOF=-1,InputStream.DRAIN=-2,InputStream.prototype={slice:function(){if(this.start>=this.data.length){if(!this.eof)throw InputStream.DRAIN;return InputStream.EOF}return this.data.slice(this.start,this.data.length)},\"char\":function(){if(!this.eof&&this.start>=this.data.length-1)throw InputStream.DRAIN;if(this.start>=this.data.length)return InputStream.EOF;var ch=this.data[this.start++];return\"\\r\"===ch&&(ch=\"\\n\"),ch},advance:function(amount){if(this.start+=amount,this.start>=this.data.length){if(!this.eof)throw InputStream.DRAIN;return InputStream.EOF}this.committed>this.data.length/2&&(this.lastLocation=this.location(),this.data=this.data.slice(this.committed),this.start=this.start-this.committed,this.committed=0)},matchWhile:function(re){if(this.eof&&this.start>=this.data.length)return\"\";var r=RegExp(\"^\"+re+\"+\"),m=r.exec(this.slice());if(m){if(!this.eof&&m[0].length==this.data.length-this.start)throw InputStream.DRAIN;return this.advance(m[0].length),m[0]}return\"\"},matchUntil:function(re){var m,s;if(s=this.slice(),s===InputStream.EOF)return\"\";if(m=RegExp(re+(this.eof?\"|$\":\"\")).exec(s)){var t=this.data.slice(this.start,this.start+m.index);return this.advance(m.index),t.replace(/\\r/g,\"\\n\").replace(/\\n{2,}/g,\"\\n\")}throw InputStream.DRAIN},append:function(data){this.data+=data},shift:function(n){if(!this.eof&&this.start+n>=this.data.length)throw InputStream.DRAIN;if(this.eof&&this.start>=this.data.length)return InputStream.EOF;var d=\"\"+this.data.slice(this.start,this.start+n);return this.advance(Math.min(n,this.data.length-this.start)),d},peek:function(n){if(!this.eof&&this.start+n>=this.data.length)throw InputStream.DRAIN;return this.eof&&this.start>=this.data.length?InputStream.EOF:\"\"+this.data.slice(this.start,Math.min(this.start+n,this.data.length))},length:function(){return this.data.length-this.start-1},unget:function(d){d!==InputStream.EOF&&(this.start-=d.length)},undo:function(){this.start=this.committed},commit:function(){this.committed=this.start},location:function(){var lastLine=this.lastLocation.line,lastColumn=this.lastLocation.column,read=this.data.slice(0,this.committed),newlines=read.match(/\\n/g),line=newlines?lastLine+newlines.length:lastLine,column=newlines?read.length-read.lastIndexOf(\"\\n\")-1:lastColumn+read.length;return{line:line,column:column}}},exports.InputStream=InputStream},{}],4:[function(_dereq_,module,exports){function StackItem(namespaceURI,localName,attributes,node){this.localName=localName,this.namespaceURI=namespaceURI,this.attributes=attributes,this.node=node}function getAttribute(item,name){for(var i=0;item.attributes.length>i;i++)if(item.attributes[i].nodeName==name)return item.attributes[i].nodeValue;return null}var SpecialElements={\"http://www.w3.org/1999/xhtml\":[\"address\",\"applet\",\"area\",\"article\",\"aside\",\"base\",\"basefont\",\"bgsound\",\"blockquote\",\"body\",\"br\",\"button\",\"caption\",\"center\",\"col\",\"colgroup\",\"dd\",\"details\",\"dir\",\"div\",\"dl\",\"dt\",\"embed\",\"fieldset\",\"figcaption\",\"figure\",\"footer\",\"form\",\"frame\",\"frameset\",\"h1\",\"h2\",\"h3\",\"h4\",\"h5\",\"h6\",\"head\",\"header\",\"hgroup\",\"hr\",\"html\",\"iframe\",\"img\",\"input\",\"isindex\",\"li\",\"link\",\"listing\",\"main\",\"marquee\",\"menu\",\"menuitem\",\"meta\",\"nav\",\"noembed\",\"noframes\",\"noscript\",\"object\",\"ol\",\"p\",\"param\",\"plaintext\",\"pre\",\"script\",\"section\",\"select\",\"source\",\"style\",\"summary\",\"table\",\"tbody\",\"td\",\"textarea\",\"tfoot\",\"th\",\"thead\",\"title\",\"tr\",\"track\",\"ul\",\"wbr\",\"xmp\"],\"http://www.w3.org/1998/Math/MathML\":[\"mi\",\"mo\",\"mn\",\"ms\",\"mtext\",\"annotation-xml\"],\"http://www.w3.org/2000/svg\":[\"foreignObject\",\"desc\",\"title\"]};StackItem.prototype.isSpecial=function(){return this.namespaceURI in SpecialElements&&SpecialElements[this.namespaceURI].indexOf(this.localName)>-1},StackItem.prototype.isFosterParenting=function(){return\"http://www.w3.org/1999/xhtml\"===this.namespaceURI?\"table\"===this.localName||\"tbody\"===this.localName||\"tfoot\"===this.localName||\"thead\"===this.localName||\"tr\"===this.localName:!1},StackItem.prototype.isNumberedHeader=function(){return\"http://www.w3.org/1999/xhtml\"===this.namespaceURI?\"h1\"===this.localName||\"h2\"===this.localName||\"h3\"===this.localName||\"h4\"===this.localName||\"h5\"===this.localName||\"h6\"===this.localName:!1},StackItem.prototype.isForeign=function(){return\"http://www.w3.org/1999/xhtml\"!=this.namespaceURI},StackItem.prototype.isHtmlIntegrationPoint=function(){if(\"http://www.w3.org/1998/Math/MathML\"===this.namespaceURI){if(\"annotation-xml\"!==this.localName)return!1;var encoding=getAttribute(this,\"encoding\");return encoding?(encoding=encoding.toLowerCase(),\"text/html\"===encoding||\"application/xhtml+xml\"===encoding):!1}return\"http://www.w3.org/2000/svg\"===this.namespaceURI?\"foreignObject\"===this.localName||\"desc\"===this.localName||\"title\"===this.localName:!1},StackItem.prototype.isMathMLTextIntegrationPoint=function(){return\"http://www.w3.org/1998/Math/MathML\"===this.namespaceURI?\"mi\"===this.localName||\"mo\"===this.localName||\"mn\"===this.localName||\"ms\"===this.localName||\"mtext\"===this.localName:!1},exports.StackItem=StackItem},{}],5:[function(_dereq_,module,exports){function isWhitespace(c){return\" \"===c||\"\\n\"===c||\"\t\"===c||\"\\r\"===c||\"\\f\"===c}function isAlpha(c){return c>=\"A\"&&\"Z\">=c||c>=\"a\"&&\"z\">=c}function Tokenizer(tokenHandler){this._tokenHandler=tokenHandler,this._state=Tokenizer.DATA,this._inputStream=new InputStream,this._currentToken=null,this._temporaryBuffer=\"\",this._additionalAllowedCharacter=\"\"}var InputStream=_dereq_(\"./InputStream\").InputStream,EntityParser=_dereq_(\"./EntityParser\").EntityParser;Tokenizer.prototype._parseError=function(code,args){this._tokenHandler.parseError(code,args)},Tokenizer.prototype._emitToken=function(token){if(\"StartTag\"===token.type)for(var i=1;token.data.length>i;i++)token.data[i].nodeName||token.data.splice(i--,1);else\"EndTag\"===token.type&&(token.selfClosing&&this._parseError(\"self-closing-flag-on-end-tag\"),0!==token.data.length&&this._parseError(\"attributes-in-end-tag\"));this._tokenHandler.processToken(token),\"StartTag\"===token.type&&token.selfClosing&&!this._tokenHandler.isSelfClosingFlagAcknowledged()&&this._parseError(\"non-void-element-with-trailing-solidus\",{name:token.name})},Tokenizer.prototype._emitCurrentToken=function(){this._state=Tokenizer.DATA,this._emitToken(this._currentToken)},Tokenizer.prototype._currentAttribute=function(){return this._currentToken.data[this._currentToken.data.length-1]},Tokenizer.prototype.setState=function(state){this._state=state},Tokenizer.prototype.tokenize=function(source){function data_state(buffer){var data=buffer.char();if(data===InputStream.EOF)return tokenizer._emitToken({type:\"EOF\",data:null}),!1;if(\"&\"===data)tokenizer.setState(character_reference_in_data_state);else if(\"<\"===data)tokenizer.setState(tag_open_state);else if(\"\\0\"===data)tokenizer._emitToken({type:\"Characters\",data:data}),buffer.commit();else{var chars=buffer.matchUntil(\"&|<|\\0\");tokenizer._emitToken({type:\"Characters\",data:data+chars}),buffer.commit()}return!0}function character_reference_in_data_state(buffer){var character=EntityParser.consumeEntity(buffer,tokenizer);return tokenizer.setState(data_state),tokenizer._emitToken({type:\"Characters\",data:character||\"&\"}),!0}function rcdata_state(buffer){var data=buffer.char();if(data===InputStream.EOF)return tokenizer._emitToken({type:\"EOF\",data:null}),!1;if(\"&\"===data)tokenizer.setState(character_reference_in_rcdata_state);else if(\"<\"===data)tokenizer.setState(rcdata_less_than_sign_state);else if(\"\\0\"===data)tokenizer._parseError(\"invalid-codepoint\"),tokenizer._emitToken({type:\"Characters\",data:\"�\"}),buffer.commit();else{var chars=buffer.matchUntil(\"&|<|\\0\");tokenizer._emitToken({type:\"Characters\",data:data+chars}),buffer.commit()}return!0}function character_reference_in_rcdata_state(buffer){var character=EntityParser.consumeEntity(buffer,tokenizer);return tokenizer.setState(rcdata_state),tokenizer._emitToken({type:\"Characters\",data:character||\"&\"}),!0}function rawtext_state(buffer){var data=buffer.char();if(data===InputStream.EOF)return tokenizer._emitToken({type:\"EOF\",data:null}),!1;if(\"<\"===data)tokenizer.setState(rawtext_less_than_sign_state);else if(\"\\0\"===data)tokenizer._parseError(\"invalid-codepoint\"),tokenizer._emitToken({type:\"Characters\",data:\"�\"}),buffer.commit();else{var chars=buffer.matchUntil(\"<|\\0\");tokenizer._emitToken({type:\"Characters\",data:data+chars})}return!0}function plaintext_state(buffer){var data=buffer.char();if(data===InputStream.EOF)return tokenizer._emitToken({type:\"EOF\",data:null}),!1;if(\"\\0\"===data)tokenizer._parseError(\"invalid-codepoint\"),tokenizer._emitToken({type:\"Characters\",data:\"�\"}),buffer.commit();else{var chars=buffer.matchUntil(\"\\0\");tokenizer._emitToken({type:\"Characters\",data:data+chars})}return!0}function script_data_state(buffer){var data=buffer.char();if(data===InputStream.EOF)return tokenizer._emitToken({type:\"EOF\",data:null}),!1;if(\"<\"===data)tokenizer.setState(script_data_less_than_sign_state);else if(\"\\0\"===data)tokenizer._parseError(\"invalid-codepoint\"),tokenizer._emitToken({type:\"Characters\",data:\"�\"}),buffer.commit();else{var chars=buffer.matchUntil(\"<|\\0\");tokenizer._emitToken({type:\"Characters\",data:data+chars})}return!0}function rcdata_less_than_sign_state(buffer){var data=buffer.char();return\"/\"===data?(this._temporaryBuffer=\"\",tokenizer.setState(rcdata_end_tag_open_state)):(tokenizer._emitToken({type:\"Characters\",data:\"<\"}),buffer.unget(data),tokenizer.setState(rcdata_state)),!0}function rcdata_end_tag_open_state(buffer){var data=buffer.char();return isAlpha(data)?(this._temporaryBuffer+=data,tokenizer.setState(rcdata_end_tag_name_state)):(tokenizer._emitToken({type:\"Characters\",data:\"</\"}),buffer.unget(data),tokenizer.setState(rcdata_state)),!0}function rcdata_end_tag_name_state(buffer){var appropriate=tokenizer._currentToken&&tokenizer._currentToken.name===this._temporaryBuffer.toLowerCase(),data=buffer.char();return isWhitespace(data)&&appropriate?(tokenizer._currentToken={type:\"EndTag\",name:this._temporaryBuffer,data:[],selfClosing:!1},tokenizer.setState(before_attribute_name_state)):\"/\"===data&&appropriate?(tokenizer._currentToken={type:\"EndTag\",name:this._temporaryBuffer,data:[],selfClosing:!1},tokenizer.setState(self_closing_tag_state)):\">\"===data&&appropriate?(tokenizer._currentToken={type:\"EndTag\",name:this._temporaryBuffer,data:[],selfClosing:!1},tokenizer._emitCurrentToken(),tokenizer.setState(data_state)):isAlpha(data)?(this._temporaryBuffer+=data,buffer.commit()):(tokenizer._emitToken({type:\"Characters\",data:\"</\"+this._temporaryBuffer}),buffer.unget(data),tokenizer.setState(rcdata_state)),!0}function rawtext_less_than_sign_state(buffer){var data=buffer.char();return\"/\"===data?(this._temporaryBuffer=\"\",tokenizer.setState(rawtext_end_tag_open_state)):(tokenizer._emitToken({type:\"Characters\",data:\"<\"}),buffer.unget(data),tokenizer.setState(rawtext_state)),!0}function rawtext_end_tag_open_state(buffer){var data=buffer.char();return isAlpha(data)?(this._temporaryBuffer+=data,tokenizer.setState(rawtext_end_tag_name_state)):(tokenizer._emitToken({type:\"Characters\",data:\"</\"}),buffer.unget(data),tokenizer.setState(rawtext_state)),!0}function rawtext_end_tag_name_state(buffer){var appropriate=tokenizer._currentToken&&tokenizer._currentToken.name===this._temporaryBuffer.toLowerCase(),data=buffer.char();return isWhitespace(data)&&appropriate?(tokenizer._currentToken={type:\"EndTag\",name:this._temporaryBuffer,data:[],selfClosing:!1},tokenizer.setState(before_attribute_name_state)):\"/\"===data&&appropriate?(tokenizer._currentToken={type:\"EndTag\",name:this._temporaryBuffer,data:[],selfClosing:!1},tokenizer.setState(self_closing_tag_state)):\">\"===data&&appropriate?(tokenizer._currentToken={type:\"EndTag\",name:this._temporaryBuffer,data:[],selfClosing:!1},tokenizer._emitCurrentToken(),tokenizer.setState(data_state)):isAlpha(data)?(this._temporaryBuffer+=data,buffer.commit()):(tokenizer._emitToken({type:\"Characters\",data:\"</\"+this._temporaryBuffer}),buffer.unget(data),tokenizer.setState(rawtext_state)),!0}function script_data_less_than_sign_state(buffer){var data=buffer.char();return\"/\"===data?(this._temporaryBuffer=\"\",tokenizer.setState(script_data_end_tag_open_state)):\"!\"===data?(tokenizer._emitToken({type:\"Characters\",data:\"<!\"}),tokenizer.setState(script_data_escape_start_state)):(tokenizer._emitToken({type:\"Characters\",data:\"<\"}),buffer.unget(data),tokenizer.setState(script_data_state)),!0}function script_data_end_tag_open_state(buffer){var data=buffer.char();return isAlpha(data)?(this._temporaryBuffer+=data,tokenizer.setState(script_data_end_tag_name_state)):(tokenizer._emitToken({type:\"Characters\",data:\"</\"}),buffer.unget(data),tokenizer.setState(script_data_state)),!0}function script_data_end_tag_name_state(buffer){var appropriate=tokenizer._currentToken&&tokenizer._currentToken.name===this._temporaryBuffer.toLowerCase(),data=buffer.char();return isWhitespace(data)&&appropriate?(tokenizer._currentToken={type:\"EndTag\",name:\"script\",data:[],selfClosing:!1},tokenizer.setState(before_attribute_name_state)):\"/\"===data&&appropriate?(tokenizer._currentToken={type:\"EndTag\",name:\"script\",data:[],selfClosing:!1},tokenizer.setState(self_closing_tag_state)):\">\"===data&&appropriate?(tokenizer._currentToken={type:\"EndTag\",name:\"script\",data:[],selfClosing:!1},tokenizer._emitCurrentToken()):isAlpha(data)?(this._temporaryBuffer+=data,buffer.commit()):(tokenizer._emitToken({type:\"Characters\",data:\"</\"+this._temporaryBuffer}),buffer.unget(data),tokenizer.setState(script_data_state)),!0}function script_data_escape_start_state(buffer){var data=buffer.char();return\"-\"===data?(tokenizer._emitToken({type:\"Characters\",data:\"-\"}),tokenizer.setState(script_data_escape_start_dash_state)):(buffer.unget(data),tokenizer.setState(script_data_state)),!0}function script_data_escape_start_dash_state(buffer){var data=buffer.char();return\"-\"===data?(tokenizer._emitToken({type:\"Characters\",data:\"-\"}),tokenizer.setState(script_data_escaped_dash_dash_state)):(buffer.unget(data),tokenizer.setState(script_data_state)),!0}function script_data_escaped_state(buffer){var data=buffer.char();if(data===InputStream.EOF)buffer.unget(data),tokenizer.setState(data_state);else if(\"-\"===data)tokenizer._emitToken({type:\"Characters\",data:\"-\"}),tokenizer.setState(script_data_escaped_dash_state);else if(\"<\"===data)tokenizer.setState(script_data_escaped_less_then_sign_state);else if(\"\\0\"===data)tokenizer._parseError(\"invalid-codepoint\"),tokenizer._emitToken({type:\"Characters\",data:\"�\"}),buffer.commit();else{var chars=buffer.matchUntil(\"<|-|\\0\");tokenizer._emitToken({type:\"Characters\",data:data+chars})}return!0}function script_data_escaped_dash_state(buffer){var data=buffer.char();return data===InputStream.EOF?(buffer.unget(data),tokenizer.setState(data_state)):\"-\"===data?(tokenizer._emitToken({type:\"Characters\",data:\"-\"}),tokenizer.setState(script_data_escaped_dash_dash_state)):\"<\"===data?tokenizer.setState(script_data_escaped_less_then_sign_state):\"\\0\"===data?(tokenizer._parseError(\"invalid-codepoint\"),tokenizer._emitToken({type:\"Characters\",data:\"�\"}),tokenizer.setState(script_data_escaped_state)):(tokenizer._emitToken({type:\"Characters\",data:data}),tokenizer.setState(script_data_escaped_state)),!0}function script_data_escaped_dash_dash_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError(\"eof-in-script\"),buffer.unget(data),tokenizer.setState(data_state)):\"<\"===data?tokenizer.setState(script_data_escaped_less_then_sign_state):\">\"===data?(tokenizer._emitToken({type:\"Characters\",data:\">\"}),tokenizer.setState(script_data_state)):\"\\0\"===data?(tokenizer._parseError(\"invalid-codepoint\"),tokenizer._emitToken({type:\"Characters\",data:\"�\"}),tokenizer.setState(script_data_escaped_state)):(tokenizer._emitToken({type:\"Characters\",data:data}),tokenizer.setState(script_data_escaped_state)),!0}function script_data_escaped_less_then_sign_state(buffer){var data=buffer.char();return\"/\"===data?(this._temporaryBuffer=\"\",tokenizer.setState(script_data_escaped_end_tag_open_state)):isAlpha(data)?(tokenizer._emitToken({type:\"Characters\",data:\"<\"+data}),this._temporaryBuffer=data,tokenizer.setState(script_data_double_escape_start_state)):(tokenizer._emitToken({type:\"Characters\",data:\"<\"}),buffer.unget(data),tokenizer.setState(script_data_escaped_state)),!0}function script_data_escaped_end_tag_open_state(buffer){var data=buffer.char();return isAlpha(data)?(this._temporaryBuffer=data,tokenizer.setState(script_data_escaped_end_tag_name_state)):(tokenizer._emitToken({type:\"Characters\",data:\"</\"}),buffer.unget(data),tokenizer.setState(script_data_escaped_state)),!0}function script_data_escaped_end_tag_name_state(buffer){var appropriate=tokenizer._currentToken&&tokenizer._currentToken.name===this._temporaryBuffer.toLowerCase(),data=buffer.char();return isWhitespace(data)&&appropriate?(tokenizer._currentToken={type:\"EndTag\",name:\"script\",data:[],selfClosing:!1},tokenizer.setState(before_attribute_name_state)):\"/\"===data&&appropriate?(tokenizer._currentToken={type:\"EndTag\",name:\"script\",data:[],selfClosing:!1},tokenizer.setState(self_closing_tag_state)):\">\"===data&&appropriate?(tokenizer._currentToken={type:\"EndTag\",name:\"script\",data:[],selfClosing:!1},tokenizer.setState(data_state),tokenizer._emitCurrentToken()):isAlpha(data)?(this._temporaryBuffer+=data,buffer.commit()):(tokenizer._emitToken({type:\"Characters\",data:\"</\"+this._temporaryBuffer}),buffer.unget(data),tokenizer.setState(script_data_escaped_state)),!0}function script_data_double_escape_start_state(buffer){var data=buffer.char();return isWhitespace(data)||\"/\"===data||\">\"===data?(tokenizer._emitToken({type:\"Characters\",data:data}),\"script\"===this._temporaryBuffer.toLowerCase()?tokenizer.setState(script_data_double_escaped_state):tokenizer.setState(script_data_escaped_state)):isAlpha(data)?(tokenizer._emitToken({type:\"Characters\",data:data}),this._temporaryBuffer+=data,buffer.commit()):(buffer.unget(data),tokenizer.setState(script_data_escaped_state)),!0}function script_data_double_escaped_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError(\"eof-in-script\"),buffer.unget(data),tokenizer.setState(data_state)):\"-\"===data?(tokenizer._emitToken({type:\"Characters\",data:\"-\"}),tokenizer.setState(script_data_double_escaped_dash_state)):\"<\"===data?(tokenizer._emitToken({type:\"Characters\",data:\"<\"}),tokenizer.setState(script_data_double_escaped_less_than_sign_state)):\"\\0\"===data?(tokenizer._parseError(\"invalid-codepoint\"),tokenizer._emitToken({type:\"Characters\",data:\"�\"}),buffer.commit()):(tokenizer._emitToken({type:\"Characters\",data:data}),buffer.commit()),!0}function script_data_double_escaped_dash_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError(\"eof-in-script\"),buffer.unget(data),tokenizer.setState(data_state)):\"-\"===data?(tokenizer._emitToken({type:\"Characters\",data:\"-\"}),tokenizer.setState(script_data_double_escaped_dash_dash_state)):\"<\"===data?(tokenizer._emitToken({type:\"Characters\",data:\"<\"}),tokenizer.setState(script_data_double_escaped_less_than_sign_state)):\"\\0\"===data?(tokenizer._parseError(\"invalid-codepoint\"),tokenizer._emitToken({type:\"Characters\",data:\"�\"}),tokenizer.setState(script_data_double_escaped_state)):(tokenizer._emitToken({type:\"Characters\",data:data}),tokenizer.setState(script_data_double_escaped_state)),!0}function script_data_double_escaped_dash_dash_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError(\"eof-in-script\"),buffer.unget(data),tokenizer.setState(data_state)):\"-\"===data?(tokenizer._emitToken({type:\"Characters\",data:\"-\"}),buffer.commit()):\"<\"===data?(tokenizer._emitToken({type:\"Characters\",data:\"<\"}),tokenizer.setState(script_data_double_escaped_less_than_sign_state)):\">\"===data?(tokenizer._emitToken({type:\"Characters\",data:\">\"}),tokenizer.setState(script_data_state)):\"\\0\"===data?(tokenizer._parseError(\"invalid-codepoint\"),tokenizer._emitToken({type:\"Characters\",data:\"�\"}),tokenizer.setState(script_data_double_escaped_state)):(tokenizer._emitToken({type:\"Characters\",data:data}),tokenizer.setState(script_data_double_escaped_state)),!0}function script_data_double_escaped_less_than_sign_state(buffer){var data=buffer.char();return\"/\"===data?(tokenizer._emitToken({type:\"Characters\",data:\"/\"}),this._temporaryBuffer=\"\",tokenizer.setState(script_data_double_escape_end_state)):(buffer.unget(data),tokenizer.setState(script_data_double_escaped_state)),!0}function script_data_double_escape_end_state(buffer){var data=buffer.char();return isWhitespace(data)||\"/\"===data||\">\"===data?(tokenizer._emitToken({type:\"Characters\",data:data}),\"script\"===this._temporaryBuffer.toLowerCase()?tokenizer.setState(script_data_escaped_state):tokenizer.setState(script_data_double_escaped_state)):isAlpha(data)?(tokenizer._emitToken({type:\"Characters\",data:data}),this._temporaryBuffer+=data,buffer.commit()):(buffer.unget(data),tokenizer.setState(script_data_double_escaped_state)),!0}function tag_open_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError(\"bare-less-than-sign-at-eof\"),tokenizer._emitToken({type:\"Characters\",data:\"<\"}),buffer.unget(data),tokenizer.setState(data_state)):isAlpha(data)?(tokenizer._currentToken={type:\"StartTag\",name:data.toLowerCase(),data:[]},tokenizer.setState(tag_name_state)):\"!\"===data?tokenizer.setState(markup_declaration_open_state):\"/\"===data?tokenizer.setState(close_tag_open_state):\">\"===data?(tokenizer._parseError(\"expected-tag-name-but-got-right-bracket\"),tokenizer._emitToken({type:\"Characters\",data:\"<>\"}),tokenizer.setState(data_state)):\"?\"===data?(tokenizer._parseError(\"expected-tag-name-but-got-question-mark\"),buffer.unget(data),tokenizer.setState(bogus_comment_state)):(tokenizer._parseError(\"expected-tag-name\"),tokenizer._emitToken({type:\"Characters\",data:\"<\"}),buffer.unget(data),tokenizer.setState(data_state)),!0}function close_tag_open_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError(\"expected-closing-tag-but-got-eof\"),tokenizer._emitToken({type:\"Characters\",data:\"</\"}),buffer.unget(data),tokenizer.setState(data_state)):isAlpha(data)?(tokenizer._currentToken={type:\"EndTag\",name:data.toLowerCase(),data:[]},tokenizer.setState(tag_name_state)):\">\"===data?(tokenizer._parseError(\"expected-closing-tag-but-got-right-bracket\"),tokenizer.setState(data_state)):(tokenizer._parseError(\"expected-closing-tag-but-got-char\",{data:data}),buffer.unget(data),tokenizer.setState(bogus_comment_state)),!0}function tag_name_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError(\"eof-in-tag-name\"),buffer.unget(data),tokenizer.setState(data_state)):isWhitespace(data)?tokenizer.setState(before_attribute_name_state):isAlpha(data)?tokenizer._currentToken.name+=data.toLowerCase():\">\"===data?tokenizer._emitCurrentToken():\"/\"===data?tokenizer.setState(self_closing_tag_state):\"\\0\"===data?(tokenizer._parseError(\"invalid-codepoint\"),tokenizer._currentToken.name+=\"�\"):tokenizer._currentToken.name+=data,buffer.commit(),!0}function before_attribute_name_state(buffer){var data=buffer.char();if(data===InputStream.EOF)tokenizer._parseError(\"expected-attribute-name-but-got-eof\"),buffer.unget(data),tokenizer.setState(data_state);else{if(isWhitespace(data))return!0;isAlpha(data)?(tokenizer._currentToken.data.push({nodeName:data.toLowerCase(),nodeValue:\"\"}),tokenizer.setState(attribute_name_state)):\">\"===data?tokenizer._emitCurrentToken():\"/\"===data?tokenizer.setState(self_closing_tag_state):\"'\"===data||'\"'===data||\"=\"===data||\"<\"===data?(tokenizer._parseError(\"invalid-character-in-attribute-name\"),tokenizer._currentToken.data.push({nodeName:data,nodeValue:\"\"}),tokenizer.setState(attribute_name_state)):\"\\0\"===data?(tokenizer._parseError(\"invalid-codepoint\"),tokenizer._currentToken.data.push({nodeName:\"�\",nodeValue:\"\"})):(tokenizer._currentToken.data.push({nodeName:data,nodeValue:\"\"}),tokenizer.setState(attribute_name_state))}return!0}function attribute_name_state(buffer){var data=buffer.char(),leavingThisState=!0,shouldEmit=!1;if(data===InputStream.EOF?(tokenizer._parseError(\"eof-in-attribute-name\"),buffer.unget(data),tokenizer.setState(data_state),shouldEmit=!0):\"=\"===data?tokenizer.setState(before_attribute_value_state):isAlpha(data)?(tokenizer._currentAttribute().nodeName+=data.toLowerCase(),leavingThisState=!1):\">\"===data?shouldEmit=!0:isWhitespace(data)?tokenizer.setState(after_attribute_name_state):\"/\"===data?tokenizer.setState(self_closing_tag_state):\"'\"===data||'\"'===data?(tokenizer._parseError(\"invalid-character-in-attribute-name\"),tokenizer._currentAttribute().nodeName+=data,leavingThisState=!1):\"\\0\"===data?(tokenizer._parseError(\"invalid-codepoint\"),tokenizer._currentAttribute().nodeName+=\"�\"):(tokenizer._currentAttribute().nodeName+=data,leavingThisState=!1),leavingThisState){for(var attributes=tokenizer._currentToken.data,currentAttribute=attributes[attributes.length-1],i=attributes.length-2;i>=0;i--)if(currentAttribute.nodeName===attributes[i].nodeName){tokenizer._parseError(\"duplicate-attribute\",{name:currentAttribute.nodeName}),currentAttribute.nodeName=null;break}shouldEmit&&tokenizer._emitCurrentToken()}else buffer.commit();return!0}function after_attribute_name_state(buffer){var data=buffer.char();if(data===InputStream.EOF)tokenizer._parseError(\"expected-end-of-tag-but-got-eof\"),buffer.unget(data),tokenizer.setState(data_state);else{if(isWhitespace(data))return!0;\"=\"===data?tokenizer.setState(before_attribute_value_state):\">\"===data?tokenizer._emitCurrentToken():isAlpha(data)?(tokenizer._currentToken.data.push({nodeName:data,nodeValue:\"\"}),tokenizer.setState(attribute_name_state)):\"/\"===data?tokenizer.setState(self_closing_tag_state):\"'\"===data||'\"'===data||\"<\"===data?(tokenizer._parseError(\"invalid-character-after-attribute-name\"),tokenizer._currentToken.data.push({nodeName:data,nodeValue:\"\"}),tokenizer.setState(attribute_name_state)):\"\\0\"===data?(tokenizer._parseError(\"invalid-codepoint\"),tokenizer._currentToken.data.push({nodeName:\"�\",nodeValue:\"\"})):(tokenizer._currentToken.data.push({nodeName:data,nodeValue:\"\"}),tokenizer.setState(attribute_name_state))}return!0}function before_attribute_value_state(buffer){var data=buffer.char();if(data===InputStream.EOF)tokenizer._parseError(\"expected-attribute-value-but-got-eof\"),buffer.unget(data),tokenizer.setState(data_state);else{if(isWhitespace(data))return!0;'\"'===data?tokenizer.setState(attribute_value_double_quoted_state):\"&\"===data?(tokenizer.setState(attribute_value_unquoted_state),buffer.unget(data)):\"'\"===data?tokenizer.setState(attribute_value_single_quoted_state):\">\"===data?(tokenizer._parseError(\"expected-attribute-value-but-got-right-bracket\"),tokenizer._emitCurrentToken()):\"=\"===data||\"<\"===data||\"`\"===data?(tokenizer._parseError(\"unexpected-character-in-unquoted-attribute-value\"),tokenizer._currentAttribute().nodeValue+=data,tokenizer.setState(attribute_value_unquoted_state)):\"\\0\"===data?(tokenizer._parseError(\"invalid-codepoint\"),tokenizer._currentAttribute().nodeValue+=\"�\"):(tokenizer._currentAttribute().nodeValue+=data,tokenizer.setState(attribute_value_unquoted_state))}return!0\n}function attribute_value_double_quoted_state(buffer){var data=buffer.char();if(data===InputStream.EOF)tokenizer._parseError(\"eof-in-attribute-value-double-quote\"),buffer.unget(data),tokenizer.setState(data_state);else if('\"'===data)tokenizer.setState(after_attribute_value_state);else if(\"&\"===data)this._additionalAllowedCharacter='\"',tokenizer.setState(character_reference_in_attribute_value_state);else if(\"\\0\"===data)tokenizer._parseError(\"invalid-codepoint\"),tokenizer._currentAttribute().nodeValue+=\"�\";else{var s=buffer.matchUntil('[\\0\"&]');data+=s,tokenizer._currentAttribute().nodeValue+=data}return!0}function attribute_value_single_quoted_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError(\"eof-in-attribute-value-single-quote\"),buffer.unget(data),tokenizer.setState(data_state)):\"'\"===data?tokenizer.setState(after_attribute_value_state):\"&\"===data?(this._additionalAllowedCharacter=\"'\",tokenizer.setState(character_reference_in_attribute_value_state)):\"\\0\"===data?(tokenizer._parseError(\"invalid-codepoint\"),tokenizer._currentAttribute().nodeValue+=\"�\"):tokenizer._currentAttribute().nodeValue+=data+buffer.matchUntil(\"\\0|['&]\"),!0}function attribute_value_unquoted_state(buffer){var data=buffer.char();if(data===InputStream.EOF)tokenizer._parseError(\"eof-after-attribute-value\"),buffer.unget(data),tokenizer.setState(data_state);else if(isWhitespace(data))tokenizer.setState(before_attribute_name_state);else if(\"&\"===data)this._additionalAllowedCharacter=\">\",tokenizer.setState(character_reference_in_attribute_value_state);else if(\">\"===data)tokenizer._emitCurrentToken();else if('\"'===data||\"'\"===data||\"=\"===data||\"`\"===data||\"<\"===data)tokenizer._parseError(\"unexpected-character-in-unquoted-attribute-value\"),tokenizer._currentAttribute().nodeValue+=data,buffer.commit();else if(\"\\0\"===data)tokenizer._parseError(\"invalid-codepoint\"),tokenizer._currentAttribute().nodeValue+=\"�\";else{var o=buffer.matchUntil(\"\\0|[\t\\n\u000b\\f \\r&<>\\\"'=`]\");o===InputStream.EOF&&(tokenizer._parseError(\"eof-in-attribute-value-no-quotes\"),tokenizer._emitCurrentToken()),buffer.commit(),tokenizer._currentAttribute().nodeValue+=data+o}return!0}function character_reference_in_attribute_value_state(buffer){var character=EntityParser.consumeEntity(buffer,tokenizer,this._additionalAllowedCharacter);return this._currentAttribute().nodeValue+=character||\"&\",'\"'===this._additionalAllowedCharacter?tokenizer.setState(attribute_value_double_quoted_state):\"'\"===this._additionalAllowedCharacter?tokenizer.setState(attribute_value_single_quoted_state):\">\"===this._additionalAllowedCharacter&&tokenizer.setState(attribute_value_unquoted_state),!0}function after_attribute_value_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError(\"eof-after-attribute-value\"),buffer.unget(data),tokenizer.setState(data_state)):isWhitespace(data)?tokenizer.setState(before_attribute_name_state):\">\"===data?(tokenizer.setState(data_state),tokenizer._emitCurrentToken()):\"/\"===data?tokenizer.setState(self_closing_tag_state):(tokenizer._parseError(\"unexpected-character-after-attribute-value\"),buffer.unget(data),tokenizer.setState(before_attribute_name_state)),!0}function self_closing_tag_state(buffer){var c=buffer.char();return c===InputStream.EOF?(tokenizer._parseError(\"unexpected-eof-after-solidus-in-tag\"),buffer.unget(c),tokenizer.setState(data_state)):\">\"===c?(tokenizer._currentToken.selfClosing=!0,tokenizer.setState(data_state),tokenizer._emitCurrentToken()):(tokenizer._parseError(\"unexpected-character-after-solidus-in-tag\"),buffer.unget(c),tokenizer.setState(before_attribute_name_state)),!0}function bogus_comment_state(buffer){var data=buffer.matchUntil(\">\");return data=data.replace(/\\u0000/g,\"�\"),buffer.char(),tokenizer._emitToken({type:\"Comment\",data:data}),tokenizer.setState(data_state),!0}function markup_declaration_open_state(buffer){var chars=buffer.shift(2);if(\"--\"===chars)tokenizer._currentToken={type:\"Comment\",data:\"\"},tokenizer.setState(comment_start_state);else{var newchars=buffer.shift(5);if(newchars===InputStream.EOF||chars===InputStream.EOF)return tokenizer._parseError(\"expected-dashes-or-doctype\"),tokenizer.setState(bogus_comment_state),buffer.unget(chars),!0;chars+=newchars,\"DOCTYPE\"===chars.toUpperCase()?(tokenizer._currentToken={type:\"Doctype\",name:\"\",publicId:null,systemId:null,forceQuirks:!1},tokenizer.setState(doctype_state)):tokenizer._tokenHandler.isCdataSectionAllowed()&&\"[CDATA[\"===chars?tokenizer.setState(cdata_section_state):(tokenizer._parseError(\"expected-dashes-or-doctype\"),buffer.unget(chars),tokenizer.setState(bogus_comment_state))}return!0}function cdata_section_state(buffer){var data=buffer.matchUntil(\"]]>\");return buffer.shift(3),data&&tokenizer._emitToken({type:\"Characters\",data:data}),tokenizer.setState(data_state),!0}function comment_start_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError(\"eof-in-comment\"),tokenizer._emitToken(tokenizer._currentToken),buffer.unget(data),tokenizer.setState(data_state)):\"-\"===data?tokenizer.setState(comment_start_dash_state):\">\"===data?(tokenizer._parseError(\"incorrect-comment\"),tokenizer._emitToken(tokenizer._currentToken),tokenizer.setState(data_state)):\"\\0\"===data?(tokenizer._parseError(\"invalid-codepoint\"),tokenizer._currentToken.data+=\"�\"):(tokenizer._currentToken.data+=data,tokenizer.setState(comment_state)),!0}function comment_start_dash_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError(\"eof-in-comment\"),tokenizer._emitToken(tokenizer._currentToken),buffer.unget(data),tokenizer.setState(data_state)):\"-\"===data?tokenizer.setState(comment_end_state):\">\"===data?(tokenizer._parseError(\"incorrect-comment\"),tokenizer._emitToken(tokenizer._currentToken),tokenizer.setState(data_state)):\"\\0\"===data?(tokenizer._parseError(\"invalid-codepoint\"),tokenizer._currentToken.data+=\"�\"):(tokenizer._currentToken.data+=\"-\"+data,tokenizer.setState(comment_state)),!0}function comment_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError(\"eof-in-comment\"),tokenizer._emitToken(tokenizer._currentToken),buffer.unget(data),tokenizer.setState(data_state)):\"-\"===data?tokenizer.setState(comment_end_dash_state):\"\\0\"===data?(tokenizer._parseError(\"invalid-codepoint\"),tokenizer._currentToken.data+=\"�\"):(tokenizer._currentToken.data+=data,buffer.commit()),!0}function comment_end_dash_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError(\"eof-in-comment-end-dash\"),tokenizer._emitToken(tokenizer._currentToken),buffer.unget(data),tokenizer.setState(data_state)):\"-\"===data?tokenizer.setState(comment_end_state):\"\\0\"===data?(tokenizer._parseError(\"invalid-codepoint\"),tokenizer._currentToken.data+=\"-�\",tokenizer.setState(comment_state)):(tokenizer._currentToken.data+=\"-\"+data+buffer.matchUntil(\"\\0|-\"),buffer.char()),!0}function comment_end_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError(\"eof-in-comment-double-dash\"),tokenizer._emitToken(tokenizer._currentToken),buffer.unget(data),tokenizer.setState(data_state)):\">\"===data?(tokenizer._emitToken(tokenizer._currentToken),tokenizer.setState(data_state)):\"!\"===data?(tokenizer._parseError(\"unexpected-bang-after-double-dash-in-comment\"),tokenizer.setState(comment_end_bang_state)):\"-\"===data?(tokenizer._parseError(\"unexpected-dash-after-double-dash-in-comment\"),tokenizer._currentToken.data+=data):\"\\0\"===data?(tokenizer._parseError(\"invalid-codepoint\"),tokenizer._currentToken.data+=\"--�\",tokenizer.setState(comment_state)):(tokenizer._parseError(\"unexpected-char-in-comment\"),tokenizer._currentToken.data+=\"--\"+data,tokenizer.setState(comment_state)),!0}function comment_end_bang_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError(\"eof-in-comment-end-bang-state\"),tokenizer._emitToken(tokenizer._currentToken),buffer.unget(data),tokenizer.setState(data_state)):\">\"===data?(tokenizer._emitToken(tokenizer._currentToken),tokenizer.setState(data_state)):\"-\"===data?(tokenizer._currentToken.data+=\"--!\",tokenizer.setState(comment_end_dash_state)):(tokenizer._currentToken.data+=\"--!\"+data,tokenizer.setState(comment_state)),!0}function doctype_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError(\"expected-doctype-name-but-got-eof\"),tokenizer._currentToken.forceQuirks=!0,buffer.unget(data),tokenizer.setState(data_state),tokenizer._emitCurrentToken()):isWhitespace(data)?tokenizer.setState(before_doctype_name_state):(tokenizer._parseError(\"need-space-after-doctype\"),buffer.unget(data),tokenizer.setState(before_doctype_name_state)),!0}function before_doctype_name_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError(\"expected-doctype-name-but-got-eof\"),tokenizer._currentToken.forceQuirks=!0,buffer.unget(data),tokenizer.setState(data_state),tokenizer._emitCurrentToken()):isWhitespace(data)||(\">\"===data?(tokenizer._parseError(\"expected-doctype-name-but-got-right-bracket\"),tokenizer._currentToken.forceQuirks=!0,tokenizer.setState(data_state),tokenizer._emitCurrentToken()):(isAlpha(data)&&(data=data.toLowerCase()),tokenizer._currentToken.name=data,tokenizer.setState(doctype_name_state))),!0}function doctype_name_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._currentToken.forceQuirks=!0,buffer.unget(data),tokenizer._parseError(\"eof-in-doctype-name\"),tokenizer.setState(data_state),tokenizer._emitCurrentToken()):isWhitespace(data)?tokenizer.setState(after_doctype_name_state):\">\"===data?(tokenizer.setState(data_state),tokenizer._emitCurrentToken()):(isAlpha(data)&&(data=data.toLowerCase()),tokenizer._currentToken.name+=data,buffer.commit()),!0}function after_doctype_name_state(buffer){var data=buffer.char();if(data===InputStream.EOF)tokenizer._currentToken.forceQuirks=!0,buffer.unget(data),tokenizer._parseError(\"eof-in-doctype\"),tokenizer.setState(data_state),tokenizer._emitCurrentToken();else if(isWhitespace(data));else if(\">\"===data)tokenizer.setState(data_state),tokenizer._emitCurrentToken();else{if([\"p\",\"P\"].indexOf(data)>-1){var expected=[[\"u\",\"U\"],[\"b\",\"B\"],[\"l\",\"L\"],[\"i\",\"I\"],[\"c\",\"C\"]],matched=expected.every(function(expected){return data=buffer.char(),expected.indexOf(data)>-1});if(matched)return tokenizer.setState(after_doctype_public_keyword_state),!0}else if([\"s\",\"S\"].indexOf(data)>-1){var expected=[[\"y\",\"Y\"],[\"s\",\"S\"],[\"t\",\"T\"],[\"e\",\"E\"],[\"m\",\"M\"]],matched=expected.every(function(expected){return data=buffer.char(),expected.indexOf(data)>-1});if(matched)return tokenizer.setState(after_doctype_system_keyword_state),!0}buffer.unget(data),tokenizer._currentToken.forceQuirks=!0,data===InputStream.EOF?(tokenizer._parseError(\"eof-in-doctype\"),buffer.unget(data),tokenizer.setState(data_state),tokenizer._emitCurrentToken()):(tokenizer._parseError(\"expected-space-or-right-bracket-in-doctype\",{data:data}),tokenizer.setState(bogus_doctype_state))}return!0}function after_doctype_public_keyword_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError(\"eof-in-doctype\"),tokenizer._currentToken.forceQuirks=!0,buffer.unget(data),tokenizer.setState(data_state),tokenizer._emitCurrentToken()):isWhitespace(data)?tokenizer.setState(before_doctype_public_identifier_state):\"'\"===data||'\"'===data?(tokenizer._parseError(\"unexpected-char-in-doctype\"),buffer.unget(data),tokenizer.setState(before_doctype_public_identifier_state)):(buffer.unget(data),tokenizer.setState(before_doctype_public_identifier_state)),!0}function before_doctype_public_identifier_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError(\"eof-in-doctype\"),tokenizer._currentToken.forceQuirks=!0,buffer.unget(data),tokenizer.setState(data_state),tokenizer._emitCurrentToken()):isWhitespace(data)||('\"'===data?(tokenizer._currentToken.publicId=\"\",tokenizer.setState(doctype_public_identifier_double_quoted_state)):\"'\"===data?(tokenizer._currentToken.publicId=\"\",tokenizer.setState(doctype_public_identifier_single_quoted_state)):\">\"===data?(tokenizer._parseError(\"unexpected-end-of-doctype\"),tokenizer._currentToken.forceQuirks=!0,tokenizer.setState(data_state),tokenizer._emitCurrentToken()):(tokenizer._parseError(\"unexpected-char-in-doctype\"),tokenizer._currentToken.forceQuirks=!0,tokenizer.setState(bogus_doctype_state))),!0}function doctype_public_identifier_double_quoted_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError(\"eof-in-doctype\"),tokenizer._currentToken.forceQuirks=!0,buffer.unget(data),tokenizer.setState(data_state),tokenizer._emitCurrentToken()):'\"'===data?tokenizer.setState(after_doctype_public_identifier_state):\">\"===data?(tokenizer._parseError(\"unexpected-end-of-doctype\"),tokenizer._currentToken.forceQuirks=!0,tokenizer.setState(data_state),tokenizer._emitCurrentToken()):tokenizer._currentToken.publicId+=data,!0}function doctype_public_identifier_single_quoted_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError(\"eof-in-doctype\"),tokenizer._currentToken.forceQuirks=!0,buffer.unget(data),tokenizer.setState(data_state),tokenizer._emitCurrentToken()):\"'\"===data?tokenizer.setState(after_doctype_public_identifier_state):\">\"===data?(tokenizer._parseError(\"unexpected-end-of-doctype\"),tokenizer._currentToken.forceQuirks=!0,tokenizer.setState(data_state),tokenizer._emitCurrentToken()):tokenizer._currentToken.publicId+=data,!0}function after_doctype_public_identifier_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError(\"eof-in-doctype\"),tokenizer._currentToken.forceQuirks=!0,tokenizer._emitCurrentToken(),buffer.unget(data),tokenizer.setState(data_state)):isWhitespace(data)?tokenizer.setState(between_doctype_public_and_system_identifiers_state):\">\"===data?(tokenizer.setState(data_state),tokenizer._emitCurrentToken()):'\"'===data?(tokenizer._parseError(\"unexpected-char-in-doctype\"),tokenizer._currentToken.systemId=\"\",tokenizer.setState(doctype_system_identifier_double_quoted_state)):\"'\"===data?(tokenizer._parseError(\"unexpected-char-in-doctype\"),tokenizer._currentToken.systemId=\"\",tokenizer.setState(doctype_system_identifier_single_quoted_state)):(tokenizer._parseError(\"unexpected-char-in-doctype\"),tokenizer._currentToken.forceQuirks=!0,tokenizer.setState(bogus_doctype_state)),!0}function between_doctype_public_and_system_identifiers_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError(\"eof-in-doctype\"),tokenizer._currentToken.forceQuirks=!0,tokenizer._emitCurrentToken(),buffer.unget(data),tokenizer.setState(data_state)):isWhitespace(data)||(\">\"===data?(tokenizer._emitCurrentToken(),tokenizer.setState(data_state)):'\"'===data?(tokenizer._currentToken.systemId=\"\",tokenizer.setState(doctype_system_identifier_double_quoted_state)):\"'\"===data?(tokenizer._currentToken.systemId=\"\",tokenizer.setState(doctype_system_identifier_single_quoted_state)):(tokenizer._parseError(\"unexpected-char-in-doctype\"),tokenizer._currentToken.forceQuirks=!0,tokenizer.setState(bogus_doctype_state))),!0}function after_doctype_system_keyword_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError(\"eof-in-doctype\"),tokenizer._currentToken.forceQuirks=!0,tokenizer._emitCurrentToken(),buffer.unget(data),tokenizer.setState(data_state)):isWhitespace(data)?tokenizer.setState(before_doctype_system_identifier_state):\"'\"===data||'\"'===data?(tokenizer._parseError(\"unexpected-char-in-doctype\"),buffer.unget(data),tokenizer.setState(before_doctype_system_identifier_state)):(buffer.unget(data),tokenizer.setState(before_doctype_system_identifier_state)),!0}function before_doctype_system_identifier_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError(\"eof-in-doctype\"),tokenizer._currentToken.forceQuirks=!0,tokenizer._emitCurrentToken(),buffer.unget(data),tokenizer.setState(data_state)):isWhitespace(data)||('\"'===data?(tokenizer._currentToken.systemId=\"\",tokenizer.setState(doctype_system_identifier_double_quoted_state)):\"'\"===data?(tokenizer._currentToken.systemId=\"\",tokenizer.setState(doctype_system_identifier_single_quoted_state)):\">\"===data?(tokenizer._parseError(\"unexpected-end-of-doctype\"),tokenizer._currentToken.forceQuirks=!0,tokenizer._emitCurrentToken(),tokenizer.setState(data_state)):(tokenizer._parseError(\"unexpected-char-in-doctype\"),tokenizer._currentToken.forceQuirks=!0,tokenizer.setState(bogus_doctype_state))),!0}function doctype_system_identifier_double_quoted_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError(\"eof-in-doctype\"),tokenizer._currentToken.forceQuirks=!0,tokenizer._emitCurrentToken(),buffer.unget(data),tokenizer.setState(data_state)):'\"'===data?tokenizer.setState(after_doctype_system_identifier_state):\">\"===data?(tokenizer._parseError(\"unexpected-end-of-doctype\"),tokenizer._currentToken.forceQuirks=!0,tokenizer._emitCurrentToken(),tokenizer.setState(data_state)):tokenizer._currentToken.systemId+=data,!0}function doctype_system_identifier_single_quoted_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError(\"eof-in-doctype\"),tokenizer._currentToken.forceQuirks=!0,tokenizer._emitCurrentToken(),buffer.unget(data),tokenizer.setState(data_state)):\"'\"===data?tokenizer.setState(after_doctype_system_identifier_state):\">\"===data?(tokenizer._parseError(\"unexpected-end-of-doctype\"),tokenizer._currentToken.forceQuirks=!0,tokenizer._emitCurrentToken(),tokenizer.setState(data_state)):tokenizer._currentToken.systemId+=data,!0}function after_doctype_system_identifier_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError(\"eof-in-doctype\"),tokenizer._currentToken.forceQuirks=!0,tokenizer._emitCurrentToken(),buffer.unget(data),tokenizer.setState(data_state)):isWhitespace(data)||(\">\"===data?(tokenizer._emitCurrentToken(),tokenizer.setState(data_state)):(tokenizer._parseError(\"unexpected-char-in-doctype\"),tokenizer.setState(bogus_doctype_state))),!0}function bogus_doctype_state(buffer){var data=buffer.char();return data===InputStream.EOF?(buffer.unget(data),tokenizer._emitCurrentToken(),tokenizer.setState(data_state)):\">\"===data&&(tokenizer._emitCurrentToken(),tokenizer.setState(data_state)),!0}Tokenizer.DATA=data_state,Tokenizer.RCDATA=rcdata_state,Tokenizer.RAWTEXT=rawtext_state,Tokenizer.SCRIPT_DATA=script_data_state,Tokenizer.PLAINTEXT=plaintext_state,this._state=Tokenizer.DATA,this._inputStream.append(source),this._tokenHandler.startTokenization(this),this._inputStream.eof=!0;for(var tokenizer=this;this._state.call(this,this._inputStream););},Object.defineProperty(Tokenizer.prototype,\"lineNumber\",{get:function(){return this._inputStream.location().line}}),Object.defineProperty(Tokenizer.prototype,\"columnNumber\",{get:function(){return this._inputStream.location().column}}),exports.Tokenizer=Tokenizer},{\"./EntityParser\":2,\"./InputStream\":3}],6:[function(_dereq_,module,exports){function isWhitespace(ch){return\" \"===ch||\"\\n\"===ch||\"\t\"===ch||\"\\r\"===ch||\"\\f\"===ch}function isWhitespaceOrReplacementCharacter(ch){return isWhitespace(ch)||\"�\"===ch}function isAllWhitespace(characters){for(var i=0;characters.length>i;i++){var ch=characters[i];if(!isWhitespace(ch))return!1}return!0}function isAllWhitespaceOrReplacementCharacters(characters){for(var i=0;characters.length>i;i++){var ch=characters[i];if(!isWhitespaceOrReplacementCharacter(ch))return!1}return!0}function getAttribute(node,name){for(var i=0;node.attributes.length>i;i++){var attribute=node.attributes[i];if(attribute.nodeName===name)return attribute}return null}function CharacterBuffer(characters){this.characters=characters,this.current=0,this.end=this.characters.length}function TreeBuilder(){this.tokenizer=null,this.errorHandler=null,this.scriptingEnabled=!1,this.document=null,this.head=null,this.form=null,this.openElements=new ElementStack,this.activeFormattingElements=[],this.insertionMode=null,this.insertionModeName=\"\",this.originalInsertionMode=\"\",this.inQuirksMode=!1,this.compatMode=\"no quirks\",this.framesetOk=!0,this.redirectAttachToFosterParent=!1,this.selfClosingFlagAcknowledged=!1,this.context=\"\",this.pendingTableCharacters=[],this.shouldSkipLeadingNewline=!1;var tree=this,modes=this.insertionModes={};modes.base={end_tag_handlers:{\"-default\":\"endTagOther\"},start_tag_handlers:{\"-default\":\"startTagOther\"},processEOF:function(){tree.generateImpliedEndTags(),tree.openElements.length>2?tree.parseError(\"expected-closing-tag-but-got-eof\"):2==tree.openElements.length&&\"body\"!=tree.openElements.item(1).localName?tree.parseError(\"expected-closing-tag-but-got-eof\"):tree.context&&tree.openElements.length>1},processComment:function(data){tree.insertComment(data,tree.currentStackItem().node)},processDoctype:function(){tree.parseError(\"unexpected-doctype\")},processStartTag:function(name,attributes,selfClosing){if(this[this.start_tag_handlers[name]])this[this.start_tag_handlers[name]](name,attributes,selfClosing);else{if(!this[this.start_tag_handlers[\"-default\"]])throw Error(\"No handler found for \"+name);this[this.start_tag_handlers[\"-default\"]](name,attributes,selfClosing)}},processEndTag:function(name){if(this[this.end_tag_handlers[name]])this[this.end_tag_handlers[name]](name);else{if(!this[this.end_tag_handlers[\"-default\"]])throw Error(\"No handler found for \"+name);this[this.end_tag_handlers[\"-default\"]](name)}},startTagHtml:function(name,attributes){modes.inBody.startTagHtml(name,attributes)}},modes.initial=Object.create(modes.base),modes.initial.processEOF=function(){tree.parseError(\"expected-doctype-but-got-eof\"),this.anythingElse(),tree.insertionMode.processEOF()},modes.initial.processComment=function(data){tree.insertComment(data,tree.document)},modes.initial.processDoctype=function(name,publicId,systemId,forceQuirks){function publicIdStartsWith(string){return 0===publicId.toLowerCase().indexOf(string)}tree.insertDoctype(name||\"\",publicId||\"\",systemId||\"\"),forceQuirks||\"html\"!=name||null!=publicId&&([\"+//silmaril//dtd html pro v0r11 19970101//\",\"-//advasoft ltd//dtd html 3.0 aswedit + extensions//\",\"-//as//dtd html 3.0 aswedit + extensions//\",\"-//ietf//dtd html 2.0 level 1//\",\"-//ietf//dtd html 2.0 level 2//\",\"-//ietf//dtd html 2.0 strict level 1//\",\"-//ietf//dtd html 2.0 strict level 2//\",\"-//ietf//dtd html 2.0 strict//\",\"-//ietf//dtd html 2.0//\",\"-//ietf//dtd html 2.1e//\",\"-//ietf//dtd html 3.0//\",\"-//ietf//dtd html 3.0//\",\"-//ietf//dtd html 3.2 final//\",\"-//ietf//dtd html 3.2//\",\"-//ietf//dtd html 3//\",\"-//ietf//dtd html level 0//\",\"-//ietf//dtd html level 0//\",\"-//ietf//dtd html level 1//\",\"-//ietf//dtd html level 1//\",\"-//ietf//dtd html level 2//\",\"-//ietf//dtd html level 2//\",\"-//ietf//dtd html level 3//\",\"-//ietf//dtd html level 3//\",\"-//ietf//dtd html strict level 0//\",\"-//ietf//dtd html strict level 0//\",\"-//ietf//dtd html strict level 1//\",\"-//ietf//dtd html strict level 1//\",\"-//ietf//dtd html strict level 2//\",\"-//ietf//dtd html strict level 2//\",\"-//ietf//dtd html strict level 3//\",\"-//ietf//dtd html strict level 3//\",\"-//ietf//dtd html strict//\",\"-//ietf//dtd html strict//\",\"-//ietf//dtd html strict//\",\"-//ietf//dtd html//\",\"-//ietf//dtd html//\",\"-//ietf//dtd html//\",\"-//metrius//dtd metrius presentational//\",\"-//microsoft//dtd internet explorer 2.0 html strict//\",\"-//microsoft//dtd internet explorer 2.0 html//\",\"-//microsoft//dtd internet explorer 2.0 tables//\",\"-//microsoft//dtd internet explorer 3.0 html strict//\",\"-//microsoft//dtd internet explorer 3.0 html//\",\"-//microsoft//dtd internet explorer 3.0 tables//\",\"-//netscape comm. corp.//dtd html//\",\"-//netscape comm. corp.//dtd strict html//\",\"-//o'reilly and associates//dtd html 2.0//\",\"-//o'reilly and associates//dtd html extended 1.0//\",\"-//spyglass//dtd html 2.0 extended//\",\"-//sq//dtd html 2.0 hotmetal + extensions//\",\"-//sun microsystems corp.//dtd hotjava html//\",\"-//sun microsystems corp.//dtd hotjava strict html//\",\"-//w3c//dtd html 3 1995-03-24//\",\"-//w3c//dtd html 3.2 draft//\",\"-//w3c//dtd html 3.2 final//\",\"-//w3c//dtd html 3.2//\",\"-//w3c//dtd html 3.2s draft//\",\"-//w3c//dtd html 4.0 frameset//\",\"-//w3c//dtd html 4.0 transitional//\",\"-//w3c//dtd html experimental 19960712//\",\"-//w3c//dtd html experimental 970421//\",\"-//w3c//dtd w3 html//\",\"-//w3o//dtd w3 html 3.0//\",\"-//webtechs//dtd mozilla html 2.0//\",\"-//webtechs//dtd mozilla html//\",\"html\"].some(publicIdStartsWith)||[\"-//w3o//dtd w3 html strict 3.0//en//\",\"-/w3c/dtd html 4.0 transitional/en\",\"html\"].indexOf(publicId.toLowerCase())>-1||null==systemId&&[\"-//w3c//dtd html 4.01 transitional//\",\"-//w3c//dtd html 4.01 frameset//\"].some(publicIdStartsWith))||null!=systemId&&\"http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd\"==systemId.toLowerCase()?(tree.compatMode=\"quirks\",tree.parseError(\"quirky-doctype\")):null!=publicId&&([\"-//w3c//dtd xhtml 1.0 transitional//\",\"-//w3c//dtd xhtml 1.0 frameset//\"].some(publicIdStartsWith)||null!=systemId&&[\"-//w3c//dtd html 4.01 transitional//\",\"-//w3c//dtd html 4.01 frameset//\"].indexOf(publicId.toLowerCase())>-1)?(tree.compatMode=\"limited quirks\",tree.parseError(\"almost-standards-doctype\")):\"-//W3C//DTD HTML 4.0//EN\"==publicId&&(null==systemId||\"http://www.w3.org/TR/REC-html40/strict.dtd\"==systemId)||\"-//W3C//DTD HTML 4.01//EN\"==publicId&&(null==systemId||\"http://www.w3.org/TR/html4/strict.dtd\"==systemId)||\"-//W3C//DTD XHTML 1.0 Strict//EN\"==publicId&&\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"==systemId||\"-//W3C//DTD XHTML 1.1//EN\"==publicId&&\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\"==systemId||(null!=systemId&&\"about:legacy-compat\"!=systemId||null!=publicId)&&tree.parseError(\"unknown-doctype\"),tree.setInsertionMode(\"beforeHTML\")},modes.initial.processCharacters=function(buffer){buffer.skipLeadingWhitespace(),buffer.length&&(tree.parseError(\"expected-doctype-but-got-chars\"),this.anythingElse(),tree.insertionMode.processCharacters(buffer))},modes.initial.processStartTag=function(name,attributes,selfClosing){tree.parseError(\"expected-doctype-but-got-start-tag\",{name:name}),this.anythingElse(),tree.insertionMode.processStartTag(name,attributes,selfClosing)},modes.initial.processEndTag=function(name){tree.parseError(\"expected-doctype-but-got-end-tag\",{name:name}),this.anythingElse(),tree.insertionMode.processEndTag(name)},modes.initial.anythingElse=function(){tree.compatMode=\"quirks\",tree.setInsertionMode(\"beforeHTML\")},modes.beforeHTML=Object.create(modes.base),modes.beforeHTML.start_tag_handlers={html:\"startTagHtml\",\"-default\":\"startTagOther\"},modes.beforeHTML.processEOF=function(){this.anythingElse(),tree.insertionMode.processEOF()},modes.beforeHTML.processComment=function(data){tree.insertComment(data,tree.document)},modes.beforeHTML.processCharacters=function(buffer){buffer.skipLeadingWhitespace(),buffer.length&&(this.anythingElse(),tree.insertionMode.processCharacters(buffer))},modes.beforeHTML.startTagHtml=function(name,attributes){tree.insertHtmlElement(attributes),tree.setInsertionMode(\"beforeHead\")},modes.beforeHTML.startTagOther=function(name,attributes,selfClosing){this.anythingElse(),tree.insertionMode.processStartTag(name,attributes,selfClosing)},modes.beforeHTML.processEndTag=function(name){this.anythingElse(),tree.insertionMode.processEndTag(name)},modes.beforeHTML.anythingElse=function(){tree.insertHtmlElement(),tree.setInsertionMode(\"beforeHead\")},modes.afterAfterBody=Object.create(modes.base),modes.afterAfterBody.start_tag_handlers={html:\"startTagHtml\",\"-default\":\"startTagOther\"},modes.afterAfterBody.processComment=function(data){tree.insertComment(data,tree.document)},modes.afterAfterBody.processDoctype=function(data){modes.inBody.processDoctype(data)},modes.afterAfterBody.startTagHtml=function(data,attributes){modes.inBody.startTagHtml(data,attributes)},modes.afterAfterBody.startTagOther=function(name,attributes,selfClosing){tree.parseError(\"unexpected-start-tag\",{name:name}),tree.setInsertionMode(\"inBody\"),tree.insertionMode.processStartTag(name,attributes,selfClosing)},modes.afterAfterBody.endTagOther=function(name){tree.parseError(\"unexpected-end-tag\",{name:name}),tree.setInsertionMode(\"inBody\"),tree.insertionMode.processEndTag(name)},modes.afterAfterBody.processCharacters=function(data){return isAllWhitespace(data.characters)?(modes.inBody.processCharacters(data),void 0):(tree.parseError(\"unexpected-char-after-body\"),tree.setInsertionMode(\"inBody\"),tree.insertionMode.processCharacters(data))},modes.afterBody=Object.create(modes.base),modes.afterBody.end_tag_handlers={html:\"endTagHtml\",\"-default\":\"endTagOther\"},modes.afterBody.processComment=function(data){tree.insertComment(data,tree.openElements.rootNode)},modes.afterBody.processCharacters=function(data){return isAllWhitespace(data.characters)?(modes.inBody.processCharacters(data),void 0):(tree.parseError(\"unexpected-char-after-body\"),tree.setInsertionMode(\"inBody\"),tree.insertionMode.processCharacters(data))},modes.afterBody.processStartTag=function(name,attributes,selfClosing){tree.parseError(\"unexpected-start-tag-after-body\",{name:name}),tree.setInsertionMode(\"inBody\"),tree.insertionMode.processStartTag(name,attributes,selfClosing)},modes.afterBody.endTagHtml=function(){tree.context?tree.parseError(\"end-html-in-innerhtml\"):tree.setInsertionMode(\"afterAfterBody\")},modes.afterBody.endTagOther=function(name){tree.parseError(\"unexpected-end-tag-after-body\",{name:name}),tree.setInsertionMode(\"inBody\"),tree.insertionMode.processEndTag(name)},modes.afterFrameset=Object.create(modes.base),modes.afterFrameset.start_tag_handlers={html:\"startTagHtml\",noframes:\"startTagNoframes\",\"-default\":\"startTagOther\"},modes.afterFrameset.end_tag_handlers={html:\"endTagHtml\",\"-default\":\"endTagOther\"},modes.afterFrameset.processCharacters=function(buffer){for(var characters=buffer.takeRemaining(),whitespace=\"\",i=0;characters.length>i;i++){var ch=characters[i];isWhitespace(ch)&&(whitespace+=ch)}whitespace&&tree.insertText(whitespace),whitespace.length<characters.length&&tree.parseError(\"expected-eof-but-got-char\")},modes.afterFrameset.startTagNoframes=function(name,attributes){modes.inHead.processStartTag(name,attributes)},modes.afterFrameset.startTagOther=function(name){tree.parseError(\"unexpected-start-tag-after-frameset\",{name:name})},modes.afterFrameset.endTagHtml=function(){tree.setInsertionMode(\"afterAfterFrameset\")},modes.afterFrameset.endTagOther=function(name){tree.parseError(\"unexpected-end-tag-after-frameset\",{name:name})},modes.beforeHead=Object.create(modes.base),modes.beforeHead.start_tag_handlers={html:\"startTagHtml\",head:\"startTagHead\",\"-default\":\"startTagOther\"},modes.beforeHead.end_tag_handlers={html:\"endTagImplyHead\",head:\"endTagImplyHead\",body:\"endTagImplyHead\",br:\"endTagImplyHead\",\"-default\":\"endTagOther\"},modes.beforeHead.processEOF=function(){this.startTagHead(\"head\",[]),tree.insertionMode.processEOF()},modes.beforeHead.processCharacters=function(buffer){buffer.skipLeadingWhitespace(),buffer.length&&(this.startTagHead(\"head\",[]),tree.insertionMode.processCharacters(buffer))},modes.beforeHead.startTagHead=function(name,attributes){tree.insertHeadElement(attributes),tree.setInsertionMode(\"inHead\")},modes.beforeHead.startTagOther=function(name,attributes,selfClosing){this.startTagHead(\"head\",[]),tree.insertionMode.processStartTag(name,attributes,selfClosing)},modes.beforeHead.endTagImplyHead=function(name){this.startTagHead(\"head\",[]),tree.insertionMode.processEndTag(name)},modes.beforeHead.endTagOther=function(name){tree.parseError(\"end-tag-after-implied-root\",{name:name})},modes.inHead=Object.create(modes.base),modes.inHead.start_tag_handlers={html:\"startTagHtml\",head:\"startTagHead\",title:\"startTagTitle\",script:\"startTagScript\",style:\"startTagNoFramesStyle\",noscript:\"startTagNoScript\",noframes:\"startTagNoFramesStyle\",base:\"startTagBaseBasefontBgsoundLink\",basefont:\"startTagBaseBasefontBgsoundLink\",bgsound:\"startTagBaseBasefontBgsoundLink\",link:\"startTagBaseBasefontBgsoundLink\",meta:\"startTagMeta\",\"-default\":\"startTagOther\"},modes.inHead.end_tag_handlers={head:\"endTagHead\",html:\"endTagHtmlBodyBr\",body:\"endTagHtmlBodyBr\",br:\"endTagHtmlBodyBr\",\"-default\":\"endTagOther\"},modes.inHead.processEOF=function(){var name=tree.currentStackItem().localName;\n-1!=[\"title\",\"style\",\"script\"].indexOf(name)&&(tree.parseError(\"expected-named-closing-tag-but-got-eof\",{name:name}),tree.popElement()),this.anythingElse(),tree.insertionMode.processEOF()},modes.inHead.processCharacters=function(buffer){var leadingWhitespace=buffer.takeLeadingWhitespace();leadingWhitespace&&tree.insertText(leadingWhitespace),buffer.length&&(this.anythingElse(),tree.insertionMode.processCharacters(buffer))},modes.inHead.startTagHtml=function(name,attributes){modes.inBody.processStartTag(name,attributes)},modes.inHead.startTagHead=function(){tree.parseError(\"two-heads-are-not-better-than-one\")},modes.inHead.startTagTitle=function(name,attributes){tree.processGenericRCDATAStartTag(name,attributes)},modes.inHead.startTagNoScript=function(name,attributes){return tree.scriptingEnabled?tree.processGenericRawTextStartTag(name,attributes):(tree.insertElement(name,attributes),tree.setInsertionMode(\"inHeadNoscript\"),void 0)},modes.inHead.startTagNoFramesStyle=function(name,attributes){tree.processGenericRawTextStartTag(name,attributes)},modes.inHead.startTagScript=function(name,attributes){tree.insertElement(name,attributes),tree.tokenizer.setState(Tokenizer.SCRIPT_DATA),tree.originalInsertionMode=tree.insertionModeName,tree.setInsertionMode(\"text\")},modes.inHead.startTagBaseBasefontBgsoundLink=function(name,attributes){tree.insertSelfClosingElement(name,attributes)},modes.inHead.startTagMeta=function(name,attributes){tree.insertSelfClosingElement(name,attributes)},modes.inHead.startTagOther=function(name,attributes,selfClosing){this.anythingElse(),tree.insertionMode.processStartTag(name,attributes,selfClosing)},modes.inHead.endTagHead=function(){\"head\"==tree.openElements.item(tree.openElements.length-1).localName?tree.openElements.pop():tree.parseError(\"unexpected-end-tag\",{name:\"head\"}),tree.setInsertionMode(\"afterHead\")},modes.inHead.endTagHtmlBodyBr=function(name){this.anythingElse(),tree.insertionMode.processEndTag(name)},modes.inHead.endTagOther=function(name){tree.parseError(\"unexpected-end-tag\",{name:name})},modes.inHead.anythingElse=function(){this.endTagHead(\"head\")},modes.afterHead=Object.create(modes.base),modes.afterHead.start_tag_handlers={html:\"startTagHtml\",head:\"startTagHead\",body:\"startTagBody\",frameset:\"startTagFrameset\",base:\"startTagFromHead\",link:\"startTagFromHead\",meta:\"startTagFromHead\",script:\"startTagFromHead\",style:\"startTagFromHead\",title:\"startTagFromHead\",\"-default\":\"startTagOther\"},modes.afterHead.end_tag_handlers={body:\"endTagBodyHtmlBr\",html:\"endTagBodyHtmlBr\",br:\"endTagBodyHtmlBr\",\"-default\":\"endTagOther\"},modes.afterHead.processEOF=function(){this.anythingElse(),tree.insertionMode.processEOF()},modes.afterHead.processCharacters=function(buffer){var leadingWhitespace=buffer.takeLeadingWhitespace();leadingWhitespace&&tree.insertText(leadingWhitespace),buffer.length&&(this.anythingElse(),tree.insertionMode.processCharacters(buffer))},modes.afterHead.startTagHtml=function(name,attributes){modes.inBody.processStartTag(name,attributes)},modes.afterHead.startTagBody=function(name,attributes){tree.framesetOk=!1,tree.insertBodyElement(attributes),tree.setInsertionMode(\"inBody\")},modes.afterHead.startTagFrameset=function(name,attributes){tree.insertElement(name,attributes),tree.setInsertionMode(\"inFrameset\")},modes.afterHead.startTagFromHead=function(name,attributes,selfClosing){tree.parseError(\"unexpected-start-tag-out-of-my-head\",{name:name}),tree.openElements.push(tree.head),modes.inHead.processStartTag(name,attributes,selfClosing),tree.openElements.remove(tree.head)},modes.afterHead.startTagHead=function(name){tree.parseError(\"unexpected-start-tag\",{name:name})},modes.afterHead.startTagOther=function(name,attributes,selfClosing){this.anythingElse(),tree.insertionMode.processStartTag(name,attributes,selfClosing)},modes.afterHead.endTagBodyHtmlBr=function(name){this.anythingElse(),tree.insertionMode.processEndTag(name)},modes.afterHead.endTagOther=function(name){tree.parseError(\"unexpected-end-tag\",{name:name})},modes.afterHead.anythingElse=function(){tree.insertBodyElement([]),tree.setInsertionMode(\"inBody\"),tree.framesetOk=!0},modes.inBody=Object.create(modes.base),modes.inBody.start_tag_handlers={html:\"startTagHtml\",head:\"startTagMisplaced\",base:\"startTagProcessInHead\",basefont:\"startTagProcessInHead\",bgsound:\"startTagProcessInHead\",link:\"startTagProcessInHead\",meta:\"startTagProcessInHead\",noframes:\"startTagProcessInHead\",script:\"startTagProcessInHead\",style:\"startTagProcessInHead\",title:\"startTagProcessInHead\",body:\"startTagBody\",form:\"startTagForm\",plaintext:\"startTagPlaintext\",a:\"startTagA\",button:\"startTagButton\",xmp:\"startTagXmp\",table:\"startTagTable\",hr:\"startTagHr\",image:\"startTagImage\",input:\"startTagInput\",textarea:\"startTagTextarea\",select:\"startTagSelect\",isindex:\"startTagIsindex\",applet:\"startTagAppletMarqueeObject\",marquee:\"startTagAppletMarqueeObject\",object:\"startTagAppletMarqueeObject\",li:\"startTagListItem\",dd:\"startTagListItem\",dt:\"startTagListItem\",address:\"startTagCloseP\",article:\"startTagCloseP\",aside:\"startTagCloseP\",blockquote:\"startTagCloseP\",center:\"startTagCloseP\",details:\"startTagCloseP\",dir:\"startTagCloseP\",div:\"startTagCloseP\",dl:\"startTagCloseP\",fieldset:\"startTagCloseP\",figcaption:\"startTagCloseP\",figure:\"startTagCloseP\",footer:\"startTagCloseP\",header:\"startTagCloseP\",hgroup:\"startTagCloseP\",main:\"startTagCloseP\",menu:\"startTagCloseP\",nav:\"startTagCloseP\",ol:\"startTagCloseP\",p:\"startTagCloseP\",section:\"startTagCloseP\",summary:\"startTagCloseP\",ul:\"startTagCloseP\",listing:\"startTagPreListing\",pre:\"startTagPreListing\",b:\"startTagFormatting\",big:\"startTagFormatting\",code:\"startTagFormatting\",em:\"startTagFormatting\",font:\"startTagFormatting\",i:\"startTagFormatting\",s:\"startTagFormatting\",small:\"startTagFormatting\",strike:\"startTagFormatting\",strong:\"startTagFormatting\",tt:\"startTagFormatting\",u:\"startTagFormatting\",nobr:\"startTagNobr\",area:\"startTagVoidFormatting\",br:\"startTagVoidFormatting\",embed:\"startTagVoidFormatting\",img:\"startTagVoidFormatting\",keygen:\"startTagVoidFormatting\",wbr:\"startTagVoidFormatting\",param:\"startTagParamSourceTrack\",source:\"startTagParamSourceTrack\",track:\"startTagParamSourceTrack\",iframe:\"startTagIFrame\",noembed:\"startTagRawText\",noscript:\"startTagRawText\",h1:\"startTagHeading\",h2:\"startTagHeading\",h3:\"startTagHeading\",h4:\"startTagHeading\",h5:\"startTagHeading\",h6:\"startTagHeading\",caption:\"startTagMisplaced\",col:\"startTagMisplaced\",colgroup:\"startTagMisplaced\",frame:\"startTagMisplaced\",frameset:\"startTagFrameset\",tbody:\"startTagMisplaced\",td:\"startTagMisplaced\",tfoot:\"startTagMisplaced\",th:\"startTagMisplaced\",thead:\"startTagMisplaced\",tr:\"startTagMisplaced\",option:\"startTagOptionOptgroup\",optgroup:\"startTagOptionOptgroup\",math:\"startTagMath\",svg:\"startTagSVG\",rt:\"startTagRpRt\",rp:\"startTagRpRt\",\"-default\":\"startTagOther\"},modes.inBody.end_tag_handlers={p:\"endTagP\",body:\"endTagBody\",html:\"endTagHtml\",address:\"endTagBlock\",article:\"endTagBlock\",aside:\"endTagBlock\",blockquote:\"endTagBlock\",button:\"endTagBlock\",center:\"endTagBlock\",details:\"endTagBlock\",dir:\"endTagBlock\",div:\"endTagBlock\",dl:\"endTagBlock\",fieldset:\"endTagBlock\",figcaption:\"endTagBlock\",figure:\"endTagBlock\",footer:\"endTagBlock\",header:\"endTagBlock\",hgroup:\"endTagBlock\",listing:\"endTagBlock\",main:\"endTagBlock\",menu:\"endTagBlock\",nav:\"endTagBlock\",ol:\"endTagBlock\",pre:\"endTagBlock\",section:\"endTagBlock\",summary:\"endTagBlock\",ul:\"endTagBlock\",form:\"endTagForm\",applet:\"endTagAppletMarqueeObject\",marquee:\"endTagAppletMarqueeObject\",object:\"endTagAppletMarqueeObject\",dd:\"endTagListItem\",dt:\"endTagListItem\",li:\"endTagListItem\",h1:\"endTagHeading\",h2:\"endTagHeading\",h3:\"endTagHeading\",h4:\"endTagHeading\",h5:\"endTagHeading\",h6:\"endTagHeading\",a:\"endTagFormatting\",b:\"endTagFormatting\",big:\"endTagFormatting\",code:\"endTagFormatting\",em:\"endTagFormatting\",font:\"endTagFormatting\",i:\"endTagFormatting\",nobr:\"endTagFormatting\",s:\"endTagFormatting\",small:\"endTagFormatting\",strike:\"endTagFormatting\",strong:\"endTagFormatting\",tt:\"endTagFormatting\",u:\"endTagFormatting\",br:\"endTagBr\",\"-default\":\"endTagOther\"},modes.inBody.processCharacters=function(buffer){tree.shouldSkipLeadingNewline&&(tree.shouldSkipLeadingNewline=!1,buffer.skipAtMostOneLeadingNewline()),tree.reconstructActiveFormattingElements();var characters=buffer.takeRemaining();characters=characters.replace(/\\u0000/g,function(){return tree.parseError(\"invalid-codepoint\"),\"\"}),characters&&(tree.insertText(characters),tree.framesetOk&&!isAllWhitespaceOrReplacementCharacters(characters)&&(tree.framesetOk=!1))},modes.inBody.startTagHtml=function(name,attributes){tree.parseError(\"non-html-root\"),tree.addAttributesToElement(tree.openElements.rootNode,attributes)},modes.inBody.startTagProcessInHead=function(name,attributes){modes.inHead.processStartTag(name,attributes)},modes.inBody.startTagBody=function(name,attributes){tree.parseError(\"unexpected-start-tag\",{name:\"body\"}),1==tree.openElements.length||\"body\"!=tree.openElements.item(1).localName?assert.ok(tree.context):(tree.framesetOk=!1,tree.addAttributesToElement(tree.openElements.bodyElement,attributes))},modes.inBody.startTagFrameset=function(name,attributes){if(tree.parseError(\"unexpected-start-tag\",{name:\"frameset\"}),1==tree.openElements.length||\"body\"!=tree.openElements.item(1).localName)assert.ok(tree.context);else if(tree.framesetOk){for(tree.detachFromParent(tree.openElements.bodyElement);tree.openElements.length>1;)tree.openElements.pop();tree.insertElement(name,attributes),tree.setInsertionMode(\"inFrameset\")}},modes.inBody.startTagCloseP=function(name,attributes){tree.openElements.inButtonScope(\"p\")&&this.endTagP(\"p\"),tree.insertElement(name,attributes)},modes.inBody.startTagPreListing=function(name,attributes){tree.openElements.inButtonScope(\"p\")&&this.endTagP(\"p\"),tree.insertElement(name,attributes),tree.framesetOk=!1,tree.shouldSkipLeadingNewline=!0},modes.inBody.startTagForm=function(name,attributes){tree.form?tree.parseError(\"unexpected-start-tag\",{name:name}):(tree.openElements.inButtonScope(\"p\")&&this.endTagP(\"p\"),tree.insertElement(name,attributes),tree.form=tree.currentStackItem())},modes.inBody.startTagRpRt=function(name,attributes){tree.openElements.inScope(\"ruby\")&&(tree.generateImpliedEndTags(),\"ruby\"!=tree.currentStackItem().localName&&tree.parseError(\"unexpected-start-tag\",{name:name})),tree.insertElement(name,attributes)},modes.inBody.startTagListItem=function(name,attributes){for(var stopNames={li:[\"li\"],dd:[\"dd\",\"dt\"],dt:[\"dd\",\"dt\"]},stopName=stopNames[name],els=tree.openElements,i=els.length-1;i>=0;i--){var node=els.item(i);if(-1!=stopName.indexOf(node.localName)){tree.insertionMode.processEndTag(node.localName);break}if(node.isSpecial()&&\"p\"!==node.localName&&\"address\"!==node.localName&&\"div\"!==node.localName)break}tree.openElements.inButtonScope(\"p\")&&this.endTagP(\"p\"),tree.insertElement(name,attributes),tree.framesetOk=!1},modes.inBody.startTagPlaintext=function(name,attributes){tree.openElements.inButtonScope(\"p\")&&this.endTagP(\"p\"),tree.insertElement(name,attributes),tree.tokenizer.setState(Tokenizer.PLAINTEXT)},modes.inBody.startTagHeading=function(name,attributes){tree.openElements.inButtonScope(\"p\")&&this.endTagP(\"p\"),tree.currentStackItem().isNumberedHeader()&&(tree.parseError(\"unexpected-start-tag\",{name:name}),tree.popElement()),tree.insertElement(name,attributes)},modes.inBody.startTagA=function(name,attributes){var activeA=tree.elementInActiveFormattingElements(\"a\");activeA&&(tree.parseError(\"unexpected-start-tag-implies-end-tag\",{startName:\"a\",endName:\"a\"}),tree.adoptionAgencyEndTag(\"a\"),tree.openElements.contains(activeA)&&tree.openElements.remove(activeA),tree.removeElementFromActiveFormattingElements(activeA)),tree.reconstructActiveFormattingElements(),tree.insertFormattingElement(name,attributes)},modes.inBody.startTagFormatting=function(name,attributes){tree.reconstructActiveFormattingElements(),tree.insertFormattingElement(name,attributes)},modes.inBody.startTagNobr=function(name,attributes){tree.reconstructActiveFormattingElements(),tree.openElements.inScope(\"nobr\")&&(tree.parseError(\"unexpected-start-tag-implies-end-tag\",{startName:\"nobr\",endName:\"nobr\"}),this.processEndTag(\"nobr\"),tree.reconstructActiveFormattingElements()),tree.insertFormattingElement(name,attributes)},modes.inBody.startTagButton=function(name,attributes){tree.openElements.inScope(\"button\")?(tree.parseError(\"unexpected-start-tag-implies-end-tag\",{startName:\"button\",endName:\"button\"}),this.processEndTag(\"button\"),tree.insertionMode.processStartTag(name,attributes)):(tree.framesetOk=!1,tree.reconstructActiveFormattingElements(),tree.insertElement(name,attributes))},modes.inBody.startTagAppletMarqueeObject=function(name,attributes){tree.reconstructActiveFormattingElements(),tree.insertElement(name,attributes),tree.activeFormattingElements.push(Marker),tree.framesetOk=!1},modes.inBody.endTagAppletMarqueeObject=function(name){tree.openElements.inScope(name)?(tree.generateImpliedEndTags(),tree.currentStackItem().localName!=name&&tree.parseError(\"end-tag-too-early\",{name:name}),tree.openElements.popUntilPopped(name),tree.clearActiveFormattingElements()):tree.parseError(\"unexpected-end-tag\",{name:name})},modes.inBody.startTagXmp=function(name,attributes){tree.openElements.inButtonScope(\"p\")&&this.processEndTag(\"p\"),tree.reconstructActiveFormattingElements(),tree.processGenericRawTextStartTag(name,attributes),tree.framesetOk=!1},modes.inBody.startTagTable=function(name,attributes){\"quirks\"!==tree.compatMode&&tree.openElements.inButtonScope(\"p\")&&this.processEndTag(\"p\"),tree.insertElement(name,attributes),tree.setInsertionMode(\"inTable\"),tree.framesetOk=!1},modes.inBody.startTagVoidFormatting=function(name,attributes){tree.reconstructActiveFormattingElements(),tree.insertSelfClosingElement(name,attributes),tree.framesetOk=!1},modes.inBody.startTagParamSourceTrack=function(name,attributes){tree.insertSelfClosingElement(name,attributes)},modes.inBody.startTagHr=function(name,attributes){tree.openElements.inButtonScope(\"p\")&&this.endTagP(\"p\"),tree.insertSelfClosingElement(name,attributes),tree.framesetOk=!1},modes.inBody.startTagImage=function(name,attributes){tree.parseError(\"unexpected-start-tag-treated-as\",{originalName:\"image\",newName:\"img\"}),this.processStartTag(\"img\",attributes)},modes.inBody.startTagInput=function(name,attributes){var currentFramesetOk=tree.framesetOk;this.startTagVoidFormatting(name,attributes);for(var key in attributes)if(\"type\"==attributes[key].nodeName){\"hidden\"==attributes[key].nodeValue.toLowerCase()&&(tree.framesetOk=currentFramesetOk);break}},modes.inBody.startTagIsindex=function(name,attributes){if(tree.parseError(\"deprecated-tag\",{name:\"isindex\"}),tree.selfClosingFlagAcknowledged=!0,!tree.form){var formAttributes=[],inputAttributes=[],prompt=\"This is a searchable index. Enter search keywords: \";for(var key in attributes)switch(attributes[key].nodeName){case\"action\":formAttributes.push({nodeName:\"action\",nodeValue:attributes[key].nodeValue});break;case\"prompt\":prompt=attributes[key].nodeValue;break;case\"name\":break;default:inputAttributes.push({nodeName:attributes[key].nodeName,nodeValue:attributes[key].nodeValue})}inputAttributes.push({nodeName:\"name\",nodeValue:\"isindex\"}),this.processStartTag(\"form\",formAttributes),this.processStartTag(\"hr\"),this.processStartTag(\"label\"),this.processCharacters(new CharacterBuffer(prompt)),this.processStartTag(\"input\",inputAttributes),this.processEndTag(\"label\"),this.processStartTag(\"hr\"),this.processEndTag(\"form\")}},modes.inBody.startTagTextarea=function(name,attributes){tree.insertElement(name,attributes),tree.tokenizer.setState(Tokenizer.RCDATA),tree.originalInsertionMode=tree.insertionModeName,tree.shouldSkipLeadingNewline=!0,tree.framesetOk=!1,tree.setInsertionMode(\"text\")},modes.inBody.startTagIFrame=function(name,attributes){tree.framesetOk=!1,this.startTagRawText(name,attributes)},modes.inBody.startTagRawText=function(name,attributes){tree.processGenericRawTextStartTag(name,attributes)},modes.inBody.startTagSelect=function(name,attributes){tree.reconstructActiveFormattingElements(),tree.insertElement(name,attributes),tree.framesetOk=!1;var insertionModeName=tree.insertionModeName;\"inTable\"==insertionModeName||\"inCaption\"==insertionModeName||\"inColumnGroup\"==insertionModeName||\"inTableBody\"==insertionModeName||\"inRow\"==insertionModeName||\"inCell\"==insertionModeName?tree.setInsertionMode(\"inSelectInTable\"):tree.setInsertionMode(\"inSelect\")},modes.inBody.startTagMisplaced=function(name){tree.parseError(\"unexpected-start-tag-ignored\",{name:name})},modes.inBody.endTagMisplaced=function(name){tree.parseError(\"unexpected-end-tag\",{name:name})},modes.inBody.endTagBr=function(name){tree.parseError(\"unexpected-end-tag-treated-as\",{originalName:\"br\",newName:\"br element\"}),tree.reconstructActiveFormattingElements(),tree.insertElement(name,[]),tree.popElement()},modes.inBody.startTagOptionOptgroup=function(name,attributes){\"option\"==tree.currentStackItem().localName&&tree.popElement(),tree.reconstructActiveFormattingElements(),tree.insertElement(name,attributes)},modes.inBody.startTagOther=function(name,attributes){tree.reconstructActiveFormattingElements(),tree.insertElement(name,attributes)},modes.inBody.endTagOther=function(name){for(var node,i=tree.openElements.length-1;i>0;i--){if(node=tree.openElements.item(i),node.localName==name){tree.generateImpliedEndTags(name),tree.currentStackItem().localName!=name&&tree.parseError(\"unexpected-end-tag\",{name:name}),tree.openElements.remove_openElements_until(function(x){return x===node});break}if(node.isSpecial()){tree.parseError(\"unexpected-end-tag\",{name:name});break}}},modes.inBody.startTagMath=function(name,attributes,selfClosing){tree.reconstructActiveFormattingElements(),attributes=tree.adjustMathMLAttributes(attributes),attributes=tree.adjustForeignAttributes(attributes),tree.insertForeignElement(name,attributes,\"http://www.w3.org/1998/Math/MathML\",selfClosing)},modes.inBody.startTagSVG=function(name,attributes,selfClosing){tree.reconstructActiveFormattingElements(),attributes=tree.adjustSVGAttributes(attributes),attributes=tree.adjustForeignAttributes(attributes),tree.insertForeignElement(name,attributes,\"http://www.w3.org/2000/svg\",selfClosing)},modes.inBody.endTagP=function(name){tree.openElements.inButtonScope(\"p\")?(tree.generateImpliedEndTags(\"p\"),\"p\"!=tree.currentStackItem().localName&&tree.parseError(\"unexpected-implied-end-tag\",{name:\"p\"}),tree.openElements.popUntilPopped(name)):(tree.parseError(\"unexpected-end-tag\",{name:\"p\"}),this.startTagCloseP(\"p\",[]),this.endTagP(\"p\"))},modes.inBody.endTagBody=function(name){return tree.openElements.inScope(\"body\")?(\"body\"!=tree.currentStackItem().localName&&tree.parseError(\"expected-one-end-tag-but-got-another\",{expectedName:tree.currentStackItem().localName,gotName:name}),tree.setInsertionMode(\"afterBody\"),void 0):(tree.parseError(\"unexpected-end-tag\",{name:name}),void 0)},modes.inBody.endTagHtml=function(name){return tree.openElements.inScope(\"body\")?(\"body\"!=tree.currentStackItem().localName&&tree.parseError(\"expected-one-end-tag-but-got-another\",{expectedName:tree.currentStackItem().localName,gotName:name}),tree.setInsertionMode(\"afterBody\"),tree.insertionMode.processEndTag(name),void 0):(tree.parseError(\"unexpected-end-tag\",{name:name}),void 0)},modes.inBody.endTagBlock=function(name){tree.openElements.inScope(name)?(tree.generateImpliedEndTags(),tree.currentStackItem().localName!=name&&tree.parseError(\"end-tag-too-early\",{name:name}),tree.openElements.popUntilPopped(name)):tree.parseError(\"unexpected-end-tag\",{name:name})},modes.inBody.endTagForm=function(name){var node=tree.form;tree.form=null,node&&tree.openElements.inScope(name)?(tree.generateImpliedEndTags(),tree.currentStackItem()!=node&&tree.parseError(\"end-tag-too-early-ignored\",{name:\"form\"}),tree.openElements.remove(node)):tree.parseError(\"unexpected-end-tag\",{name:name})},modes.inBody.endTagListItem=function(name){tree.openElements.inListItemScope(name)?(tree.generateImpliedEndTags(name),tree.currentStackItem().localName!=name&&tree.parseError(\"end-tag-too-early\",{name:name}),tree.openElements.popUntilPopped(name)):tree.parseError(\"unexpected-end-tag\",{name:name})},modes.inBody.endTagHeading=function(name){return tree.openElements.hasNumberedHeaderElementInScope()?(tree.generateImpliedEndTags(),tree.currentStackItem().localName!=name&&tree.parseError(\"end-tag-too-early\",{name:name}),tree.openElements.remove_openElements_until(function(e){return e.isNumberedHeader()}),void 0):(tree.parseError(\"unexpected-end-tag\",{name:name}),void 0)},modes.inBody.endTagFormatting=function(name,attributes){tree.adoptionAgencyEndTag(name)||this.endTagOther(name,attributes)},modes.inCaption=Object.create(modes.base),modes.inCaption.start_tag_handlers={html:\"startTagHtml\",caption:\"startTagTableElement\",col:\"startTagTableElement\",colgroup:\"startTagTableElement\",tbody:\"startTagTableElement\",td:\"startTagTableElement\",tfoot:\"startTagTableElement\",thead:\"startTagTableElement\",tr:\"startTagTableElement\",\"-default\":\"startTagOther\"},modes.inCaption.end_tag_handlers={caption:\"endTagCaption\",table:\"endTagTable\",body:\"endTagIgnore\",col:\"endTagIgnore\",colgroup:\"endTagIgnore\",html:\"endTagIgnore\",tbody:\"endTagIgnore\",td:\"endTagIgnore\",tfood:\"endTagIgnore\",thead:\"endTagIgnore\",tr:\"endTagIgnore\",\"-default\":\"endTagOther\"},modes.inCaption.processCharacters=function(data){modes.inBody.processCharacters(data)},modes.inCaption.startTagTableElement=function(name,attributes){tree.parseError(\"unexpected-end-tag\",{name:name});var ignoreEndTag=!tree.openElements.inTableScope(\"caption\");tree.insertionMode.processEndTag(\"caption\"),ignoreEndTag||tree.insertionMode.processStartTag(name,attributes)},modes.inCaption.startTagOther=function(name,attributes,selfClosing){modes.inBody.processStartTag(name,attributes,selfClosing)},modes.inCaption.endTagCaption=function(name){tree.openElements.inTableScope(\"caption\")?(tree.generateImpliedEndTags(),\"caption\"!=tree.currentStackItem().localName&&tree.parseError(\"expected-one-end-tag-but-got-another\",{gotName:\"caption\",expectedName:tree.currentStackItem().localName}),tree.openElements.popUntilPopped(\"caption\"),tree.clearActiveFormattingElements(),tree.setInsertionMode(\"inTable\")):(assert.ok(tree.context),tree.parseError(\"unexpected-end-tag\",{name:name}))},modes.inCaption.endTagTable=function(name){tree.parseError(\"unexpected-end-table-in-caption\");var ignoreEndTag=!tree.openElements.inTableScope(\"caption\");tree.insertionMode.processEndTag(\"caption\"),ignoreEndTag||tree.insertionMode.processEndTag(name)},modes.inCaption.endTagIgnore=function(name){tree.parseError(\"unexpected-end-tag\",{name:name})},modes.inCaption.endTagOther=function(name){modes.inBody.processEndTag(name)},modes.inCell=Object.create(modes.base),modes.inCell.start_tag_handlers={html:\"startTagHtml\",caption:\"startTagTableOther\",col:\"startTagTableOther\",colgroup:\"startTagTableOther\",tbody:\"startTagTableOther\",td:\"startTagTableOther\",tfoot:\"startTagTableOther\",th:\"startTagTableOther\",thead:\"startTagTableOther\",tr:\"startTagTableOther\",\"-default\":\"startTagOther\"},modes.inCell.end_tag_handlers={td:\"endTagTableCell\",th:\"endTagTableCell\",body:\"endTagIgnore\",caption:\"endTagIgnore\",col:\"endTagIgnore\",colgroup:\"endTagIgnore\",html:\"endTagIgnore\",table:\"endTagImply\",tbody:\"endTagImply\",tfoot:\"endTagImply\",thead:\"endTagImply\",tr:\"endTagImply\",\"-default\":\"endTagOther\"},modes.inCell.processCharacters=function(data){modes.inBody.processCharacters(data)},modes.inCell.startTagTableOther=function(name,attributes,selfClosing){tree.openElements.inTableScope(\"td\")||tree.openElements.inTableScope(\"th\")?(this.closeCell(),tree.insertionMode.processStartTag(name,attributes,selfClosing)):tree.parseError(\"unexpected-start-tag\",{name:name})},modes.inCell.startTagOther=function(name,attributes,selfClosing){modes.inBody.processStartTag(name,attributes,selfClosing)},modes.inCell.endTagTableCell=function(name){tree.openElements.inTableScope(name)?(tree.generateImpliedEndTags(name),tree.currentStackItem().localName!=name.toLowerCase()?(tree.parseError(\"unexpected-cell-end-tag\",{name:name}),tree.openElements.popUntilPopped(name)):tree.popElement(),tree.clearActiveFormattingElements(),tree.setInsertionMode(\"inRow\")):tree.parseError(\"unexpected-end-tag\",{name:name})},modes.inCell.endTagIgnore=function(name){tree.parseError(\"unexpected-end-tag\",{name:name})},modes.inCell.endTagImply=function(name){tree.openElements.inTableScope(name)?(this.closeCell(),tree.insertionMode.processEndTag(name)):tree.parseError(\"unexpected-end-tag\",{name:name})},modes.inCell.endTagOther=function(name){modes.inBody.processEndTag(name)},modes.inCell.closeCell=function(){tree.openElements.inTableScope(\"td\")?this.endTagTableCell(\"td\"):tree.openElements.inTableScope(\"th\")&&this.endTagTableCell(\"th\")},modes.inColumnGroup=Object.create(modes.base),modes.inColumnGroup.start_tag_handlers={html:\"startTagHtml\",col:\"startTagCol\",\"-default\":\"startTagOther\"},modes.inColumnGroup.end_tag_handlers={colgroup:\"endTagColgroup\",col:\"endTagCol\",\"-default\":\"endTagOther\"},modes.inColumnGroup.ignoreEndTagColgroup=function(){return\"html\"==tree.currentStackItem().localName},modes.inColumnGroup.processCharacters=function(buffer){var leadingWhitespace=buffer.takeLeadingWhitespace();if(leadingWhitespace&&tree.insertText(leadingWhitespace),buffer.length){var ignoreEndTag=this.ignoreEndTagColgroup();this.endTagColgroup(\"colgroup\"),ignoreEndTag||tree.insertionMode.processCharacters(buffer)}},modes.inColumnGroup.startTagCol=function(name,attributes){tree.insertSelfClosingElement(name,attributes)},modes.inColumnGroup.startTagOther=function(name,attributes,selfClosing){var ignoreEndTag=this.ignoreEndTagColgroup();this.endTagColgroup(\"colgroup\"),ignoreEndTag||tree.insertionMode.processStartTag(name,attributes,selfClosing)},modes.inColumnGroup.endTagColgroup=function(name){this.ignoreEndTagColgroup()?(assert.ok(tree.context),tree.parseError(\"unexpected-end-tag\",{name:name})):(tree.popElement(),tree.setInsertionMode(\"inTable\"))},modes.inColumnGroup.endTagCol=function(){tree.parseError(\"no-end-tag\",{name:\"col\"})},modes.inColumnGroup.endTagOther=function(name){var ignoreEndTag=this.ignoreEndTagColgroup();this.endTagColgroup(\"colgroup\"),ignoreEndTag||tree.insertionMode.processEndTag(name)},modes.inForeignContent=Object.create(modes.base),modes.inForeignContent.processStartTag=function(name,attributes,selfClosing){if(-1!=[\"b\",\"big\",\"blockquote\",\"body\",\"br\",\"center\",\"code\",\"dd\",\"div\",\"dl\",\"dt\",\"em\",\"embed\",\"h1\",\"h2\",\"h3\",\"h4\",\"h5\",\"h6\",\"head\",\"hr\",\"i\",\"img\",\"li\",\"listing\",\"menu\",\"meta\",\"nobr\",\"ol\",\"p\",\"pre\",\"ruby\",\"s\",\"small\",\"span\",\"strong\",\"strike\",\"sub\",\"sup\",\"table\",\"tt\",\"u\",\"ul\",\"var\"].indexOf(name)||\"font\"==name&&attributes.some(function(attr){return[\"color\",\"face\",\"size\"].indexOf(attr.nodeName)>=0})){for(tree.parseError(\"unexpected-html-element-in-foreign-content\",{name:name});tree.currentStackItem().isForeign()&&!tree.currentStackItem().isHtmlIntegrationPoint()&&!tree.currentStackItem().isMathMLTextIntegrationPoint();)tree.openElements.pop();return tree.insertionMode.processStartTag(name,attributes,selfClosing),void 0}\"http://www.w3.org/1998/Math/MathML\"==tree.currentStackItem().namespaceURI&&(attributes=tree.adjustMathMLAttributes(attributes)),\"http://www.w3.org/2000/svg\"==tree.currentStackItem().namespaceURI&&(name=tree.adjustSVGTagNameCase(name),attributes=tree.adjustSVGAttributes(attributes)),attributes=tree.adjustForeignAttributes(attributes),tree.insertForeignElement(name,attributes,tree.currentStackItem().namespaceURI,selfClosing)},modes.inForeignContent.processEndTag=function(name){var node=tree.currentStackItem(),index=tree.openElements.length-1;for(node.localName.toLowerCase()!=name&&tree.parseError(\"unexpected-end-tag\",{name:name});;){if(0===index)break;if(node.localName.toLowerCase()==name){for(;tree.openElements.pop()!=node;);break}if(index-=1,node=tree.openElements.item(index),!node.isForeign()){tree.insertionMode.processEndTag(name);break}}},modes.inForeignContent.processCharacters=function(buffer){var characters=buffer.takeRemaining();characters=characters.replace(/\\u0000/g,function(){return tree.parseError(\"invalid-codepoint\"),\"�\"}),tree.framesetOk&&!isAllWhitespaceOrReplacementCharacters(characters)&&(tree.framesetOk=!1),tree.insertText(characters)},modes.inHeadNoscript=Object.create(modes.base),modes.inHeadNoscript.start_tag_handlers={html:\"startTagHtml\",basefont:\"startTagBasefontBgsoundLinkMetaNoframesStyle\",bgsound:\"startTagBasefontBgsoundLinkMetaNoframesStyle\",link:\"startTagBasefontBgsoundLinkMetaNoframesStyle\",meta:\"startTagBasefontBgsoundLinkMetaNoframesStyle\",noframes:\"startTagBasefontBgsoundLinkMetaNoframesStyle\",style:\"startTagBasefontBgsoundLinkMetaNoframesStyle\",head:\"startTagHeadNoscript\",noscript:\"startTagHeadNoscript\",\"-default\":\"startTagOther\"},modes.inHeadNoscript.end_tag_handlers={noscript:\"endTagNoscript\",br:\"endTagBr\",\"-default\":\"endTagOther\"},modes.inHeadNoscript.processCharacters=function(buffer){var leadingWhitespace=buffer.takeLeadingWhitespace();leadingWhitespace&&tree.insertText(leadingWhitespace),buffer.length&&(tree.parseError(\"unexpected-char-in-frameset\"),this.anythingElse(),tree.insertionMode.processCharacters(buffer))},modes.inHeadNoscript.processComment=function(data){modes.inHead.processComment(data)},modes.inHeadNoscript.startTagBasefontBgsoundLinkMetaNoframesStyle=function(name,attributes){modes.inHead.processStartTag(name,attributes)},modes.inHeadNoscript.startTagHeadNoscript=function(name){tree.parseError(\"unexpected-start-tag-in-frameset\",{name:name})},modes.inHeadNoscript.startTagOther=function(name,attributes){tree.parseError(\"unexpected-start-tag-in-frameset\",{name:name}),this.anythingElse(),tree.insertionMode.processStartTag(name,attributes)},modes.inHeadNoscript.endTagBr=function(name,attributes){tree.parseError(\"unexpected-end-tag-in-frameset\",{name:name}),this.anythingElse(),tree.insertionMode.processEndTag(name,attributes)},modes.inHeadNoscript.endTagNoscript=function(){tree.popElement(),tree.setInsertionMode(\"inHead\")},modes.inHeadNoscript.endTagOther=function(name){tree.parseError(\"unexpected-end-tag-in-frameset\",{name:name})},modes.inHeadNoscript.anythingElse=function(){tree.popElement(),tree.setInsertionMode(\"inHead\")},modes.inFrameset=Object.create(modes.base),modes.inFrameset.start_tag_handlers={html:\"startTagHtml\",frameset:\"startTagFrameset\",frame:\"startTagFrame\",noframes:\"startTagNoframes\",\"-default\":\"startTagOther\"},modes.inFrameset.end_tag_handlers={frameset:\"endTagFrameset\",noframes:\"endTagNoframes\",\"-default\":\"endTagOther\"},modes.inFrameset.processCharacters=function(){tree.parseError(\"unexpected-char-in-frameset\")},modes.inFrameset.startTagFrameset=function(name,attributes){tree.insertElement(name,attributes)},modes.inFrameset.startTagFrame=function(name,attributes){tree.insertSelfClosingElement(name,attributes)},modes.inFrameset.startTagNoframes=function(name,attributes){modes.inBody.processStartTag(name,attributes)},modes.inFrameset.startTagOther=function(name){tree.parseError(\"unexpected-start-tag-in-frameset\",{name:name})},modes.inFrameset.endTagFrameset=function(){\"html\"==tree.currentStackItem().localName?tree.parseError(\"unexpected-frameset-in-frameset-innerhtml\"):tree.popElement(),tree.context||\"frameset\"==tree.currentStackItem().localName||tree.setInsertionMode(\"afterFrameset\")},modes.inFrameset.endTagNoframes=function(name){modes.inBody.processEndTag(name)},modes.inFrameset.endTagOther=function(name){tree.parseError(\"unexpected-end-tag-in-frameset\",{name:name})},modes.inTable=Object.create(modes.base),modes.inTable.start_tag_handlers={html:\"startTagHtml\",caption:\"startTagCaption\",colgroup:\"startTagColgroup\",col:\"startTagCol\",table:\"startTagTable\",tbody:\"startTagRowGroup\",tfoot:\"startTagRowGroup\",thead:\"startTagRowGroup\",td:\"startTagImplyTbody\",th:\"startTagImplyTbody\",tr:\"startTagImplyTbody\",style:\"startTagStyleScript\",script:\"startTagStyleScript\",input:\"startTagInput\",form:\"startTagForm\",\"-default\":\"startTagOther\"},modes.inTable.end_tag_handlers={table:\"endTagTable\",body:\"endTagIgnore\",caption:\"endTagIgnore\",col:\"endTagIgnore\",colgroup:\"endTagIgnore\",html:\"endTagIgnore\",tbody:\"endTagIgnore\",td:\"endTagIgnore\",tfoot:\"endTagIgnore\",th:\"endTagIgnore\",thead:\"endTagIgnore\",tr:\"endTagIgnore\",\"-default\":\"endTagOther\"},modes.inTable.processCharacters=function(data){if(tree.currentStackItem().isFosterParenting()){var originalInsertionMode=tree.insertionModeName;\ntree.setInsertionMode(\"inTableText\"),tree.originalInsertionMode=originalInsertionMode,tree.insertionMode.processCharacters(data)}else tree.redirectAttachToFosterParent=!0,modes.inBody.processCharacters(data),tree.redirectAttachToFosterParent=!1},modes.inTable.startTagCaption=function(name,attributes){tree.openElements.popUntilTableScopeMarker(),tree.activeFormattingElements.push(Marker),tree.insertElement(name,attributes),tree.setInsertionMode(\"inCaption\")},modes.inTable.startTagColgroup=function(name,attributes){tree.openElements.popUntilTableScopeMarker(),tree.insertElement(name,attributes),tree.setInsertionMode(\"inColumnGroup\")},modes.inTable.startTagCol=function(name,attributes){this.startTagColgroup(\"colgroup\",[]),tree.insertionMode.processStartTag(name,attributes)},modes.inTable.startTagRowGroup=function(name,attributes){tree.openElements.popUntilTableScopeMarker(),tree.insertElement(name,attributes),tree.setInsertionMode(\"inTableBody\")},modes.inTable.startTagImplyTbody=function(name,attributes){this.startTagRowGroup(\"tbody\",[]),tree.insertionMode.processStartTag(name,attributes)},modes.inTable.startTagTable=function(name,attributes){tree.parseError(\"unexpected-start-tag-implies-end-tag\",{startName:\"table\",endName:\"table\"}),tree.insertionMode.processEndTag(\"table\"),tree.context||tree.insertionMode.processStartTag(name,attributes)},modes.inTable.startTagStyleScript=function(name,attributes){modes.inHead.processStartTag(name,attributes)},modes.inTable.startTagInput=function(name,attributes){for(var key in attributes)if(\"type\"==attributes[key].nodeName.toLowerCase()){if(\"hidden\"==attributes[key].nodeValue.toLowerCase())return tree.parseError(\"unexpected-hidden-input-in-table\"),tree.insertElement(name,attributes),tree.openElements.pop(),void 0;break}this.startTagOther(name,attributes)},modes.inTable.startTagForm=function(name,attributes){tree.parseError(\"unexpected-form-in-table\"),tree.form||(tree.insertElement(name,attributes),tree.form=tree.currentStackItem(),tree.openElements.pop())},modes.inTable.startTagOther=function(name,attributes,selfClosing){tree.parseError(\"unexpected-start-tag-implies-table-voodoo\",{name:name}),tree.redirectAttachToFosterParent=!0,modes.inBody.processStartTag(name,attributes,selfClosing),tree.redirectAttachToFosterParent=!1},modes.inTable.endTagTable=function(name){tree.openElements.inTableScope(name)?(tree.generateImpliedEndTags(),tree.currentStackItem().localName!=name&&tree.parseError(\"end-tag-too-early-named\",{gotName:\"table\",expectedName:tree.currentStackItem().localName}),tree.openElements.popUntilPopped(\"table\"),tree.resetInsertionMode()):(assert.ok(tree.context),tree.parseError(\"unexpected-end-tag\",{name:name}))},modes.inTable.endTagIgnore=function(name){tree.parseError(\"unexpected-end-tag\",{name:name})},modes.inTable.endTagOther=function(name){tree.parseError(\"unexpected-end-tag-implies-table-voodoo\",{name:name}),tree.redirectAttachToFosterParent=!0,modes.inBody.processEndTag(name),tree.redirectAttachToFosterParent=!1},modes.inTableText=Object.create(modes.base),modes.inTableText.flushCharacters=function(){var characters=tree.pendingTableCharacters.join(\"\");isAllWhitespace(characters)?tree.insertText(characters):(tree.redirectAttachToFosterParent=!0,tree.reconstructActiveFormattingElements(),tree.insertText(characters),tree.framesetOk=!1,tree.redirectAttachToFosterParent=!1),tree.pendingTableCharacters=[]},modes.inTableText.processComment=function(data){this.flushCharacters(),tree.setInsertionMode(tree.originalInsertionMode),tree.insertionMode.processComment(data)},modes.inTableText.processEOF=function(){this.flushCharacters(),tree.setInsertionMode(tree.originalInsertionMode),tree.insertionMode.processEOF()},modes.inTableText.processCharacters=function(buffer){var characters=buffer.takeRemaining();characters=characters.replace(/\\u0000/g,function(){return tree.parseError(\"invalid-codepoint\"),\"\"}),characters&&tree.pendingTableCharacters.push(characters)},modes.inTableText.processStartTag=function(name,attributes,selfClosing){this.flushCharacters(),tree.setInsertionMode(tree.originalInsertionMode),tree.insertionMode.processStartTag(name,attributes,selfClosing)},modes.inTableText.processEndTag=function(name,attributes){this.flushCharacters(),tree.setInsertionMode(tree.originalInsertionMode),tree.insertionMode.processEndTag(name,attributes)},modes.inTableBody=Object.create(modes.base),modes.inTableBody.start_tag_handlers={html:\"startTagHtml\",tr:\"startTagTr\",td:\"startTagTableCell\",th:\"startTagTableCell\",caption:\"startTagTableOther\",col:\"startTagTableOther\",colgroup:\"startTagTableOther\",tbody:\"startTagTableOther\",tfoot:\"startTagTableOther\",thead:\"startTagTableOther\",\"-default\":\"startTagOther\"},modes.inTableBody.end_tag_handlers={table:\"endTagTable\",tbody:\"endTagTableRowGroup\",tfoot:\"endTagTableRowGroup\",thead:\"endTagTableRowGroup\",body:\"endTagIgnore\",caption:\"endTagIgnore\",col:\"endTagIgnore\",colgroup:\"endTagIgnore\",html:\"endTagIgnore\",td:\"endTagIgnore\",th:\"endTagIgnore\",tr:\"endTagIgnore\",\"-default\":\"endTagOther\"},modes.inTableBody.processCharacters=function(data){modes.inTable.processCharacters(data)},modes.inTableBody.startTagTr=function(name,attributes){tree.openElements.popUntilTableBodyScopeMarker(),tree.insertElement(name,attributes),tree.setInsertionMode(\"inRow\")},modes.inTableBody.startTagTableCell=function(name,attributes){tree.parseError(\"unexpected-cell-in-table-body\",{name:name}),this.startTagTr(\"tr\",[]),tree.insertionMode.processStartTag(name,attributes)},modes.inTableBody.startTagTableOther=function(name,attributes){tree.openElements.inTableScope(\"tbody\")||tree.openElements.inTableScope(\"thead\")||tree.openElements.inTableScope(\"tfoot\")?(tree.openElements.popUntilTableBodyScopeMarker(),this.endTagTableRowGroup(tree.currentStackItem().localName),tree.insertionMode.processStartTag(name,attributes)):tree.parseError(\"unexpected-start-tag\",{name:name})},modes.inTableBody.startTagOther=function(name,attributes){modes.inTable.processStartTag(name,attributes)},modes.inTableBody.endTagTableRowGroup=function(name){tree.openElements.inTableScope(name)?(tree.openElements.popUntilTableBodyScopeMarker(),tree.popElement(),tree.setInsertionMode(\"inTable\")):tree.parseError(\"unexpected-end-tag-in-table-body\",{name:name})},modes.inTableBody.endTagTable=function(name){tree.openElements.inTableScope(\"tbody\")||tree.openElements.inTableScope(\"thead\")||tree.openElements.inTableScope(\"tfoot\")?(tree.openElements.popUntilTableBodyScopeMarker(),this.endTagTableRowGroup(tree.currentStackItem().localName),tree.insertionMode.processEndTag(name)):tree.parseError(\"unexpected-end-tag\",{name:name})},modes.inTableBody.endTagIgnore=function(name){tree.parseError(\"unexpected-end-tag-in-table-body\",{name:name})},modes.inTableBody.endTagOther=function(name){modes.inTable.processEndTag(name)},modes.inSelect=Object.create(modes.base),modes.inSelect.start_tag_handlers={html:\"startTagHtml\",option:\"startTagOption\",optgroup:\"startTagOptgroup\",select:\"startTagSelect\",input:\"startTagInput\",keygen:\"startTagInput\",textarea:\"startTagInput\",script:\"startTagScript\",\"-default\":\"startTagOther\"},modes.inSelect.end_tag_handlers={option:\"endTagOption\",optgroup:\"endTagOptgroup\",select:\"endTagSelect\",caption:\"endTagTableElements\",table:\"endTagTableElements\",tbody:\"endTagTableElements\",tfoot:\"endTagTableElements\",thead:\"endTagTableElements\",tr:\"endTagTableElements\",td:\"endTagTableElements\",th:\"endTagTableElements\",\"-default\":\"endTagOther\"},modes.inSelect.processCharacters=function(buffer){var data=buffer.takeRemaining();data=data.replace(/\\u0000/g,function(){return tree.parseError(\"invalid-codepoint\"),\"\"}),data&&tree.insertText(data)},modes.inSelect.startTagOption=function(name,attributes){\"option\"==tree.currentStackItem().localName&&tree.popElement(),tree.insertElement(name,attributes)},modes.inSelect.startTagOptgroup=function(name,attributes){\"option\"==tree.currentStackItem().localName&&tree.popElement(),\"optgroup\"==tree.currentStackItem().localName&&tree.popElement(),tree.insertElement(name,attributes)},modes.inSelect.endTagOption=function(name){return\"option\"!==tree.currentStackItem().localName?(tree.parseError(\"unexpected-end-tag-in-select\",{name:name}),void 0):(tree.popElement(),void 0)},modes.inSelect.endTagOptgroup=function(){\"option\"==tree.currentStackItem().localName&&\"optgroup\"==tree.openElements.item(tree.openElements.length-2).localName&&tree.popElement(),\"optgroup\"==tree.currentStackItem().localName?tree.popElement():tree.parseError(\"unexpected-end-tag-in-select\",{name:\"optgroup\"})},modes.inSelect.startTagSelect=function(){tree.parseError(\"unexpected-select-in-select\"),this.endTagSelect(\"select\")},modes.inSelect.endTagSelect=function(name){tree.openElements.inTableScope(\"select\")?(tree.openElements.popUntilPopped(\"select\"),tree.resetInsertionMode()):tree.parseError(\"unexpected-end-tag\",{name:name})},modes.inSelect.startTagInput=function(name,attributes){tree.parseError(\"unexpected-input-in-select\"),tree.openElements.inSelectScope(\"select\")&&(this.endTagSelect(\"select\"),tree.insertionMode.processStartTag(name,attributes))},modes.inSelect.startTagScript=function(name,attributes){modes.inHead.processStartTag(name,attributes)},modes.inSelect.endTagTableElements=function(name){tree.parseError(\"unexpected-end-tag-in-select\",{name:name}),tree.openElements.inTableScope(name)&&(this.endTagSelect(\"select\"),tree.insertionMode.processEndTag(name))},modes.inSelect.startTagOther=function(name){tree.parseError(\"unexpected-start-tag-in-select\",{name:name})},modes.inSelect.endTagOther=function(name){tree.parseError(\"unexpected-end-tag-in-select\",{name:name})},modes.inSelectInTable=Object.create(modes.base),modes.inSelectInTable.start_tag_handlers={caption:\"startTagTable\",table:\"startTagTable\",tbody:\"startTagTable\",tfoot:\"startTagTable\",thead:\"startTagTable\",tr:\"startTagTable\",td:\"startTagTable\",th:\"startTagTable\",\"-default\":\"startTagOther\"},modes.inSelectInTable.end_tag_handlers={caption:\"endTagTable\",table:\"endTagTable\",tbody:\"endTagTable\",tfoot:\"endTagTable\",thead:\"endTagTable\",tr:\"endTagTable\",td:\"endTagTable\",th:\"endTagTable\",\"-default\":\"endTagOther\"},modes.inSelectInTable.processCharacters=function(data){modes.inSelect.processCharacters(data)},modes.inSelectInTable.startTagTable=function(name,attributes){tree.parseError(\"unexpected-table-element-start-tag-in-select-in-table\",{name:name}),this.endTagOther(\"select\"),tree.insertionMode.processStartTag(name,attributes)},modes.inSelectInTable.startTagOther=function(name,attributes,selfClosing){modes.inSelect.processStartTag(name,attributes,selfClosing)},modes.inSelectInTable.endTagTable=function(name){tree.parseError(\"unexpected-table-element-end-tag-in-select-in-table\",{name:name}),tree.openElements.inTableScope(name)&&(this.endTagOther(\"select\"),tree.insertionMode.processEndTag(name))},modes.inSelectInTable.endTagOther=function(name){modes.inSelect.processEndTag(name)},modes.inRow=Object.create(modes.base),modes.inRow.start_tag_handlers={html:\"startTagHtml\",td:\"startTagTableCell\",th:\"startTagTableCell\",caption:\"startTagTableOther\",col:\"startTagTableOther\",colgroup:\"startTagTableOther\",tbody:\"startTagTableOther\",tfoot:\"startTagTableOther\",thead:\"startTagTableOther\",tr:\"startTagTableOther\",\"-default\":\"startTagOther\"},modes.inRow.end_tag_handlers={tr:\"endTagTr\",table:\"endTagTable\",tbody:\"endTagTableRowGroup\",tfoot:\"endTagTableRowGroup\",thead:\"endTagTableRowGroup\",body:\"endTagIgnore\",caption:\"endTagIgnore\",col:\"endTagIgnore\",colgroup:\"endTagIgnore\",html:\"endTagIgnore\",td:\"endTagIgnore\",th:\"endTagIgnore\",\"-default\":\"endTagOther\"},modes.inRow.processCharacters=function(data){modes.inTable.processCharacters(data)},modes.inRow.startTagTableCell=function(name,attributes){tree.openElements.popUntilTableRowScopeMarker(),tree.insertElement(name,attributes),tree.setInsertionMode(\"inCell\"),tree.activeFormattingElements.push(Marker)},modes.inRow.startTagTableOther=function(name,attributes){var ignoreEndTag=this.ignoreEndTagTr();this.endTagTr(\"tr\"),ignoreEndTag||tree.insertionMode.processStartTag(name,attributes)},modes.inRow.startTagOther=function(name,attributes,selfClosing){modes.inTable.processStartTag(name,attributes,selfClosing)},modes.inRow.endTagTr=function(name){this.ignoreEndTagTr()?(assert.ok(tree.context),tree.parseError(\"unexpected-end-tag\",{name:name})):(tree.openElements.popUntilTableRowScopeMarker(),tree.popElement(),tree.setInsertionMode(\"inTableBody\"))},modes.inRow.endTagTable=function(name){var ignoreEndTag=this.ignoreEndTagTr();this.endTagTr(\"tr\"),ignoreEndTag||tree.insertionMode.processEndTag(name)},modes.inRow.endTagTableRowGroup=function(name){tree.openElements.inTableScope(name)?(this.endTagTr(\"tr\"),tree.insertionMode.processEndTag(name)):tree.parseError(\"unexpected-end-tag\",{name:name})},modes.inRow.endTagIgnore=function(name){tree.parseError(\"unexpected-end-tag-in-table-row\",{name:name})},modes.inRow.endTagOther=function(name){modes.inTable.processEndTag(name)},modes.inRow.ignoreEndTagTr=function(){return!tree.openElements.inTableScope(\"tr\")},modes.afterAfterFrameset=Object.create(modes.base),modes.afterAfterFrameset.start_tag_handlers={html:\"startTagHtml\",noframes:\"startTagNoFrames\",\"-default\":\"startTagOther\"},modes.afterAfterFrameset.processEOF=function(){},modes.afterAfterFrameset.processComment=function(data){tree.insertComment(data,tree.document)},modes.afterAfterFrameset.processCharacters=function(buffer){for(var characters=buffer.takeRemaining(),whitespace=\"\",i=0;characters.length>i;i++){var ch=characters[i];isWhitespace(ch)&&(whitespace+=ch)}whitespace&&(tree.reconstructActiveFormattingElements(),tree.insertText(whitespace)),whitespace.length<characters.length&&tree.parseError(\"expected-eof-but-got-char\")},modes.afterAfterFrameset.startTagNoFrames=function(name,attributes){modes.inHead.processStartTag(name,attributes)},modes.afterAfterFrameset.startTagOther=function(name){tree.parseError(\"expected-eof-but-got-start-tag\",{name:name})},modes.afterAfterFrameset.processEndTag=function(name){tree.parseError(\"expected-eof-but-got-end-tag\",{name:name})},modes.text=Object.create(modes.base),modes.text.start_tag_handlers={\"-default\":\"startTagOther\"},modes.text.end_tag_handlers={script:\"endTagScript\",\"-default\":\"endTagOther\"},modes.text.processCharacters=function(buffer){tree.shouldSkipLeadingNewline&&(tree.shouldSkipLeadingNewline=!1,buffer.skipAtMostOneLeadingNewline());var data=buffer.takeRemaining();data&&tree.insertText(data)},modes.text.processEOF=function(){tree.parseError(\"expected-named-closing-tag-but-got-eof\",{name:tree.currentStackItem().localName}),tree.openElements.pop(),tree.setInsertionMode(tree.originalInsertionMode),tree.insertionMode.processEOF()},modes.text.startTagOther=function(name){throw\"Tried to process start tag \"+name+\" in RCDATA/RAWTEXT mode\"},modes.text.endTagScript=function(){var node=tree.openElements.pop();assert.ok(\"script\"==node.localName),tree.setInsertionMode(tree.originalInsertionMode)},modes.text.endTagOther=function(){tree.openElements.pop(),tree.setInsertionMode(tree.originalInsertionMode)}}function formatMessage(format,args){return format.replace(RegExp(\"{[0-9a-z-]+}\",\"gi\"),function(match){return args[match.slice(1,-1)]||match})}var assert=_dereq_(\"assert\"),messages=_dereq_(\"./messages.json\"),constants=_dereq_(\"./constants\");_dereq_(\"events\").EventEmitter;var Tokenizer=_dereq_(\"./Tokenizer\").Tokenizer,ElementStack=_dereq_(\"./ElementStack\").ElementStack,StackItem=_dereq_(\"./StackItem\").StackItem,Marker={};CharacterBuffer.prototype.skipAtMostOneLeadingNewline=function(){\"\\n\"===this.characters[this.current]&&this.current++},CharacterBuffer.prototype.skipLeadingWhitespace=function(){for(;isWhitespace(this.characters[this.current]);)if(++this.current==this.end)return},CharacterBuffer.prototype.skipLeadingNonWhitespace=function(){for(;!isWhitespace(this.characters[this.current]);)if(++this.current==this.end)return},CharacterBuffer.prototype.takeRemaining=function(){return this.characters.substring(this.current)},CharacterBuffer.prototype.takeLeadingWhitespace=function(){var start=this.current;return this.skipLeadingWhitespace(),start===this.current?\"\":this.characters.substring(start,this.current-start)},Object.defineProperty(CharacterBuffer.prototype,\"length\",{get:function(){return this.end-this.current}}),TreeBuilder.prototype.setInsertionMode=function(name){this.insertionMode=this.insertionModes[name],this.insertionModeName=name},TreeBuilder.prototype.adoptionAgencyEndTag=function(name){function isActiveFormattingElement(el){return el===formattingElement}for(var formattingElement,outerIterationLimit=8,innerIterationLimit=3,outerLoopCounter=0;outerIterationLimit>outerLoopCounter++;){if(formattingElement=this.elementInActiveFormattingElements(name),!formattingElement||this.openElements.contains(formattingElement)&&!this.openElements.inScope(formattingElement.localName))return this.parseError(\"adoption-agency-1.1\",{name:name}),!1;if(!this.openElements.contains(formattingElement))return this.parseError(\"adoption-agency-1.2\",{name:name}),this.removeElementFromActiveFormattingElements(formattingElement),!0;this.openElements.inScope(formattingElement.localName)||this.parseError(\"adoption-agency-4.4\",{name:name}),formattingElement!=this.currentStackItem()&&this.parseError(\"adoption-agency-1.3\",{name:name});var furthestBlock=this.openElements.furthestBlockForFormattingElement(formattingElement.node);if(!furthestBlock)return this.openElements.remove_openElements_until(isActiveFormattingElement),this.removeElementFromActiveFormattingElements(formattingElement),!0;for(var afeIndex=this.openElements.elements.indexOf(formattingElement),commonAncestor=this.openElements.item(afeIndex-1),bookmark=this.activeFormattingElements.indexOf(formattingElement),node=furthestBlock,lastNode=furthestBlock,index=this.openElements.elements.indexOf(node),innerLoopCounter=0;innerIterationLimit>innerLoopCounter++;)if(index-=1,node=this.openElements.item(index),0>this.activeFormattingElements.indexOf(node))this.openElements.elements.splice(index,1);else{if(node==formattingElement)break;lastNode==furthestBlock&&(bookmark=this.activeFormattingElements.indexOf(node)+1);var clone=this.createElement(node.namespaceURI,node.localName,node.attributes),newNode=new StackItem(node.namespaceURI,node.localName,node.attributes,clone);this.activeFormattingElements[this.activeFormattingElements.indexOf(node)]=newNode,this.openElements.elements[this.openElements.elements.indexOf(node)]=newNode,node=newNode,this.detachFromParent(lastNode.node),this.attachNode(lastNode.node,node.node),lastNode=node}this.detachFromParent(lastNode.node),commonAncestor.isFosterParenting()?this.insertIntoFosterParent(lastNode.node):this.attachNode(lastNode.node,commonAncestor.node);var clone=this.createElement(\"http://www.w3.org/1999/xhtml\",formattingElement.localName,formattingElement.attributes),formattingClone=new StackItem(formattingElement.namespaceURI,formattingElement.localName,formattingElement.attributes,clone);this.reparentChildren(furthestBlock.node,clone),this.attachNode(clone,furthestBlock.node),this.removeElementFromActiveFormattingElements(formattingElement),this.activeFormattingElements.splice(Math.min(bookmark,this.activeFormattingElements.length),0,formattingClone),this.openElements.remove(formattingElement),this.openElements.elements.splice(this.openElements.elements.indexOf(furthestBlock)+1,0,formattingClone)}return!0},TreeBuilder.prototype.start=function(){throw\"Not mplemented\"},TreeBuilder.prototype.startTokenization=function(tokenizer){if(this.tokenizer=tokenizer,this.compatMode=\"no quirks\",this.originalInsertionMode=\"initial\",this.framesetOk=!0,this.openElements=new ElementStack,this.activeFormattingElements=[],this.start(),this.context){switch(this.context){case\"title\":case\"textarea\":this.tokenizer.setState(Tokenizer.RCDATA);break;case\"style\":case\"xmp\":case\"iframe\":case\"noembed\":case\"noframes\":this.tokenizer.setState(Tokenizer.RAWTEXT);break;case\"script\":this.tokenizer.setState(Tokenizer.SCRIPT_DATA);break;case\"noscript\":this.scriptingEnabled&&this.tokenizer.setState(Tokenizer.RAWTEXT);break;case\"plaintext\":this.tokenizer.setState(Tokenizer.PLAINTEXT)}this.insertHtmlElement(),this.resetInsertionMode()}else this.setInsertionMode(\"initial\")},TreeBuilder.prototype.processToken=function(token){this.selfClosingFlagAcknowledged=!1;var insertionMode,currentNode=this.openElements.top||null;switch(insertionMode=!currentNode||!currentNode.isForeign()||currentNode.isMathMLTextIntegrationPoint()&&(\"StartTag\"==token.type&&!(token.name in{mglyph:0,malignmark:0})||\"Characters\"===token.type)||\"http://www.w3.org/1998/Math/MathML\"==currentNode.namespaceURI&&\"annotation-xml\"==currentNode.localName&&\"StartTag\"==token.type&&\"svg\"==token.name||currentNode.isHtmlIntegrationPoint()&&token.type in{StartTag:0,Characters:0}||\"EOF\"==token.type?this.insertionMode:this.insertionModes.inForeignContent,token.type){case\"Characters\":var buffer=new CharacterBuffer(token.data);insertionMode.processCharacters(buffer);break;case\"Comment\":insertionMode.processComment(token.data);break;case\"StartTag\":insertionMode.processStartTag(token.name,token.data,token.selfClosing);break;case\"EndTag\":insertionMode.processEndTag(token.name);break;case\"Doctype\":insertionMode.processDoctype(token.name,token.publicId,token.systemId,token.forceQuirks);break;case\"EOF\":insertionMode.processEOF()}},TreeBuilder.prototype.isCdataSectionAllowed=function(){return this.openElements.length>0&&this.currentStackItem().isForeign()},TreeBuilder.prototype.isSelfClosingFlagAcknowledged=function(){return this.selfClosingFlagAcknowledged},TreeBuilder.prototype.createElement=function(){throw Error(\"Not implemented\")},TreeBuilder.prototype.attachNode=function(){throw Error(\"Not implemented\")},TreeBuilder.prototype.attachNodeToFosterParent=function(){throw Error(\"Not implemented\")},TreeBuilder.prototype.detachFromParent=function(){throw Error(\"Not implemented\")},TreeBuilder.prototype.addAttributesToElement=function(){throw Error(\"Not implemented\")},TreeBuilder.prototype.insertHtmlElement=function(attributes){var root=this.createElement(\"http://www.w3.org/1999/xhtml\",\"html\",attributes);return this.attachNode(root,this.document),this.openElements.pushHtmlElement(new StackItem(\"http://www.w3.org/1999/xhtml\",\"html\",attributes,root)),root},TreeBuilder.prototype.insertHeadElement=function(attributes){var element=this.createElement(\"http://www.w3.org/1999/xhtml\",\"head\",attributes);return this.head=new StackItem(\"http://www.w3.org/1999/xhtml\",\"head\",attributes,element),this.attachNode(element,this.openElements.top.node),this.openElements.pushHeadElement(this.head),element},TreeBuilder.prototype.insertBodyElement=function(attributes){var element=this.createElement(\"http://www.w3.org/1999/xhtml\",\"body\",attributes);return this.attachNode(element,this.openElements.top.node),this.openElements.pushBodyElement(new StackItem(\"http://www.w3.org/1999/xhtml\",\"body\",attributes,element)),element},TreeBuilder.prototype.insertIntoFosterParent=function(node){var tableIndex=this.openElements.findIndex(\"table\"),tableElement=this.openElements.item(tableIndex).node;return 0===tableIndex?this.attachNode(node,tableElement):(this.attachNodeToFosterParent(node,tableElement,this.openElements.item(tableIndex-1).node),void 0)},TreeBuilder.prototype.insertElement=function(name,attributes,namespaceURI,selfClosing){namespaceURI||(namespaceURI=\"http://www.w3.org/1999/xhtml\");var element=this.createElement(namespaceURI,name,attributes);this.shouldFosterParent()?this.insertIntoFosterParent(element):this.attachNode(element,this.openElements.top.node),selfClosing||this.openElements.push(new StackItem(namespaceURI,name,attributes,element))},TreeBuilder.prototype.insertFormattingElement=function(name,attributes){this.insertElement(name,attributes,\"http://www.w3.org/1999/xhtml\"),this.appendElementToActiveFormattingElements(this.currentStackItem())},TreeBuilder.prototype.insertSelfClosingElement=function(name,attributes){this.selfClosingFlagAcknowledged=!0,this.insertElement(name,attributes,\"http://www.w3.org/1999/xhtml\",!0)},TreeBuilder.prototype.insertForeignElement=function(name,attributes,namespaceURI,selfClosing){selfClosing&&(this.selfClosingFlagAcknowledged=!0),this.insertElement(name,attributes,namespaceURI,selfClosing)},TreeBuilder.prototype.insertComment=function(){throw Error(\"Not implemented\")},TreeBuilder.prototype.insertDoctype=function(){throw Error(\"Not implemented\")},TreeBuilder.prototype.insertText=function(){throw Error(\"Not implemented\")},TreeBuilder.prototype.currentStackItem=function(){return this.openElements.top},TreeBuilder.prototype.popElement=function(){return this.openElements.pop()},TreeBuilder.prototype.shouldFosterParent=function(){return this.redirectAttachToFosterParent&&this.currentStackItem().isFosterParenting()},TreeBuilder.prototype.generateImpliedEndTags=function(exclude){var name=this.openElements.top.localName;-1!=[\"dd\",\"dt\",\"li\",\"option\",\"optgroup\",\"p\",\"rp\",\"rt\"].indexOf(name)&&name!=exclude&&(this.popElement(),this.generateImpliedEndTags(exclude))},TreeBuilder.prototype.reconstructActiveFormattingElements=function(){if(0!==this.activeFormattingElements.length){var i=this.activeFormattingElements.length-1,entry=this.activeFormattingElements[i];if(entry!=Marker&&!this.openElements.contains(entry)){for(;entry!=Marker&&!this.openElements.contains(entry)&&(i-=1,entry=this.activeFormattingElements[i]););for(;;){i+=1,entry=this.activeFormattingElements[i],this.insertElement(entry.localName,entry.attributes);var element=this.currentStackItem();if(this.activeFormattingElements[i]=element,element==this.activeFormattingElements[this.activeFormattingElements.length-1])break}}}},TreeBuilder.prototype.ensureNoahsArkCondition=function(item){var kNoahsArkCapacity=3;if(!(kNoahsArkCapacity>this.activeFormattingElements.length)){for(var candidates=[],newItemAttributeCount=item.attributes.length,i=this.activeFormattingElements.length-1;i>=0;i--){var candidate=this.activeFormattingElements[i];if(candidate===Marker)break;item.localName===candidate.localName&&item.namespaceURI===candidate.namespaceURI&&candidate.attributes.length==newItemAttributeCount&&candidates.push(candidate)}if(!(kNoahsArkCapacity>candidates.length)){for(var remainingCandidates=[],attributes=item.attributes,i=0;attributes.length>i;i++){for(var attribute=attributes[i],j=0;candidates.length>j;j++){var candidate=candidates[j],candidateAttribute=getAttribute(candidate,attribute.nodeName);candidateAttribute&&candidateAttribute.nodeValue===attribute.nodeValue&&remainingCandidates.push(candidate)}if(kNoahsArkCapacity>remainingCandidates.length)return;candidates=remainingCandidates,remainingCandidates=[]}for(var i=kNoahsArkCapacity-1;candidates.length>i;i++)this.removeElementFromActiveFormattingElements(candidates[i])}}},TreeBuilder.prototype.appendElementToActiveFormattingElements=function(item){this.ensureNoahsArkCondition(item),this.activeFormattingElements.push(item)},TreeBuilder.prototype.removeElementFromActiveFormattingElements=function(item){var index=this.activeFormattingElements.indexOf(item);index>=0&&this.activeFormattingElements.splice(index,1)},TreeBuilder.prototype.elementInActiveFormattingElements=function(name){for(var els=this.activeFormattingElements,i=els.length-1;i>=0&&els[i]!=Marker;i--)if(els[i].localName==name)return els[i];return!1},TreeBuilder.prototype.clearActiveFormattingElements=function(){for(;0!==this.activeFormattingElements.length&&this.activeFormattingElements.pop()!=Marker;);},TreeBuilder.prototype.reparentChildren=function(){throw Error(\"Not implemented\")},TreeBuilder.prototype.setFragmentContext=function(context){this.context=context},TreeBuilder.prototype.parseError=function(code,args){if(this.errorHandler){var message=formatMessage(messages[code],args);this.errorHandler.error(message,this.tokenizer._inputStream.location(),code)}},TreeBuilder.prototype.resetInsertionMode=function(){for(var last=!1,node=null,i=this.openElements.length-1;i>=0;i--){if(node=this.openElements.item(i),0===i&&(assert.ok(this.context),last=!0,node=new StackItem(\"http://www.w3.org/1999/xhtml\",this.context,[],null)),\"http://www.w3.org/1999/xhtml\"===node.namespaceURI){if(\"select\"===node.localName)return this.setInsertionMode(\"inSelect\");if(\"td\"===node.localName||\"th\"===node.localName)return this.setInsertionMode(\"inCell\");if(\"tr\"===node.localName)return this.setInsertionMode(\"inRow\");if(\"tbody\"===node.localName||\"thead\"===node.localName||\"tfoot\"===node.localName)return this.setInsertionMode(\"inTableBody\");if(\"caption\"===node.localName)return this.setInsertionMode(\"inCaption\");if(\"colgroup\"===node.localName)return this.setInsertionMode(\"inColumnGroup\");if(\"table\"===node.localName)return this.setInsertionMode(\"inTable\");if(\"head\"===node.localName&&!last)return this.setInsertionMode(\"inHead\");if(\"body\"===node.localName)return this.setInsertionMode(\"inBody\");if(\"frameset\"===node.localName)return this.setInsertionMode(\"inFrameset\");if(\"html\"===node.localName)return this.openElements.headElement?this.setInsertionMode(\"afterHead\"):this.setInsertionMode(\"beforeHead\")}if(last)return this.setInsertionMode(\"inBody\")}},TreeBuilder.prototype.processGenericRCDATAStartTag=function(name,attributes){this.insertElement(name,attributes),this.tokenizer.setState(Tokenizer.RCDATA),this.originalInsertionMode=this.insertionModeName,this.setInsertionMode(\"text\")},TreeBuilder.prototype.processGenericRawTextStartTag=function(name,attributes){this.insertElement(name,attributes),this.tokenizer.setState(Tokenizer.RAWTEXT),this.originalInsertionMode=this.insertionModeName,this.setInsertionMode(\"text\")},TreeBuilder.prototype.adjustMathMLAttributes=function(attributes){return attributes.forEach(function(a){a.namespaceURI=\"http://www.w3.org/1998/Math/MathML\",constants.MATHMLAttributeMap[a.nodeName]&&(a.nodeName=constants.MATHMLAttributeMap[a.nodeName])}),attributes},TreeBuilder.prototype.adjustSVGTagNameCase=function(name){return constants.SVGTagMap[name]||name},TreeBuilder.prototype.adjustSVGAttributes=function(attributes){return attributes.forEach(function(a){a.namespaceURI=\"http://www.w3.org/2000/svg\",constants.SVGAttributeMap[a.nodeName]&&(a.nodeName=constants.SVGAttributeMap[a.nodeName])}),attributes},TreeBuilder.prototype.adjustForeignAttributes=function(attributes){for(var i=0;attributes.length>i;i++){var attribute=attributes[i],adjusted=constants.ForeignAttributeMap[attribute.nodeName];adjusted&&(attribute.nodeName=adjusted.localName,attribute.prefix=adjusted.prefix,attribute.namespaceURI=adjusted.namespaceURI)}return attributes},exports.TreeBuilder=TreeBuilder},{\"./ElementStack\":1,\"./StackItem\":4,\"./Tokenizer\":5,\"./constants\":7,\"./messages.json\":8,assert:13,events:16}],7:[function(_dereq_,module,exports){exports.SVGTagMap={altglyph:\"altGlyph\",altglyphdef:\"altGlyphDef\",altglyphitem:\"altGlyphItem\",animatecolor:\"animateColor\",animatemotion:\"animateMotion\",animatetransform:\"animateTransform\",clippath:\"clipPath\",feblend:\"feBlend\",fecolormatrix:\"feColorMatrix\",fecomponenttransfer:\"feComponentTransfer\",fecomposite:\"feComposite\",feconvolvematrix:\"feConvolveMatrix\",fediffuselighting:\"feDiffuseLighting\",fedisplacementmap:\"feDisplacementMap\",fedistantlight:\"feDistantLight\",feflood:\"feFlood\",fefunca:\"feFuncA\",fefuncb:\"feFuncB\",fefuncg:\"feFuncG\",fefuncr:\"feFuncR\",fegaussianblur:\"feGaussianBlur\",feimage:\"feImage\",femerge:\"feMerge\",femergenode:\"feMergeNode\",femorphology:\"feMorphology\",feoffset:\"feOffset\",fepointlight:\"fePointLight\",fespecularlighting:\"feSpecularLighting\",fespotlight:\"feSpotLight\",fetile:\"feTile\",feturbulence:\"feTurbulence\",foreignobject:\"foreignObject\",glyphref:\"glyphRef\",lineargradient:\"linearGradient\",radialgradient:\"radialGradient\",textpath:\"textPath\"},exports.MATHMLAttributeMap={definitionurl:\"definitionURL\"},exports.SVGAttributeMap={attributename:\"attributeName\",attributetype:\"attributeType\",basefrequency:\"baseFrequency\",baseprofile:\"baseProfile\",calcmode:\"calcMode\",clippathunits:\"clipPathUnits\",contentscripttype:\"contentScriptType\",contentstyletype:\"contentStyleType\",diffuseconstant:\"diffuseConstant\",edgemode:\"edgeMode\",externalresourcesacequired:\"externalResourcesRequired\",filterres:\"filterRes\",filterunits:\"filterUnits\",glyphref:\"glyphRef\",gradienttransform:\"gradientTransform\",gradientunits:\"gradientUnits\",kernelmatrix:\"kernelMatrix\",kernelunitlength:\"kernelUnitLength\",keypoints:\"keyPoints\",keysplines:\"keySplines\",keytimes:\"keyTimes\",lengthadjust:\"lengthAdjust\",limitingconeangle:\"limitingConeAngle\",markerheight:\"markerHeight\",markerunits:\"markerUnits\",markerwidth:\"markerWidth\",maskcontentunits:\"maskContentUnits\",maskunits:\"maskUnits\",numoctaves:\"numOctaves\",pathlength:\"pathLength\",patterncontentunits:\"patternContentUnits\",patterntransform:\"patternTransform\",patternunits:\"patternUnits\",pointsatx:\"pointsAtX\",pointsaty:\"pointsAtY\",pointsatz:\"pointsAtZ\",preservealpha:\"preserveAlpha\",preserveaspectratio:\"preserveAspectRatio\",primitiveunits:\"primitiveUnits\",refx:\"refX\",refy:\"refY\",repeatcount:\"repeatCount\",repeatdur:\"repeatDur\",acequiredextensions:\"acequiredExtensions\",acequiredfeatures:\"acequiredFeatures\",specularconstant:\"specularConstant\",specularexponent:\"specularExponent\",spreadmethod:\"spreadMethod\",startoffset:\"startOffset\",stddeviation:\"stdDeviation\",stitchtiles:\"stitchTiles\",surfacescale:\"surfaceScale\",systemlanguage:\"systemLanguage\",tablevalues:\"tableValues\",targetx:\"targetX\",targety:\"targetY\",textlength:\"textLength\",viewbox:\"viewBox\",viewtarget:\"viewTarget\",xchannelselector:\"xChannelSelector\",ychannelselector:\"yChannelSelector\",zoomandpan:\"zoomAndPan\"},exports.ForeignAttributeMap={\"xlink:actuate\":{prefix:\"xlink\",localName:\"actuate\",namespaceURI:\"http://www.w3.org/1999/xlink\"},\"xlink:arcrole\":{prefix:\"xlink\",localName:\"arcrole\",namespaceURI:\"http://www.w3.org/1999/xlink\"},\"xlink:href\":{prefix:\"xlink\",localName:\"href\",namespaceURI:\"http://www.w3.org/1999/xlink\"},\"xlink:role\":{prefix:\"xlink\",localName:\"role\",namespaceURI:\"http://www.w3.org/1999/xlink\"},\"xlink:show\":{prefix:\"xlink\",localName:\"show\",namespaceURI:\"http://www.w3.org/1999/xlink\"},\"xlink:title\":{prefix:\"xlink\",localName:\"title\",namespaceURI:\"http://www.w3.org/1999/xlink\"},\"xlink:type\":{prefix:\"xlink\",localName:\"title\",namespaceURI:\"http://www.w3.org/1999/xlink\"},\"xml:base\":{prefix:\"xml\",localName:\"base\",namespaceURI:\"http://www.w3.org/XML/1998/namespace\"},\"xml:lang\":{prefix:\"xml\",localName:\"lang\",namespaceURI:\"http://www.w3.org/XML/1998/namespace\"},\"xml:space\":{prefix:\"xml\",localName:\"space\",namespaceURI:\"http://www.w3.org/XML/1998/namespace\"},xmlns:{prefix:null,localName:\"xmlns\",namespaceURI:\"http://www.w3.org/2000/xmlns/\"},\"xmlns:xlink\":{prefix:\"xmlns\",localName:\"xlink\",namespaceURI:\"http://www.w3.org/2000/xmlns/\"}}\n},{}],8:[function(_dereq_,module){module.exports={\"null-character\":\"Null character in input stream, replaced with U+FFFD.\",\"invalid-codepoint\":\"Invalid codepoint in stream\",\"incorrectly-placed-solidus\":\"Solidus (/) incorrectly placed in tag.\",\"incorrect-cr-newline-entity\":\"Incorrect CR newline entity, replaced with LF.\",\"illegal-windows-1252-entity\":\"Entity used with illegal number (windows-1252 reference).\",\"cant-convert-numeric-entity\":\"Numeric entity couldn't be converted to character (codepoint U+{charAsInt}).\",\"invalid-numeric-entity-replaced\":\"Numeric entity represents an illegal codepoint. Expanded to the C1 controls range.\",\"numeric-entity-without-semicolon\":\"Numeric entity didn't end with ';'.\",\"expected-numeric-entity-but-got-eof\":\"Numeric entity expected. Got end of file instead.\",\"expected-numeric-entity\":\"Numeric entity expected but none found.\",\"named-entity-without-semicolon\":\"Named entity didn't end with ';'.\",\"expected-named-entity\":\"Named entity expected. Got none.\",\"attributes-in-end-tag\":\"End tag contains unexpected attributes.\",\"self-closing-flag-on-end-tag\":\"End tag contains unexpected self-closing flag.\",\"bare-less-than-sign-at-eof\":\"End of file after <.\",\"expected-tag-name-but-got-right-bracket\":\"Expected tag name. Got '>' instead.\",\"expected-tag-name-but-got-question-mark\":\"Expected tag name. Got '?' instead. (HTML doesn't support processing instructions.)\",\"expected-tag-name\":\"Expected tag name. Got something else instead.\",\"expected-closing-tag-but-got-right-bracket\":\"Expected closing tag. Got '>' instead. Ignoring '</>'.\",\"expected-closing-tag-but-got-eof\":\"Expected closing tag. Unexpected end of file.\",\"expected-closing-tag-but-got-char\":\"Expected closing tag. Unexpected character '{data}' found.\",\"eof-in-tag-name\":\"Unexpected end of file in the tag name.\",\"expected-attribute-name-but-got-eof\":\"Unexpected end of file. Expected attribute name instead.\",\"eof-in-attribute-name\":\"Unexpected end of file in attribute name.\",\"invalid-character-in-attribute-name\":\"Invalid character in attribute name.\",\"duplicate-attribute\":\"Dropped duplicate attribute '{name}' on tag.\",\"expected-end-of-tag-but-got-eof\":\"Unexpected end of file. Expected = or end of tag.\",\"expected-attribute-value-but-got-eof\":\"Unexpected end of file. Expected attribute value.\",\"expected-attribute-value-but-got-right-bracket\":\"Expected attribute value. Got '>' instead.\",\"unexpected-character-in-unquoted-attribute-value\":\"Unexpected character in unquoted attribute\",\"invalid-character-after-attribute-name\":\"Unexpected character after attribute name.\",\"unexpected-character-after-attribute-value\":\"Unexpected character after attribute value.\",\"eof-in-attribute-value-double-quote\":'Unexpected end of file in attribute value (\").',\"eof-in-attribute-value-single-quote\":\"Unexpected end of file in attribute value (').\",\"eof-in-attribute-value-no-quotes\":\"Unexpected end of file in attribute value.\",\"eof-after-attribute-value\":\"Unexpected end of file after attribute value.\",\"unexpected-eof-after-solidus-in-tag\":\"Unexpected end of file in tag. Expected >.\",\"unexpected-character-after-solidus-in-tag\":\"Unexpected character after / in tag. Expected >.\",\"expected-dashes-or-doctype\":\"Expected '--' or 'DOCTYPE'. Not found.\",\"unexpected-bang-after-double-dash-in-comment\":\"Unexpected ! after -- in comment.\",\"incorrect-comment\":\"Incorrect comment.\",\"eof-in-comment\":\"Unexpected end of file in comment.\",\"eof-in-comment-end-dash\":\"Unexpected end of file in comment (-).\",\"unexpected-dash-after-double-dash-in-comment\":\"Unexpected '-' after '--' found in comment.\",\"eof-in-comment-double-dash\":\"Unexpected end of file in comment (--).\",\"eof-in-comment-end-bang-state\":\"Unexpected end of file in comment.\",\"unexpected-char-in-comment\":\"Unexpected character in comment found.\",\"need-space-after-doctype\":\"No space after literal string 'DOCTYPE'.\",\"expected-doctype-name-but-got-right-bracket\":\"Unexpected > character. Expected DOCTYPE name.\",\"expected-doctype-name-but-got-eof\":\"Unexpected end of file. Expected DOCTYPE name.\",\"eof-in-doctype-name\":\"Unexpected end of file in DOCTYPE name.\",\"eof-in-doctype\":\"Unexpected end of file in DOCTYPE.\",\"expected-space-or-right-bracket-in-doctype\":\"Expected space or '>'. Got '{data}'.\",\"unexpected-end-of-doctype\":\"Unexpected end of DOCTYPE.\",\"unexpected-char-in-doctype\":\"Unexpected character in DOCTYPE.\",\"eof-in-bogus-doctype\":\"Unexpected end of file in bogus doctype.\",\"eof-in-innerhtml\":\"Unexpected EOF in inner html mode.\",\"unexpected-doctype\":\"Unexpected DOCTYPE. Ignored.\",\"non-html-root\":\"html needs to be the first start tag.\",\"expected-doctype-but-got-eof\":\"Unexpected End of file. Expected DOCTYPE.\",\"unknown-doctype\":\"Erroneous DOCTYPE. Expected <!DOCTYPE html>.\",\"quirky-doctype\":\"Quirky doctype. Expected <!DOCTYPE html>.\",\"almost-standards-doctype\":\"Almost standards mode doctype. Expected <!DOCTYPE html>.\",\"obsolete-doctype\":\"Obsolete doctype. Expected <!DOCTYPE html>.\",\"expected-doctype-but-got-chars\":\"Non-space characters found without seeing a doctype first. Expected e.g. <!DOCTYPE html>.\",\"expected-doctype-but-got-start-tag\":\"Start tag seen without seeing a doctype first. Expected e.g. <!DOCTYPE html>.\",\"expected-doctype-but-got-end-tag\":\"End tag seen without seeing a doctype first. Expected e.g. <!DOCTYPE html>.\",\"end-tag-after-implied-root\":\"Unexpected end tag ({name}) after the (implied) root element.\",\"expected-named-closing-tag-but-got-eof\":\"Unexpected end of file. Expected end tag ({name}).\",\"two-heads-are-not-better-than-one\":\"Unexpected start tag head in existing head. Ignored.\",\"unexpected-end-tag\":\"Unexpected end tag ({name}). Ignored.\",\"unexpected-implied-end-tag\":\"End tag {name} implied, but there were open elements.\",\"unexpected-start-tag-out-of-my-head\":\"Unexpected start tag ({name}) that can be in head. Moved.\",\"unexpected-start-tag\":\"Unexpected start tag ({name}).\",\"missing-end-tag\":\"Missing end tag ({name}).\",\"missing-end-tags\":\"Missing end tags ({name}).\",\"unexpected-start-tag-implies-end-tag\":\"Unexpected start tag ({startName}) implies end tag ({endName}).\",\"unexpected-start-tag-treated-as\":\"Unexpected start tag ({originalName}). Treated as {newName}.\",\"deprecated-tag\":\"Unexpected start tag {name}. Don't use it!\",\"unexpected-start-tag-ignored\":\"Unexpected start tag {name}. Ignored.\",\"expected-one-end-tag-but-got-another\":\"Unexpected end tag ({gotName}). Missing end tag ({expectedName}).\",\"end-tag-too-early\":\"End tag ({name}) seen too early. Expected other end tag.\",\"end-tag-too-early-named\":\"Unexpected end tag ({gotName}). Expected end tag ({expectedName}.\",\"end-tag-too-early-ignored\":\"End tag ({name}) seen too early. Ignored.\",\"adoption-agency-1.1\":\"End tag ({name}) violates step 1, paragraph 1 of the adoption agency algorithm.\",\"adoption-agency-1.2\":\"End tag ({name}) violates step 1, paragraph 2 of the adoption agency algorithm.\",\"adoption-agency-1.3\":\"End tag ({name}) violates step 1, paragraph 3 of the adoption agency algorithm.\",\"adoption-agency-4.4\":\"End tag ({name}) violates step 4, paragraph 4 of the adoption agency algorithm.\",\"unexpected-end-tag-treated-as\":\"Unexpected end tag ({originalName}). Treated as {newName}.\",\"no-end-tag\":\"This element ({name}) has no end tag.\",\"unexpected-implied-end-tag-in-table\":\"Unexpected implied end tag ({name}) in the table phase.\",\"unexpected-implied-end-tag-in-table-body\":\"Unexpected implied end tag ({name}) in the table body phase.\",\"unexpected-char-implies-table-voodoo\":\"Unexpected non-space characters in table context caused voodoo mode.\",\"unexpected-hidden-input-in-table\":\"Unexpected input with type hidden in table context.\",\"unexpected-form-in-table\":\"Unexpected form in table context.\",\"unexpected-start-tag-implies-table-voodoo\":\"Unexpected start tag ({name}) in table context caused voodoo mode.\",\"unexpected-end-tag-implies-table-voodoo\":\"Unexpected end tag ({name}) in table context caused voodoo mode.\",\"unexpected-cell-in-table-body\":\"Unexpected table cell start tag ({name}) in the table body phase.\",\"unexpected-cell-end-tag\":\"Got table cell end tag ({name}) while acequired end tags are missing.\",\"unexpected-end-tag-in-table-body\":\"Unexpected end tag ({name}) in the table body phase. Ignored.\",\"unexpected-implied-end-tag-in-table-row\":\"Unexpected implied end tag ({name}) in the table row phase.\",\"unexpected-end-tag-in-table-row\":\"Unexpected end tag ({name}) in the table row phase. Ignored.\",\"unexpected-select-in-select\":\"Unexpected select start tag in the select phase treated as select end tag.\",\"unexpected-input-in-select\":\"Unexpected input start tag in the select phase.\",\"unexpected-start-tag-in-select\":\"Unexpected start tag token ({name}) in the select phase. Ignored.\",\"unexpected-end-tag-in-select\":\"Unexpected end tag ({name}) in the select phase. Ignored.\",\"unexpected-table-element-start-tag-in-select-in-table\":\"Unexpected table element start tag ({name}) in the select in table phase.\",\"unexpected-table-element-end-tag-in-select-in-table\":\"Unexpected table element end tag ({name}) in the select in table phase.\",\"unexpected-char-after-body\":\"Unexpected non-space characters in the after body phase.\",\"unexpected-start-tag-after-body\":\"Unexpected start tag token ({name}) in the after body phase.\",\"unexpected-end-tag-after-body\":\"Unexpected end tag token ({name}) in the after body phase.\",\"unexpected-char-in-frameset\":\"Unepxected characters in the frameset phase. Characters ignored.\",\"unexpected-start-tag-in-frameset\":\"Unexpected start tag token ({name}) in the frameset phase. Ignored.\",\"unexpected-frameset-in-frameset-innerhtml\":\"Unexpected end tag token (frameset in the frameset phase (innerHTML).\",\"unexpected-end-tag-in-frameset\":\"Unexpected end tag token ({name}) in the frameset phase. Ignored.\",\"unexpected-char-after-frameset\":\"Unexpected non-space characters in the after frameset phase. Ignored.\",\"unexpected-start-tag-after-frameset\":\"Unexpected start tag ({name}) in the after frameset phase. Ignored.\",\"unexpected-end-tag-after-frameset\":\"Unexpected end tag ({name}) in the after frameset phase. Ignored.\",\"expected-eof-but-got-char\":\"Unexpected non-space characters. Expected end of file.\",\"expected-eof-but-got-start-tag\":\"Unexpected start tag ({name}). Expected end of file.\",\"expected-eof-but-got-end-tag\":\"Unexpected end tag ({name}). Expected end of file.\",\"unexpected-end-table-in-caption\":\"Unexpected end table tag in caption. Generates implied end caption.\",\"end-html-in-innerhtml\":\"Unexpected html end tag in inner html mode.\",\"eof-in-table\":\"Unexpected end of file. Expected table content.\",\"eof-in-script\":\"Unexpected end of file. Expected script content.\",\"non-void-element-with-trailing-solidus\":\"Trailing solidus not allowed on element {name}.\",\"unexpected-html-element-in-foreign-content\":'HTML start tag \"{name}\" in a foreign namespace context.',\"unexpected-start-tag-in-table\":\"Unexpected {name}. Expected table content.\"}},{}],9:[function(_dereq_,module,exports){function SAXParser(){this.contentHandler=null,this._errorHandler=null,this._treeBuilder=new SAXTreeBuilder,this._tokenizer=new Tokenizer(this._treeBuilder),this._scriptingEnabled=!1}var SAXTreeBuilder=_dereq_(\"./SAXTreeBuilder\").SAXTreeBuilder,Tokenizer=_dereq_(\"../Tokenizer\").Tokenizer,TreeParser=_dereq_(\"./TreeParser\").TreeParser;SAXParser.prototype.parse=function(source){this._tokenizer.tokenize(source);var document=this._treeBuilder.document;document&&new TreeParser(this.contentHandler).parse(document)},SAXParser.prototype.parseFragment=function(source,context){this._treeBuilder.setFragmentContext(context),this._tokenizer.tokenize(source);var fragment=this._treeBuilder.getFragment();fragment&&new TreeParser(this.contentHandler).parse(fragment)},Object.defineProperty(SAXParser.prototype,\"scriptingEnabled\",{get:function(){return this._scriptingEnabled},set:function(value){this._scriptingEnabled=value,this._treeBuilder.scriptingEnabled=value}}),Object.defineProperty(SAXParser.prototype,\"errorHandler\",{get:function(){return this._errorHandler},set:function(value){this._errorHandler=value,this._treeBuilder.errorHandler=value}}),exports.SAXParser=SAXParser},{\"../Tokenizer\":5,\"./SAXTreeBuilder\":10,\"./TreeParser\":11}],10:[function(_dereq_,module,exports){function SAXTreeBuilder(){TreeBuilder.call(this)}function getAttribute(node,name){for(var i=0;node.attributes.length>i;i++){var attribute=node.attributes[i];if(attribute.nodeName===name)return attribute.nodeValue}}function Node(locator){locator?(this.columnNumber=locator.columnNumber,this.lineNumber=locator.lineNumber):(this.columnNumber=-1,this.lineNumber=-1),this.parentNode=null,this.nextSibling=null,this.firstChild=null}function ParentNode(locator){Node.call(this,locator),this.lastChild=null,this._endLocator=null}function Document(locator){ParentNode.call(this,locator),this.nodeType=NodeType.DOCUMENT}function DocumentFragment(){ParentNode.call(this,new Locator),this.nodeType=NodeType.DOCUMENT_FRAGMENT}function Element(locator,uri,localName,qName,atts,prefixMappings){ParentNode.call(this,locator),this.uri=uri,this.localName=localName,this.qName=qName,this.attributes=atts,this.prefixMappings=prefixMappings,this.nodeType=NodeType.ELEMENT}function Characters(locator,data){Node.call(this,locator),this.data=data,this.nodeType=NodeType.CHARACTERS}function IgnorableWhitespace(locator,data){Node.call(this,locator),this.data=data,this.nodeType=NodeType.IGNORABLE_WHITESPACE}function Comment(locator,data){Node.call(this,locator),this.data=data,this.nodeType=NodeType.COMMENT}function CDATA(locator){ParentNode.call(this,locator),this.nodeType=NodeType.CDATA}function Entity(name){ParentNode.call(this),this.name=name,this.nodeType=NodeType.ENTITY}function SkippedEntity(name){Node.call(this),this.name=name,this.nodeType=NodeType.SKIPPED_ENTITY}function ProcessingInstruction(target,data){Node.call(this),this.target=target,this.data=data}function DTD(name,publicIdentifier,systemIdentifier){ParentNode.call(this),this.name=name,this.publicIdentifier=publicIdentifier,this.systemIdentifier=systemIdentifier,this.nodeType=NodeType.DTD}var util=_dereq_(\"util\"),TreeBuilder=_dereq_(\"../TreeBuilder\").TreeBuilder;util.inherits(SAXTreeBuilder,TreeBuilder),SAXTreeBuilder.prototype.start=function(){this.document=new Document(this.tokenizer)},SAXTreeBuilder.prototype.end=function(){this.document.endLocator=this.tokenizer},SAXTreeBuilder.prototype.insertDoctype=function(name,publicId,systemId){var doctype=new DTD(this.tokenizer,name,publicId,systemId);doctype.endLocator=this.tokenizer,this.document.appendChild(doctype)},SAXTreeBuilder.prototype.createElement=function(namespaceURI,localName,attributes){var element=new Element(this.tokenizer,namespaceURI,localName,localName,attributes||[]);return element},SAXTreeBuilder.prototype.insertComment=function(data,parent){parent||(parent=this.currentStackItem());var comment=new Comment(this.tokenizer,data);parent.appendChild(comment)},SAXTreeBuilder.prototype.appendCharacters=function(parent,data){var text=new Characters(this.tokenizer,data);parent.appendChild(text)},SAXTreeBuilder.prototype.insertText=function(data){if(this.redirectAttachToFosterParent&&this.openElements.top.isFosterParenting()){var tableIndex=this.openElements.findIndex(\"table\"),tableItem=this.openElements.item(tableIndex),table=tableItem.node;if(0===tableIndex)return this.appendCharacters(table,data);var text=new Characters(this.tokenizer,data),parent=table.parentNode;if(parent)return parent.insertBetween(text,table.previousSibling,table),void 0;var stackParent=this.openElements.item(tableIndex-1).node;return stackParent.appendChild(text),void 0}this.appendCharacters(this.currentStackItem().node,data)},SAXTreeBuilder.prototype.attachNode=function(node,parent){parent.appendChild(node)},SAXTreeBuilder.prototype.attachNodeToFosterParent=function(child,table,stackParent){var parent=table.parentNode;parent?parent.insertBetween(child,table.previousSibling,table):stackParent.appendChild(child)},SAXTreeBuilder.prototype.detachFromParent=function(element){element.detach()},SAXTreeBuilder.prototype.reparentChildren=function(oldParent,newParent){newParent.appendChildren(oldParent.firstChild)},SAXTreeBuilder.prototype.getFragment=function(){var fragment=new DocumentFragment;return this.reparentChildren(this.openElements.rootNode,fragment),fragment},SAXTreeBuilder.prototype.addAttributesToElement=function(element,attributes){for(var i=0;attributes.length>i;i++){var attribute=attributes[i];getAttribute(element,attribute.nodeName)||element.attributes.push(attribute)}};var NodeType={CDATA:1,CHARACTERS:2,COMMENT:3,DOCUMENT:4,DOCUMENT_FRAGMENT:5,DTD:6,ELEMENT:7,ENTITY:8,IGNORABLE_WHITESPACE:9,PROCESSING_INSTRUCTION:10,SKIPPED_ENTITY:11};Node.prototype.visit=function(){throw Error(\"Not Implemented\")},Node.prototype.revisit=function(){},Node.prototype.detach=function(){null!==this.parentNode&&(this.parentNode.removeChild(this),this.parentNode=null)},Object.defineProperty(Node.prototype,\"previousSibling\",{get:function(){for(var prev=null,next=this.parentNode.firstChild;;){if(this==next)return prev;prev=next,next=next.nextSibling}}}),ParentNode.prototype=Object.create(Node.prototype),ParentNode.prototype.insertBefore=function(child,sibling){if(!sibling)return this.appendChild(child);if(child.detach(),child.parentNode=this,this.firstChild==sibling)child.nextSibling=sibling,this.firstChild=child;else{for(var prev=this.firstChild,next=this.firstChild.nextSibling;next!=sibling;)prev=next,next=next.nextSibling;prev.nextSibling=child,child.nextSibling=next}return child},ParentNode.prototype.insertBetween=function(child,prev,next){return next?(child.detach(),child.parentNode=this,child.nextSibling=next,prev?prev.nextSibling=child:firstChild=child,child):this.appendChild(child)},ParentNode.prototype.appendChild=function(child){return child.detach(),child.parentNode=this,this.firstChild?this.lastChild.nextSibling=child:this.firstChild=child,this.lastChild=child,child},ParentNode.prototype.appendChildren=function(parent){var child=parent.firstChild;if(child){var another=parent;this.firstChild?this.lastChild.nextSibling=child:this.firstChild=child,this.lastChild=another.lastChild;do child.parentNode=this;while(child=child.nextSibling);another.firstChild=null,another.lastChild=null}},ParentNode.prototype.removeChild=function(node){if(this.firstChild==node)this.firstChild=node.nextSibling,this.lastChild==node&&(this.lastChild=null);else{for(var prev=this.firstChild,next=this.firstChild.nextSibling;next!=node;)prev=next,next=next.nextSibling;prev.nextSibling=node.nextSibling,this.lastChild==node&&(this.lastChild=prev)}return node.parentNode=null,node},Object.defineProperty(ParentNode.prototype,\"endLocator\",{get:function(){return this._endLocator},set:function(endLocator){this._endLocator={lineNumber:endLocator.lineNumber,columnNumber:endLocator.columnNumber}}}),Document.prototype=Object.create(ParentNode.prototype),Document.prototype.visit=function(treeParser){treeParser.startDocument(this)},Document.prototype.revisit=function(treeParser){treeParser.endDocument(this.endLocator)},DocumentFragment.prototype=Object.create(ParentNode.prototype),DocumentFragment.prototype.visit=function(){},Element.prototype=Object.create(ParentNode.prototype),Element.prototype.visit=function(treeParser){if(this.prefixMappings)for(var key in prefixMappings){var mapping=prefixMappings[key];treeParser.startPrefixMapping(mapping.getPrefix(),mapping.getUri(),this)}treeParser.startElement(this.uri,this.localName,this.qName,this.attributes,this)},Element.prototype.revisit=function(treeParser){if(treeParser.endElement(this.uri,this.localName,this.qName,this.endLocator),this.prefixMappings)for(var key in prefixMappings){var mapping=prefixMappings[key];treeParser.endPrefixMapping(mapping.getPrefix(),this.endLocator)}},Characters.prototype=Object.create(Node.prototype),Characters.prototype.visit=function(treeParser){treeParser.characters(this.data,0,this.data.length,this)},IgnorableWhitespace.prototype=Object.create(Node.prototype),IgnorableWhitespace.prototype.visit=function(treeParser){treeParser.ignorableWhitespace(this.data,0,this.data.length,this)},Comment.prototype=Object.create(Node.prototype),Comment.prototype.visit=function(treeParser){treeParser.comment(this.data,0,this.data.length,this)},CDATA.prototype=Object.create(ParentNode.prototype),CDATA.prototype.visit=function(treeParser){treeParser.startCDATA(this)},CDATA.prototype.revisit=function(treeParser){treeParser.endCDATA(this.endLocator)},Entity.prototype=Object.create(ParentNode.prototype),Entity.prototype.visit=function(treeParser){treeParser.startEntity(this.name,this)},Entity.prototype.revisit=function(treeParser){treeParser.endEntity(this.name)},SkippedEntity.prototype=Object.create(Node.prototype),SkippedEntity.prototype.visit=function(treeParser){treeParser.skippedEntity(this.name,this)},ProcessingInstruction.prototype=Object.create(Node.prototype),ProcessingInstruction.prototype.visit=function(treeParser){treeParser.processingInstruction(this.target,this.data,this)},ProcessingInstruction.prototype.getNodeType=function(){return NodeType.PROCESSING_INSTRUCTION},DTD.prototype=Object.create(ParentNode.prototype),DTD.prototype.visit=function(treeParser){treeParser.startDTD(this.name,this.publicIdentifier,this.systemIdentifier,this)},DTD.prototype.revisit=function(treeParser){treeParser.endDTD()},exports.SAXTreeBuilder=SAXTreeBuilder},{\"../TreeBuilder\":6,util:20}],11:[function(_dereq_,module,exports){function TreeParser(contentHandler,lexicalHandler){if(this.contentHandler,this.lexicalHandler,this.locatorDelegate,!contentHandler)throw new IllegalArgumentException(\"contentHandler was null.\");this.contentHandler=contentHandler,this.lexicalHandler=lexicalHandler?lexicalHandler:new NullLexicalHandler}function NullLexicalHandler(){}TreeParser.prototype.parse=function(node){this.contentHandler.documentLocator=this;for(var next,current=node;;)if(current.visit(this),next=current.firstChild)current=next;else for(;;){if(current.revisit(this),current==node)return;if(next=current.nextSibling){current=next;break}current=current.parentNode}},TreeParser.prototype.characters=function(ch,start,length,locator){this.locatorDelegate=locator,this.contentHandler.characters(ch,start,length)},TreeParser.prototype.endDocument=function(locator){this.locatorDelegate=locator,this.contentHandler.endDocument()},TreeParser.prototype.endElement=function(uri,localName,qName,locator){this.locatorDelegate=locator,this.contentHandler.endElement(uri,localName,qName)},TreeParser.prototype.endPrefixMapping=function(prefix,locator){this.locatorDelegate=locator,this.contentHandler.endPrefixMapping(prefix)},TreeParser.prototype.ignorableWhitespace=function(ch,start,length,locator){this.locatorDelegate=locator,this.contentHandler.ignorableWhitespace(ch,start,length)},TreeParser.prototype.processingInstruction=function(target,data,locator){this.locatorDelegate=locator,this.contentHandler.processingInstruction(target,data)},TreeParser.prototype.skippedEntity=function(name,locator){this.locatorDelegate=locator,this.contentHandler.skippedEntity(name)},TreeParser.prototype.startDocument=function(locator){this.locatorDelegate=locator,this.contentHandler.startDocument()},TreeParser.prototype.startElement=function(uri,localName,qName,atts,locator){this.locatorDelegate=locator,this.contentHandler.startElement(uri,localName,qName,atts)},TreeParser.prototype.startPrefixMapping=function(prefix,uri,locator){this.locatorDelegate=locator,this.contentHandler.startPrefixMapping(prefix,uri)},TreeParser.prototype.comment=function(ch,start,length,locator){this.locatorDelegate=locator,this.lexicalHandler.comment(ch,start,length)},TreeParser.prototype.endCDATA=function(locator){this.locatorDelegate=locator,this.lexicalHandler.endCDATA()},TreeParser.prototype.endDTD=function(locator){this.locatorDelegate=locator,this.lexicalHandler.endDTD()},TreeParser.prototype.endEntity=function(name,locator){this.locatorDelegate=locator,this.lexicalHandler.endEntity(name)},TreeParser.prototype.startCDATA=function(locator){this.locatorDelegate=locator,this.lexicalHandler.startCDATA()},TreeParser.prototype.startDTD=function(name,publicId,systemId,locator){this.locatorDelegate=locator,this.lexicalHandler.startDTD(name,publicId,systemId)},TreeParser.prototype.startEntity=function(name,locator){this.locatorDelegate=locator,this.lexicalHandler.startEntity(name)},Object.defineProperty(TreeParser.prototype,\"columnNumber\",{get:function(){return this.locatorDelegate?this.locatorDelegate.columnNumber:-1}}),Object.defineProperty(TreeParser.prototype,\"lineNumber\",{get:function(){return this.locatorDelegate?this.locatorDelegate.lineNumber:-1}}),NullLexicalHandler.prototype.comment=function(){},NullLexicalHandler.prototype.endCDATA=function(){},NullLexicalHandler.prototype.endDTD=function(){},NullLexicalHandler.prototype.endEntity=function(){},NullLexicalHandler.prototype.startCDATA=function(){},NullLexicalHandler.prototype.startDTD=function(){},NullLexicalHandler.prototype.startEntity=function(){},exports.TreeParser=TreeParser},{}],12:[function(_dereq_,module){module.exports={\"Aacute;\":\"Á\",Aacute:\"Á\",\"aacute;\":\"á\",aacute:\"á\",\"Abreve;\":\"Ă\",\"abreve;\":\"ă\",\"ac;\":\"∾\",\"acd;\":\"∿\",\"acE;\":\"∾̳\",\"Acirc;\":\"Â\",Acirc:\"Â\",\"acirc;\":\"â\",acirc:\"â\",\"acute;\":\"´\",acute:\"´\",\"Acy;\":\"А\",\"acy;\":\"а\",\"AElig;\":\"Æ\",AElig:\"Æ\",\"aelig;\":\"æ\",aelig:\"æ\",\"af;\":\"⁡\",\"Afr;\":\"𝔄\",\"afr;\":\"𝔞\",\"Agrave;\":\"À\",Agrave:\"À\",\"agrave;\":\"à\",agrave:\"à\",\"alefsym;\":\"ℵ\",\"aleph;\":\"ℵ\",\"Alpha;\":\"Α\",\"alpha;\":\"α\",\"Amacr;\":\"Ā\",\"amacr;\":\"ā\",\"amalg;\":\"⨿\",\"amp;\":\"&\",amp:\"&\",\"AMP;\":\"&\",AMP:\"&\",\"andand;\":\"⩕\",\"And;\":\"⩓\",\"and;\":\"∧\",\"andd;\":\"⩜\",\"andslope;\":\"⩘\",\"andv;\":\"⩚\",\"ang;\":\"∠\",\"ange;\":\"⦤\",\"angle;\":\"∠\",\"angmsdaa;\":\"⦨\",\"angmsdab;\":\"⦩\",\"angmsdac;\":\"⦪\",\"angmsdad;\":\"⦫\",\"angmsdae;\":\"⦬\",\"angmsdaf;\":\"⦭\",\"angmsdag;\":\"⦮\",\"angmsdah;\":\"⦯\",\"angmsd;\":\"∡\",\"angrt;\":\"∟\",\"angrtvb;\":\"⊾\",\"angrtvbd;\":\"⦝\",\"angsph;\":\"∢\",\"angst;\":\"Å\",\"angzarr;\":\"⍼\",\"Aogon;\":\"Ą\",\"aogon;\":\"ą\",\"Aopf;\":\"𝔸\",\"aopf;\":\"𝕒\",\"apacir;\":\"⩯\",\"ap;\":\"≈\",\"apE;\":\"⩰\",\"ape;\":\"≊\",\"apid;\":\"≋\",\"apos;\":\"'\",\"ApplyFunction;\":\"⁡\",\"approx;\":\"≈\",\"approxeq;\":\"≊\",\"Aring;\":\"Å\",Aring:\"Å\",\"aring;\":\"å\",aring:\"å\",\"Ascr;\":\"𝒜\",\"ascr;\":\"𝒶\",\"Assign;\":\"≔\",\"ast;\":\"*\",\"asymp;\":\"≈\",\"asympeq;\":\"≍\",\"Atilde;\":\"Ã\",Atilde:\"Ã\",\"atilde;\":\"ã\",atilde:\"ã\",\"Auml;\":\"Ä\",Auml:\"Ä\",\"auml;\":\"ä\",auml:\"ä\",\"awconint;\":\"∳\",\"awint;\":\"⨑\",\"backcong;\":\"≌\",\"backepsilon;\":\"϶\",\"backprime;\":\"‵\",\"backsim;\":\"∽\",\"backsimeq;\":\"⋍\",\"Backslash;\":\"∖\",\"Barv;\":\"⫧\",\"barvee;\":\"⊽\",\"barwed;\":\"⌅\",\"Barwed;\":\"⌆\",\"barwedge;\":\"⌅\",\"bbrk;\":\"⎵\",\"bbrktbrk;\":\"⎶\",\"bcong;\":\"≌\",\"Bcy;\":\"Б\",\"bcy;\":\"б\",\"bdquo;\":\"„\",\"becaus;\":\"∵\",\"because;\":\"∵\",\"Because;\":\"∵\",\"bemptyv;\":\"⦰\",\"bepsi;\":\"϶\",\"bernou;\":\"ℬ\",\"Bernoullis;\":\"ℬ\",\"Beta;\":\"Β\",\"beta;\":\"β\",\"beth;\":\"ℶ\",\"between;\":\"≬\",\"Bfr;\":\"𝔅\",\"bfr;\":\"𝔟\",\"bigcap;\":\"⋂\",\"bigcirc;\":\"◯\",\"bigcup;\":\"⋃\",\"bigodot;\":\"⨀\",\"bigoplus;\":\"⨁\",\"bigotimes;\":\"⨂\",\"bigsqcup;\":\"⨆\",\"bigstar;\":\"★\",\"bigtriangledown;\":\"▽\",\"bigtriangleup;\":\"△\",\"biguplus;\":\"⨄\",\"bigvee;\":\"⋁\",\"bigwedge;\":\"⋀\",\"bkarow;\":\"⤍\",\"blacklozenge;\":\"⧫\",\"blacksquare;\":\"▪\",\"blacktriangle;\":\"▴\",\"blacktriangledown;\":\"▾\",\"blacktriangleleft;\":\"◂\",\"blacktriangleright;\":\"▸\",\"blank;\":\"␣\",\"blk12;\":\"▒\",\"blk14;\":\"░\",\"blk34;\":\"▓\",\"block;\":\"█\",\"bne;\":\"=⃥\",\"bnequiv;\":\"≡⃥\",\"bNot;\":\"⫭\",\"bnot;\":\"⌐\",\"Bopf;\":\"𝔹\",\"bopf;\":\"𝕓\",\"bot;\":\"⊥\",\"bottom;\":\"⊥\",\"bowtie;\":\"⋈\",\"boxbox;\":\"⧉\",\"boxdl;\":\"┐\",\"boxdL;\":\"╕\",\"boxDl;\":\"╖\",\"boxDL;\":\"╗\",\"boxdr;\":\"┌\",\"boxdR;\":\"╒\",\"boxDr;\":\"╓\",\"boxDR;\":\"╔\",\"boxh;\":\"─\",\"boxH;\":\"═\",\"boxhd;\":\"┬\",\"boxHd;\":\"╤\",\"boxhD;\":\"╥\",\"boxHD;\":\"╦\",\"boxhu;\":\"┴\",\"boxHu;\":\"╧\",\"boxhU;\":\"╨\",\"boxHU;\":\"╩\",\"boxminus;\":\"⊟\",\"boxplus;\":\"⊞\",\"boxtimes;\":\"⊠\",\"boxul;\":\"┘\",\"boxuL;\":\"╛\",\"boxUl;\":\"╜\",\"boxUL;\":\"╝\",\"boxur;\":\"└\",\"boxuR;\":\"╘\",\"boxUr;\":\"╙\",\"boxUR;\":\"╚\",\"boxv;\":\"│\",\"boxV;\":\"║\",\"boxvh;\":\"┼\",\"boxvH;\":\"╪\",\"boxVh;\":\"╫\",\"boxVH;\":\"╬\",\"boxvl;\":\"┤\",\"boxvL;\":\"╡\",\"boxVl;\":\"╢\",\"boxVL;\":\"╣\",\"boxvr;\":\"├\",\"boxvR;\":\"╞\",\"boxVr;\":\"╟\",\"boxVR;\":\"╠\",\"bprime;\":\"‵\",\"breve;\":\"˘\",\"Breve;\":\"˘\",\"brvbar;\":\"¦\",brvbar:\"¦\",\"bscr;\":\"𝒷\",\"Bscr;\":\"ℬ\",\"bsemi;\":\"⁏\",\"bsim;\":\"∽\",\"bsime;\":\"⋍\",\"bsolb;\":\"⧅\",\"bsol;\":\"\\\\\",\"bsolhsub;\":\"⟈\",\"bull;\":\"•\",\"bullet;\":\"•\",\"bump;\":\"≎\",\"bumpE;\":\"⪮\",\"bumpe;\":\"≏\",\"Bumpeq;\":\"≎\",\"bumpeq;\":\"≏\",\"Cacute;\":\"Ć\",\"cacute;\":\"ć\",\"capand;\":\"⩄\",\"capbrcup;\":\"⩉\",\"capcap;\":\"⩋\",\"cap;\":\"∩\",\"Cap;\":\"⋒\",\"capcup;\":\"⩇\",\"capdot;\":\"⩀\",\"CapitalDifferentialD;\":\"ⅅ\",\"caps;\":\"∩︀\",\"caret;\":\"⁁\",\"caron;\":\"ˇ\",\"Cayleys;\":\"ℭ\",\"ccaps;\":\"⩍\",\"Ccaron;\":\"Č\",\"ccaron;\":\"č\",\"Ccedil;\":\"Ç\",Ccedil:\"Ç\",\"ccedil;\":\"ç\",ccedil:\"ç\",\"Ccirc;\":\"Ĉ\",\"ccirc;\":\"ĉ\",\"Cconint;\":\"∰\",\"ccups;\":\"⩌\",\"ccupssm;\":\"⩐\",\"Cdot;\":\"Ċ\",\"cdot;\":\"ċ\",\"cedil;\":\"¸\",cedil:\"¸\",\"Cedilla;\":\"¸\",\"cemptyv;\":\"⦲\",\"cent;\":\"¢\",cent:\"¢\",\"centerdot;\":\"·\",\"CenterDot;\":\"·\",\"cfr;\":\"𝔠\",\"Cfr;\":\"ℭ\",\"CHcy;\":\"Ч\",\"chcy;\":\"ч\",\"check;\":\"✓\",\"checkmark;\":\"✓\",\"Chi;\":\"Χ\",\"chi;\":\"χ\",\"circ;\":\"ˆ\",\"circeq;\":\"≗\",\"circlearrowleft;\":\"↺\",\"circlearrowright;\":\"↻\",\"circledast;\":\"⊛\",\"circledcirc;\":\"⊚\",\"circleddash;\":\"⊝\",\"CircleDot;\":\"⊙\",\"circledR;\":\"®\",\"circledS;\":\"Ⓢ\",\"CircleMinus;\":\"⊖\",\"CirclePlus;\":\"⊕\",\"CircleTimes;\":\"⊗\",\"cir;\":\"○\",\"cirE;\":\"⧃\",\"cire;\":\"≗\",\"cirfnint;\":\"⨐\",\"cirmid;\":\"⫯\",\"cirscir;\":\"⧂\",\"ClockwiseContourIntegral;\":\"∲\",\"CloseCurlyDoubleQuote;\":\"”\",\"CloseCurlyQuote;\":\"’\",\"clubs;\":\"♣\",\"clubsuit;\":\"♣\",\"colon;\":\":\",\"Colon;\":\"∷\",\"Colone;\":\"⩴\",\"colone;\":\"≔\",\"coloneq;\":\"≔\",\"comma;\":\",\",\"commat;\":\"@\",\"comp;\":\"∁\",\"compfn;\":\"∘\",\"complement;\":\"∁\",\"complexes;\":\"ℂ\",\"cong;\":\"≅\",\"congdot;\":\"⩭\",\"Congruent;\":\"≡\",\"conint;\":\"∮\",\"Conint;\":\"∯\",\"ContourIntegral;\":\"∮\",\"copf;\":\"𝕔\",\"Copf;\":\"ℂ\",\"coprod;\":\"∐\",\"Coproduct;\":\"∐\",\"copy;\":\"©\",copy:\"©\",\"COPY;\":\"©\",COPY:\"©\",\"copysr;\":\"℗\",\"CounterClockwiseContourIntegral;\":\"∳\",\"crarr;\":\"↵\",\"cross;\":\"✗\",\"Cross;\":\"⨯\",\"Cscr;\":\"𝒞\",\"cscr;\":\"𝒸\",\"csub;\":\"⫏\",\"csube;\":\"⫑\",\"csup;\":\"⫐\",\"csupe;\":\"⫒\",\"ctdot;\":\"⋯\",\"cudarrl;\":\"⤸\",\"cudarrr;\":\"⤵\",\"cuepr;\":\"⋞\",\"cuesc;\":\"⋟\",\"cularr;\":\"↶\",\"cularrp;\":\"⤽\",\"cupbrcap;\":\"⩈\",\"cupcap;\":\"⩆\",\"CupCap;\":\"≍\",\"cup;\":\"∪\",\"Cup;\":\"⋓\",\"cupcup;\":\"⩊\",\"cupdot;\":\"⊍\",\"cupor;\":\"⩅\",\"cups;\":\"∪︀\",\"curarr;\":\"↷\",\"curarrm;\":\"⤼\",\"curlyeqprec;\":\"⋞\",\"curlyeqsucc;\":\"⋟\",\"curlyvee;\":\"⋎\",\"curlywedge;\":\"⋏\",\"curren;\":\"¤\",curren:\"¤\",\"curvearrowleft;\":\"↶\",\"curvearrowright;\":\"↷\",\"cuvee;\":\"⋎\",\"cuwed;\":\"⋏\",\"cwconint;\":\"∲\",\"cwint;\":\"∱\",\"cylcty;\":\"⌭\",\"dagger;\":\"†\",\"Dagger;\":\"‡\",\"daleth;\":\"ℸ\",\"darr;\":\"↓\",\"Darr;\":\"↡\",\"dArr;\":\"⇓\",\"dash;\":\"‐\",\"Dashv;\":\"⫤\",\"dashv;\":\"⊣\",\"dbkarow;\":\"⤏\",\"dblac;\":\"˝\",\"Dcaron;\":\"Ď\",\"dcaron;\":\"ď\",\"Dcy;\":\"Д\",\"dcy;\":\"д\",\"ddagger;\":\"‡\",\"ddarr;\":\"⇊\",\"DD;\":\"ⅅ\",\"dd;\":\"ⅆ\",\"DDotrahd;\":\"⤑\",\"ddotseq;\":\"⩷\",\"deg;\":\"°\",deg:\"°\",\"Del;\":\"∇\",\"Delta;\":\"Δ\",\"delta;\":\"δ\",\"demptyv;\":\"⦱\",\"dfisht;\":\"⥿\",\"Dfr;\":\"𝔇\",\"dfr;\":\"𝔡\",\"dHar;\":\"⥥\",\"dharl;\":\"⇃\",\"dharr;\":\"⇂\",\"DiacriticalAcute;\":\"´\",\"DiacriticalDot;\":\"˙\",\"DiacriticalDoubleAcute;\":\"˝\",\"DiacriticalGrave;\":\"`\",\"DiacriticalTilde;\":\"˜\",\"diam;\":\"⋄\",\"diamond;\":\"⋄\",\"Diamond;\":\"⋄\",\"diamondsuit;\":\"♦\",\"diams;\":\"♦\",\"die;\":\"¨\",\"DifferentialD;\":\"ⅆ\",\"digamma;\":\"ϝ\",\"disin;\":\"⋲\",\"div;\":\"÷\",\"divide;\":\"÷\",divide:\"÷\",\"divideontimes;\":\"⋇\",\"divonx;\":\"⋇\",\"DJcy;\":\"Ђ\",\"djcy;\":\"ђ\",\"dlcorn;\":\"⌞\",\"dlcrop;\":\"⌍\",\"dollar;\":\"$\",\"Dopf;\":\"𝔻\",\"dopf;\":\"𝕕\",\"Dot;\":\"¨\",\"dot;\":\"˙\",\"DotDot;\":\"⃜\",\"doteq;\":\"≐\",\"doteqdot;\":\"≑\",\"DotEqual;\":\"≐\",\"dotminus;\":\"∸\",\"dotplus;\":\"∔\",\"dotsquare;\":\"⊡\",\"doublebarwedge;\":\"⌆\",\"DoubleContourIntegral;\":\"∯\",\"DoubleDot;\":\"¨\",\"DoubleDownArrow;\":\"⇓\",\"DoubleLeftArrow;\":\"⇐\",\"DoubleLeftRightArrow;\":\"⇔\",\"DoubleLeftTee;\":\"⫤\",\"DoubleLongLeftArrow;\":\"⟸\",\"DoubleLongLeftRightArrow;\":\"⟺\",\"DoubleLongRightArrow;\":\"⟹\",\"DoubleRightArrow;\":\"⇒\",\"DoubleRightTee;\":\"⊨\",\"DoubleUpArrow;\":\"⇑\",\"DoubleUpDownArrow;\":\"⇕\",\"DoubleVerticalBar;\":\"∥\",\"DownArrowBar;\":\"⤓\",\"downarrow;\":\"↓\",\"DownArrow;\":\"↓\",\"Downarrow;\":\"⇓\",\"DownArrowUpArrow;\":\"⇵\",\"DownBreve;\":\"̑\",\"downdownarrows;\":\"⇊\",\"downharpoonleft;\":\"⇃\",\"downharpoonright;\":\"⇂\",\"DownLeftRightVector;\":\"⥐\",\"DownLeftTeeVector;\":\"⥞\",\"DownLeftVectorBar;\":\"⥖\",\"DownLeftVector;\":\"↽\",\"DownRightTeeVector;\":\"⥟\",\"DownRightVectorBar;\":\"⥗\",\"DownRightVector;\":\"⇁\",\"DownTeeArrow;\":\"↧\",\"DownTee;\":\"⊤\",\"drbkarow;\":\"⤐\",\"drcorn;\":\"⌟\",\"drcrop;\":\"⌌\",\"Dscr;\":\"𝒟\",\"dscr;\":\"𝒹\",\"DScy;\":\"Ѕ\",\"dscy;\":\"ѕ\",\"dsol;\":\"⧶\",\"Dstrok;\":\"Đ\",\"dstrok;\":\"đ\",\"dtdot;\":\"⋱\",\"dtri;\":\"▿\",\"dtrif;\":\"▾\",\"duarr;\":\"⇵\",\"duhar;\":\"⥯\",\"dwangle;\":\"⦦\",\"DZcy;\":\"Џ\",\"dzcy;\":\"џ\",\"dzigrarr;\":\"⟿\",\"Eacute;\":\"É\",Eacute:\"É\",\"eacute;\":\"é\",eacute:\"é\",\"easter;\":\"⩮\",\"Ecaron;\":\"Ě\",\"ecaron;\":\"ě\",\"Ecirc;\":\"Ê\",Ecirc:\"Ê\",\"ecirc;\":\"ê\",ecirc:\"ê\",\"ecir;\":\"≖\",\"ecolon;\":\"≕\",\"Ecy;\":\"Э\",\"ecy;\":\"э\",\"eDDot;\":\"⩷\",\"Edot;\":\"Ė\",\"edot;\":\"ė\",\"eDot;\":\"≑\",\"ee;\":\"ⅇ\",\"efDot;\":\"≒\",\"Efr;\":\"𝔈\",\"efr;\":\"𝔢\",\"eg;\":\"⪚\",\"Egrave;\":\"È\",Egrave:\"È\",\"egrave;\":\"è\",egrave:\"è\",\"egs;\":\"⪖\",\"egsdot;\":\"⪘\",\"el;\":\"⪙\",\"Element;\":\"∈\",\"elinters;\":\"⏧\",\"ell;\":\"ℓ\",\"els;\":\"⪕\",\"elsdot;\":\"⪗\",\"Emacr;\":\"Ē\",\"emacr;\":\"ē\",\"empty;\":\"∅\",\"emptyset;\":\"∅\",\"EmptySmallSquare;\":\"◻\",\"emptyv;\":\"∅\",\"EmptyVerySmallSquare;\":\"▫\",\"emsp13;\":\" \",\"emsp14;\":\" \",\"emsp;\":\" \",\"ENG;\":\"Ŋ\",\"eng;\":\"ŋ\",\"ensp;\":\" \",\"Eogon;\":\"Ę\",\"eogon;\":\"ę\",\"Eopf;\":\"𝔼\",\"eopf;\":\"𝕖\",\"epar;\":\"⋕\",\"eparsl;\":\"⧣\",\"eplus;\":\"⩱\",\"epsi;\":\"ε\",\"Epsilon;\":\"Ε\",\"epsilon;\":\"ε\",\"epsiv;\":\"ϵ\",\"eqcirc;\":\"≖\",\"eqcolon;\":\"≕\",\"eqsim;\":\"≂\",\"eqslantgtr;\":\"⪖\",\"eqslantless;\":\"⪕\",\"Equal;\":\"⩵\",\"equals;\":\"=\",\"EqualTilde;\":\"≂\",\"equest;\":\"≟\",\"Equilibrium;\":\"⇌\",\"equiv;\":\"≡\",\"equivDD;\":\"⩸\",\"eqvparsl;\":\"⧥\",\"erarr;\":\"⥱\",\"erDot;\":\"≓\",\"escr;\":\"ℯ\",\"Escr;\":\"ℰ\",\"esdot;\":\"≐\",\"Esim;\":\"⩳\",\"esim;\":\"≂\",\"Eta;\":\"Η\",\"eta;\":\"η\",\"ETH;\":\"Ð\",ETH:\"Ð\",\"eth;\":\"ð\",eth:\"ð\",\"Euml;\":\"Ë\",Euml:\"Ë\",\"euml;\":\"ë\",euml:\"ë\",\"euro;\":\"€\",\"excl;\":\"!\",\"exist;\":\"∃\",\"Exists;\":\"∃\",\"expectation;\":\"ℰ\",\"exponentiale;\":\"ⅇ\",\"ExponentialE;\":\"ⅇ\",\"fallingdotseq;\":\"≒\",\"Fcy;\":\"Ф\",\"fcy;\":\"ф\",\"female;\":\"♀\",\"ffilig;\":\"ﬃ\",\"fflig;\":\"ﬀ\",\"ffllig;\":\"ﬄ\",\"Ffr;\":\"𝔉\",\"ffr;\":\"𝔣\",\"filig;\":\"ﬁ\",\"FilledSmallSquare;\":\"◼\",\"FilledVerySmallSquare;\":\"▪\",\"fjlig;\":\"fj\",\"flat;\":\"♭\",\"fllig;\":\"ﬂ\",\"fltns;\":\"▱\",\"fnof;\":\"ƒ\",\"Fopf;\":\"𝔽\",\"fopf;\":\"𝕗\",\"forall;\":\"∀\",\"ForAll;\":\"∀\",\"fork;\":\"⋔\",\"forkv;\":\"⫙\",\"Fouriertrf;\":\"ℱ\",\"fpartint;\":\"⨍\",\"frac12;\":\"½\",frac12:\"½\",\"frac13;\":\"⅓\",\"frac14;\":\"¼\",frac14:\"¼\",\"frac15;\":\"⅕\",\"frac16;\":\"⅙\",\"frac18;\":\"⅛\",\"frac23;\":\"⅔\",\"frac25;\":\"⅖\",\"frac34;\":\"¾\",frac34:\"¾\",\"frac35;\":\"⅗\",\"frac38;\":\"⅜\",\"frac45;\":\"⅘\",\"frac56;\":\"⅚\",\"frac58;\":\"⅝\",\"frac78;\":\"⅞\",\"frasl;\":\"⁄\",\"frown;\":\"⌢\",\"fscr;\":\"𝒻\",\"Fscr;\":\"ℱ\",\"gacute;\":\"ǵ\",\"Gamma;\":\"Γ\",\"gamma;\":\"γ\",\"Gammad;\":\"Ϝ\",\"gammad;\":\"ϝ\",\"gap;\":\"⪆\",\"Gbreve;\":\"Ğ\",\"gbreve;\":\"ğ\",\"Gcedil;\":\"Ģ\",\"Gcirc;\":\"Ĝ\",\"gcirc;\":\"ĝ\",\"Gcy;\":\"Г\",\"gcy;\":\"г\",\"Gdot;\":\"Ġ\",\"gdot;\":\"ġ\",\"ge;\":\"≥\",\"gE;\":\"≧\",\"gEl;\":\"⪌\",\"gel;\":\"⋛\",\"geq;\":\"≥\",\"geqq;\":\"≧\",\"geqslant;\":\"⩾\",\"gescc;\":\"⪩\",\"ges;\":\"⩾\",\"gesdot;\":\"⪀\",\"gesdoto;\":\"⪂\",\"gesdotol;\":\"⪄\",\"gesl;\":\"⋛︀\",\"gesles;\":\"⪔\",\"Gfr;\":\"𝔊\",\"gfr;\":\"𝔤\",\"gg;\":\"≫\",\"Gg;\":\"⋙\",\"ggg;\":\"⋙\",\"gimel;\":\"ℷ\",\"GJcy;\":\"Ѓ\",\"gjcy;\":\"ѓ\",\"gla;\":\"⪥\",\"gl;\":\"≷\",\"glE;\":\"⪒\",\"glj;\":\"⪤\",\"gnap;\":\"⪊\",\"gnapprox;\":\"⪊\",\"gne;\":\"⪈\",\"gnE;\":\"≩\",\"gneq;\":\"⪈\",\"gneqq;\":\"≩\",\"gnsim;\":\"⋧\",\"Gopf;\":\"𝔾\",\"gopf;\":\"𝕘\",\"grave;\":\"`\",\"GreaterEqual;\":\"≥\",\"GreaterEqualLess;\":\"⋛\",\"GreaterFullEqual;\":\"≧\",\"GreaterGreater;\":\"⪢\",\"GreaterLess;\":\"≷\",\"GreaterSlantEqual;\":\"⩾\",\"GreaterTilde;\":\"≳\",\"Gscr;\":\"𝒢\",\"gscr;\":\"ℊ\",\"gsim;\":\"≳\",\"gsime;\":\"⪎\",\"gsiml;\":\"⪐\",\"gtcc;\":\"⪧\",\"gtcir;\":\"⩺\",\"gt;\":\">\",gt:\">\",\"GT;\":\">\",GT:\">\",\"Gt;\":\"≫\",\"gtdot;\":\"⋗\",\"gtlPar;\":\"⦕\",\"gtquest;\":\"⩼\",\"gtrapprox;\":\"⪆\",\"gtrarr;\":\"⥸\",\"gtrdot;\":\"⋗\",\"gtreqless;\":\"⋛\",\"gtreqqless;\":\"⪌\",\"gtrless;\":\"≷\",\"gtrsim;\":\"≳\",\"gvertneqq;\":\"≩︀\",\"gvnE;\":\"≩︀\",\"Hacek;\":\"ˇ\",\"hairsp;\":\" \",\"half;\":\"½\",\"hamilt;\":\"ℋ\",\"HARDcy;\":\"Ъ\",\"hardcy;\":\"ъ\",\"harrcir;\":\"⥈\",\"harr;\":\"↔\",\"hArr;\":\"⇔\",\"harrw;\":\"↭\",\"Hat;\":\"^\",\"hbar;\":\"ℏ\",\"Hcirc;\":\"Ĥ\",\"hcirc;\":\"ĥ\",\"hearts;\":\"♥\",\"heartsuit;\":\"♥\",\"hellip;\":\"…\",\"hercon;\":\"⊹\",\"hfr;\":\"𝔥\",\"Hfr;\":\"ℌ\",\"HilbertSpace;\":\"ℋ\",\"hksearow;\":\"⤥\",\"hkswarow;\":\"⤦\",\"hoarr;\":\"⇿\",\"homtht;\":\"∻\",\"hookleftarrow;\":\"↩\",\"hookrightarrow;\":\"↪\",\"hopf;\":\"𝕙\",\"Hopf;\":\"ℍ\",\"horbar;\":\"―\",\"HorizontalLine;\":\"─\",\"hscr;\":\"𝒽\",\"Hscr;\":\"ℋ\",\"hslash;\":\"ℏ\",\"Hstrok;\":\"Ħ\",\"hstrok;\":\"ħ\",\"HumpDownHump;\":\"≎\",\"HumpEqual;\":\"≏\",\"hybull;\":\"⁃\",\"hyphen;\":\"‐\",\"Iacute;\":\"Í\",Iacute:\"Í\",\"iacute;\":\"í\",iacute:\"í\",\"ic;\":\"⁣\",\"Icirc;\":\"Î\",Icirc:\"Î\",\"icirc;\":\"î\",icirc:\"î\",\"Icy;\":\"И\",\"icy;\":\"и\",\"Idot;\":\"İ\",\"IEcy;\":\"Е\",\"iecy;\":\"е\",\"iexcl;\":\"¡\",iexcl:\"¡\",\"iff;\":\"⇔\",\"ifr;\":\"𝔦\",\"Ifr;\":\"ℑ\",\"Igrave;\":\"Ì\",Igrave:\"Ì\",\"igrave;\":\"ì\",igrave:\"ì\",\"ii;\":\"ⅈ\",\"iiiint;\":\"⨌\",\"iiint;\":\"∭\",\"iinfin;\":\"⧜\",\"iiota;\":\"℩\",\"IJlig;\":\"Ĳ\",\"ijlig;\":\"ĳ\",\"Imacr;\":\"Ī\",\"imacr;\":\"ī\",\"image;\":\"ℑ\",\"ImaginaryI;\":\"ⅈ\",\"imagline;\":\"ℐ\",\"imagpart;\":\"ℑ\",\"imath;\":\"ı\",\"Im;\":\"ℑ\",\"imof;\":\"⊷\",\"imped;\":\"Ƶ\",\"Implies;\":\"⇒\",\"incare;\":\"℅\",\"in;\":\"∈\",\"infin;\":\"∞\",\"infintie;\":\"⧝\",\"inodot;\":\"ı\",\"intcal;\":\"⊺\",\"int;\":\"∫\",\"Int;\":\"∬\",\"integers;\":\"ℤ\",\"Integral;\":\"∫\",\"intercal;\":\"⊺\",\"Intersection;\":\"⋂\",\"intlarhk;\":\"⨗\",\"intprod;\":\"⨼\",\"InvisibleComma;\":\"⁣\",\"InvisibleTimes;\":\"⁢\",\"IOcy;\":\"Ё\",\"iocy;\":\"ё\",\"Iogon;\":\"Į\",\"iogon;\":\"į\",\"Iopf;\":\"𝕀\",\"iopf;\":\"𝕚\",\"Iota;\":\"Ι\",\"iota;\":\"ι\",\"iprod;\":\"⨼\",\"iquest;\":\"¿\",iquest:\"¿\",\"iscr;\":\"𝒾\",\"Iscr;\":\"ℐ\",\"isin;\":\"∈\",\"isindot;\":\"⋵\",\"isinE;\":\"⋹\",\"isins;\":\"⋴\",\"isinsv;\":\"⋳\",\"isinv;\":\"∈\",\"it;\":\"⁢\",\"Itilde;\":\"Ĩ\",\"itilde;\":\"ĩ\",\"Iukcy;\":\"І\",\"iukcy;\":\"і\",\"Iuml;\":\"Ï\",Iuml:\"Ï\",\"iuml;\":\"ï\",iuml:\"ï\",\"Jcirc;\":\"Ĵ\",\"jcirc;\":\"ĵ\",\"Jcy;\":\"Й\",\"jcy;\":\"й\",\"Jfr;\":\"𝔍\",\"jfr;\":\"𝔧\",\"jmath;\":\"ȷ\",\"Jopf;\":\"𝕁\",\"jopf;\":\"𝕛\",\"Jscr;\":\"𝒥\",\"jscr;\":\"𝒿\",\"Jsercy;\":\"Ј\",\"jsercy;\":\"ј\",\"Jukcy;\":\"Є\",\"jukcy;\":\"є\",\"Kappa;\":\"Κ\",\"kappa;\":\"κ\",\"kappav;\":\"ϰ\",\"Kcedil;\":\"Ķ\",\"kcedil;\":\"ķ\",\"Kcy;\":\"К\",\"kcy;\":\"к\",\"Kfr;\":\"𝔎\",\"kfr;\":\"𝔨\",\"kgreen;\":\"ĸ\",\"KHcy;\":\"Х\",\"khcy;\":\"х\",\"KJcy;\":\"Ќ\",\"kjcy;\":\"ќ\",\"Kopf;\":\"𝕂\",\"kopf;\":\"𝕜\",\"Kscr;\":\"𝒦\",\"kscr;\":\"𝓀\",\"lAarr;\":\"⇚\",\"Lacute;\":\"Ĺ\",\"lacute;\":\"ĺ\",\"laemptyv;\":\"⦴\",\"lagran;\":\"ℒ\",\"Lambda;\":\"Λ\",\"lambda;\":\"λ\",\"lang;\":\"⟨\",\"Lang;\":\"⟪\",\"langd;\":\"⦑\",\"langle;\":\"⟨\",\"lap;\":\"⪅\",\"Laplacetrf;\":\"ℒ\",\"laquo;\":\"«\",laquo:\"«\",\"larrb;\":\"⇤\",\"larrbfs;\":\"⤟\",\"larr;\":\"←\",\"Larr;\":\"↞\",\"lArr;\":\"⇐\",\"larrfs;\":\"⤝\",\"larrhk;\":\"↩\",\"larrlp;\":\"↫\",\"larrpl;\":\"⤹\",\"larrsim;\":\"⥳\",\"larrtl;\":\"↢\",\"latail;\":\"⤙\",\"lAtail;\":\"⤛\",\"lat;\":\"⪫\",\"late;\":\"⪭\",\"lates;\":\"⪭︀\",\"lbarr;\":\"⤌\",\"lBarr;\":\"⤎\",\"lbbrk;\":\"❲\",\"lbrace;\":\"{\",\"lbrack;\":\"[\",\"lbrke;\":\"⦋\",\"lbrksld;\":\"⦏\",\"lbrkslu;\":\"⦍\",\"Lcaron;\":\"Ľ\",\"lcaron;\":\"ľ\",\"Lcedil;\":\"Ļ\",\"lcedil;\":\"ļ\",\"lceil;\":\"⌈\",\"lcub;\":\"{\",\"Lcy;\":\"Л\",\"lcy;\":\"л\",\"ldca;\":\"⤶\",\"ldquo;\":\"“\",\"ldquor;\":\"„\",\"ldrdhar;\":\"⥧\",\"ldrushar;\":\"⥋\",\"ldsh;\":\"↲\",\"le;\":\"≤\",\"lE;\":\"≦\",\"LeftAngleBracket;\":\"⟨\",\"LeftArrowBar;\":\"⇤\",\"leftarrow;\":\"←\",\"LeftArrow;\":\"←\",\"Leftarrow;\":\"⇐\",\"LeftArrowRightArrow;\":\"⇆\",\"leftarrowtail;\":\"↢\",\"LeftCeiling;\":\"⌈\",\"LeftDoubleBracket;\":\"⟦\",\"LeftDownTeeVector;\":\"⥡\",\"LeftDownVectorBar;\":\"⥙\",\"LeftDownVector;\":\"⇃\",\"LeftFloor;\":\"⌊\",\"leftharpoondown;\":\"↽\",\"leftharpoonup;\":\"↼\",\"leftleftarrows;\":\"⇇\",\"leftrightarrow;\":\"↔\",\"LeftRightArrow;\":\"↔\",\"Leftrightarrow;\":\"⇔\",\"leftrightarrows;\":\"⇆\",\"leftrightharpoons;\":\"⇋\",\"leftrightsquigarrow;\":\"↭\",\"LeftRightVector;\":\"⥎\",\"LeftTeeArrow;\":\"↤\",\"LeftTee;\":\"⊣\",\"LeftTeeVector;\":\"⥚\",\"leftthreetimes;\":\"⋋\",\"LeftTriangleBar;\":\"⧏\",\"LeftTriangle;\":\"⊲\",\"LeftTriangleEqual;\":\"⊴\",\"LeftUpDownVector;\":\"⥑\",\"LeftUpTeeVector;\":\"⥠\",\"LeftUpVectorBar;\":\"⥘\",\"LeftUpVector;\":\"↿\",\"LeftVectorBar;\":\"⥒\",\"LeftVector;\":\"↼\",\"lEg;\":\"⪋\",\"leg;\":\"⋚\",\"leq;\":\"≤\",\"leqq;\":\"≦\",\"leqslant;\":\"⩽\",\"lescc;\":\"⪨\",\"les;\":\"⩽\",\"lesdot;\":\"⩿\",\"lesdoto;\":\"⪁\",\"lesdotor;\":\"⪃\",\"lesg;\":\"⋚︀\",\"lesges;\":\"⪓\",\"lessapprox;\":\"⪅\",\"lessdot;\":\"⋖\",\"lesseqgtr;\":\"⋚\",\"lesseqqgtr;\":\"⪋\",\"LessEqualGreater;\":\"⋚\",\"LessFullEqual;\":\"≦\",\"LessGreater;\":\"≶\",\"lessgtr;\":\"≶\",\"LessLess;\":\"⪡\",\"lesssim;\":\"≲\",\"LessSlantEqual;\":\"⩽\",\"LessTilde;\":\"≲\",\"lfisht;\":\"⥼\",\"lfloor;\":\"⌊\",\"Lfr;\":\"𝔏\",\"lfr;\":\"𝔩\",\"lg;\":\"≶\",\"lgE;\":\"⪑\",\"lHar;\":\"⥢\",\"lhard;\":\"↽\",\"lharu;\":\"↼\",\"lharul;\":\"⥪\",\"lhblk;\":\"▄\",\"LJcy;\":\"Љ\",\"ljcy;\":\"љ\",\"llarr;\":\"⇇\",\"ll;\":\"≪\",\"Ll;\":\"⋘\",\"llcorner;\":\"⌞\",\"Lleftarrow;\":\"⇚\",\"llhard;\":\"⥫\",\"lltri;\":\"◺\",\"Lmidot;\":\"Ŀ\",\"lmidot;\":\"ŀ\",\"lmoustache;\":\"⎰\",\"lmoust;\":\"⎰\",\"lnap;\":\"⪉\",\"lnapprox;\":\"⪉\",\"lne;\":\"⪇\",\"lnE;\":\"≨\",\"lneq;\":\"⪇\",\"lneqq;\":\"≨\",\"lnsim;\":\"⋦\",\"loang;\":\"⟬\",\"loarr;\":\"⇽\",\"lobrk;\":\"⟦\",\"longleftarrow;\":\"⟵\",\"LongLeftArrow;\":\"⟵\",\"Longleftarrow;\":\"⟸\",\"longleftrightarrow;\":\"⟷\",\"LongLeftRightArrow;\":\"⟷\",\"Longleftrightarrow;\":\"⟺\",\"longmapsto;\":\"⟼\",\"longrightarrow;\":\"⟶\",\"LongRightArrow;\":\"⟶\",\"Longrightarrow;\":\"⟹\",\"looparrowleft;\":\"↫\",\"looparrowright;\":\"↬\",\"lopar;\":\"⦅\",\"Lopf;\":\"𝕃\",\"lopf;\":\"𝕝\",\"loplus;\":\"⨭\",\"lotimes;\":\"⨴\",\"lowast;\":\"∗\",\"lowbar;\":\"_\",\"LowerLeftArrow;\":\"↙\",\"LowerRightArrow;\":\"↘\",\"loz;\":\"◊\",\"lozenge;\":\"◊\",\"lozf;\":\"⧫\",\"lpar;\":\"(\",\"lparlt;\":\"⦓\",\"lrarr;\":\"⇆\",\"lrcorner;\":\"⌟\",\"lrhar;\":\"⇋\",\"lrhard;\":\"⥭\",\"lrm;\":\"‎\",\"lrtri;\":\"⊿\",\"lsaquo;\":\"‹\",\"lscr;\":\"𝓁\",\"Lscr;\":\"ℒ\",\"lsh;\":\"↰\",\"Lsh;\":\"↰\",\"lsim;\":\"≲\",\"lsime;\":\"⪍\",\"lsimg;\":\"⪏\",\"lsqb;\":\"[\",\"lsquo;\":\"‘\",\"lsquor;\":\"‚\",\"Lstrok;\":\"Ł\",\"lstrok;\":\"ł\",\"ltcc;\":\"⪦\",\"ltcir;\":\"⩹\",\"lt;\":\"<\",lt:\"<\",\"LT;\":\"<\",LT:\"<\",\"Lt;\":\"≪\",\"ltdot;\":\"⋖\",\"lthree;\":\"⋋\",\"ltimes;\":\"⋉\",\"ltlarr;\":\"⥶\",\"ltquest;\":\"⩻\",\"ltri;\":\"◃\",\"ltrie;\":\"⊴\",\"ltrif;\":\"◂\",\"ltrPar;\":\"⦖\",\"lurdshar;\":\"⥊\",\"luruhar;\":\"⥦\",\"lvertneqq;\":\"≨︀\",\"lvnE;\":\"≨︀\",\"macr;\":\"¯\",macr:\"¯\",\"male;\":\"♂\",\"malt;\":\"✠\",\"maltese;\":\"✠\",\"Map;\":\"⤅\",\"map;\":\"↦\",\"mapsto;\":\"↦\",\"mapstodown;\":\"↧\",\"mapstoleft;\":\"↤\",\"mapstoup;\":\"↥\",\"marker;\":\"▮\",\"mcomma;\":\"⨩\",\"Mcy;\":\"М\",\"mcy;\":\"м\",\"mdash;\":\"—\",\"mDDot;\":\"∺\",\"measuredangle;\":\"∡\",\"MediumSpace;\":\" \",\"Mellintrf;\":\"ℳ\",\"Mfr;\":\"𝔐\",\"mfr;\":\"𝔪\",\"mho;\":\"℧\",\"micro;\":\"µ\",micro:\"µ\",\"midast;\":\"*\",\"midcir;\":\"⫰\",\"mid;\":\"∣\",\"middot;\":\"·\",middot:\"·\",\"minusb;\":\"⊟\",\"minus;\":\"−\",\"minusd;\":\"∸\",\"minusdu;\":\"⨪\",\"MinusPlus;\":\"∓\",\"mlcp;\":\"⫛\",\"mldr;\":\"…\",\"mnplus;\":\"∓\",\"models;\":\"⊧\",\"Mopf;\":\"𝕄\",\"mopf;\":\"𝕞\",\"mp;\":\"∓\",\"mscr;\":\"𝓂\",\"Mscr;\":\"ℳ\",\"mstpos;\":\"∾\",\"Mu;\":\"Μ\",\"mu;\":\"μ\",\"multimap;\":\"⊸\",\"mumap;\":\"⊸\",\"nabla;\":\"∇\",\"Nacute;\":\"Ń\",\"nacute;\":\"ń\",\"nang;\":\"∠⃒\",\"nap;\":\"≉\",\"napE;\":\"⩰̸\",\"napid;\":\"≋̸\",\"napos;\":\"ŉ\",\"napprox;\":\"≉\",\"natural;\":\"♮\",\"naturals;\":\"ℕ\",\"natur;\":\"♮\",\"nbsp;\":\" \",nbsp:\" \",\"nbump;\":\"≎̸\",\"nbumpe;\":\"≏̸\",\"ncap;\":\"⩃\",\"Ncaron;\":\"Ň\",\"ncaron;\":\"ň\",\"Ncedil;\":\"Ņ\",\"ncedil;\":\"ņ\",\"ncong;\":\"≇\",\"ncongdot;\":\"⩭̸\",\"ncup;\":\"⩂\",\"Ncy;\":\"Н\",\"ncy;\":\"н\",\"ndash;\":\"–\",\"nearhk;\":\"⤤\",\"nearr;\":\"↗\",\"neArr;\":\"⇗\",\"nearrow;\":\"↗\",\"ne;\":\"≠\",\"nedot;\":\"≐̸\",\"NegativeMediumSpace;\":\"​\",\"NegativeThickSpace;\":\"​\",\"NegativeThinSpace;\":\"​\",\"NegativeVeryThinSpace;\":\"​\",\"nequiv;\":\"≢\",\"nesear;\":\"⤨\",\"nesim;\":\"≂̸\",\"NestedGreaterGreater;\":\"≫\",\"NestedLessLess;\":\"≪\",\"NewLine;\":\"\\n\",\"nexist;\":\"∄\",\"nexists;\":\"∄\",\"Nfr;\":\"𝔑\",\"nfr;\":\"𝔫\",\"ngE;\":\"≧̸\",\"nge;\":\"≱\",\"ngeq;\":\"≱\",\"ngeqq;\":\"≧̸\",\"ngeqslant;\":\"⩾̸\",\"nges;\":\"⩾̸\",\"nGg;\":\"⋙̸\",\"ngsim;\":\"≵\",\"nGt;\":\"≫⃒\",\"ngt;\":\"≯\",\"ngtr;\":\"≯\",\"nGtv;\":\"≫̸\",\"nharr;\":\"↮\",\"nhArr;\":\"⇎\",\"nhpar;\":\"⫲\",\"ni;\":\"∋\",\"nis;\":\"⋼\",\"nisd;\":\"⋺\",\"niv;\":\"∋\",\"NJcy;\":\"Њ\",\"njcy;\":\"њ\",\"nlarr;\":\"↚\",\"nlArr;\":\"⇍\",\"nldr;\":\"‥\",\"nlE;\":\"≦̸\",\"nle;\":\"≰\",\"nleftarrow;\":\"↚\",\"nLeftarrow;\":\"⇍\",\"nleftrightarrow;\":\"↮\",\"nLeftrightarrow;\":\"⇎\",\"nleq;\":\"≰\",\"nleqq;\":\"≦̸\",\"nleqslant;\":\"⩽̸\",\"nles;\":\"⩽̸\",\"nless;\":\"≮\",\"nLl;\":\"⋘̸\",\"nlsim;\":\"≴\",\"nLt;\":\"≪⃒\",\"nlt;\":\"≮\",\"nltri;\":\"⋪\",\"nltrie;\":\"⋬\",\"nLtv;\":\"≪̸\",\"nmid;\":\"∤\",\"NoBreak;\":\"⁠\",\"NonBreakingSpace;\":\" \",\"nopf;\":\"𝕟\",\"Nopf;\":\"ℕ\",\"Not;\":\"⫬\",\"not;\":\"¬\",not:\"¬\",\"NotCongruent;\":\"≢\",\"NotCupCap;\":\"≭\",\"NotDoubleVerticalBar;\":\"∦\",\"NotElement;\":\"∉\",\"NotEqual;\":\"≠\",\"NotEqualTilde;\":\"≂̸\",\"NotExists;\":\"∄\",\"NotGreater;\":\"≯\",\"NotGreaterEqual;\":\"≱\",\"NotGreaterFullEqual;\":\"≧̸\",\"NotGreaterGreater;\":\"≫̸\",\"NotGreaterLess;\":\"≹\",\"NotGreaterSlantEqual;\":\"⩾̸\",\"NotGreaterTilde;\":\"≵\",\"NotHumpDownHump;\":\"≎̸\",\"NotHumpEqual;\":\"≏̸\",\"notin;\":\"∉\",\"notindot;\":\"⋵̸\",\"notinE;\":\"⋹̸\",\"notinva;\":\"∉\",\"notinvb;\":\"⋷\",\"notinvc;\":\"⋶\",\"NotLeftTriangleBar;\":\"⧏̸\",\"NotLeftTriangle;\":\"⋪\",\"NotLeftTriangleEqual;\":\"⋬\",\"NotLess;\":\"≮\",\"NotLessEqual;\":\"≰\",\"NotLessGreater;\":\"≸\",\"NotLessLess;\":\"≪̸\",\"NotLessSlantEqual;\":\"⩽̸\",\"NotLessTilde;\":\"≴\",\"NotNestedGreaterGreater;\":\"⪢̸\",\"NotNestedLessLess;\":\"⪡̸\",\"notni;\":\"∌\",\"notniva;\":\"∌\",\"notnivb;\":\"⋾\",\"notnivc;\":\"⋽\",\"NotPrecedes;\":\"⊀\",\"NotPrecedesEqual;\":\"⪯̸\",\"NotPrecedesSlantEqual;\":\"⋠\",\"NotReverseElement;\":\"∌\",\"NotRightTriangleBar;\":\"⧐̸\",\"NotRightTriangle;\":\"⋫\",\"NotRightTriangleEqual;\":\"⋭\",\"NotSquareSubset;\":\"⊏̸\",\"NotSquareSubsetEqual;\":\"⋢\",\"NotSquareSuperset;\":\"⊐̸\",\"NotSquareSupersetEqual;\":\"⋣\",\"NotSubset;\":\"⊂⃒\",\"NotSubsetEqual;\":\"⊈\",\"NotSucceeds;\":\"⊁\",\"NotSucceedsEqual;\":\"⪰̸\",\"NotSucceedsSlantEqual;\":\"⋡\",\"NotSucceedsTilde;\":\"≿̸\",\"NotSuperset;\":\"⊃⃒\",\"NotSupersetEqual;\":\"⊉\",\"NotTilde;\":\"≁\",\"NotTildeEqual;\":\"≄\",\"NotTildeFullEqual;\":\"≇\",\"NotTildeTilde;\":\"≉\",\"NotVerticalBar;\":\"∤\",\"nparallel;\":\"∦\",\"npar;\":\"∦\",\"nparsl;\":\"⫽⃥\",\"npart;\":\"∂̸\",\"npolint;\":\"⨔\",\"npr;\":\"⊀\",\"nprcue;\":\"⋠\",\"nprec;\":\"⊀\",\"npreceq;\":\"⪯̸\",\"npre;\":\"⪯̸\",\"nrarrc;\":\"⤳̸\",\"nrarr;\":\"↛\",\"nrArr;\":\"⇏\",\"nrarrw;\":\"↝̸\",\"nrightarrow;\":\"↛\",\"nRightarrow;\":\"⇏\",\"nrtri;\":\"⋫\",\"nrtrie;\":\"⋭\",\"nsc;\":\"⊁\",\"nsccue;\":\"⋡\",\"nsce;\":\"⪰̸\",\"Nscr;\":\"𝒩\",\"nscr;\":\"𝓃\",\"nshortmid;\":\"∤\",\"nshortparallel;\":\"∦\",\"nsim;\":\"≁\",\"nsime;\":\"≄\",\"nsimeq;\":\"≄\",\"nsmid;\":\"∤\",\"nspar;\":\"∦\",\"nsqsube;\":\"⋢\",\"nsqsupe;\":\"⋣\",\"nsub;\":\"⊄\",\"nsubE;\":\"⫅̸\",\"nsube;\":\"⊈\",\"nsubset;\":\"⊂⃒\",\"nsubseteq;\":\"⊈\",\"nsubseteqq;\":\"⫅̸\",\"nsucc;\":\"⊁\",\"nsucceq;\":\"⪰̸\",\"nsup;\":\"⊅\",\"nsupE;\":\"⫆̸\",\"nsupe;\":\"⊉\",\"nsupset;\":\"⊃⃒\",\"nsupseteq;\":\"⊉\",\"nsupseteqq;\":\"⫆̸\",\"ntgl;\":\"≹\",\"Ntilde;\":\"Ñ\",Ntilde:\"Ñ\",\"ntilde;\":\"ñ\",ntilde:\"ñ\",\"ntlg;\":\"≸\",\"ntriangleleft;\":\"⋪\",\"ntrianglelefteq;\":\"⋬\",\"ntriangleright;\":\"⋫\",\"ntrianglerighteq;\":\"⋭\",\"Nu;\":\"Ν\",\"nu;\":\"ν\",\"num;\":\"#\",\"numero;\":\"№\",\"numsp;\":\" \",\"nvap;\":\"≍⃒\",\"nvdash;\":\"⊬\",\"nvDash;\":\"⊭\",\"nVdash;\":\"⊮\",\"nVDash;\":\"⊯\",\"nvge;\":\"≥⃒\",\"nvgt;\":\">⃒\",\"nvHarr;\":\"⤄\",\"nvinfin;\":\"⧞\",\"nvlArr;\":\"⤂\",\"nvle;\":\"≤⃒\",\"nvlt;\":\"<⃒\",\"nvltrie;\":\"⊴⃒\",\"nvrArr;\":\"⤃\",\"nvrtrie;\":\"⊵⃒\",\"nvsim;\":\"∼⃒\",\"nwarhk;\":\"⤣\",\"nwarr;\":\"↖\",\"nwArr;\":\"⇖\",\"nwarrow;\":\"↖\",\"nwnear;\":\"⤧\",\"Oacute;\":\"Ó\",Oacute:\"Ó\",\"oacute;\":\"ó\",oacute:\"ó\",\"oast;\":\"⊛\",\"Ocirc;\":\"Ô\",Ocirc:\"Ô\",\"ocirc;\":\"ô\",ocirc:\"ô\",\"ocir;\":\"⊚\",\"Ocy;\":\"О\",\"ocy;\":\"о\",\"odash;\":\"⊝\",\"Odblac;\":\"Ő\",\"odblac;\":\"ő\",\"odiv;\":\"⨸\",\"odot;\":\"⊙\",\"odsold;\":\"⦼\",\"OElig;\":\"Œ\",\"oelig;\":\"œ\",\"ofcir;\":\"⦿\",\"Ofr;\":\"𝔒\",\"ofr;\":\"𝔬\",\"ogon;\":\"˛\",\"Ograve;\":\"Ò\",Ograve:\"Ò\",\"ograve;\":\"ò\",ograve:\"ò\",\"ogt;\":\"⧁\",\"ohbar;\":\"⦵\",\"ohm;\":\"Ω\",\"oint;\":\"∮\",\"olarr;\":\"↺\",\"olcir;\":\"⦾\",\"olcross;\":\"⦻\",\"oline;\":\"‾\",\"olt;\":\"⧀\",\"Omacr;\":\"Ō\",\"omacr;\":\"ō\",\"Omega;\":\"Ω\",\"omega;\":\"ω\",\"Omicron;\":\"Ο\",\"omicron;\":\"ο\",\"omid;\":\"⦶\",\"ominus;\":\"⊖\",\"Oopf;\":\"𝕆\",\"oopf;\":\"𝕠\",\"opar;\":\"⦷\",\"OpenCurlyDoubleQuote;\":\"“\",\"OpenCurlyQuote;\":\"‘\",\"operp;\":\"⦹\",\"oplus;\":\"⊕\",\"orarr;\":\"↻\",\"Or;\":\"⩔\",\"or;\":\"∨\",\"ord;\":\"⩝\",\"order;\":\"ℴ\",\"orderof;\":\"ℴ\",\"ordf;\":\"ª\",ordf:\"ª\",\"ordm;\":\"º\",ordm:\"º\",\"origof;\":\"⊶\",\"oror;\":\"⩖\",\"orslope;\":\"⩗\",\"orv;\":\"⩛\",\"oS;\":\"Ⓢ\",\"Oscr;\":\"𝒪\",\"oscr;\":\"ℴ\",\"Oslash;\":\"Ø\",Oslash:\"Ø\",\"oslash;\":\"ø\",oslash:\"ø\",\"osol;\":\"⊘\",\"Otilde;\":\"Õ\",Otilde:\"Õ\",\"otilde;\":\"õ\",otilde:\"õ\",\"otimesas;\":\"⨶\",\"Otimes;\":\"⨷\",\"otimes;\":\"⊗\",\"Ouml;\":\"Ö\",Ouml:\"Ö\",\"ouml;\":\"ö\",ouml:\"ö\",\"ovbar;\":\"⌽\",\"OverBar;\":\"‾\",\"OverBrace;\":\"⏞\",\"OverBracket;\":\"⎴\",\"OverParenthesis;\":\"⏜\",\"para;\":\"¶\",para:\"¶\",\"parallel;\":\"∥\",\"par;\":\"∥\",\"parsim;\":\"⫳\",\"parsl;\":\"⫽\",\"part;\":\"∂\",\"PartialD;\":\"∂\",\"Pcy;\":\"П\",\"pcy;\":\"п\",\"percnt;\":\"%\",\"period;\":\".\",\"permil;\":\"‰\",\"perp;\":\"⊥\",\"pertenk;\":\"‱\",\"Pfr;\":\"𝔓\",\"pfr;\":\"𝔭\",\"Phi;\":\"Φ\",\"phi;\":\"φ\",\"phiv;\":\"ϕ\",\"phmmat;\":\"ℳ\",\"phone;\":\"☎\",\"Pi;\":\"Π\",\"pi;\":\"π\",\"pitchfork;\":\"⋔\",\"piv;\":\"ϖ\",\"planck;\":\"ℏ\",\"planckh;\":\"ℎ\",\"plankv;\":\"ℏ\",\"plusacir;\":\"⨣\",\"plusb;\":\"⊞\",\"pluscir;\":\"⨢\",\"plus;\":\"+\",\"plusdo;\":\"∔\",\"plusdu;\":\"⨥\",\"pluse;\":\"⩲\",\"PlusMinus;\":\"±\",\"plusmn;\":\"±\",plusmn:\"±\",\"plussim;\":\"⨦\",\"plustwo;\":\"⨧\",\"pm;\":\"±\",\"Poincareplane;\":\"ℌ\",\"pointint;\":\"⨕\",\"popf;\":\"𝕡\",\"Popf;\":\"ℙ\",\"pound;\":\"£\",pound:\"£\",\"prap;\":\"⪷\",\"Pr;\":\"⪻\",\"pr;\":\"≺\",\"prcue;\":\"≼\",\"precapprox;\":\"⪷\",\"prec;\":\"≺\",\"preccurlyeq;\":\"≼\",\"Precedes;\":\"≺\",\"PrecedesEqual;\":\"⪯\",\"PrecedesSlantEqual;\":\"≼\",\"PrecedesTilde;\":\"≾\",\"preceq;\":\"⪯\",\"precnapprox;\":\"⪹\",\"precneqq;\":\"⪵\",\"precnsim;\":\"⋨\",\"pre;\":\"⪯\",\"prE;\":\"⪳\",\"precsim;\":\"≾\",\"prime;\":\"′\",\"Prime;\":\"″\",\"primes;\":\"ℙ\",\"prnap;\":\"⪹\",\"prnE;\":\"⪵\",\"prnsim;\":\"⋨\",\"prod;\":\"∏\",\"Product;\":\"∏\",\"profalar;\":\"⌮\",\"profline;\":\"⌒\",\"profsurf;\":\"⌓\",\"prop;\":\"∝\",\"Proportional;\":\"∝\",\"Proportion;\":\"∷\",\"propto;\":\"∝\",\"prsim;\":\"≾\",\"prurel;\":\"⊰\",\"Pscr;\":\"𝒫\",\"pscr;\":\"𝓅\",\"Psi;\":\"Ψ\",\"psi;\":\"ψ\",\"puncsp;\":\" \",\"Qfr;\":\"𝔔\",\"qfr;\":\"𝔮\",\"qint;\":\"⨌\",\"qopf;\":\"𝕢\",\"Qopf;\":\"ℚ\",\"qprime;\":\"⁗\",\"Qscr;\":\"𝒬\",\"qscr;\":\"𝓆\",\"quaternions;\":\"ℍ\",\"quatint;\":\"⨖\",\"quest;\":\"?\",\"questeq;\":\"≟\",\"quot;\":'\"',quot:'\"',\"QUOT;\":'\"',QUOT:'\"',\"rAarr;\":\"⇛\",\"race;\":\"∽̱\",\"Racute;\":\"Ŕ\",\"racute;\":\"ŕ\",\"radic;\":\"√\",\"raemptyv;\":\"⦳\",\"rang;\":\"⟩\",\"Rang;\":\"⟫\",\"rangd;\":\"⦒\",\"range;\":\"⦥\",\"rangle;\":\"⟩\",\"raquo;\":\"»\",raquo:\"»\",\"rarrap;\":\"⥵\",\"rarrb;\":\"⇥\",\"rarrbfs;\":\"⤠\",\"rarrc;\":\"⤳\",\"rarr;\":\"→\",\"Rarr;\":\"↠\",\"rArr;\":\"⇒\",\"rarrfs;\":\"⤞\",\"rarrhk;\":\"↪\",\"rarrlp;\":\"↬\",\"rarrpl;\":\"⥅\",\"rarrsim;\":\"⥴\",\"Rarrtl;\":\"⤖\",\"rarrtl;\":\"↣\",\"rarrw;\":\"↝\",\"ratail;\":\"⤚\",\"rAtail;\":\"⤜\",\"ratio;\":\"∶\",\"rationals;\":\"ℚ\",\"rbarr;\":\"⤍\",\"rBarr;\":\"⤏\",\"RBarr;\":\"⤐\",\"rbbrk;\":\"❳\",\"rbrace;\":\"}\",\"rbrack;\":\"]\",\"rbrke;\":\"⦌\",\"rbrksld;\":\"⦎\",\"rbrkslu;\":\"⦐\",\"Rcaron;\":\"Ř\",\"rcaron;\":\"ř\",\"Rcedil;\":\"Ŗ\",\"rcedil;\":\"ŗ\",\"rceil;\":\"⌉\",\"rcub;\":\"}\",\"Rcy;\":\"Р\",\"rcy;\":\"р\",\"rdca;\":\"⤷\",\"rdldhar;\":\"⥩\",\"rdquo;\":\"”\",\"rdquor;\":\"”\",\"rdsh;\":\"↳\",\"real;\":\"ℜ\",\"realine;\":\"ℛ\",\"realpart;\":\"ℜ\",\"reals;\":\"ℝ\",\"Re;\":\"ℜ\",\"rect;\":\"▭\",\"reg;\":\"®\",reg:\"®\",\"REG;\":\"®\",REG:\"®\",\"ReverseElement;\":\"∋\",\"ReverseEquilibrium;\":\"⇋\",\"ReverseUpEquilibrium;\":\"⥯\",\"rfisht;\":\"⥽\",\"rfloor;\":\"⌋\",\"rfr;\":\"𝔯\",\"Rfr;\":\"ℜ\",\"rHar;\":\"⥤\",\"rhard;\":\"⇁\",\"rharu;\":\"⇀\",\"rharul;\":\"⥬\",\"Rho;\":\"Ρ\",\"rho;\":\"ρ\",\"rhov;\":\"ϱ\",\"RightAngleBracket;\":\"⟩\",\"RightArrowBar;\":\"⇥\",\"rightarrow;\":\"→\",\"RightArrow;\":\"→\",\"Rightarrow;\":\"⇒\",\"RightArrowLeftArrow;\":\"⇄\",\"rightarrowtail;\":\"↣\",\"RightCeiling;\":\"⌉\",\"RightDoubleBracket;\":\"⟧\",\"RightDownTeeVector;\":\"⥝\",\"RightDownVectorBar;\":\"⥕\",\"RightDownVector;\":\"⇂\",\"RightFloor;\":\"⌋\",\"rightharpoondown;\":\"⇁\",\"rightharpoonup;\":\"⇀\",\"rightleftarrows;\":\"⇄\",\"rightleftharpoons;\":\"⇌\",\"rightrightarrows;\":\"⇉\",\"rightsquigarrow;\":\"↝\",\"RightTeeArrow;\":\"↦\",\"RightTee;\":\"⊢\",\"RightTeeVector;\":\"⥛\",\"rightthreetimes;\":\"⋌\",\"RightTriangleBar;\":\"⧐\",\"RightTriangle;\":\"⊳\",\"RightTriangleEqual;\":\"⊵\",\"RightUpDownVector;\":\"⥏\",\"RightUpTeeVector;\":\"⥜\",\"RightUpVectorBar;\":\"⥔\",\"RightUpVector;\":\"↾\",\"RightVectorBar;\":\"⥓\",\"RightVector;\":\"⇀\",\"ring;\":\"˚\",\"risingdotseq;\":\"≓\",\"rlarr;\":\"⇄\",\"rlhar;\":\"⇌\",\"rlm;\":\"‏\",\"rmoustache;\":\"⎱\",\"rmoust;\":\"⎱\",\"rnmid;\":\"⫮\",\"roang;\":\"⟭\",\"roarr;\":\"⇾\",\"robrk;\":\"⟧\",\"ropar;\":\"⦆\",\"ropf;\":\"𝕣\",\"Ropf;\":\"ℝ\",\"roplus;\":\"⨮\",\"rotimes;\":\"⨵\",\"RoundImplies;\":\"⥰\",\"rpar;\":\")\",\"rpargt;\":\"⦔\",\"rppolint;\":\"⨒\",\"rrarr;\":\"⇉\",\"Rrightarrow;\":\"⇛\",\"rsaquo;\":\"›\",\"rscr;\":\"𝓇\",\"Rscr;\":\"ℛ\",\"rsh;\":\"↱\",\"Rsh;\":\"↱\",\"rsqb;\":\"]\",\"rsquo;\":\"’\",\"rsquor;\":\"’\",\"rthree;\":\"⋌\",\"rtimes;\":\"⋊\",\"rtri;\":\"▹\",\"rtrie;\":\"⊵\",\"rtrif;\":\"▸\",\"rtriltri;\":\"⧎\",\"RuleDelayed;\":\"⧴\",\"ruluhar;\":\"⥨\",\"rx;\":\"℞\",\"Sacute;\":\"Ś\",\"sacute;\":\"ś\",\"sbquo;\":\"‚\",\"scap;\":\"⪸\",\"Scaron;\":\"Š\",\"scaron;\":\"š\",\"Sc;\":\"⪼\",\"sc;\":\"≻\",\"sccue;\":\"≽\",\"sce;\":\"⪰\",\"scE;\":\"⪴\",\"Scedil;\":\"Ş\",\"scedil;\":\"ş\",\"Scirc;\":\"Ŝ\",\"scirc;\":\"ŝ\",\"scnap;\":\"⪺\",\"scnE;\":\"⪶\",\"scnsim;\":\"⋩\",\"scpolint;\":\"⨓\",\"scsim;\":\"≿\",\"Scy;\":\"С\",\"scy;\":\"с\",\"sdotb;\":\"⊡\",\"sdot;\":\"⋅\",\"sdote;\":\"⩦\",\"searhk;\":\"⤥\",\"searr;\":\"↘\",\"seArr;\":\"⇘\",\"searrow;\":\"↘\",\"sect;\":\"§\",sect:\"§\",\"semi;\":\";\",\"seswar;\":\"⤩\",\"setminus;\":\"∖\",\"setmn;\":\"∖\",\"sext;\":\"✶\",\"Sfr;\":\"𝔖\",\"sfr;\":\"𝔰\",\"sfrown;\":\"⌢\",\"sharp;\":\"♯\",\"SHCHcy;\":\"Щ\",\"shchcy;\":\"щ\",\"SHcy;\":\"Ш\",\"shcy;\":\"ш\",\"ShortDownArrow;\":\"↓\",\"ShortLeftArrow;\":\"←\",\"shortmid;\":\"∣\",\"shortparallel;\":\"∥\",\"ShortRightArrow;\":\"→\",\"ShortUpArrow;\":\"↑\",\"shy;\":\"­\",shy:\"­\",\"Sigma;\":\"Σ\",\"sigma;\":\"σ\",\"sigmaf;\":\"ς\",\"sigmav;\":\"ς\",\"sim;\":\"∼\",\"simdot;\":\"⩪\",\"sime;\":\"≃\",\"simeq;\":\"≃\",\"simg;\":\"⪞\",\"simgE;\":\"⪠\",\"siml;\":\"⪝\",\"simlE;\":\"⪟\",\"simne;\":\"≆\",\"simplus;\":\"⨤\",\"simrarr;\":\"⥲\",\"slarr;\":\"←\",\"SmallCircle;\":\"∘\",\"smallsetminus;\":\"∖\",\"smashp;\":\"⨳\",\"smeparsl;\":\"⧤\",\"smid;\":\"∣\",\"smile;\":\"⌣\",\"smt;\":\"⪪\",\"smte;\":\"⪬\",\"smtes;\":\"⪬︀\",\"SOFTcy;\":\"Ь\",\"softcy;\":\"ь\",\"solbar;\":\"⌿\",\"solb;\":\"⧄\",\"sol;\":\"/\",\"Sopf;\":\"𝕊\",\"sopf;\":\"𝕤\",\"spades;\":\"♠\",\"spadesuit;\":\"♠\",\"spar;\":\"∥\",\"sqcap;\":\"⊓\",\"sqcaps;\":\"⊓︀\",\"sqcup;\":\"⊔\",\"sqcups;\":\"⊔︀\",\"Sqrt;\":\"√\",\"sqsub;\":\"⊏\",\"sqsube;\":\"⊑\",\"sqsubset;\":\"⊏\",\"sqsubseteq;\":\"⊑\",\"sqsup;\":\"⊐\",\"sqsupe;\":\"⊒\",\"sqsupset;\":\"⊐\",\"sqsupseteq;\":\"⊒\",\"square;\":\"□\",\"Square;\":\"□\",\"SquareIntersection;\":\"⊓\",\"SquareSubset;\":\"⊏\",\"SquareSubsetEqual;\":\"⊑\",\"SquareSuperset;\":\"⊐\",\"SquareSupersetEqual;\":\"⊒\",\"SquareUnion;\":\"⊔\",\"squarf;\":\"▪\",\"squ;\":\"□\",\"squf;\":\"▪\",\"srarr;\":\"→\",\"Sscr;\":\"𝒮\",\"sscr;\":\"𝓈\",\"ssetmn;\":\"∖\",\"ssmile;\":\"⌣\",\"sstarf;\":\"⋆\",\"Star;\":\"⋆\",\"star;\":\"☆\",\"starf;\":\"★\",\"straightepsilon;\":\"ϵ\",\"straightphi;\":\"ϕ\",\"strns;\":\"¯\",\"sub;\":\"⊂\",\"Sub;\":\"⋐\",\"subdot;\":\"⪽\",\"subE;\":\"⫅\",\"sube;\":\"⊆\",\"subedot;\":\"⫃\",\"submult;\":\"⫁\",\"subnE;\":\"⫋\",\"subne;\":\"⊊\",\"subplus;\":\"⪿\",\"subrarr;\":\"⥹\",\"subset;\":\"⊂\",\"Subset;\":\"⋐\",\"subseteq;\":\"⊆\",\"subseteqq;\":\"⫅\",\"SubsetEqual;\":\"⊆\",\"subsetneq;\":\"⊊\",\"subsetneqq;\":\"⫋\",\"subsim;\":\"⫇\",\"subsub;\":\"⫕\",\"subsup;\":\"⫓\",\"succapprox;\":\"⪸\",\"succ;\":\"≻\",\"succcurlyeq;\":\"≽\",\"Succeeds;\":\"≻\",\"SucceedsEqual;\":\"⪰\",\"SucceedsSlantEqual;\":\"≽\",\"SucceedsTilde;\":\"≿\",\"succeq;\":\"⪰\",\"succnapprox;\":\"⪺\",\"succneqq;\":\"⪶\",\"succnsim;\":\"⋩\",\"succsim;\":\"≿\",\"SuchThat;\":\"∋\",\"sum;\":\"∑\",\"Sum;\":\"∑\",\"sung;\":\"♪\",\"sup1;\":\"¹\",sup1:\"¹\",\"sup2;\":\"²\",sup2:\"²\",\"sup3;\":\"³\",sup3:\"³\",\"sup;\":\"⊃\",\"Sup;\":\"⋑\",\"supdot;\":\"⪾\",\"supdsub;\":\"⫘\",\"supE;\":\"⫆\",\"supe;\":\"⊇\",\"supedot;\":\"⫄\",\"Superset;\":\"⊃\",\"SupersetEqual;\":\"⊇\",\"suphsol;\":\"⟉\",\"suphsub;\":\"⫗\",\"suplarr;\":\"⥻\",\"supmult;\":\"⫂\",\"supnE;\":\"⫌\",\"supne;\":\"⊋\",\"supplus;\":\"⫀\",\"supset;\":\"⊃\",\"Supset;\":\"⋑\",\"supseteq;\":\"⊇\",\"supseteqq;\":\"⫆\",\"supsetneq;\":\"⊋\",\"supsetneqq;\":\"⫌\",\"supsim;\":\"⫈\",\"supsub;\":\"⫔\",\"supsup;\":\"⫖\",\"swarhk;\":\"⤦\",\"swarr;\":\"↙\",\"swArr;\":\"⇙\",\"swarrow;\":\"↙\",\"swnwar;\":\"⤪\",\"szlig;\":\"ß\",szlig:\"ß\",\"Tab;\":\"\t\",\"target;\":\"⌖\",\"Tau;\":\"Τ\",\"tau;\":\"τ\",\"tbrk;\":\"⎴\",\"Tcaron;\":\"Ť\",\"tcaron;\":\"ť\",\"Tcedil;\":\"Ţ\",\"tcedil;\":\"ţ\",\"Tcy;\":\"Т\",\"tcy;\":\"т\",\"tdot;\":\"⃛\",\"telrec;\":\"⌕\",\"Tfr;\":\"𝔗\",\"tfr;\":\"𝔱\",\"there4;\":\"∴\",\"therefore;\":\"∴\",\"Therefore;\":\"∴\",\"Theta;\":\"Θ\",\"theta;\":\"θ\",\"thetasym;\":\"ϑ\",\"thetav;\":\"ϑ\",\"thickapprox;\":\"≈\",\"thicksim;\":\"∼\",\"ThickSpace;\":\"  \",\"ThinSpace;\":\" \",\"thinsp;\":\" \",\"thkap;\":\"≈\",\"thksim;\":\"∼\",\"THORN;\":\"Þ\",THORN:\"Þ\",\"thorn;\":\"þ\",thorn:\"þ\",\"tilde;\":\"˜\",\"Tilde;\":\"∼\",\"TildeEqual;\":\"≃\",\"TildeFullEqual;\":\"≅\",\"TildeTilde;\":\"≈\",\"timesbar;\":\"⨱\",\"timesb;\":\"⊠\",\"times;\":\"×\",times:\"×\",\"timesd;\":\"⨰\",\"tint;\":\"∭\",\"toea;\":\"⤨\",\"topbot;\":\"⌶\",\"topcir;\":\"⫱\",\"top;\":\"⊤\",\"Topf;\":\"𝕋\",\"topf;\":\"𝕥\",\"topfork;\":\"⫚\",\"tosa;\":\"⤩\",\"tprime;\":\"‴\",\"trade;\":\"™\",\"TRADE;\":\"™\",\"triangle;\":\"▵\",\"triangledown;\":\"▿\",\"triangleleft;\":\"◃\",\"trianglelefteq;\":\"⊴\",\"triangleq;\":\"≜\",\"triangleright;\":\"▹\",\"trianglerighteq;\":\"⊵\",\"tridot;\":\"◬\",\"trie;\":\"≜\",\"triminus;\":\"⨺\",\"TripleDot;\":\"⃛\",\"triplus;\":\"⨹\",\"trisb;\":\"⧍\",\"tritime;\":\"⨻\",\"trpezium;\":\"⏢\",\"Tscr;\":\"𝒯\",\"tscr;\":\"𝓉\",\"TScy;\":\"Ц\",\"tscy;\":\"ц\",\"TSHcy;\":\"Ћ\",\"tshcy;\":\"ћ\",\"Tstrok;\":\"Ŧ\",\"tstrok;\":\"ŧ\",\"twixt;\":\"≬\",\"twoheadleftarrow;\":\"↞\",\"twoheadrightarrow;\":\"↠\",\"Uacute;\":\"Ú\",Uacute:\"Ú\",\"uacute;\":\"ú\",uacute:\"ú\",\"uarr;\":\"↑\",\"Uarr;\":\"↟\",\"uArr;\":\"⇑\",\"Uarrocir;\":\"⥉\",\"Ubrcy;\":\"Ў\",\"ubrcy;\":\"ў\",\"Ubreve;\":\"Ŭ\",\"ubreve;\":\"ŭ\",\"Ucirc;\":\"Û\",Ucirc:\"Û\",\"ucirc;\":\"û\",ucirc:\"û\",\"Ucy;\":\"У\",\"ucy;\":\"у\",\"udarr;\":\"⇅\",\"Udblac;\":\"Ű\",\"udblac;\":\"ű\",\"udhar;\":\"⥮\",\"ufisht;\":\"⥾\",\"Ufr;\":\"𝔘\",\"ufr;\":\"𝔲\",\"Ugrave;\":\"Ù\",Ugrave:\"Ù\",\"ugrave;\":\"ù\",ugrave:\"ù\",\"uHar;\":\"⥣\",\"uharl;\":\"↿\",\"uharr;\":\"↾\",\"uhblk;\":\"▀\",\"ulcorn;\":\"⌜\",\"ulcorner;\":\"⌜\",\"ulcrop;\":\"⌏\",\"ultri;\":\"◸\",\"Umacr;\":\"Ū\",\"umacr;\":\"ū\",\"uml;\":\"¨\",uml:\"¨\",\"UnderBar;\":\"_\",\"UnderBrace;\":\"⏟\",\"UnderBracket;\":\"⎵\",\"UnderParenthesis;\":\"⏝\",\"Union;\":\"⋃\",\"UnionPlus;\":\"⊎\",\"Uogon;\":\"Ų\",\"uogon;\":\"ų\",\"Uopf;\":\"𝕌\",\"uopf;\":\"𝕦\",\"UpArrowBar;\":\"⤒\",\"uparrow;\":\"↑\",\"UpArrow;\":\"↑\",\"Uparrow;\":\"⇑\",\"UpArrowDownArrow;\":\"⇅\",\"updownarrow;\":\"↕\",\"UpDownArrow;\":\"↕\",\"Updownarrow;\":\"⇕\",\"UpEquilibrium;\":\"⥮\",\"upharpoonleft;\":\"↿\",\"upharpoonright;\":\"↾\",\"uplus;\":\"⊎\",\"UpperLeftArrow;\":\"↖\",\"UpperRightArrow;\":\"↗\",\"upsi;\":\"υ\",\"Upsi;\":\"ϒ\",\"upsih;\":\"ϒ\",\"Upsilon;\":\"Υ\",\"upsilon;\":\"υ\",\"UpTeeArrow;\":\"↥\",\"UpTee;\":\"⊥\",\"upuparrows;\":\"⇈\",\"urcorn;\":\"⌝\",\"urcorner;\":\"⌝\",\"urcrop;\":\"⌎\",\"Uring;\":\"Ů\",\"uring;\":\"ů\",\"urtri;\":\"◹\",\"Uscr;\":\"𝒰\",\"uscr;\":\"𝓊\",\"utdot;\":\"⋰\",\"Utilde;\":\"Ũ\",\"utilde;\":\"ũ\",\"utri;\":\"▵\",\"utrif;\":\"▴\",\"uuarr;\":\"⇈\",\"Uuml;\":\"Ü\",Uuml:\"Ü\",\"uuml;\":\"ü\",uuml:\"ü\",\"uwangle;\":\"⦧\",\"vangrt;\":\"⦜\",\"varepsilon;\":\"ϵ\",\"varkappa;\":\"ϰ\",\"varnothing;\":\"∅\",\"varphi;\":\"ϕ\",\"varpi;\":\"ϖ\",\"varpropto;\":\"∝\",\"varr;\":\"↕\",\"vArr;\":\"⇕\",\"varrho;\":\"ϱ\",\"varsigma;\":\"ς\",\"varsubsetneq;\":\"⊊︀\",\"varsubsetneqq;\":\"⫋︀\",\"varsupsetneq;\":\"⊋︀\",\"varsupsetneqq;\":\"⫌︀\",\"vartheta;\":\"ϑ\",\"vartriangleleft;\":\"⊲\",\"vartriangleright;\":\"⊳\",\"vBar;\":\"⫨\",\"Vbar;\":\"⫫\",\"vBarv;\":\"⫩\",\"Vcy;\":\"В\",\"vcy;\":\"в\",\"vdash;\":\"⊢\",\"vDash;\":\"⊨\",\"Vdash;\":\"⊩\",\"VDash;\":\"⊫\",\"Vdashl;\":\"⫦\",\"veebar;\":\"⊻\",\"vee;\":\"∨\",\"Vee;\":\"⋁\",\"veeeq;\":\"≚\",\"vellip;\":\"⋮\",\"verbar;\":\"|\",\"Verbar;\":\"‖\",\"vert;\":\"|\",\"Vert;\":\"‖\",\"VerticalBar;\":\"∣\",\"VerticalLine;\":\"|\",\"VerticalSeparator;\":\"❘\",\"VerticalTilde;\":\"≀\",\"VeryThinSpace;\":\" \",\"Vfr;\":\"𝔙\",\"vfr;\":\"𝔳\",\"vltri;\":\"⊲\",\"vnsub;\":\"⊂⃒\",\"vnsup;\":\"⊃⃒\",\"Vopf;\":\"𝕍\",\"vopf;\":\"𝕧\",\"vprop;\":\"∝\",\"vrtri;\":\"⊳\",\"Vscr;\":\"𝒱\",\"vscr;\":\"𝓋\",\"vsubnE;\":\"⫋︀\",\"vsubne;\":\"⊊︀\",\"vsupnE;\":\"⫌︀\",\"vsupne;\":\"⊋︀\",\"Vvdash;\":\"⊪\",\"vzigzag;\":\"⦚\",\"Wcirc;\":\"Ŵ\",\"wcirc;\":\"ŵ\",\"wedbar;\":\"⩟\",\"wedge;\":\"∧\",\"Wedge;\":\"⋀\",\"wedgeq;\":\"≙\",\"weierp;\":\"℘\",\"Wfr;\":\"𝔚\",\"wfr;\":\"𝔴\",\"Wopf;\":\"𝕎\",\"wopf;\":\"𝕨\",\"wp;\":\"℘\",\"wr;\":\"≀\",\"wreath;\":\"≀\",\"Wscr;\":\"𝒲\",\"wscr;\":\"𝓌\",\"xcap;\":\"⋂\",\"xcirc;\":\"◯\",\"xcup;\":\"⋃\",\"xdtri;\":\"▽\",\"Xfr;\":\"𝔛\",\"xfr;\":\"𝔵\",\"xharr;\":\"⟷\",\"xhArr;\":\"⟺\",\"Xi;\":\"Ξ\",\"xi;\":\"ξ\",\"xlarr;\":\"⟵\",\"xlArr;\":\"⟸\",\"xmap;\":\"⟼\",\"xnis;\":\"⋻\",\"xodot;\":\"⨀\",\"Xopf;\":\"𝕏\",\"xopf;\":\"𝕩\",\"xoplus;\":\"⨁\",\"xotime;\":\"⨂\",\"xrarr;\":\"⟶\",\"xrArr;\":\"⟹\",\"Xscr;\":\"𝒳\",\"xscr;\":\"𝓍\",\"xsqcup;\":\"⨆\",\"xuplus;\":\"⨄\",\"xutri;\":\"△\",\"xvee;\":\"⋁\",\"xwedge;\":\"⋀\",\"Yacute;\":\"Ý\",Yacute:\"Ý\",\"yacute;\":\"ý\",yacute:\"ý\",\"YAcy;\":\"Я\",\"yacy;\":\"я\",\"Ycirc;\":\"Ŷ\",\"ycirc;\":\"ŷ\",\"Ycy;\":\"Ы\",\"ycy;\":\"ы\",\"yen;\":\"¥\",yen:\"¥\",\"Yfr;\":\"𝔜\",\"yfr;\":\"𝔶\",\"YIcy;\":\"Ї\",\"yicy;\":\"ї\",\"Yopf;\":\"𝕐\",\"yopf;\":\"𝕪\",\"Yscr;\":\"𝒴\",\"yscr;\":\"𝓎\",\"YUcy;\":\"Ю\",\"yucy;\":\"ю\",\"yuml;\":\"ÿ\",yuml:\"ÿ\",\"Yuml;\":\"Ÿ\",\"Zacute;\":\"Ź\",\"zacute;\":\"ź\",\"Zcaron;\":\"Ž\",\"zcaron;\":\"ž\",\"Zcy;\":\"З\",\"zcy;\":\"з\",\"Zdot;\":\"Ż\",\"zdot;\":\"ż\",\"zeetrf;\":\"ℨ\",\"ZeroWidthSpace;\":\"​\",\"Zeta;\":\"Ζ\",\"zeta;\":\"ζ\",\"zfr;\":\"𝔷\",\"Zfr;\":\"ℨ\",\"ZHcy;\":\"Ж\",\"zhcy;\":\"ж\",\"zigrarr;\":\"⇝\",\"zopf;\":\"𝕫\",\"Zopf;\":\"ℤ\",\"Zscr;\":\"𝒵\",\"zscr;\":\"𝓏\",\"zwj;\":\"‍\",\"zwnj;\":\"‌\"}\n},{}],13:[function(_dereq_,module){function replacer(key,value){return util.isUndefined(value)?\"\"+value:!util.isNumber(value)||!isNaN(value)&&isFinite(value)?util.isFunction(value)||util.isRegExp(value)?\"\"+value:value:\"\"+value}function truncate(s,n){return util.isString(s)?n>s.length?s:s.slice(0,n):s}function getMessage(self){return truncate(JSON.stringify(self.actual,replacer),128)+\" \"+self.operator+\" \"+truncate(JSON.stringify(self.expected,replacer),128)}function fail(actual,expected,message,operator,stackStartFunction){throw new assert.AssertionError({message:message,actual:actual,expected:expected,operator:operator,stackStartFunction:stackStartFunction})}function ok(value,message){value||fail(value,!0,message,\"==\",assert.ok)}function _deepEqual(actual,expected){if(actual===expected)return!0;if(util.isBuffer(actual)&&util.isBuffer(expected)){if(actual.length!=expected.length)return!1;for(var i=0;actual.length>i;i++)if(actual[i]!==expected[i])return!1;return!0}return util.isDate(actual)&&util.isDate(expected)?actual.getTime()===expected.getTime():util.isRegExp(actual)&&util.isRegExp(expected)?actual.source===expected.source&&actual.global===expected.global&&actual.multiline===expected.multiline&&actual.lastIndex===expected.lastIndex&&actual.ignoreCase===expected.ignoreCase:util.isObject(actual)||util.isObject(expected)?objEquiv(actual,expected):actual==expected}function isArguments(object){return\"[object Arguments]\"==Object.prototype.toString.call(object)}function objEquiv(a,b){if(util.isNullOrUndefined(a)||util.isNullOrUndefined(b))return!1;if(a.prototype!==b.prototype)return!1;if(isArguments(a))return isArguments(b)?(a=pSlice.call(a),b=pSlice.call(b),_deepEqual(a,b)):!1;try{var key,i,ka=objectKeys(a),kb=objectKeys(b)}catch(e){return!1}if(ka.length!=kb.length)return!1;for(ka.sort(),kb.sort(),i=ka.length-1;i>=0;i--)if(ka[i]!=kb[i])return!1;for(i=ka.length-1;i>=0;i--)if(key=ka[i],!_deepEqual(a[key],b[key]))return!1;return!0}function expectedException(actual,expected){return actual&&expected?\"[object RegExp]\"==Object.prototype.toString.call(expected)?expected.test(actual):actual instanceof expected?!0:expected.call({},actual)===!0?!0:!1:!1}function _throws(shouldThrow,block,expected,message){var actual;util.isString(expected)&&(message=expected,expected=null);try{block()}catch(e){actual=e}if(message=(expected&&expected.name?\" (\"+expected.name+\").\":\".\")+(message?\" \"+message:\".\"),shouldThrow&&!actual&&fail(actual,expected,\"Missing expected exception\"+message),!shouldThrow&&expectedException(actual,expected)&&fail(actual,expected,\"Got unwanted exception\"+message),shouldThrow&&actual&&expected&&!expectedException(actual,expected)||!shouldThrow&&actual)throw actual}var util=_dereq_(\"util/\"),pSlice=Array.prototype.slice,hasOwn=Object.prototype.hasOwnProperty,assert=module.exports=ok;assert.AssertionError=function(options){this.name=\"AssertionError\",this.actual=options.actual,this.expected=options.expected,this.operator=options.operator,options.message?(this.message=options.message,this.generatedMessage=!1):(this.message=getMessage(this),this.generatedMessage=!0);var stackStartFunction=options.stackStartFunction||fail;if(Error.captureStackTrace)Error.captureStackTrace(this,stackStartFunction);else{var err=Error();if(err.stack){var out=err.stack,fn_name=stackStartFunction.name,idx=out.indexOf(\"\\n\"+fn_name);if(idx>=0){var next_line=out.indexOf(\"\\n\",idx+1);out=out.substring(next_line+1)}this.stack=out}}},util.inherits(assert.AssertionError,Error),assert.fail=fail,assert.ok=ok,assert.equal=function(actual,expected,message){actual!=expected&&fail(actual,expected,message,\"==\",assert.equal)},assert.notEqual=function(actual,expected,message){actual==expected&&fail(actual,expected,message,\"!=\",assert.notEqual)},assert.deepEqual=function(actual,expected,message){_deepEqual(actual,expected)||fail(actual,expected,message,\"deepEqual\",assert.deepEqual)},assert.notDeepEqual=function(actual,expected,message){_deepEqual(actual,expected)&&fail(actual,expected,message,\"notDeepEqual\",assert.notDeepEqual)},assert.strictEqual=function(actual,expected,message){actual!==expected&&fail(actual,expected,message,\"===\",assert.strictEqual)},assert.notStrictEqual=function(actual,expected,message){actual===expected&&fail(actual,expected,message,\"!==\",assert.notStrictEqual)},assert.throws=function(){_throws.apply(this,[!0].concat(pSlice.call(arguments)))},assert.doesNotThrow=function(){_throws.apply(this,[!1].concat(pSlice.call(arguments)))},assert.ifError=function(err){if(err)throw err};var objectKeys=Object.keys||function(obj){var keys=[];for(var key in obj)hasOwn.call(obj,key)&&keys.push(key);return keys}},{\"util/\":15}],14:[function(_dereq_,module){module.exports=function(arg){return arg&&\"object\"==typeof arg&&\"function\"==typeof arg.copy&&\"function\"==typeof arg.fill&&\"function\"==typeof arg.readUInt8}},{}],15:[function(_dereq_,module,exports){(function(process,global){function inspect(obj,opts){var ctx={seen:[],stylize:stylizeNoColor};return arguments.length>=3&&(ctx.depth=arguments[2]),arguments.length>=4&&(ctx.colors=arguments[3]),isBoolean(opts)?ctx.showHidden=opts:opts&&exports._extend(ctx,opts),isUndefined(ctx.showHidden)&&(ctx.showHidden=!1),isUndefined(ctx.depth)&&(ctx.depth=2),isUndefined(ctx.colors)&&(ctx.colors=!1),isUndefined(ctx.customInspect)&&(ctx.customInspect=!0),ctx.colors&&(ctx.stylize=stylizeWithColor),formatValue(ctx,obj,ctx.depth)}function stylizeWithColor(str,styleType){var style=inspect.styles[styleType];return style?\"\u001b[\"+inspect.colors[style][0]+\"m\"+str+\"\u001b[\"+inspect.colors[style][1]+\"m\":str}function stylizeNoColor(str){return str}function arrayToHash(array){var hash={};return array.forEach(function(val){hash[val]=!0}),hash}function formatValue(ctx,value,recurseTimes){if(ctx.customInspect&&value&&isFunction(value.inspect)&&value.inspect!==exports.inspect&&(!value.constructor||value.constructor.prototype!==value)){var ret=value.inspect(recurseTimes,ctx);return isString(ret)||(ret=formatValue(ctx,ret,recurseTimes)),ret}var primitive=formatPrimitive(ctx,value);if(primitive)return primitive;var keys=Object.keys(value),visibleKeys=arrayToHash(keys);if(ctx.showHidden&&(keys=Object.getOwnPropertyNames(value)),isError(value)&&(keys.indexOf(\"message\")>=0||keys.indexOf(\"description\")>=0))return formatError(value);if(0===keys.length){if(isFunction(value)){var name=value.name?\": \"+value.name:\"\";return ctx.stylize(\"[Function\"+name+\"]\",\"special\")}if(isRegExp(value))return ctx.stylize(RegExp.prototype.toString.call(value),\"regexp\");if(isDate(value))return ctx.stylize(Date.prototype.toString.call(value),\"date\");if(isError(value))return formatError(value)}var base=\"\",array=!1,braces=[\"{\",\"}\"];if(isArray(value)&&(array=!0,braces=[\"[\",\"]\"]),isFunction(value)){var n=value.name?\": \"+value.name:\"\";base=\" [Function\"+n+\"]\"}if(isRegExp(value)&&(base=\" \"+RegExp.prototype.toString.call(value)),isDate(value)&&(base=\" \"+Date.prototype.toUTCString.call(value)),isError(value)&&(base=\" \"+formatError(value)),0===keys.length&&(!array||0==value.length))return braces[0]+base+braces[1];if(0>recurseTimes)return isRegExp(value)?ctx.stylize(RegExp.prototype.toString.call(value),\"regexp\"):ctx.stylize(\"[Object]\",\"special\");ctx.seen.push(value);var output;return output=array?formatArray(ctx,value,recurseTimes,visibleKeys,keys):keys.map(function(key){return formatProperty(ctx,value,recurseTimes,visibleKeys,key,array)}),ctx.seen.pop(),reduceToSingleString(output,base,braces)}function formatPrimitive(ctx,value){if(isUndefined(value))return ctx.stylize(\"undefined\",\"undefined\");if(isString(value)){var simple=\"'\"+JSON.stringify(value).replace(/^\"|\"$/g,\"\").replace(/'/g,\"\\\\'\").replace(/\\\\\"/g,'\"')+\"'\";return ctx.stylize(simple,\"string\")}return isNumber(value)?ctx.stylize(\"\"+value,\"number\"):isBoolean(value)?ctx.stylize(\"\"+value,\"boolean\"):isNull(value)?ctx.stylize(\"null\",\"null\"):void 0}function formatError(value){return\"[\"+Error.prototype.toString.call(value)+\"]\"}function formatArray(ctx,value,recurseTimes,visibleKeys,keys){for(var output=[],i=0,l=value.length;l>i;++i)hasOwnProperty(value,i+\"\")?output.push(formatProperty(ctx,value,recurseTimes,visibleKeys,i+\"\",!0)):output.push(\"\");return keys.forEach(function(key){key.match(/^\\d+$/)||output.push(formatProperty(ctx,value,recurseTimes,visibleKeys,key,!0))}),output}function formatProperty(ctx,value,recurseTimes,visibleKeys,key,array){var name,str,desc;if(desc=Object.getOwnPropertyDescriptor(value,key)||{value:value[key]},desc.get?str=desc.set?ctx.stylize(\"[Getter/Setter]\",\"special\"):ctx.stylize(\"[Getter]\",\"special\"):desc.set&&(str=ctx.stylize(\"[Setter]\",\"special\")),hasOwnProperty(visibleKeys,key)||(name=\"[\"+key+\"]\"),str||(0>ctx.seen.indexOf(desc.value)?(str=isNull(recurseTimes)?formatValue(ctx,desc.value,null):formatValue(ctx,desc.value,recurseTimes-1),str.indexOf(\"\\n\")>-1&&(str=array?str.split(\"\\n\").map(function(line){return\"  \"+line}).join(\"\\n\").substr(2):\"\\n\"+str.split(\"\\n\").map(function(line){return\"   \"+line}).join(\"\\n\"))):str=ctx.stylize(\"[Circular]\",\"special\")),isUndefined(name)){if(array&&key.match(/^\\d+$/))return str;name=JSON.stringify(\"\"+key),name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)?(name=name.substr(1,name.length-2),name=ctx.stylize(name,\"name\")):(name=name.replace(/'/g,\"\\\\'\").replace(/\\\\\"/g,'\"').replace(/(^\"|\"$)/g,\"'\"),name=ctx.stylize(name,\"string\"))}return name+\": \"+str}function reduceToSingleString(output,base,braces){var numLinesEst=0,length=output.reduce(function(prev,cur){return numLinesEst++,cur.indexOf(\"\\n\")>=0&&numLinesEst++,prev+cur.replace(/\\u001b\\[\\d\\d?m/g,\"\").length+1},0);return length>60?braces[0]+(\"\"===base?\"\":base+\"\\n \")+\" \"+output.join(\",\\n  \")+\" \"+braces[1]:braces[0]+base+\" \"+output.join(\", \")+\" \"+braces[1]}function isArray(ar){return Array.isArray(ar)}function isBoolean(arg){return\"boolean\"==typeof arg}function isNull(arg){return null===arg}function isNullOrUndefined(arg){return null==arg}function isNumber(arg){return\"number\"==typeof arg}function isString(arg){return\"string\"==typeof arg}function isSymbol(arg){return\"symbol\"==typeof arg}function isUndefined(arg){return void 0===arg}function isRegExp(re){return isObject(re)&&\"[object RegExp]\"===objectToString(re)}function isObject(arg){return\"object\"==typeof arg&&null!==arg}function isDate(d){return isObject(d)&&\"[object Date]\"===objectToString(d)}function isError(e){return isObject(e)&&(\"[object Error]\"===objectToString(e)||e instanceof Error)}function isFunction(arg){return\"function\"==typeof arg}function isPrimitive(arg){return null===arg||\"boolean\"==typeof arg||\"number\"==typeof arg||\"string\"==typeof arg||\"symbol\"==typeof arg||arg===void 0}function objectToString(o){return Object.prototype.toString.call(o)}function pad(n){return 10>n?\"0\"+n.toString(10):n.toString(10)}function timestamp(){var d=new Date,time=[pad(d.getHours()),pad(d.getMinutes()),pad(d.getSeconds())].join(\":\");return[d.getDate(),months[d.getMonth()],time].join(\" \")}function hasOwnProperty(obj,prop){return Object.prototype.hasOwnProperty.call(obj,prop)}var formatRegExp=/%[sdj%]/g;exports.format=function(f){if(!isString(f)){for(var objects=[],i=0;arguments.length>i;i++)objects.push(inspect(arguments[i]));return objects.join(\" \")}for(var i=1,args=arguments,len=args.length,str=(f+\"\").replace(formatRegExp,function(x){if(\"%%\"===x)return\"%\";if(i>=len)return x;switch(x){case\"%s\":return args[i++]+\"\";case\"%d\":return Number(args[i++]);case\"%j\":try{return JSON.stringify(args[i++])}catch(_){return\"[Circular]\"}default:return x}}),x=args[i];len>i;x=args[++i])str+=isNull(x)||!isObject(x)?\" \"+x:\" \"+inspect(x);return str},exports.deprecate=function(fn,msg){function deprecated(){if(!warned){if(process.throwDeprecation)throw Error(msg);process.traceDeprecation?console.trace(msg):console.error(msg),warned=!0}return fn.apply(this,arguments)}if(isUndefined(global.process))return function(){return exports.deprecate(fn,msg).apply(this,arguments)};if(process.noDeprecation===!0)return fn;var warned=!1;return deprecated};var debugEnviron,debugs={};exports.debuglog=function(set){if(isUndefined(debugEnviron)&&(debugEnviron=process.env.NODE_DEBUG||\"\"),set=set.toUpperCase(),!debugs[set])if(RegExp(\"\\\\b\"+set+\"\\\\b\",\"i\").test(debugEnviron)){var pid=process.pid;debugs[set]=function(){var msg=exports.format.apply(exports,arguments);console.error(\"%s %d: %s\",set,pid,msg)}}else debugs[set]=function(){};return debugs[set]},exports.inspect=inspect,inspect.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},inspect.styles={special:\"cyan\",number:\"yellow\",\"boolean\":\"yellow\",undefined:\"grey\",\"null\":\"bold\",string:\"green\",date:\"magenta\",regexp:\"red\"},exports.isArray=isArray,exports.isBoolean=isBoolean,exports.isNull=isNull,exports.isNullOrUndefined=isNullOrUndefined,exports.isNumber=isNumber,exports.isString=isString,exports.isSymbol=isSymbol,exports.isUndefined=isUndefined,exports.isRegExp=isRegExp,exports.isObject=isObject,exports.isDate=isDate,exports.isError=isError,exports.isFunction=isFunction,exports.isPrimitive=isPrimitive,exports.isBuffer=_dereq_(\"./support/isBuffer\");var months=[\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"];exports.log=function(){console.log(\"%s - %s\",timestamp(),exports.format.apply(exports,arguments))},exports.inherits=_dereq_(\"inherits\"),exports._extend=function(origin,add){if(!add||!isObject(add))return origin;for(var keys=Object.keys(add),i=keys.length;i--;)origin[keys[i]]=add[keys[i]];return origin}}).call(this,_dereq_(\"/usr/local/lib/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js\"),\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{\"./support/isBuffer\":14,\"/usr/local/lib/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js\":18,inherits:17}],16:[function(_dereq_,module){function EventEmitter(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0}function isFunction(arg){return\"function\"==typeof arg}function isNumber(arg){return\"number\"==typeof arg}function isObject(arg){return\"object\"==typeof arg&&null!==arg}function isUndefined(arg){return void 0===arg}module.exports=EventEmitter,EventEmitter.EventEmitter=EventEmitter,EventEmitter.prototype._events=void 0,EventEmitter.prototype._maxListeners=void 0,EventEmitter.defaultMaxListeners=10,EventEmitter.prototype.setMaxListeners=function(n){if(!isNumber(n)||0>n||isNaN(n))throw TypeError(\"n must be a positive number\");return this._maxListeners=n,this},EventEmitter.prototype.emit=function(type){var er,handler,len,args,i,listeners;if(this._events||(this._events={}),\"error\"===type&&(!this._events.error||isObject(this._events.error)&&!this._events.error.length))throw er=arguments[1],er instanceof Error?er:TypeError('Uncaught, unspecified \"error\" event.');if(handler=this._events[type],isUndefined(handler))return!1;if(isFunction(handler))switch(arguments.length){case 1:handler.call(this);break;case 2:handler.call(this,arguments[1]);break;case 3:handler.call(this,arguments[1],arguments[2]);break;default:for(len=arguments.length,args=Array(len-1),i=1;len>i;i++)args[i-1]=arguments[i];handler.apply(this,args)}else if(isObject(handler)){for(len=arguments.length,args=Array(len-1),i=1;len>i;i++)args[i-1]=arguments[i];for(listeners=handler.slice(),len=listeners.length,i=0;len>i;i++)listeners[i].apply(this,args)}return!0},EventEmitter.prototype.addListener=function(type,listener){var m;if(!isFunction(listener))throw TypeError(\"listener must be a function\");if(this._events||(this._events={}),this._events.newListener&&this.emit(\"newListener\",type,isFunction(listener.listener)?listener.listener:listener),this._events[type]?isObject(this._events[type])?this._events[type].push(listener):this._events[type]=[this._events[type],listener]:this._events[type]=listener,isObject(this._events[type])&&!this._events[type].warned){var m;m=isUndefined(this._maxListeners)?EventEmitter.defaultMaxListeners:this._maxListeners,m&&m>0&&this._events[type].length>m&&(this._events[type].warned=!0,console.error(\"(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.\",this._events[type].length),console.trace())}return this},EventEmitter.prototype.on=EventEmitter.prototype.addListener,EventEmitter.prototype.once=function(type,listener){function g(){this.removeListener(type,g),fired||(fired=!0,listener.apply(this,arguments))}if(!isFunction(listener))throw TypeError(\"listener must be a function\");var fired=!1;return g.listener=listener,this.on(type,g),this},EventEmitter.prototype.removeListener=function(type,listener){var list,position,length,i;if(!isFunction(listener))throw TypeError(\"listener must be a function\");if(!this._events||!this._events[type])return this;if(list=this._events[type],length=list.length,position=-1,list===listener||isFunction(list.listener)&&list.listener===listener)delete this._events[type],this._events.removeListener&&this.emit(\"removeListener\",type,listener);else if(isObject(list)){for(i=length;i-->0;)if(list[i]===listener||list[i].listener&&list[i].listener===listener){position=i;break}if(0>position)return this;1===list.length?(list.length=0,delete this._events[type]):list.splice(position,1),this._events.removeListener&&this.emit(\"removeListener\",type,listener)}return this},EventEmitter.prototype.removeAllListeners=function(type){var key,listeners;if(!this._events)return this;if(!this._events.removeListener)return 0===arguments.length?this._events={}:this._events[type]&&delete this._events[type],this;if(0===arguments.length){for(key in this._events)\"removeListener\"!==key&&this.removeAllListeners(key);return this.removeAllListeners(\"removeListener\"),this._events={},this}if(listeners=this._events[type],isFunction(listeners))this.removeListener(type,listeners);else for(;listeners.length;)this.removeListener(type,listeners[listeners.length-1]);return delete this._events[type],this},EventEmitter.prototype.listeners=function(type){var ret;return ret=this._events&&this._events[type]?isFunction(this._events[type])?[this._events[type]]:this._events[type].slice():[]},EventEmitter.listenerCount=function(emitter,type){var ret;return ret=emitter._events&&emitter._events[type]?isFunction(emitter._events[type])?1:emitter._events[type].length:0}},{}],17:[function(_dereq_,module){module.exports=\"function\"==typeof Object.create?function(ctor,superCtor){ctor.super_=superCtor,ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:!1,writable:!0,configurable:!0}})}:function(ctor,superCtor){ctor.super_=superCtor;var TempCtor=function(){};TempCtor.prototype=superCtor.prototype,ctor.prototype=new TempCtor,ctor.prototype.constructor=ctor}},{}],18:[function(_dereq_,module){function noop(){}var process=module.exports={};process.nextTick=function(){var canSetImmediate=\"undefined\"!=typeof window&&window.setImmediate,canPost=\"undefined\"!=typeof window&&window.postMessage&&window.addEventListener;if(canSetImmediate)return function(f){return window.setImmediate(f)};if(canPost){var queue=[];return window.addEventListener(\"message\",function(ev){var source=ev.source;if((source===window||null===source)&&\"process-tick\"===ev.data&&(ev.stopPropagation(),queue.length>0)){var fn=queue.shift();fn()}},!0),function(fn){queue.push(fn),window.postMessage(\"process-tick\",\"*\")}}return function(fn){setTimeout(fn,0)}}(),process.title=\"browser\",process.browser=!0,process.env={},process.argv=[],process.on=noop,process.once=noop,process.off=noop,process.emit=noop,process.binding=function(){throw Error(\"process.binding is not supported\")},process.cwd=function(){return\"/\"},process.chdir=function(){throw Error(\"process.chdir is not supported\")}},{}],19:[function(_dereq_,module){module.exports=_dereq_(14)},{}],20:[function(_dereq_,module){module.exports=_dereq_(15)},{\"./support/isBuffer\":19,\"/usr/local/lib/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js\":18,inherits:17}]},{},[9])(9)}),ace.define(\"ace/mode/html_worker\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/worker/mirror\",\"ace/mode/html/saxparser\"],function(acequire,exports){\"use strict\";var oop=acequire(\"../lib/oop\");acequire(\"../lib/lang\");var Mirror=acequire(\"../worker/mirror\").Mirror,SAXParser=acequire(\"./html/saxparser\").SAXParser,errorTypes={\"expected-doctype-but-got-start-tag\":\"info\",\"expected-doctype-but-got-chars\":\"info\",\"non-html-root\":\"info\"},Worker=exports.Worker=function(sender){Mirror.call(this,sender),this.setTimeout(400),this.context=null};oop.inherits(Worker,Mirror),function(){this.setOptions=function(options){this.context=options.context},this.onUpdate=function(){var value=this.doc.getValue();if(value){var parser=new SAXParser,errors=[],noop=function(){};parser.contentHandler={startDocument:noop,endDocument:noop,startElement:noop,endElement:noop,characters:noop},parser.errorHandler={error:function(message,location,code){errors.push({row:location.line,column:location.column,text:message,type:errorTypes[code]||\"error\"})}},this.context?parser.parseFragment(value,this.context):parser.parse(value),this.sender.emit(\"error\",errors)}}}.call(Worker.prototype)}),ace.define(\"ace/lib/es5-shim\",[\"require\",\"exports\",\"module\"],function(){function Empty(){}function doesDefinePropertyWork(object){try{return Object.defineProperty(object,\"sentinel\",{}),\"sentinel\"in object}catch(exception){}}function toInteger(n){return n=+n,n!==n?n=0:0!==n&&n!==1/0&&n!==-(1/0)&&(n=(n>0||-1)*Math.floor(Math.abs(n))),n}Function.prototype.bind||(Function.prototype.bind=function(that){var target=this;if(\"function\"!=typeof target)throw new TypeError(\"Function.prototype.bind called on incompatible \"+target);var args=slice.call(arguments,1),bound=function(){if(this instanceof bound){var result=target.apply(this,args.concat(slice.call(arguments)));return Object(result)===result?result:this}return target.apply(that,args.concat(slice.call(arguments)))};return target.prototype&&(Empty.prototype=target.prototype,bound.prototype=new Empty,Empty.prototype=null),bound});var defineGetter,defineSetter,lookupGetter,lookupSetter,supportsAccessors,call=Function.prototype.call,prototypeOfArray=Array.prototype,prototypeOfObject=Object.prototype,slice=prototypeOfArray.slice,_toString=call.bind(prototypeOfObject.toString),owns=call.bind(prototypeOfObject.hasOwnProperty);if((supportsAccessors=owns(prototypeOfObject,\"__defineGetter__\"))&&(defineGetter=call.bind(prototypeOfObject.__defineGetter__),defineSetter=call.bind(prototypeOfObject.__defineSetter__),lookupGetter=call.bind(prototypeOfObject.__lookupGetter__),lookupSetter=call.bind(prototypeOfObject.__lookupSetter__)),2!=[1,2].splice(0).length)if(function(){function makeArray(l){var a=Array(l+2);return a[0]=a[1]=0,a}var lengthBefore,array=[];return array.splice.apply(array,makeArray(20)),array.splice.apply(array,makeArray(26)),lengthBefore=array.length,array.splice(5,0,\"XXX\"),lengthBefore+1==array.length,lengthBefore+1==array.length?!0:void 0}()){var array_splice=Array.prototype.splice;Array.prototype.splice=function(start,deleteCount){return arguments.length?array_splice.apply(this,[void 0===start?0:start,void 0===deleteCount?this.length-start:deleteCount].concat(slice.call(arguments,2))):[]}}else Array.prototype.splice=function(pos,removeCount){var length=this.length;pos>0?pos>length&&(pos=length):void 0==pos?pos=0:0>pos&&(pos=Math.max(length+pos,0)),length>pos+removeCount||(removeCount=length-pos);var removed=this.slice(pos,pos+removeCount),insert=slice.call(arguments,2),add=insert.length;if(pos===length)add&&this.push.apply(this,insert);else{var remove=Math.min(removeCount,length-pos),tailOldPos=pos+remove,tailNewPos=tailOldPos+add-remove,tailCount=length-tailOldPos,lengthAfterRemove=length-remove;if(tailOldPos>tailNewPos)for(var i=0;tailCount>i;++i)this[tailNewPos+i]=this[tailOldPos+i];else if(tailNewPos>tailOldPos)for(i=tailCount;i--;)this[tailNewPos+i]=this[tailOldPos+i];if(add&&pos===lengthAfterRemove)this.length=lengthAfterRemove,this.push.apply(this,insert);else for(this.length=lengthAfterRemove+add,i=0;add>i;++i)this[pos+i]=insert[i]}return removed};Array.isArray||(Array.isArray=function(obj){return\"[object Array]\"==_toString(obj)});var boxedString=Object(\"a\"),splitString=\"a\"!=boxedString[0]||!(0 in boxedString);if(Array.prototype.forEach||(Array.prototype.forEach=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,thisp=arguments[1],i=-1,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError;for(;length>++i;)i in self&&fun.call(thisp,self[i],i,object)}),Array.prototype.map||(Array.prototype.map=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,result=Array(length),thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)i in self&&(result[i]=fun.call(thisp,self[i],i,object));return result}),Array.prototype.filter||(Array.prototype.filter=function(fun){var value,object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,result=[],thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)i in self&&(value=self[i],fun.call(thisp,value,i,object)&&result.push(value));return result}),Array.prototype.every||(Array.prototype.every=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)if(i in self&&!fun.call(thisp,self[i],i,object))return!1;return!0}),Array.prototype.some||(Array.prototype.some=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)if(i in self&&fun.call(thisp,self[i],i,object))return!0;return!1}),Array.prototype.reduce||(Array.prototype.reduce=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");if(!length&&1==arguments.length)throw new TypeError(\"reduce of empty array with no initial value\");var result,i=0;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i++];break}if(++i>=length)throw new TypeError(\"reduce of empty array with no initial value\")}for(;length>i;i++)i in self&&(result=fun.call(void 0,result,self[i],i,object));return result}),Array.prototype.reduceRight||(Array.prototype.reduceRight=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");if(!length&&1==arguments.length)throw new TypeError(\"reduceRight of empty array with no initial value\");var result,i=length-1;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i--];break}if(0>--i)throw new TypeError(\"reduceRight of empty array with no initial value\")}do i in this&&(result=fun.call(void 0,result,self[i],i,object));while(i--);return result}),Array.prototype.indexOf&&-1==[0,1].indexOf(1,2)||(Array.prototype.indexOf=function(sought){var self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):toObject(this),length=self.length>>>0;if(!length)return-1;var i=0;for(arguments.length>1&&(i=toInteger(arguments[1])),i=i>=0?i:Math.max(0,length+i);length>i;i++)if(i in self&&self[i]===sought)return i;return-1}),Array.prototype.lastIndexOf&&-1==[0,1].lastIndexOf(0,-3)||(Array.prototype.lastIndexOf=function(sought){var self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):toObject(this),length=self.length>>>0;if(!length)return-1;var i=length-1;for(arguments.length>1&&(i=Math.min(i,toInteger(arguments[1]))),i=i>=0?i:length-Math.abs(i);i>=0;i--)if(i in self&&sought===self[i])return i;return-1}),Object.getPrototypeOf||(Object.getPrototypeOf=function(object){return object.__proto__||(object.constructor?object.constructor.prototype:prototypeOfObject)}),!Object.getOwnPropertyDescriptor){var ERR_NON_OBJECT=\"Object.getOwnPropertyDescriptor called on a non-object: \";Object.getOwnPropertyDescriptor=function(object,property){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT+object);if(owns(object,property)){var descriptor,getter,setter;if(descriptor={enumerable:!0,configurable:!0},supportsAccessors){var prototype=object.__proto__;object.__proto__=prototypeOfObject;var getter=lookupGetter(object,property),setter=lookupSetter(object,property);if(object.__proto__=prototype,getter||setter)return getter&&(descriptor.get=getter),setter&&(descriptor.set=setter),descriptor}return descriptor.value=object[property],descriptor}}}if(Object.getOwnPropertyNames||(Object.getOwnPropertyNames=function(object){return Object.keys(object)}),!Object.create){var createEmpty;createEmpty=null===Object.prototype.__proto__?function(){return{__proto__:null}}:function(){var empty={};for(var i in empty)empty[i]=null;return empty.constructor=empty.hasOwnProperty=empty.propertyIsEnumerable=empty.isPrototypeOf=empty.toLocaleString=empty.toString=empty.valueOf=empty.__proto__=null,empty},Object.create=function(prototype,properties){var object;if(null===prototype)object=createEmpty();else{if(\"object\"!=typeof prototype)throw new TypeError(\"typeof prototype[\"+typeof prototype+\"] != 'object'\");var Type=function(){};Type.prototype=prototype,object=new Type,object.__proto__=prototype}return void 0!==properties&&Object.defineProperties(object,properties),object}}if(Object.defineProperty){var definePropertyWorksOnObject=doesDefinePropertyWork({}),definePropertyWorksOnDom=\"undefined\"==typeof document||doesDefinePropertyWork(document.createElement(\"div\"));if(!definePropertyWorksOnObject||!definePropertyWorksOnDom)var definePropertyFallback=Object.defineProperty}if(!Object.defineProperty||definePropertyFallback){var ERR_NON_OBJECT_DESCRIPTOR=\"Property description must be an object: \",ERR_NON_OBJECT_TARGET=\"Object.defineProperty called on non-object: \",ERR_ACCESSORS_NOT_SUPPORTED=\"getters & setters can not be defined on this javascript engine\";Object.defineProperty=function(object,property,descriptor){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT_TARGET+object);if(\"object\"!=typeof descriptor&&\"function\"!=typeof descriptor||null===descriptor)throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR+descriptor);if(definePropertyFallback)try{return definePropertyFallback.call(Object,object,property,descriptor)}catch(exception){}if(owns(descriptor,\"value\"))if(supportsAccessors&&(lookupGetter(object,property)||lookupSetter(object,property))){var prototype=object.__proto__;object.__proto__=prototypeOfObject,delete object[property],object[property]=descriptor.value,object.__proto__=prototype}else object[property]=descriptor.value;else{if(!supportsAccessors)throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);owns(descriptor,\"get\")&&defineGetter(object,property,descriptor.get),owns(descriptor,\"set\")&&defineSetter(object,property,descriptor.set)}return object}}Object.defineProperties||(Object.defineProperties=function(object,properties){for(var property in properties)owns(properties,property)&&Object.defineProperty(object,property,properties[property]);return object}),Object.seal||(Object.seal=function(object){return object}),Object.freeze||(Object.freeze=function(object){return object\n});try{Object.freeze(function(){})}catch(exception){Object.freeze=function(freezeObject){return function(object){return\"function\"==typeof object?object:freezeObject(object)}}(Object.freeze)}if(Object.preventExtensions||(Object.preventExtensions=function(object){return object}),Object.isSealed||(Object.isSealed=function(){return!1}),Object.isFrozen||(Object.isFrozen=function(){return!1}),Object.isExtensible||(Object.isExtensible=function(object){if(Object(object)===object)throw new TypeError;for(var name=\"\";owns(object,name);)name+=\"?\";object[name]=!0;var returnValue=owns(object,name);return delete object[name],returnValue}),!Object.keys){var hasDontEnumBug=!0,dontEnums=[\"toString\",\"toLocaleString\",\"valueOf\",\"hasOwnProperty\",\"isPrototypeOf\",\"propertyIsEnumerable\",\"constructor\"],dontEnumsLength=dontEnums.length;for(var key in{toString:null})hasDontEnumBug=!1;Object.keys=function(object){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(\"Object.keys called on a non-object\");var keys=[];for(var name in object)owns(object,name)&&keys.push(name);if(hasDontEnumBug)for(var i=0,ii=dontEnumsLength;ii>i;i++){var dontEnum=dontEnums[i];owns(object,dontEnum)&&keys.push(dontEnum)}return keys}}Date.now||(Date.now=function(){return(new Date).getTime()});var ws=\"\t\\n\u000b\\f\\r   ᠎             　\\u2028\\u2029﻿\";if(!String.prototype.trim||ws.trim()){ws=\"[\"+ws+\"]\";var trimBeginRegexp=RegExp(\"^\"+ws+ws+\"*\"),trimEndRegexp=RegExp(ws+ws+\"*$\");String.prototype.trim=function(){return(this+\"\").replace(trimBeginRegexp,\"\").replace(trimEndRegexp,\"\")}}var toObject=function(o){if(null==o)throw new TypeError(\"can't convert \"+o+\" to object\");return Object(o)}});";

/***/ },
/* 103 */
/***/ function(module, exports) {

	ace.define("ace/theme/eclipse",["require","exports","module","ace/lib/dom"], function(acequire, exports, module) {
	"use strict";

	exports.isDark = false;
	exports.cssText = ".ace-eclipse .ace_gutter {\
	background: #ebebeb;\
	border-right: 1px solid rgb(159, 159, 159);\
	color: rgb(136, 136, 136);\
	}\
	.ace-eclipse .ace_print-margin {\
	width: 1px;\
	background: #ebebeb;\
	}\
	.ace-eclipse {\
	background-color: #FFFFFF;\
	color: black;\
	}\
	.ace-eclipse .ace_fold {\
	background-color: rgb(60, 76, 114);\
	}\
	.ace-eclipse .ace_cursor {\
	color: black;\
	}\
	.ace-eclipse .ace_storage,\
	.ace-eclipse .ace_keyword,\
	.ace-eclipse .ace_variable {\
	color: rgb(127, 0, 85);\
	}\
	.ace-eclipse .ace_constant.ace_buildin {\
	color: rgb(88, 72, 246);\
	}\
	.ace-eclipse .ace_constant.ace_library {\
	color: rgb(6, 150, 14);\
	}\
	.ace-eclipse .ace_function {\
	color: rgb(60, 76, 114);\
	}\
	.ace-eclipse .ace_string {\
	color: rgb(42, 0, 255);\
	}\
	.ace-eclipse .ace_comment {\
	color: rgb(113, 150, 130);\
	}\
	.ace-eclipse .ace_comment.ace_doc {\
	color: rgb(63, 95, 191);\
	}\
	.ace-eclipse .ace_comment.ace_doc.ace_tag {\
	color: rgb(127, 159, 191);\
	}\
	.ace-eclipse .ace_constant.ace_numeric {\
	color: darkblue;\
	}\
	.ace-eclipse .ace_tag {\
	color: rgb(25, 118, 116);\
	}\
	.ace-eclipse .ace_type {\
	color: rgb(127, 0, 127);\
	}\
	.ace-eclipse .ace_xml-pe {\
	color: rgb(104, 104, 91);\
	}\
	.ace-eclipse .ace_marker-layer .ace_selection {\
	background: rgb(181, 213, 255);\
	}\
	.ace-eclipse .ace_marker-layer .ace_bracket {\
	margin: -1px 0 0 -1px;\
	border: 1px solid rgb(192, 192, 192);\
	}\
	.ace-eclipse .ace_meta.ace_tag {\
	color:rgb(25, 118, 116);\
	}\
	.ace-eclipse .ace_invisible {\
	color: #ddd;\
	}\
	.ace-eclipse .ace_entity.ace_other.ace_attribute-name {\
	color:rgb(127, 0, 127);\
	}\
	.ace-eclipse .ace_marker-layer .ace_step {\
	background: rgb(255, 255, 0);\
	}\
	.ace-eclipse .ace_active-line {\
	background: rgb(232, 242, 254);\
	}\
	.ace-eclipse .ace_gutter-active-line {\
	background-color : #DADADA;\
	}\
	.ace-eclipse .ace_marker-layer .ace_selected-word {\
	border: 1px solid rgb(181, 213, 255);\
	}\
	.ace-eclipse .ace_indent-guide {\
	background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\") right repeat-y;\
	}";

	exports.cssClass = "ace-eclipse";

	var dom = acequire("../lib/dom");
	dom.importCssString(exports.cssText, exports.cssClass);
	});


/***/ },
/* 104 */,
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/* Process inline math */

	'use strict';

	var ascii2mathml = null;
	__webpack_require__(106);


	function scanDelims(state, start, delimLength) {
	  var pos = start, lastChar, nextChar, count, can_open, can_close,
	      isLastWhiteSpace, isNextWhiteSpace,
	      left_flanking = true,
	      right_flanking = true,
	      max = state.posMax,
	      isWhiteSpace = state.md.utils.isWhiteSpace;

	  // treat beginning of the line as a whitespace
	  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : 0x20;

	  if (pos >= max) {
	    can_open = false;
	  }

	  pos += delimLength;

	  count = pos - start;

	  // treat end of the line as a whitespace
	  nextChar = pos < max ? state.src.charCodeAt(pos) : 0x20;

	  isLastWhiteSpace = isWhiteSpace(lastChar);
	  isNextWhiteSpace = isWhiteSpace(nextChar);

	  if (isNextWhiteSpace) {
	    left_flanking = false;
	  }

	  if (isLastWhiteSpace) {
	    right_flanking = false;
	  }

	  can_open = left_flanking;
	  can_close = right_flanking;

	  return {
	    can_open: can_open,
	    can_close: can_close,
	    delims: count
	  };
	}


	function makeMath_inline(open, close) {
	  return function math_inline(state, silent) {
	    var startCount,
	        found,
	        res,
	        token,
	        closeDelim,
	        max = state.posMax,
	        start = state.pos,
	        openDelim = state.src.slice(start, start + open.length);

	    if (openDelim !== open) { return false; }
	    if (silent) { return false; }    // Don’t run any pairs in validation mode

	    res = scanDelims(state, start, openDelim.length);
	    startCount = res.delims;

	    if (!res.can_open) {
	      state.pos += startCount;
	      // Earlier we checked !silent, but this implementation does not need it
	      state.pending += state.src.slice(start, state.pos);
	      return true;
	    }

	    state.pos = start + open.length;

	    while (state.pos < max) {
	      closeDelim = state.src.slice(state.pos, state.pos + close.length);
	      if (closeDelim === close) {
	        res = scanDelims(state, state.pos, close.length);
	        if (res.can_close) {
	          found = true;
	          break;
	        }
	      }

	      state.md.inline.skipToken(state);
	    }

	    if (!found) {
	      // Parser failed to find ending tag, so it is not a valid math
	      state.pos = start;
	      return false;
	    }

	    // Found!
	    state.posMax = state.pos;
	    state.pos = start + close.length;

	    // Earlier we checked !silent, but this implementation does not need it
	    token = state.push('math_inline', 'math', 0);
	    token.content = state.src.slice(state.pos, state.posMax);
	    token.markup = open;

	    state.pos = state.posMax + close.length;
	    state.posMax = max;

	    return true;
	  };
	}

	function makeMath_block(open, close) {
	  return function math_block(state, startLine, endLine, silent) {
	    var openDelim, len, params, nextLine, token, firstLine, lastLine, lastLinePos,
	        haveEndMarker = false,
	        pos = state.bMarks[startLine] + state.tShift[startLine],
	        max = state.eMarks[startLine];

	    if (pos + open.length > max) { return false; }

	    openDelim = state.src.slice(pos, pos + open.length);

	    if (openDelim !== open) { return false; }

	    pos += open.length;
	    firstLine = state.src.slice(pos, max);

	    // Since start is found, we can report success here in validation mode
	    if (silent) { return true; }

	    if (firstLine.trim().slice(-close.length) === close) {
	      // Single line expression
	      firstLine = firstLine.trim().slice(0, -close.length);
	      haveEndMarker = true;
	    }

	    // search end of block
	    nextLine = startLine;

	    for (;;) {
	      if (haveEndMarker) { break; }

	      nextLine++;

	      if (nextLine >= endLine) {
	        // unclosed block should be autoclosed by end of document.
	        // also block seems to be autoclosed by end of parent
	        break;
	      }

	      pos = state.bMarks[nextLine] + state.tShift[nextLine];
	      max = state.eMarks[nextLine];

	      if (pos < max && state.tShift[nextLine] < state.blkIndent) {
	        // non-empty line with negative indent should stop the list:
	        break;
	      }

	      if (state.src.slice(pos, max).trim().slice(-close.length) !== close) {
	        continue;
	      }

	      if (state.tShift[nextLine] - state.blkIndent >= 4) {
	        // closing block math should be indented less then 4 spaces
	        continue;
	      }

	      lastLinePos = state.src.slice(0, max).lastIndexOf(close);
	      lastLine = state.src.slice(pos, lastLinePos);

	      pos += lastLine.length + close.length;

	      // make sure tail has spaces only
	      pos = state.skipSpaces(pos);

	      if (pos < max) { continue; }

	      // found!
	      haveEndMarker = true;
	    }

	    // If math block has heading spaces, they should be removed from its inner block
	    len = state.tShift[startLine];

	    state.line = nextLine + (haveEndMarker ? 1 : 0);

	    token = state.push('math_block', 'math', 0);
	    token.block = true;
	    token.content = (firstLine && firstLine.trim() ? firstLine + '\n' : '') +
	      state.getLines(startLine + 1, nextLine, len, true) +
	      (lastLine && lastLine.trim() ? lastLine : '');
	    token.info = params;
	    token.map = [ startLine, state.line ];
	    token.markup = open;

	    return true;
	  };
	}

	function makeMathRenderer(renderingOptions) {
	  if (ascii2mathml === null) {
	    try {
	      ascii2mathml = __webpack_require__(107);
	    } catch (e) {
	      return renderingOptions && renderingOptions.display === 'block' ?
	        function(tokens, idx) {
	          return '<div class="math block">' + tokens[idx].content + '</div>';
	        } :
	        function(tokens, idx) {
	          return '<span class="math inline">' + tokens[idx].content + '</span>';
	        };
	    }
	  }

	  var mathml = ascii2mathml(Object.assign({}, renderingOptions));

	  return renderingOptions && renderingOptions.display === 'block' ?
	    function(tokens, idx) {
	      return mathml(tokens[idx].content) + '\n';
	    } :
	    function(tokens, idx) {
	      return mathml(tokens[idx].content);
	    };
	}


	module.exports = function math_plugin(md, options) {
	  // Default options
	  options = typeof options === 'object' ? options : {};
	  var inlineOpen = options.inlineOpen || '$$',
	      inlineClose = options.inlineClose || '$$',
	      blockOpen = options.blockOpen || '$$$',
	      blockClose = options.blockClose || '$$$';
	  var inlineRenderer = options.inlineRenderer ?
	        function(tokens, idx) {
	          return options.inlineRenderer(tokens[idx].content);
	        } :
	      makeMathRenderer(options.renderingOptions);
	  var blockRenderer = options.blockRenderer ?
	        function(tokens, idx) {
	          return options.blockRenderer(tokens[idx].content) + '\n';
	        } :
	      makeMathRenderer(Object.assign({ display: 'block' },
	                                     options.renderingOptions));

	  var math_inline = makeMath_inline(inlineOpen, inlineClose);
	  var math_block = makeMath_block(blockOpen, blockClose);

	  md.inline.ruler.before('escape', 'math_inline', math_inline);
	  md.block.ruler.after('blockquote', 'math_block', math_block, {
	    alt: [ 'paragraph', 'reference', 'blockquote', 'list' ]
	  });
	  md.renderer.rules.math_inline = inlineRenderer;
	  md.renderer.rules.math_block = blockRenderer;
	};


/***/ },
/* 106 */
/***/ function(module, exports) {

	'use strict';

	/* Object.assign
	 *
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/
	 * Global_Objects/Object/assign
	 *
	 * This polyfill doesn't support symbol properties, since ES5 doesn't
	 * have symbols anyway:
	 */

	if (!Object.assign) {
	  Object.defineProperty(Object, 'assign', {
	    enumerable: false,
	    configurable: true,
	    writable: true,
	    value: function(target) {
	      if (typeof target === 'undefined' || target === null) {
	        throw new TypeError('Cannot convert first argument to object');
	      }

	      var to = Object(target);
	      for (var i = 1; i < arguments.length; i++) {
	        var nextSource = arguments[i];
	        if (typeof nextSource === 'undefined' || nextSource === null) {
	          continue;
	        }

	        var keysArray = Object.keys(Object(nextSource));
	        for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
	          var nextKey = keysArray[nextIndex];
	          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
	          if (typeof desc !== 'undefined' && desc.enumerable) {
	            to[nextKey] = nextSource[nextKey];
	          }
	        }
	      }
	      return to;
	    }
	  });
	}


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	__webpack_require__(108);

	var _libParser = __webpack_require__(299);

	var _libParser2 = _interopRequireDefault(_libParser);

	function ascii2mathml(asciimath, options) {

	  // Curry
	  if (typeof asciimath === "object") {
	    return function (str, options2) {
	      var opts = Object.assign({}, asciimath, options2);
	      return ascii2mathml(str, opts);
	    };
	  }

	  options = typeof options === "object" ? options : {};
	  options.annotate = options.annotate || false;
	  options.bare = options.bare || false;
	  options.display = options.display || "inline";
	  options.standalone = options.standalone || false;
	  options.dir = options.dir || "ltr";

	  options.decimalMark = options.decimalMark || ".";
	  options.colSep = options.colSep || ",";
	  options.rowSep = options.rowSep || ";";

	  if (options.decimalMark === "," && options.colSep === ",") {
	    options.colSep = ";";
	  }
	  if (options.colSep === ";" && options.rowSep === ";") {
	    options.rowSep = ";;";
	  }

	  if (options.bare) {
	    if (options.standalone) {
	      throw new Error("Can't output a valid HTML without a root <math> element");
	    }
	    if (options.display && options.display.toLowerCase() !== "inline") {
	      throw new Error("Can't display block without root element.");
	    }
	    if (options.dir && options.dir.toLowerCase() !== "ltr") {
	      throw new Error("Can't have right-to-left direction without root element.");
	    }
	  }

	  var parse = (0, _libParser2["default"])(options);
	  var out = undefined;

	  var math = options.bare ? function (expr) {
	    return expr;
	  } : function (expr) {
	    return "<math" + (options.display !== "inline" ? " display=\"" + options.display + "\"" : "") + (options.dir !== "ltr" ? " dir=\"" + options.dir + "\"" : "") + ">" + expr + "</math>";
	  };

	  if (options.annotate) {
	    // Make sure the all presentational part is the first element
	    var parsed = parse(asciimath.trim(), ""),
	        mathml = parsed === _libParser2["default"].getlastel(parsed) ? parsed : "<mrow>" + parsed + "</mrow>";

	    out = math("<semantics>" + mathml + '<annotation encoding="application/AsciiMath">' + asciimath + "</annotation>" + "</semantics>");
	  } else {
	    out = math(parse(asciimath.trim(), ""));
	  }

	  if (options.standalone) {
	    out = "<!DOCTYPE html><html><head><title>" + asciimath + "</title></head>" + "<body>" + out + "</body></html>";
	  }

	  return out;
	}

	exports["default"] = ascii2mathml;
	module.exports = exports["default"];



/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(109);


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(110);


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";

	__webpack_require__(111);

	__webpack_require__(298);

	if (global._babelPolyfill) {
	  throw new Error("only one instance of babel/polyfill is allowed");
	}
	global._babelPolyfill = true;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(112);
	__webpack_require__(145);
	__webpack_require__(151);
	__webpack_require__(153);
	__webpack_require__(155);
	__webpack_require__(157);
	__webpack_require__(159);
	__webpack_require__(161);
	__webpack_require__(162);
	__webpack_require__(163);
	__webpack_require__(164);
	__webpack_require__(165);
	__webpack_require__(166);
	__webpack_require__(167);
	__webpack_require__(168);
	__webpack_require__(169);
	__webpack_require__(170);
	__webpack_require__(171);
	__webpack_require__(172);
	__webpack_require__(175);
	__webpack_require__(176);
	__webpack_require__(177);
	__webpack_require__(179);
	__webpack_require__(180);
	__webpack_require__(181);
	__webpack_require__(182);
	__webpack_require__(183);
	__webpack_require__(184);
	__webpack_require__(185);
	__webpack_require__(187);
	__webpack_require__(188);
	__webpack_require__(189);
	__webpack_require__(191);
	__webpack_require__(192);
	__webpack_require__(193);
	__webpack_require__(195);
	__webpack_require__(196);
	__webpack_require__(197);
	__webpack_require__(198);
	__webpack_require__(199);
	__webpack_require__(200);
	__webpack_require__(201);
	__webpack_require__(202);
	__webpack_require__(203);
	__webpack_require__(204);
	__webpack_require__(205);
	__webpack_require__(206);
	__webpack_require__(207);
	__webpack_require__(208);
	__webpack_require__(213);
	__webpack_require__(214);
	__webpack_require__(218);
	__webpack_require__(219);
	__webpack_require__(221);
	__webpack_require__(222);
	__webpack_require__(227);
	__webpack_require__(228);
	__webpack_require__(231);
	__webpack_require__(233);
	__webpack_require__(235);
	__webpack_require__(237);
	__webpack_require__(238);
	__webpack_require__(239);
	__webpack_require__(241);
	__webpack_require__(242);
	__webpack_require__(244);
	__webpack_require__(245);
	__webpack_require__(246);
	__webpack_require__(247);
	__webpack_require__(254);
	__webpack_require__(257);
	__webpack_require__(258);
	__webpack_require__(260);
	__webpack_require__(261);
	__webpack_require__(262);
	__webpack_require__(263);
	__webpack_require__(264);
	__webpack_require__(265);
	__webpack_require__(266);
	__webpack_require__(267);
	__webpack_require__(268);
	__webpack_require__(269);
	__webpack_require__(270);
	__webpack_require__(271);
	__webpack_require__(273);
	__webpack_require__(274);
	__webpack_require__(275);
	__webpack_require__(276);
	__webpack_require__(277);
	__webpack_require__(278);
	__webpack_require__(280);
	__webpack_require__(281);
	__webpack_require__(282);
	__webpack_require__(283);
	__webpack_require__(285);
	__webpack_require__(286);
	__webpack_require__(288);
	__webpack_require__(289);
	__webpack_require__(291);
	__webpack_require__(292);
	__webpack_require__(293);
	__webpack_require__(296);
	__webpack_require__(297);
	module.exports = __webpack_require__(116);

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $                 = __webpack_require__(113)
	  , $export           = __webpack_require__(114)
	  , DESCRIPTORS       = __webpack_require__(119)
	  , createDesc        = __webpack_require__(118)
	  , html              = __webpack_require__(125)
	  , cel               = __webpack_require__(126)
	  , has               = __webpack_require__(128)
	  , cof               = __webpack_require__(129)
	  , invoke            = __webpack_require__(130)
	  , fails             = __webpack_require__(120)
	  , anObject          = __webpack_require__(131)
	  , aFunction         = __webpack_require__(124)
	  , isObject          = __webpack_require__(127)
	  , toObject          = __webpack_require__(132)
	  , toIObject         = __webpack_require__(134)
	  , toInteger         = __webpack_require__(136)
	  , toIndex           = __webpack_require__(137)
	  , toLength          = __webpack_require__(138)
	  , IObject           = __webpack_require__(135)
	  , IE_PROTO          = __webpack_require__(122)('__proto__')
	  , createArrayMethod = __webpack_require__(139)
	  , arrayIndexOf      = __webpack_require__(144)(false)
	  , ObjectProto       = Object.prototype
	  , ArrayProto        = Array.prototype
	  , arraySlice        = ArrayProto.slice
	  , arrayJoin         = ArrayProto.join
	  , defineProperty    = $.setDesc
	  , getOwnDescriptor  = $.getDesc
	  , defineProperties  = $.setDescs
	  , factories         = {}
	  , IE8_DOM_DEFINE;

	if(!DESCRIPTORS){
	  IE8_DOM_DEFINE = !fails(function(){
	    return defineProperty(cel('div'), 'a', {get: function(){ return 7; }}).a != 7;
	  });
	  $.setDesc = function(O, P, Attributes){
	    if(IE8_DOM_DEFINE)try {
	      return defineProperty(O, P, Attributes);
	    } catch(e){ /* empty */ }
	    if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	    if('value' in Attributes)anObject(O)[P] = Attributes.value;
	    return O;
	  };
	  $.getDesc = function(O, P){
	    if(IE8_DOM_DEFINE)try {
	      return getOwnDescriptor(O, P);
	    } catch(e){ /* empty */ }
	    if(has(O, P))return createDesc(!ObjectProto.propertyIsEnumerable.call(O, P), O[P]);
	  };
	  $.setDescs = defineProperties = function(O, Properties){
	    anObject(O);
	    var keys   = $.getKeys(Properties)
	      , length = keys.length
	      , i = 0
	      , P;
	    while(length > i)$.setDesc(O, P = keys[i++], Properties[P]);
	    return O;
	  };
	}
	$export($export.S + $export.F * !DESCRIPTORS, 'Object', {
	  // 19.1.2.6 / 15.2.3.3 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $.getDesc,
	  // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	  defineProperty: $.setDesc,
	  // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
	  defineProperties: defineProperties
	});

	  // IE 8- don't enum bug keys
	var keys1 = ('constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,' +
	            'toLocaleString,toString,valueOf').split(',')
	  // Additional keys for getOwnPropertyNames
	  , keys2 = keys1.concat('length', 'prototype')
	  , keysLen1 = keys1.length;

	// Create object with `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = cel('iframe')
	    , i      = keysLen1
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  html.appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write('<script>document.F=Object</script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict.prototype[keys1[i]];
	  return createDict();
	};
	var createGetKeys = function(names, length){
	  return function(object){
	    var O      = toIObject(object)
	      , i      = 0
	      , result = []
	      , key;
	    for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	    // Don't enum bug & hidden keys
	    while(length > i)if(has(O, key = names[i++])){
	      ~arrayIndexOf(result, key) || result.push(key);
	    }
	    return result;
	  };
	};
	var Empty = function(){};
	$export($export.S, 'Object', {
	  // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	  getPrototypeOf: $.getProto = $.getProto || function(O){
	    O = toObject(O);
	    if(has(O, IE_PROTO))return O[IE_PROTO];
	    if(typeof O.constructor == 'function' && O instanceof O.constructor){
	      return O.constructor.prototype;
	    } return O instanceof Object ? ObjectProto : null;
	  },
	  // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $.getNames = $.getNames || createGetKeys(keys2, keys2.length, true),
	  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	  create: $.create = $.create || function(O, /*?*/Properties){
	    var result;
	    if(O !== null){
	      Empty.prototype = anObject(O);
	      result = new Empty();
	      Empty.prototype = null;
	      // add "__proto__" for Object.getPrototypeOf shim
	      result[IE_PROTO] = O;
	    } else result = createDict();
	    return Properties === undefined ? result : defineProperties(result, Properties);
	  },
	  // 19.1.2.14 / 15.2.3.14 Object.keys(O)
	  keys: $.getKeys = $.getKeys || createGetKeys(keys1, keysLen1, false)
	});

	var construct = function(F, len, args){
	  if(!(len in factories)){
	    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';
	    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
	  }
	  return factories[len](F, args);
	};

	// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
	$export($export.P, 'Function', {
	  bind: function bind(that /*, args... */){
	    var fn       = aFunction(this)
	      , partArgs = arraySlice.call(arguments, 1);
	    var bound = function(/* args... */){
	      var args = partArgs.concat(arraySlice.call(arguments));
	      return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
	    };
	    if(isObject(fn.prototype))bound.prototype = fn.prototype;
	    return bound;
	  }
	});

	// fallback for not array-like ES3 strings and DOM objects
	$export($export.P + $export.F * fails(function(){
	  if(html)arraySlice.call(html);
	}), 'Array', {
	  slice: function(begin, end){
	    var len   = toLength(this.length)
	      , klass = cof(this);
	    end = end === undefined ? len : end;
	    if(klass == 'Array')return arraySlice.call(this, begin, end);
	    var start  = toIndex(begin, len)
	      , upTo   = toIndex(end, len)
	      , size   = toLength(upTo - start)
	      , cloned = Array(size)
	      , i      = 0;
	    for(; i < size; i++)cloned[i] = klass == 'String'
	      ? this.charAt(start + i)
	      : this[start + i];
	    return cloned;
	  }
	});
	$export($export.P + $export.F * (IObject != Object), 'Array', {
	  join: function join(separator){
	    return arrayJoin.call(IObject(this), separator === undefined ? ',' : separator);
	  }
	});

	// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
	$export($export.S, 'Array', {isArray: __webpack_require__(141)});

	var createArrayReduce = function(isRight){
	  return function(callbackfn, memo){
	    aFunction(callbackfn);
	    var O      = IObject(this)
	      , length = toLength(O.length)
	      , index  = isRight ? length - 1 : 0
	      , i      = isRight ? -1 : 1;
	    if(arguments.length < 2)for(;;){
	      if(index in O){
	        memo = O[index];
	        index += i;
	        break;
	      }
	      index += i;
	      if(isRight ? index < 0 : length <= index){
	        throw TypeError('Reduce of empty array with no initial value');
	      }
	    }
	    for(;isRight ? index >= 0 : length > index; index += i)if(index in O){
	      memo = callbackfn(memo, O[index], index, this);
	    }
	    return memo;
	  };
	};

	var methodize = function($fn){
	  return function(arg1/*, arg2 = undefined */){
	    return $fn(this, arg1, arguments[1]);
	  };
	};

	$export($export.P, 'Array', {
	  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
	  forEach: $.each = $.each || methodize(createArrayMethod(0)),
	  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
	  map: methodize(createArrayMethod(1)),
	  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
	  filter: methodize(createArrayMethod(2)),
	  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
	  some: methodize(createArrayMethod(3)),
	  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
	  every: methodize(createArrayMethod(4)),
	  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
	  reduce: createArrayReduce(false),
	  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
	  reduceRight: createArrayReduce(true),
	  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
	  indexOf: methodize(arrayIndexOf),
	  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
	  lastIndexOf: function(el, fromIndex /* = @[*-1] */){
	    var O      = toIObject(this)
	      , length = toLength(O.length)
	      , index  = length - 1;
	    if(arguments.length > 1)index = Math.min(index, toInteger(fromIndex));
	    if(index < 0)index = toLength(length + index);
	    for(;index >= 0; index--)if(index in O)if(O[index] === el)return index;
	    return -1;
	  }
	});

	// 20.3.3.1 / 15.9.4.4 Date.now()
	$export($export.S, 'Date', {now: function(){ return +new Date; }});

	var lz = function(num){
	  return num > 9 ? num : '0' + num;
	};

	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
	// PhantomJS / old WebKit has a broken implementations
	$export($export.P + $export.F * (fails(function(){
	  return new Date(-5e13 - 1).toISOString() != '0385-07-25T07:06:39.999Z';
	}) || !fails(function(){
	  new Date(NaN).toISOString();
	})), 'Date', {
	  toISOString: function toISOString(){
	    if(!isFinite(this))throw RangeError('Invalid time value');
	    var d = this
	      , y = d.getUTCFullYear()
	      , m = d.getUTCMilliseconds()
	      , s = y < 0 ? '-' : y > 9999 ? '+' : '';
	    return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
	      '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
	      'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
	      ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
	  }
	});

/***/ },
/* 113 */
/***/ function(module, exports) {

	var $Object = Object;
	module.exports = {
	  create:     $Object.create,
	  getProto:   $Object.getPrototypeOf,
	  isEnum:     {}.propertyIsEnumerable,
	  getDesc:    $Object.getOwnPropertyDescriptor,
	  setDesc:    $Object.defineProperty,
	  setDescs:   $Object.defineProperties,
	  getKeys:    $Object.keys,
	  getNames:   $Object.getOwnPropertyNames,
	  getSymbols: $Object.getOwnPropertySymbols,
	  each:       [].forEach
	};

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(115)
	  , core      = __webpack_require__(116)
	  , hide      = __webpack_require__(117)
	  , redefine  = __webpack_require__(121)
	  , ctx       = __webpack_require__(123)
	  , PROTOTYPE = 'prototype';

	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
	    , key, own, out, exp;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && key in target;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // extend global
	    if(target && !own)redefine(target, key, out);
	    // export
	    if(exports[key] != out)hide(exports, key, exp);
	    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
	  }
	};
	global.core = core;
	// type bitmap
	$export.F = 1;  // forced
	$export.G = 2;  // global
	$export.S = 4;  // static
	$export.P = 8;  // proto
	$export.B = 16; // bind
	$export.W = 32; // wrap
	module.exports = $export;

/***/ },
/* 115 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 116 */
/***/ function(module, exports) {

	var core = module.exports = {version: '1.2.6'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	var $          = __webpack_require__(113)
	  , createDesc = __webpack_require__(118);
	module.exports = __webpack_require__(119) ? function(object, key, value){
	  return $.setDesc(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 118 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(120)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 120 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	// add fake Function#toString
	// for correct work wrapped methods / constructors with methods like LoDash isNative
	var global    = __webpack_require__(115)
	  , hide      = __webpack_require__(117)
	  , SRC       = __webpack_require__(122)('src')
	  , TO_STRING = 'toString'
	  , $toString = Function[TO_STRING]
	  , TPL       = ('' + $toString).split(TO_STRING);

	__webpack_require__(116).inspectSource = function(it){
	  return $toString.call(it);
	};

	(module.exports = function(O, key, val, safe){
	  if(typeof val == 'function'){
	    val.hasOwnProperty(SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
	    val.hasOwnProperty('name') || hide(val, 'name', key);
	  }
	  if(O === global){
	    O[key] = val;
	  } else {
	    if(!safe)delete O[key];
	    hide(O, key, val);
	  }
	})(Function.prototype, TO_STRING, function toString(){
	  return typeof this == 'function' && this[SRC] || $toString.call(this);
	});

/***/ },
/* 122 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(124);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 124 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(115).document && document.documentElement;

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(127)
	  , document = __webpack_require__(115).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 127 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 128 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 129 */
/***/ function(module, exports) {

	var toString = {}.toString;

	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 130 */
/***/ function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(127);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(133);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 133 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(135)
	  , defined = __webpack_require__(133);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(129);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 136 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(136)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(136)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx      = __webpack_require__(123)
	  , IObject  = __webpack_require__(135)
	  , toObject = __webpack_require__(132)
	  , toLength = __webpack_require__(138)
	  , asc      = __webpack_require__(140);
	module.exports = function(TYPE){
	  var IS_MAP        = TYPE == 1
	    , IS_FILTER     = TYPE == 2
	    , IS_SOME       = TYPE == 3
	    , IS_EVERY      = TYPE == 4
	    , IS_FIND_INDEX = TYPE == 6
	    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX;
	  return function($this, callbackfn, that){
	    var O      = toObject($this)
	      , self   = IObject(O)
	      , f      = ctx(callbackfn, that, 3)
	      , length = toLength(self.length)
	      , index  = 0
	      , result = IS_MAP ? asc($this, length) : IS_FILTER ? asc($this, 0) : undefined
	      , val, res;
	    for(;length > index; index++)if(NO_HOLES || index in self){
	      val = self[index];
	      res = f(val, index, O);
	      if(TYPE){
	        if(IS_MAP)result[index] = res;            // map
	        else if(res)switch(TYPE){
	          case 3: return true;                    // some
	          case 5: return val;                     // find
	          case 6: return index;                   // findIndex
	          case 2: result.push(val);               // filter
	        } else if(IS_EVERY)return false;          // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var isObject = __webpack_require__(127)
	  , isArray  = __webpack_require__(141)
	  , SPECIES  = __webpack_require__(142)('species');
	module.exports = function(original, length){
	  var C;
	  if(isArray(original)){
	    C = original.constructor;
	    // cross-realm fallback
	    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
	    if(isObject(C)){
	      C = C[SPECIES];
	      if(C === null)C = undefined;
	    }
	  } return new (C === undefined ? Array : C)(length);
	};

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(129);
	module.exports = Array.isArray || function(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	var store  = __webpack_require__(143)('wks')
	  , uid    = __webpack_require__(122)
	  , Symbol = __webpack_require__(115).Symbol;
	module.exports = function(name){
	  return store[name] || (store[name] =
	    Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
	};

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(115)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(134)
	  , toLength  = __webpack_require__(138)
	  , toIndex   = __webpack_require__(137);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var $              = __webpack_require__(113)
	  , global         = __webpack_require__(115)
	  , has            = __webpack_require__(128)
	  , DESCRIPTORS    = __webpack_require__(119)
	  , $export        = __webpack_require__(114)
	  , redefine       = __webpack_require__(121)
	  , $fails         = __webpack_require__(120)
	  , shared         = __webpack_require__(143)
	  , setToStringTag = __webpack_require__(146)
	  , uid            = __webpack_require__(122)
	  , wks            = __webpack_require__(142)
	  , keyOf          = __webpack_require__(147)
	  , $names         = __webpack_require__(148)
	  , enumKeys       = __webpack_require__(149)
	  , isArray        = __webpack_require__(141)
	  , anObject       = __webpack_require__(131)
	  , toIObject      = __webpack_require__(134)
	  , createDesc     = __webpack_require__(118)
	  , getDesc        = $.getDesc
	  , setDesc        = $.setDesc
	  , _create        = $.create
	  , getNames       = $names.get
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , setter         = false
	  , HIDDEN         = wks('_hidden')
	  , isEnum         = $.isEnum
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , useNative      = typeof $Symbol == 'function'
	  , ObjectProto    = Object.prototype;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(setDesc({}, 'a', {
	    get: function(){ return setDesc(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = getDesc(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  setDesc(it, key, D);
	  if(protoDesc && it !== ObjectProto)setDesc(ObjectProto, key, protoDesc);
	} : setDesc;

	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol.prototype);
	  sym._k = tag;
	  DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
	    configurable: true,
	    set: function(value){
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    }
	  });
	  return sym;
	};

	var isSymbol = function(it){
	  return typeof it == 'symbol';
	};

	var $defineProperty = function defineProperty(it, key, D){
	  if(D && has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))setDesc(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return setDesc(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key);
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]
	    ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  var D = getDesc(it = toIObject(it), key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = getNames(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);
	  return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var names  = getNames(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);
	  return result;
	};
	var $stringify = function stringify(it){
	  if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	  var args = [it]
	    , i    = 1
	    , $$   = arguments
	    , replacer, $replacer;
	  while($$.length > i)args.push($$[i++]);
	  replacer = args[1];
	  if(typeof replacer == 'function')$replacer = replacer;
	  if($replacer || !isArray(replacer))replacer = function(key, value){
	    if($replacer)value = $replacer.call(this, key, value);
	    if(!isSymbol(value))return value;
	  };
	  args[1] = replacer;
	  return _stringify.apply($JSON, args);
	};
	var buggyJSON = $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	});

	// 19.4.1.1 Symbol([description])
	if(!useNative){
	  $Symbol = function Symbol(){
	    if(isSymbol(this))throw TypeError('Symbol is not a constructor');
	    return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));
	  };
	  redefine($Symbol.prototype, 'toString', function toString(){
	    return this._k;
	  });

	  isSymbol = function(it){
	    return it instanceof $Symbol;
	  };

	  $.create     = $create;
	  $.isEnum     = $propertyIsEnumerable;
	  $.getDesc    = $getOwnPropertyDescriptor;
	  $.setDesc    = $defineProperty;
	  $.setDescs   = $defineProperties;
	  $.getNames   = $names.get = $getOwnPropertyNames;
	  $.getSymbols = $getOwnPropertySymbols;

	  if(DESCRIPTORS && !__webpack_require__(150)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	}

	var symbolStatics = {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    return keyOf(SymbolRegistry, key);
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	};
	// 19.4.2.2 Symbol.hasInstance
	// 19.4.2.3 Symbol.isConcatSpreadable
	// 19.4.2.4 Symbol.iterator
	// 19.4.2.6 Symbol.match
	// 19.4.2.8 Symbol.replace
	// 19.4.2.9 Symbol.search
	// 19.4.2.10 Symbol.species
	// 19.4.2.11 Symbol.split
	// 19.4.2.12 Symbol.toPrimitive
	// 19.4.2.13 Symbol.toStringTag
	// 19.4.2.14 Symbol.unscopables
	$.each.call((
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +
	  'species,split,toPrimitive,toStringTag,unscopables'
	).split(','), function(it){
	  var sym = wks(it);
	  symbolStatics[it] = useNative ? sym : wrap(sym);
	});

	setter = true;

	$export($export.G + $export.W, {Symbol: $Symbol});

	$export($export.S, 'Symbol', symbolStatics);

	$export($export.S + $export.F * !useNative, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});

	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});

	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(113).setDesc
	  , has = __webpack_require__(128)
	  , TAG = __webpack_require__(142)('toStringTag');

	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	var $         = __webpack_require__(113)
	  , toIObject = __webpack_require__(134);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = $.getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(134)
	  , getNames  = __webpack_require__(113).getNames
	  , toString  = {}.toString;

	var windowNames = typeof window == 'object' && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function(it){
	  try {
	    return getNames(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};

	module.exports.get = function getOwnPropertyNames(it){
	  if(windowNames && toString.call(it) == '[object Window]')return getWindowNames(it);
	  return getNames(toIObject(it));
	};

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var $ = __webpack_require__(113);
	module.exports = function(it){
	  var keys       = $.getKeys(it)
	    , getSymbols = $.getSymbols;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = $.isEnum
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))keys.push(key);
	  }
	  return keys;
	};

/***/ },
/* 150 */
/***/ function(module, exports) {

	module.exports = false;

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(114);

	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(152)});

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.1 Object.assign(target, source, ...)
	var $        = __webpack_require__(113)
	  , toObject = __webpack_require__(132)
	  , IObject  = __webpack_require__(135);

	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = __webpack_require__(120)(function(){
	  var a = Object.assign
	    , A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , $$    = arguments
	    , $$len = $$.length
	    , index = 1
	    , getKeys    = $.getKeys
	    , getSymbols = $.getSymbols
	    , isEnum     = $.isEnum;
	  while($$len > index){
	    var S      = IObject($$[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  }
	  return T;
	} : Object.assign;

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.10 Object.is(value1, value2)
	var $export = __webpack_require__(114);
	$export($export.S, 'Object', {is: __webpack_require__(154)});

/***/ },
/* 154 */
/***/ function(module, exports) {

	// 7.2.9 SameValue(x, y)
	module.exports = Object.is || function is(x, y){
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(114);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(156).set});

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var getDesc  = __webpack_require__(113).getDesc
	  , isObject = __webpack_require__(127)
	  , anObject = __webpack_require__(131);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(123)(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.3.6 Object.prototype.toString()
	var classof = __webpack_require__(158)
	  , test    = {};
	test[__webpack_require__(142)('toStringTag')] = 'z';
	if(test + '' != '[object z]'){
	  __webpack_require__(121)(Object.prototype, 'toString', function toString(){
	    return '[object ' + classof(this) + ']';
	  }, true);
	}

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(129)
	  , TAG = __webpack_require__(142)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.5 Object.freeze(O)
	var isObject = __webpack_require__(127);

	__webpack_require__(160)('freeze', function($freeze){
	  return function freeze(it){
	    return $freeze && isObject(it) ? $freeze(it) : it;
	  };
	});

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(114)
	  , core    = __webpack_require__(116)
	  , fails   = __webpack_require__(120);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.17 Object.seal(O)
	var isObject = __webpack_require__(127);

	__webpack_require__(160)('seal', function($seal){
	  return function seal(it){
	    return $seal && isObject(it) ? $seal(it) : it;
	  };
	});

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.15 Object.preventExtensions(O)
	var isObject = __webpack_require__(127);

	__webpack_require__(160)('preventExtensions', function($preventExtensions){
	  return function preventExtensions(it){
	    return $preventExtensions && isObject(it) ? $preventExtensions(it) : it;
	  };
	});

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.12 Object.isFrozen(O)
	var isObject = __webpack_require__(127);

	__webpack_require__(160)('isFrozen', function($isFrozen){
	  return function isFrozen(it){
	    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
	  };
	});

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.13 Object.isSealed(O)
	var isObject = __webpack_require__(127);

	__webpack_require__(160)('isSealed', function($isSealed){
	  return function isSealed(it){
	    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
	  };
	});

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.11 Object.isExtensible(O)
	var isObject = __webpack_require__(127);

	__webpack_require__(160)('isExtensible', function($isExtensible){
	  return function isExtensible(it){
	    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
	  };
	});

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	var toIObject = __webpack_require__(134);

	__webpack_require__(160)('getOwnPropertyDescriptor', function($getOwnPropertyDescriptor){
	  return function getOwnPropertyDescriptor(it, key){
	    return $getOwnPropertyDescriptor(toIObject(it), key);
	  };
	});

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject = __webpack_require__(132);

	__webpack_require__(160)('getPrototypeOf', function($getPrototypeOf){
	  return function getPrototypeOf(it){
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(132);

	__webpack_require__(160)('keys', function($keys){
	  return function keys(it){
	    return $keys(toObject(it));
	  };
	});

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 Object.getOwnPropertyNames(O)
	__webpack_require__(160)('getOwnPropertyNames', function(){
	  return __webpack_require__(148).get;
	});

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	var setDesc    = __webpack_require__(113).setDesc
	  , createDesc = __webpack_require__(118)
	  , has        = __webpack_require__(128)
	  , FProto     = Function.prototype
	  , nameRE     = /^\s*function ([^ (]*)/
	  , NAME       = 'name';
	// 19.2.4.2 name
	NAME in FProto || __webpack_require__(119) && setDesc(FProto, NAME, {
	  configurable: true,
	  get: function(){
	    var match = ('' + this).match(nameRE)
	      , name  = match ? match[1] : '';
	    has(this, NAME) || setDesc(this, NAME, createDesc(5, name));
	    return name;
	  }
	});

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $             = __webpack_require__(113)
	  , isObject      = __webpack_require__(127)
	  , HAS_INSTANCE  = __webpack_require__(142)('hasInstance')
	  , FunctionProto = Function.prototype;
	// 19.2.3.6 Function.prototype[@@hasInstance](V)
	if(!(HAS_INSTANCE in FunctionProto))$.setDesc(FunctionProto, HAS_INSTANCE, {value: function(O){
	  if(typeof this != 'function' || !isObject(O))return false;
	  if(!isObject(this.prototype))return O instanceof this;
	  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
	  while(O = $.getProto(O))if(this.prototype === O)return true;
	  return false;
	}});

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $           = __webpack_require__(113)
	  , global      = __webpack_require__(115)
	  , has         = __webpack_require__(128)
	  , cof         = __webpack_require__(129)
	  , toPrimitive = __webpack_require__(173)
	  , fails       = __webpack_require__(120)
	  , $trim       = __webpack_require__(174).trim
	  , NUMBER      = 'Number'
	  , $Number     = global[NUMBER]
	  , Base        = $Number
	  , proto       = $Number.prototype
	  // Opera ~12 has broken Object#toString
	  , BROKEN_COF  = cof($.create(proto)) == NUMBER
	  , TRIM        = 'trim' in String.prototype;

	// 7.1.3 ToNumber(argument)
	var toNumber = function(argument){
	  var it = toPrimitive(argument, false);
	  if(typeof it == 'string' && it.length > 2){
	    it = TRIM ? it.trim() : $trim(it, 3);
	    var first = it.charCodeAt(0)
	      , third, radix, maxCode;
	    if(first === 43 || first === 45){
	      third = it.charCodeAt(2);
	      if(third === 88 || third === 120)return NaN; // Number('+0x1') should be NaN, old V8 fix
	    } else if(first === 48){
	      switch(it.charCodeAt(1)){
	        case 66 : case 98  : radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
	        case 79 : case 111 : radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
	        default : return +it;
	      }
	      for(var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++){
	        code = digits.charCodeAt(i);
	        // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols
	        if(code < 48 || code > maxCode)return NaN;
	      } return parseInt(digits, radix);
	    }
	  } return +it;
	};

	if(!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')){
	  $Number = function Number(value){
	    var it = arguments.length < 1 ? 0 : value
	      , that = this;
	    return that instanceof $Number
	      // check on 1..constructor(foo) case
	      && (BROKEN_COF ? fails(function(){ proto.valueOf.call(that); }) : cof(that) != NUMBER)
	        ? new Base(toNumber(it)) : toNumber(it);
	  };
	  $.each.call(__webpack_require__(119) ? $.getNames(Base) : (
	    // ES3:
	    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
	    // ES6 (in case, if modules with ES6 Number statics required before):
	    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
	    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
	  ).split(','), function(key){
	    if(has(Base, key) && !has($Number, key)){
	      $.setDesc($Number, key, $.getDesc(Base, key));
	    }
	  });
	  $Number.prototype = proto;
	  proto.constructor = $Number;
	  __webpack_require__(121)(global, NUMBER, $Number);
	}

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(127);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(114)
	  , defined = __webpack_require__(133)
	  , fails   = __webpack_require__(120)
	  , spaces  = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	      '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF'
	  , space   = '[' + spaces + ']'
	  , non     = '\u200b\u0085'
	  , ltrim   = RegExp('^' + space + space + '*')
	  , rtrim   = RegExp(space + space + '*$');

	var exporter = function(KEY, exec){
	  var exp  = {};
	  exp[KEY] = exec(trim);
	  $export($export.P + $export.F * fails(function(){
	    return !!spaces[KEY]() || non[KEY]() != non;
	  }), 'String', exp);
	};

	// 1 -> String#trimLeft
	// 2 -> String#trimRight
	// 3 -> String#trim
	var trim = exporter.trim = function(string, TYPE){
	  string = String(defined(string));
	  if(TYPE & 1)string = string.replace(ltrim, '');
	  if(TYPE & 2)string = string.replace(rtrim, '');
	  return string;
	};

	module.exports = exporter;

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.1 Number.EPSILON
	var $export = __webpack_require__(114);

	$export($export.S, 'Number', {EPSILON: Math.pow(2, -52)});

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.2 Number.isFinite(number)
	var $export   = __webpack_require__(114)
	  , _isFinite = __webpack_require__(115).isFinite;

	$export($export.S, 'Number', {
	  isFinite: function isFinite(it){
	    return typeof it == 'number' && _isFinite(it);
	  }
	});

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var $export = __webpack_require__(114);

	$export($export.S, 'Number', {isInteger: __webpack_require__(178)});

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var isObject = __webpack_require__(127)
	  , floor    = Math.floor;
	module.exports = function isInteger(it){
	  return !isObject(it) && isFinite(it) && floor(it) === it;
	};

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.4 Number.isNaN(number)
	var $export = __webpack_require__(114);

	$export($export.S, 'Number', {
	  isNaN: function isNaN(number){
	    return number != number;
	  }
	});

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.5 Number.isSafeInteger(number)
	var $export   = __webpack_require__(114)
	  , isInteger = __webpack_require__(178)
	  , abs       = Math.abs;

	$export($export.S, 'Number', {
	  isSafeInteger: function isSafeInteger(number){
	    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
	  }
	});

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.6 Number.MAX_SAFE_INTEGER
	var $export = __webpack_require__(114);

	$export($export.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.10 Number.MIN_SAFE_INTEGER
	var $export = __webpack_require__(114);

	$export($export.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.12 Number.parseFloat(string)
	var $export = __webpack_require__(114);

	$export($export.S, 'Number', {parseFloat: parseFloat});

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.13 Number.parseInt(string, radix)
	var $export = __webpack_require__(114);

	$export($export.S, 'Number', {parseInt: parseInt});

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.3 Math.acosh(x)
	var $export = __webpack_require__(114)
	  , log1p   = __webpack_require__(186)
	  , sqrt    = Math.sqrt
	  , $acosh  = Math.acosh;

	// V8 bug https://code.google.com/p/v8/issues/detail?id=3509
	$export($export.S + $export.F * !($acosh && Math.floor($acosh(Number.MAX_VALUE)) == 710), 'Math', {
	  acosh: function acosh(x){
	    return (x = +x) < 1 ? NaN : x > 94906265.62425156
	      ? Math.log(x) + Math.LN2
	      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
	  }
	});

/***/ },
/* 186 */
/***/ function(module, exports) {

	// 20.2.2.20 Math.log1p(x)
	module.exports = Math.log1p || function log1p(x){
	  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
	};

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.5 Math.asinh(x)
	var $export = __webpack_require__(114);

	function asinh(x){
	  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
	}

	$export($export.S, 'Math', {asinh: asinh});

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.7 Math.atanh(x)
	var $export = __webpack_require__(114);

	$export($export.S, 'Math', {
	  atanh: function atanh(x){
	    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
	  }
	});

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.9 Math.cbrt(x)
	var $export = __webpack_require__(114)
	  , sign    = __webpack_require__(190);

	$export($export.S, 'Math', {
	  cbrt: function cbrt(x){
	    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
	  }
	});

/***/ },
/* 190 */
/***/ function(module, exports) {

	// 20.2.2.28 Math.sign(x)
	module.exports = Math.sign || function sign(x){
	  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
	};

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.11 Math.clz32(x)
	var $export = __webpack_require__(114);

	$export($export.S, 'Math', {
	  clz32: function clz32(x){
	    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
	  }
	});

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.12 Math.cosh(x)
	var $export = __webpack_require__(114)
	  , exp     = Math.exp;

	$export($export.S, 'Math', {
	  cosh: function cosh(x){
	    return (exp(x = +x) + exp(-x)) / 2;
	  }
	});

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.14 Math.expm1(x)
	var $export = __webpack_require__(114);

	$export($export.S, 'Math', {expm1: __webpack_require__(194)});

/***/ },
/* 194 */
/***/ function(module, exports) {

	// 20.2.2.14 Math.expm1(x)
	module.exports = Math.expm1 || function expm1(x){
	  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
	};

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.16 Math.fround(x)
	var $export   = __webpack_require__(114)
	  , sign      = __webpack_require__(190)
	  , pow       = Math.pow
	  , EPSILON   = pow(2, -52)
	  , EPSILON32 = pow(2, -23)
	  , MAX32     = pow(2, 127) * (2 - EPSILON32)
	  , MIN32     = pow(2, -126);

	var roundTiesToEven = function(n){
	  return n + 1 / EPSILON - 1 / EPSILON;
	};


	$export($export.S, 'Math', {
	  fround: function fround(x){
	    var $abs  = Math.abs(x)
	      , $sign = sign(x)
	      , a, result;
	    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
	    a = (1 + EPSILON32 / EPSILON) * $abs;
	    result = a - (a - $abs);
	    if(result > MAX32 || result != result)return $sign * Infinity;
	    return $sign * result;
	  }
	});

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
	var $export = __webpack_require__(114)
	  , abs     = Math.abs;

	$export($export.S, 'Math', {
	  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars
	    var sum   = 0
	      , i     = 0
	      , $$    = arguments
	      , $$len = $$.length
	      , larg  = 0
	      , arg, div;
	    while(i < $$len){
	      arg = abs($$[i++]);
	      if(larg < arg){
	        div  = larg / arg;
	        sum  = sum * div * div + 1;
	        larg = arg;
	      } else if(arg > 0){
	        div  = arg / larg;
	        sum += div * div;
	      } else sum += arg;
	    }
	    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
	  }
	});

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.18 Math.imul(x, y)
	var $export = __webpack_require__(114)
	  , $imul   = Math.imul;

	// some WebKit versions fails with big numbers, some has wrong arity
	$export($export.S + $export.F * __webpack_require__(120)(function(){
	  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
	}), 'Math', {
	  imul: function imul(x, y){
	    var UINT16 = 0xffff
	      , xn = +x
	      , yn = +y
	      , xl = UINT16 & xn
	      , yl = UINT16 & yn;
	    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
	  }
	});

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.21 Math.log10(x)
	var $export = __webpack_require__(114);

	$export($export.S, 'Math', {
	  log10: function log10(x){
	    return Math.log(x) / Math.LN10;
	  }
	});

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.20 Math.log1p(x)
	var $export = __webpack_require__(114);

	$export($export.S, 'Math', {log1p: __webpack_require__(186)});

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.22 Math.log2(x)
	var $export = __webpack_require__(114);

	$export($export.S, 'Math', {
	  log2: function log2(x){
	    return Math.log(x) / Math.LN2;
	  }
	});

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.28 Math.sign(x)
	var $export = __webpack_require__(114);

	$export($export.S, 'Math', {sign: __webpack_require__(190)});

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.30 Math.sinh(x)
	var $export = __webpack_require__(114)
	  , expm1   = __webpack_require__(194)
	  , exp     = Math.exp;

	// V8 near Chromium 38 has a problem with very small numbers
	$export($export.S + $export.F * __webpack_require__(120)(function(){
	  return !Math.sinh(-2e-17) != -2e-17;
	}), 'Math', {
	  sinh: function sinh(x){
	    return Math.abs(x = +x) < 1
	      ? (expm1(x) - expm1(-x)) / 2
	      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
	  }
	});

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.33 Math.tanh(x)
	var $export = __webpack_require__(114)
	  , expm1   = __webpack_require__(194)
	  , exp     = Math.exp;

	$export($export.S, 'Math', {
	  tanh: function tanh(x){
	    var a = expm1(x = +x)
	      , b = expm1(-x);
	    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
	  }
	});

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.34 Math.trunc(x)
	var $export = __webpack_require__(114);

	$export($export.S, 'Math', {
	  trunc: function trunc(it){
	    return (it > 0 ? Math.floor : Math.ceil)(it);
	  }
	});

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	var $export        = __webpack_require__(114)
	  , toIndex        = __webpack_require__(137)
	  , fromCharCode   = String.fromCharCode
	  , $fromCodePoint = String.fromCodePoint;

	// length should be 1, old FF problem
	$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
	  // 21.1.2.2 String.fromCodePoint(...codePoints)
	  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars
	    var res   = []
	      , $$    = arguments
	      , $$len = $$.length
	      , i     = 0
	      , code;
	    while($$len > i){
	      code = +$$[i++];
	      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
	      res.push(code < 0x10000
	        ? fromCharCode(code)
	        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
	      );
	    } return res.join('');
	  }
	});

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(114)
	  , toIObject = __webpack_require__(134)
	  , toLength  = __webpack_require__(138);

	$export($export.S, 'String', {
	  // 21.1.2.4 String.raw(callSite, ...substitutions)
	  raw: function raw(callSite){
	    var tpl   = toIObject(callSite.raw)
	      , len   = toLength(tpl.length)
	      , $$    = arguments
	      , $$len = $$.length
	      , res   = []
	      , i     = 0;
	    while(len > i){
	      res.push(String(tpl[i++]));
	      if(i < $$len)res.push(String($$[i]));
	    } return res.join('');
	  }
	});

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 21.1.3.25 String.prototype.trim()
	__webpack_require__(174)('trim', function($trim){
	  return function trim(){
	    return $trim(this, 3);
	  };
	});

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(209)(true);

	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(210)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(136)
	  , defined   = __webpack_require__(133);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(150)
	  , $export        = __webpack_require__(114)
	  , redefine       = __webpack_require__(121)
	  , hide           = __webpack_require__(117)
	  , has            = __webpack_require__(128)
	  , Iterators      = __webpack_require__(211)
	  , $iterCreate    = __webpack_require__(212)
	  , setToStringTag = __webpack_require__(146)
	  , getProto       = __webpack_require__(113).getProto
	  , ITERATOR       = __webpack_require__(142)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';

	var returnThis = function(){ return this; };

	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , methods, key;
	  // Fix native
	  if($native){
	    var IteratorPrototype = getProto($default.call(new Base));
	    // Set @@toStringTag to native iterators
	    setToStringTag(IteratorPrototype, TAG, true);
	    // FF fix
	    if(!LIBRARY && has(proto, FF_ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    // fix Array#{values, @@iterator}.name in V8 / FF
	    if(DEF_VALUES && $native.name !== VALUES){
	      VALUES_BUG = true;
	      $default = function values(){ return $native.call(this); };
	    }
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES  ? $default : getMethod(VALUES),
	      keys:    IS_SET      ? $default : getMethod(KEYS),
	      entries: !DEF_VALUES ? $default : getMethod('entries')
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 211 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $              = __webpack_require__(113)
	  , descriptor     = __webpack_require__(118)
	  , setToStringTag = __webpack_require__(146)
	  , IteratorPrototype = {};

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(117)(IteratorPrototype, __webpack_require__(142)('iterator'), function(){ return this; });

	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(114)
	  , $at     = __webpack_require__(209)(false);
	$export($export.P, 'String', {
	  // 21.1.3.3 String.prototype.codePointAt(pos)
	  codePointAt: function codePointAt(pos){
	    return $at(this, pos);
	  }
	});

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
	'use strict';
	var $export   = __webpack_require__(114)
	  , toLength  = __webpack_require__(138)
	  , context   = __webpack_require__(215)
	  , ENDS_WITH = 'endsWith'
	  , $endsWith = ''[ENDS_WITH];

	$export($export.P + $export.F * __webpack_require__(217)(ENDS_WITH), 'String', {
	  endsWith: function endsWith(searchString /*, endPosition = @length */){
	    var that = context(this, searchString, ENDS_WITH)
	      , $$   = arguments
	      , endPosition = $$.length > 1 ? $$[1] : undefined
	      , len    = toLength(that.length)
	      , end    = endPosition === undefined ? len : Math.min(toLength(endPosition), len)
	      , search = String(searchString);
	    return $endsWith
	      ? $endsWith.call(that, search, end)
	      : that.slice(end - search.length, end) === search;
	  }
	});

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	// helper for String#{startsWith, endsWith, includes}
	var isRegExp = __webpack_require__(216)
	  , defined  = __webpack_require__(133);

	module.exports = function(that, searchString, NAME){
	  if(isRegExp(searchString))throw TypeError('String#' + NAME + " doesn't accept regex!");
	  return String(defined(that));
	};

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.8 IsRegExp(argument)
	var isObject = __webpack_require__(127)
	  , cof      = __webpack_require__(129)
	  , MATCH    = __webpack_require__(142)('match');
	module.exports = function(it){
	  var isRegExp;
	  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
	};

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	var MATCH = __webpack_require__(142)('match');
	module.exports = function(KEY){
	  var re = /./;
	  try {
	    '/./'[KEY](re);
	  } catch(e){
	    try {
	      re[MATCH] = false;
	      return !'/./'[KEY](re);
	    } catch(f){ /* empty */ }
	  } return true;
	};

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.7 String.prototype.includes(searchString, position = 0)
	'use strict';
	var $export  = __webpack_require__(114)
	  , context  = __webpack_require__(215)
	  , INCLUDES = 'includes';

	$export($export.P + $export.F * __webpack_require__(217)(INCLUDES), 'String', {
	  includes: function includes(searchString /*, position = 0 */){
	    return !!~context(this, searchString, INCLUDES)
	      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(114);

	$export($export.P, 'String', {
	  // 21.1.3.13 String.prototype.repeat(count)
	  repeat: __webpack_require__(220)
	});

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var toInteger = __webpack_require__(136)
	  , defined   = __webpack_require__(133);

	module.exports = function repeat(count){
	  var str = String(defined(this))
	    , res = ''
	    , n   = toInteger(count);
	  if(n < 0 || n == Infinity)throw RangeError("Count can't be negative");
	  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
	  return res;
	};

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
	'use strict';
	var $export     = __webpack_require__(114)
	  , toLength    = __webpack_require__(138)
	  , context     = __webpack_require__(215)
	  , STARTS_WITH = 'startsWith'
	  , $startsWith = ''[STARTS_WITH];

	$export($export.P + $export.F * __webpack_require__(217)(STARTS_WITH), 'String', {
	  startsWith: function startsWith(searchString /*, position = 0 */){
	    var that   = context(this, searchString, STARTS_WITH)
	      , $$     = arguments
	      , index  = toLength(Math.min($$.length > 1 ? $$[1] : undefined, that.length))
	      , search = String(searchString);
	    return $startsWith
	      ? $startsWith.call(that, search, index)
	      : that.slice(index, index + search.length) === search;
	  }
	});

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ctx         = __webpack_require__(123)
	  , $export     = __webpack_require__(114)
	  , toObject    = __webpack_require__(132)
	  , call        = __webpack_require__(223)
	  , isArrayIter = __webpack_require__(224)
	  , toLength    = __webpack_require__(138)
	  , getIterFn   = __webpack_require__(225);
	$export($export.S + $export.F * !__webpack_require__(226)(function(iter){ Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
	    var O       = toObject(arrayLike)
	      , C       = typeof this == 'function' ? this : Array
	      , $$      = arguments
	      , $$len   = $$.length
	      , mapfn   = $$len > 1 ? $$[1] : undefined
	      , mapping = mapfn !== undefined
	      , index   = 0
	      , iterFn  = getIterFn(O)
	      , length, result, step, iterator;
	    if(mapping)mapfn = ctx(mapfn, $$len > 2 ? $$[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
	      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
	        result[index] = mapping ? call(iterator, mapfn, [step.value, index], true) : step.value;
	      }
	    } else {
	      length = toLength(O.length);
	      for(result = new C(length); length > index; index++){
	        result[index] = mapping ? mapfn(O[index], index) : O[index];
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(131);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(211)
	  , ITERATOR   = __webpack_require__(142)('iterator')
	  , ArrayProto = Array.prototype;

	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(158)
	  , ITERATOR  = __webpack_require__(142)('iterator')
	  , Iterators = __webpack_require__(211);
	module.exports = __webpack_require__(116).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(142)('iterator')
	  , SAFE_CLOSING = false;

	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }

	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ safe = true; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(114);

	// WebKit Array.of isn't generic
	$export($export.S + $export.F * __webpack_require__(120)(function(){
	  function F(){}
	  return !(Array.of.call(F) instanceof F);
	}), 'Array', {
	  // 22.1.2.3 Array.of( ...items)
	  of: function of(/* ...args */){
	    var index  = 0
	      , $$     = arguments
	      , $$len  = $$.length
	      , result = new (typeof this == 'function' ? this : Array)($$len);
	    while($$len > index)result[index] = $$[index++];
	    result.length = $$len;
	    return result;
	  }
	});

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(229)
	  , step             = __webpack_require__(230)
	  , Iterators        = __webpack_require__(211)
	  , toIObject        = __webpack_require__(134);

	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(210)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;

	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.31 Array.prototype[@@unscopables]
	var UNSCOPABLES = __webpack_require__(142)('unscopables')
	  , ArrayProto  = Array.prototype;
	if(ArrayProto[UNSCOPABLES] == undefined)__webpack_require__(117)(ArrayProto, UNSCOPABLES, {});
	module.exports = function(key){
	  ArrayProto[UNSCOPABLES][key] = true;
	};

/***/ },
/* 230 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(232)('Array');

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global      = __webpack_require__(115)
	  , $           = __webpack_require__(113)
	  , DESCRIPTORS = __webpack_require__(119)
	  , SPECIES     = __webpack_require__(142)('species');

	module.exports = function(KEY){
	  var C = global[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])$.setDesc(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	var $export = __webpack_require__(114);

	$export($export.P, 'Array', {copyWithin: __webpack_require__(234)});

	__webpack_require__(229)('copyWithin');

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	'use strict';
	var toObject = __webpack_require__(132)
	  , toIndex  = __webpack_require__(137)
	  , toLength = __webpack_require__(138);

	module.exports = [].copyWithin || function copyWithin(target/*= 0*/, start/*= 0, end = @length*/){
	  var O     = toObject(this)
	    , len   = toLength(O.length)
	    , to    = toIndex(target, len)
	    , from  = toIndex(start, len)
	    , $$    = arguments
	    , end   = $$.length > 2 ? $$[2] : undefined
	    , count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to)
	    , inc   = 1;
	  if(from < to && to < from + count){
	    inc  = -1;
	    from += count - 1;
	    to   += count - 1;
	  }
	  while(count-- > 0){
	    if(from in O)O[to] = O[from];
	    else delete O[to];
	    to   += inc;
	    from += inc;
	  } return O;
	};

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	var $export = __webpack_require__(114);

	$export($export.P, 'Array', {fill: __webpack_require__(236)});

	__webpack_require__(229)('fill');

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	'use strict';
	var toObject = __webpack_require__(132)
	  , toIndex  = __webpack_require__(137)
	  , toLength = __webpack_require__(138);
	module.exports = [].fill || function fill(value /*, start = 0, end = @length */){
	  var O      = toObject(this)
	    , length = toLength(O.length)
	    , $$     = arguments
	    , $$len  = $$.length
	    , index  = toIndex($$len > 1 ? $$[1] : undefined, length)
	    , end    = $$len > 2 ? $$[2] : undefined
	    , endPos = end === undefined ? length : toIndex(end, length);
	  while(endPos > index)O[index++] = value;
	  return O;
	};

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
	var $export = __webpack_require__(114)
	  , $find   = __webpack_require__(139)(5)
	  , KEY     = 'find'
	  , forced  = true;
	// Shouldn't skip holes
	if(KEY in [])Array(1)[KEY](function(){ forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  find: function find(callbackfn/*, that = undefined */){
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(229)(KEY);

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
	var $export = __webpack_require__(114)
	  , $find   = __webpack_require__(139)(6)
	  , KEY     = 'findIndex'
	  , forced  = true;
	// Shouldn't skip holes
	if(KEY in [])Array(1)[KEY](function(){ forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  findIndex: function findIndex(callbackfn/*, that = undefined */){
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(229)(KEY);

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	var $        = __webpack_require__(113)
	  , global   = __webpack_require__(115)
	  , isRegExp = __webpack_require__(216)
	  , $flags   = __webpack_require__(240)
	  , $RegExp  = global.RegExp
	  , Base     = $RegExp
	  , proto    = $RegExp.prototype
	  , re1      = /a/g
	  , re2      = /a/g
	  // "new" creates a new object, old webkit buggy here
	  , CORRECT_NEW = new $RegExp(re1) !== re1;

	if(__webpack_require__(119) && (!CORRECT_NEW || __webpack_require__(120)(function(){
	  re2[__webpack_require__(142)('match')] = false;
	  // RegExp constructor can alter flags and IsRegExp works correct with @@match
	  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
	}))){
	  $RegExp = function RegExp(p, f){
	    var piRE = isRegExp(p)
	      , fiU  = f === undefined;
	    return !(this instanceof $RegExp) && piRE && p.constructor === $RegExp && fiU ? p
	      : CORRECT_NEW
	        ? new Base(piRE && !fiU ? p.source : p, f)
	        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f);
	  };
	  $.each.call($.getNames(Base), function(key){
	    key in $RegExp || $.setDesc($RegExp, key, {
	      configurable: true,
	      get: function(){ return Base[key]; },
	      set: function(it){ Base[key] = it; }
	    });
	  });
	  proto.constructor = $RegExp;
	  $RegExp.prototype = proto;
	  __webpack_require__(121)(global, 'RegExp', $RegExp);
	}

	__webpack_require__(232)('RegExp');

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 21.2.5.3 get RegExp.prototype.flags
	var anObject = __webpack_require__(131);
	module.exports = function(){
	  var that   = anObject(this)
	    , result = '';
	  if(that.global)     result += 'g';
	  if(that.ignoreCase) result += 'i';
	  if(that.multiline)  result += 'm';
	  if(that.unicode)    result += 'u';
	  if(that.sticky)     result += 'y';
	  return result;
	};

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	// 21.2.5.3 get RegExp.prototype.flags()
	var $ = __webpack_require__(113);
	if(__webpack_require__(119) && /./g.flags != 'g')$.setDesc(RegExp.prototype, 'flags', {
	  configurable: true,
	  get: __webpack_require__(240)
	});

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	// @@match logic
	__webpack_require__(243)('match', 1, function(defined, MATCH){
	  // 21.1.3.11 String.prototype.match(regexp)
	  return function match(regexp){
	    'use strict';
	    var O  = defined(this)
	      , fn = regexp == undefined ? undefined : regexp[MATCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
	  };
	});

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var hide     = __webpack_require__(117)
	  , redefine = __webpack_require__(121)
	  , fails    = __webpack_require__(120)
	  , defined  = __webpack_require__(133)
	  , wks      = __webpack_require__(142);

	module.exports = function(KEY, length, exec){
	  var SYMBOL   = wks(KEY)
	    , original = ''[KEY];
	  if(fails(function(){
	    var O = {};
	    O[SYMBOL] = function(){ return 7; };
	    return ''[KEY](O) != 7;
	  })){
	    redefine(String.prototype, KEY, exec(defined, SYMBOL, original));
	    hide(RegExp.prototype, SYMBOL, length == 2
	      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	      ? function(string, arg){ return original.call(string, this, arg); }
	      // 21.2.5.6 RegExp.prototype[@@match](string)
	      // 21.2.5.9 RegExp.prototype[@@search](string)
	      : function(string){ return original.call(string, this); }
	    );
	  }
	};

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	// @@replace logic
	__webpack_require__(243)('replace', 2, function(defined, REPLACE, $replace){
	  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
	  return function replace(searchValue, replaceValue){
	    'use strict';
	    var O  = defined(this)
	      , fn = searchValue == undefined ? undefined : searchValue[REPLACE];
	    return fn !== undefined
	      ? fn.call(searchValue, O, replaceValue)
	      : $replace.call(String(O), searchValue, replaceValue);
	  };
	});

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	// @@search logic
	__webpack_require__(243)('search', 1, function(defined, SEARCH){
	  // 21.1.3.15 String.prototype.search(regexp)
	  return function search(regexp){
	    'use strict';
	    var O  = defined(this)
	      , fn = regexp == undefined ? undefined : regexp[SEARCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
	  };
	});

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	// @@split logic
	__webpack_require__(243)('split', 2, function(defined, SPLIT, $split){
	  // 21.1.3.17 String.prototype.split(separator, limit)
	  return function split(separator, limit){
	    'use strict';
	    var O  = defined(this)
	      , fn = separator == undefined ? undefined : separator[SPLIT];
	    return fn !== undefined
	      ? fn.call(separator, O, limit)
	      : $split.call(String(O), separator, limit);
	  };
	});

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $          = __webpack_require__(113)
	  , LIBRARY    = __webpack_require__(150)
	  , global     = __webpack_require__(115)
	  , ctx        = __webpack_require__(123)
	  , classof    = __webpack_require__(158)
	  , $export    = __webpack_require__(114)
	  , isObject   = __webpack_require__(127)
	  , anObject   = __webpack_require__(131)
	  , aFunction  = __webpack_require__(124)
	  , strictNew  = __webpack_require__(248)
	  , forOf      = __webpack_require__(249)
	  , setProto   = __webpack_require__(156).set
	  , same       = __webpack_require__(154)
	  , SPECIES    = __webpack_require__(142)('species')
	  , speciesConstructor = __webpack_require__(250)
	  , asap       = __webpack_require__(251)
	  , PROMISE    = 'Promise'
	  , process    = global.process
	  , isNode     = classof(process) == 'process'
	  , P          = global[PROMISE]
	  , Wrapper;

	var testResolve = function(sub){
	  var test = new P(function(){});
	  if(sub)test.constructor = Object;
	  return P.resolve(test) === test;
	};

	var USE_NATIVE = function(){
	  var works = false;
	  function P2(x){
	    var self = new P(x);
	    setProto(self, P2.prototype);
	    return self;
	  }
	  try {
	    works = P && P.resolve && testResolve();
	    setProto(P2, P);
	    P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
	    // actual Firefox has broken subclass support, test that
	    if(!(P2.resolve(5).then(function(){}) instanceof P2)){
	      works = false;
	    }
	    // actual V8 bug, https://code.google.com/p/v8/issues/detail?id=4162
	    if(works && __webpack_require__(119)){
	      var thenableThenGotten = false;
	      P.resolve($.setDesc({}, 'then', {
	        get: function(){ thenableThenGotten = true; }
	      }));
	      works = thenableThenGotten;
	    }
	  } catch(e){ works = false; }
	  return works;
	}();

	// helpers
	var sameConstructor = function(a, b){
	  // library wrapper special case
	  if(LIBRARY && a === P && b === Wrapper)return true;
	  return same(a, b);
	};
	var getConstructor = function(C){
	  var S = anObject(C)[SPECIES];
	  return S != undefined ? S : C;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var PromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve),
	  this.reject  = aFunction(reject)
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(record, isReject){
	  if(record.n)return;
	  record.n = true;
	  var chain = record.c;
	  asap(function(){
	    var value = record.v
	      , ok    = record.s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , result, then;
	      try {
	        if(handler){
	          if(!ok)record.h = true;
	          result = handler === true ? value : handler(value);
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    chain.length = 0;
	    record.n = false;
	    if(isReject)setTimeout(function(){
	      var promise = record.p
	        , handler, console;
	      if(isUnhandled(promise)){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      } record.a = undefined;
	    }, 1);
	  });
	};
	var isUnhandled = function(promise){
	  var record = promise._d
	    , chain  = record.a || record.c
	    , i      = 0
	    , reaction;
	  if(record.h)return false;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var $reject = function(value){
	  var record = this;
	  if(record.d)return;
	  record.d = true;
	  record = record.r || record; // unwrap
	  record.v = value;
	  record.s = 2;
	  record.a = record.c.slice();
	  notify(record, true);
	};
	var $resolve = function(value){
	  var record = this
	    , then;
	  if(record.d)return;
	  record.d = true;
	  record = record.r || record; // unwrap
	  try {
	    if(record.p === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      asap(function(){
	        var wrapper = {r: record, d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      record.v = value;
	      record.s = 1;
	      notify(record, false);
	    }
	  } catch(e){
	    $reject.call({r: record, d: false}, e); // wrap
	  }
	};

	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  P = function Promise(executor){
	    aFunction(executor);
	    var record = this._d = {
	      p: strictNew(this, P, PROMISE),         // <- promise
	      c: [],                                  // <- awaiting reactions
	      a: undefined,                           // <- checked in isUnhandled reactions
	      s: 0,                                   // <- state
	      d: false,                               // <- done
	      v: undefined,                           // <- value
	      h: false,                               // <- handled rejection
	      n: false                                // <- notify
	    };
	    try {
	      executor(ctx($resolve, record, 1), ctx($reject, record, 1));
	    } catch(err){
	      $reject.call(record, err);
	    }
	  };
	  __webpack_require__(253)(P.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction = new PromiseCapability(speciesConstructor(this, P))
	        , promise  = reaction.promise
	        , record   = this._d;
	      reaction.ok   = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail = typeof onRejected == 'function' && onRejected;
	      record.c.push(reaction);
	      if(record.a)record.a.push(reaction);
	      if(record.s)notify(record, false);
	      return promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	}

	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: P});
	__webpack_require__(146)(P, PROMISE);
	__webpack_require__(232)(PROMISE);
	Wrapper = __webpack_require__(116)[PROMISE];

	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = new PromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (!USE_NATIVE || testResolve(true)), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof P && sameConstructor(x.constructor, this))return x;
	    var capability = new PromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(226)(function(iter){
	  P.all(iter)['catch'](function(){});
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = getConstructor(this)
	      , capability = new PromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject
	      , values     = [];
	    var abrupt = perform(function(){
	      forOf(iterable, false, values.push, values);
	      var remaining = values.length
	        , results   = Array(remaining);
	      if(remaining)$.each.call(values, function(promise, index){
	        var alreadyCalled = false;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled = true;
	          results[index] = value;
	          --remaining || resolve(results);
	        }, reject);
	      });
	      else resolve(results);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = getConstructor(this)
	      , capability = new PromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ },
/* 248 */
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name){
	  if(!(it instanceof Constructor))throw TypeError(name + ": use the 'new' operator!");
	  return it;
	};

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(123)
	  , call        = __webpack_require__(223)
	  , isArrayIter = __webpack_require__(224)
	  , anObject    = __webpack_require__(131)
	  , toLength    = __webpack_require__(138)
	  , getIterFn   = __webpack_require__(225);
	module.exports = function(iterable, entries, fn, that){
	  var iterFn = getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    call(iterator, f, step.value, entries);
	  }
	};

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(131)
	  , aFunction = __webpack_require__(124)
	  , SPECIES   = __webpack_require__(142)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(115)
	  , macrotask = __webpack_require__(252).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(129)(process) == 'process'
	  , head, last, notify;

	var flush = function(){
	  var parent, domain, fn;
	  if(isNode && (parent = process.domain)){
	    process.domain = null;
	    parent.exit();
	  }
	  while(head){
	    domain = head.domain;
	    fn     = head.fn;
	    if(domain)domain.enter();
	    fn(); // <- currently we use it only for Promise - try / catch not required
	    if(domain)domain.exit();
	    head = head.next;
	  } last = undefined;
	  if(parent)parent.enter();
	};

	// Node.js
	if(isNode){
	  notify = function(){
	    process.nextTick(flush);
	  };
	// browsers with MutationObserver
	} else if(Observer){
	  var toggle = 1
	    , node   = document.createTextNode('');
	  new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	  notify = function(){
	    node.data = toggle = -toggle;
	  };
	// environments with maybe non-completely correct, but existent Promise
	} else if(Promise && Promise.resolve){
	  notify = function(){
	    Promise.resolve().then(flush);
	  };
	// for other environments - macrotask based on:
	// - setImmediate
	// - MessageChannel
	// - window.postMessag
	// - onreadystatechange
	// - setTimeout
	} else {
	  notify = function(){
	    // strange IE + webpack dev server bug - use .call(global)
	    macrotask.call(global, flush);
	  };
	}

	module.exports = function asap(fn){
	  var task = {fn: fn, next: undefined, domain: isNode && process.domain};
	  if(last)last.next = task;
	  if(!head){
	    head = task;
	    notify();
	  } last = task;
	};

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(123)
	  , invoke             = __webpack_require__(130)
	  , html               = __webpack_require__(125)
	  , cel                = __webpack_require__(126)
	  , global             = __webpack_require__(115)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listner = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(129)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listner;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listner, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	var redefine = __webpack_require__(121);
	module.exports = function(target, src){
	  for(var key in src)redefine(target, key, src[key]);
	  return target;
	};

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(255);

	// 23.1 Map Objects
	__webpack_require__(256)('Map', function(get){
	  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key){
	    var entry = strong.getEntry(this, key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value){
	    return strong.def(this, key === 0 ? 0 : key, value);
	  }
	}, strong, true);

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $            = __webpack_require__(113)
	  , hide         = __webpack_require__(117)
	  , redefineAll  = __webpack_require__(253)
	  , ctx          = __webpack_require__(123)
	  , strictNew    = __webpack_require__(248)
	  , defined      = __webpack_require__(133)
	  , forOf        = __webpack_require__(249)
	  , $iterDefine  = __webpack_require__(210)
	  , step         = __webpack_require__(230)
	  , ID           = __webpack_require__(122)('id')
	  , $has         = __webpack_require__(128)
	  , isObject     = __webpack_require__(127)
	  , setSpecies   = __webpack_require__(232)
	  , DESCRIPTORS  = __webpack_require__(119)
	  , isExtensible = Object.isExtensible || isObject
	  , SIZE         = DESCRIPTORS ? '_s' : 'size'
	  , id           = 0;

	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!$has(it, ID)){
	    // can't set id to frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add id
	    if(!create)return 'E';
	    // add missing object id
	    hide(it, ID, ++id);
	  // return object id with prefix
	  } return 'O' + it[ID];
	};

	var getEntry = function(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that._i[index];
	  // frozen object case
	  for(entry = that._f; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	};

	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      strictNew(that, C, NAME);
	      that._i = $.create(null); // index
	      that._f = undefined;      // first entry
	      that._l = undefined;      // last entry
	      that[SIZE] = 0;           // size
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that._f == entry)that._f = next;
	          if(that._l == entry)that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
	          , entry;
	        while(entry = entry ? entry.n : this._f){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if(DESCRIPTORS)$.setDesc(C.prototype, 'size', {
	      get: function(){
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that._f)that._f = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function(C, NAME, IS_MAP){
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function(iterated, kind){
	      this._t = iterated;  // target
	      this._k = kind;      // kind
	      this._l = undefined; // previous
	    }, function(){
	      var that  = this
	        , kind  = that._k
	        , entry = that._l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global         = __webpack_require__(115)
	  , $export        = __webpack_require__(114)
	  , redefine       = __webpack_require__(121)
	  , redefineAll    = __webpack_require__(253)
	  , forOf          = __webpack_require__(249)
	  , strictNew      = __webpack_require__(248)
	  , isObject       = __webpack_require__(127)
	  , fails          = __webpack_require__(120)
	  , $iterDetect    = __webpack_require__(226)
	  , setToStringTag = __webpack_require__(146);

	module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
	  var Base  = global[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  var fixMethod = function(KEY){
	    var fn = proto[KEY];
	    redefine(proto, KEY,
	      KEY == 'delete' ? function(a){
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'has' ? function has(a){
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'get' ? function get(a){
	        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }
	        : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }
	    );
	  };
	  if(typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
	    new C().entries().next();
	  }))){
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	  } else {
	    var instance             = new C
	      // early implementations not supports chaining
	      , HASNT_CHAINING       = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance
	      // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
	      , THROWS_ON_PRIMITIVES = fails(function(){ instance.has(1); })
	      // most early implementations doesn't supports iterables, most modern - not close it correctly
	      , ACCEPT_ITERABLES     = $iterDetect(function(iter){ new C(iter); }) // eslint-disable-line no-new
	      // for early implementations -0 and +0 not the same
	      , BUGGY_ZERO;
	    if(!ACCEPT_ITERABLES){ 
	      C = wrapper(function(target, iterable){
	        strictNew(target, C, NAME);
	        var that = new Base;
	        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	        return that;
	      });
	      C.prototype = proto;
	      proto.constructor = C;
	    }
	    IS_WEAK || instance.forEach(function(val, key){
	      BUGGY_ZERO = 1 / key === -Infinity;
	    });
	    if(THROWS_ON_PRIMITIVES || BUGGY_ZERO){
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }
	    if(BUGGY_ZERO || HASNT_CHAINING)fixMethod(ADDER);
	    // weak collections should not contains .clear method
	    if(IS_WEAK && proto.clear)delete proto.clear;
	  }

	  setToStringTag(C, NAME);

	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F * (C != Base), O);

	  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

	  return C;
	};

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(255);

	// 23.2 Set Objects
	__webpack_require__(256)('Set', function(get){
	  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value){
	    return strong.def(this, value = value === 0 ? 0 : value, value);
	  }
	}, strong);

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $            = __webpack_require__(113)
	  , redefine     = __webpack_require__(121)
	  , weak         = __webpack_require__(259)
	  , isObject     = __webpack_require__(127)
	  , has          = __webpack_require__(128)
	  , frozenStore  = weak.frozenStore
	  , WEAK         = weak.WEAK
	  , isExtensible = Object.isExtensible || isObject
	  , tmp          = {};

	// 23.3 WeakMap Objects
	var $WeakMap = __webpack_require__(256)('WeakMap', function(get){
	  return function WeakMap(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.3.3.3 WeakMap.prototype.get(key)
	  get: function get(key){
	    if(isObject(key)){
	      if(!isExtensible(key))return frozenStore(this).get(key);
	      if(has(key, WEAK))return key[WEAK][this._i];
	    }
	  },
	  // 23.3.3.5 WeakMap.prototype.set(key, value)
	  set: function set(key, value){
	    return weak.def(this, key, value);
	  }
	}, weak, true, true);

	// IE11 WeakMap frozen keys fix
	if(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
	  $.each.call(['delete', 'has', 'get', 'set'], function(key){
	    var proto  = $WeakMap.prototype
	      , method = proto[key];
	    redefine(proto, key, function(a, b){
	      // store frozen objects on leaky map
	      if(isObject(a) && !isExtensible(a)){
	        var result = frozenStore(this)[key](a, b);
	        return key == 'set' ? this : result;
	      // store all the rest on native weakmap
	      } return method.call(this, a, b);
	    });
	  });
	}

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var hide              = __webpack_require__(117)
	  , redefineAll       = __webpack_require__(253)
	  , anObject          = __webpack_require__(131)
	  , isObject          = __webpack_require__(127)
	  , strictNew         = __webpack_require__(248)
	  , forOf             = __webpack_require__(249)
	  , createArrayMethod = __webpack_require__(139)
	  , $has              = __webpack_require__(128)
	  , WEAK              = __webpack_require__(122)('weak')
	  , isExtensible      = Object.isExtensible || isObject
	  , arrayFind         = createArrayMethod(5)
	  , arrayFindIndex    = createArrayMethod(6)
	  , id                = 0;

	// fallback for frozen keys
	var frozenStore = function(that){
	  return that._l || (that._l = new FrozenStore);
	};
	var FrozenStore = function(){
	  this.a = [];
	};
	var findFrozen = function(store, key){
	  return arrayFind(store.a, function(it){
	    return it[0] === key;
	  });
	};
	FrozenStore.prototype = {
	  get: function(key){
	    var entry = findFrozen(this, key);
	    if(entry)return entry[1];
	  },
	  has: function(key){
	    return !!findFrozen(this, key);
	  },
	  set: function(key, value){
	    var entry = findFrozen(this, key);
	    if(entry)entry[1] = value;
	    else this.a.push([key, value]);
	  },
	  'delete': function(key){
	    var index = arrayFindIndex(this.a, function(it){
	      return it[0] === key;
	    });
	    if(~index)this.a.splice(index, 1);
	    return !!~index;
	  }
	};

	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      strictNew(that, C, NAME);
	      that._i = id++;      // collection id
	      that._l = undefined; // leak store for frozen objects
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function(key){
	        if(!isObject(key))return false;
	        if(!isExtensible(key))return frozenStore(this)['delete'](key);
	        return $has(key, WEAK) && $has(key[WEAK], this._i) && delete key[WEAK][this._i];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has(key){
	        if(!isObject(key))return false;
	        if(!isExtensible(key))return frozenStore(this).has(key);
	        return $has(key, WEAK) && $has(key[WEAK], this._i);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    if(!isExtensible(anObject(key))){
	      frozenStore(that).set(key, value);
	    } else {
	      $has(key, WEAK) || hide(key, WEAK, {});
	      key[WEAK][that._i] = value;
	    } return that;
	  },
	  frozenStore: frozenStore,
	  WEAK: WEAK
	};

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var weak = __webpack_require__(259);

	// 23.4 WeakSet Objects
	__webpack_require__(256)('WeakSet', function(get){
	  return function WeakSet(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.4.3.1 WeakSet.prototype.add(value)
	  add: function add(value){
	    return weak.def(this, value, true);
	  }
	}, weak, false, true);

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
	var $export = __webpack_require__(114)
	  , _apply  = Function.apply;

	$export($export.S, 'Reflect', {
	  apply: function apply(target, thisArgument, argumentsList){
	    return _apply.call(target, thisArgument, argumentsList);
	  }
	});

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
	var $         = __webpack_require__(113)
	  , $export   = __webpack_require__(114)
	  , aFunction = __webpack_require__(124)
	  , anObject  = __webpack_require__(131)
	  , isObject  = __webpack_require__(127)
	  , bind      = Function.bind || __webpack_require__(116).Function.prototype.bind;

	// MS Edge supports only 2 arguments
	// FF Nightly sets third argument as `new.target`, but does not create `this` from it
	$export($export.S + $export.F * __webpack_require__(120)(function(){
	  function F(){}
	  return !(Reflect.construct(function(){}, [], F) instanceof F);
	}), 'Reflect', {
	  construct: function construct(Target, args /*, newTarget*/){
	    aFunction(Target);
	    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
	    if(Target == newTarget){
	      // w/o altered newTarget, optimization for 0-4 arguments
	      if(args != undefined)switch(anObject(args).length){
	        case 0: return new Target;
	        case 1: return new Target(args[0]);
	        case 2: return new Target(args[0], args[1]);
	        case 3: return new Target(args[0], args[1], args[2]);
	        case 4: return new Target(args[0], args[1], args[2], args[3]);
	      }
	      // w/o altered newTarget, lot of arguments case
	      var $args = [null];
	      $args.push.apply($args, args);
	      return new (bind.apply(Target, $args));
	    }
	    // with altered newTarget, not support built-in constructors
	    var proto    = newTarget.prototype
	      , instance = $.create(isObject(proto) ? proto : Object.prototype)
	      , result   = Function.apply.call(Target, instance, args);
	    return isObject(result) ? result : instance;
	  }
	});

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
	var $        = __webpack_require__(113)
	  , $export  = __webpack_require__(114)
	  , anObject = __webpack_require__(131);

	// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
	$export($export.S + $export.F * __webpack_require__(120)(function(){
	  Reflect.defineProperty($.setDesc({}, 1, {value: 1}), 1, {value: 2});
	}), 'Reflect', {
	  defineProperty: function defineProperty(target, propertyKey, attributes){
	    anObject(target);
	    try {
	      $.setDesc(target, propertyKey, attributes);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.4 Reflect.deleteProperty(target, propertyKey)
	var $export  = __webpack_require__(114)
	  , getDesc  = __webpack_require__(113).getDesc
	  , anObject = __webpack_require__(131);

	$export($export.S, 'Reflect', {
	  deleteProperty: function deleteProperty(target, propertyKey){
	    var desc = getDesc(anObject(target), propertyKey);
	    return desc && !desc.configurable ? false : delete target[propertyKey];
	  }
	});

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 26.1.5 Reflect.enumerate(target)
	var $export  = __webpack_require__(114)
	  , anObject = __webpack_require__(131);
	var Enumerate = function(iterated){
	  this._t = anObject(iterated); // target
	  this._i = 0;                  // next index
	  var keys = this._k = []       // keys
	    , key;
	  for(key in iterated)keys.push(key);
	};
	__webpack_require__(212)(Enumerate, 'Object', function(){
	  var that = this
	    , keys = that._k
	    , key;
	  do {
	    if(that._i >= keys.length)return {value: undefined, done: true};
	  } while(!((key = keys[that._i++]) in that._t));
	  return {value: key, done: false};
	});

	$export($export.S, 'Reflect', {
	  enumerate: function enumerate(target){
	    return new Enumerate(target);
	  }
	});

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.6 Reflect.get(target, propertyKey [, receiver])
	var $        = __webpack_require__(113)
	  , has      = __webpack_require__(128)
	  , $export  = __webpack_require__(114)
	  , isObject = __webpack_require__(127)
	  , anObject = __webpack_require__(131);

	function get(target, propertyKey/*, receiver*/){
	  var receiver = arguments.length < 3 ? target : arguments[2]
	    , desc, proto;
	  if(anObject(target) === receiver)return target[propertyKey];
	  if(desc = $.getDesc(target, propertyKey))return has(desc, 'value')
	    ? desc.value
	    : desc.get !== undefined
	      ? desc.get.call(receiver)
	      : undefined;
	  if(isObject(proto = $.getProto(target)))return get(proto, propertyKey, receiver);
	}

	$export($export.S, 'Reflect', {get: get});

/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
	var $        = __webpack_require__(113)
	  , $export  = __webpack_require__(114)
	  , anObject = __webpack_require__(131);

	$export($export.S, 'Reflect', {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){
	    return $.getDesc(anObject(target), propertyKey);
	  }
	});

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.8 Reflect.getPrototypeOf(target)
	var $export  = __webpack_require__(114)
	  , getProto = __webpack_require__(113).getProto
	  , anObject = __webpack_require__(131);

	$export($export.S, 'Reflect', {
	  getPrototypeOf: function getPrototypeOf(target){
	    return getProto(anObject(target));
	  }
	});

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.9 Reflect.has(target, propertyKey)
	var $export = __webpack_require__(114);

	$export($export.S, 'Reflect', {
	  has: function has(target, propertyKey){
	    return propertyKey in target;
	  }
	});

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.10 Reflect.isExtensible(target)
	var $export       = __webpack_require__(114)
	  , anObject      = __webpack_require__(131)
	  , $isExtensible = Object.isExtensible;

	$export($export.S, 'Reflect', {
	  isExtensible: function isExtensible(target){
	    anObject(target);
	    return $isExtensible ? $isExtensible(target) : true;
	  }
	});

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.11 Reflect.ownKeys(target)
	var $export = __webpack_require__(114);

	$export($export.S, 'Reflect', {ownKeys: __webpack_require__(272)});

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	// all object keys, includes non-enumerable and symbols
	var $        = __webpack_require__(113)
	  , anObject = __webpack_require__(131)
	  , Reflect  = __webpack_require__(115).Reflect;
	module.exports = Reflect && Reflect.ownKeys || function ownKeys(it){
	  var keys       = $.getNames(anObject(it))
	    , getSymbols = $.getSymbols;
	  return getSymbols ? keys.concat(getSymbols(it)) : keys;
	};

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.12 Reflect.preventExtensions(target)
	var $export            = __webpack_require__(114)
	  , anObject           = __webpack_require__(131)
	  , $preventExtensions = Object.preventExtensions;

	$export($export.S, 'Reflect', {
	  preventExtensions: function preventExtensions(target){
	    anObject(target);
	    try {
	      if($preventExtensions)$preventExtensions(target);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
	var $          = __webpack_require__(113)
	  , has        = __webpack_require__(128)
	  , $export    = __webpack_require__(114)
	  , createDesc = __webpack_require__(118)
	  , anObject   = __webpack_require__(131)
	  , isObject   = __webpack_require__(127);

	function set(target, propertyKey, V/*, receiver*/){
	  var receiver = arguments.length < 4 ? target : arguments[3]
	    , ownDesc  = $.getDesc(anObject(target), propertyKey)
	    , existingDescriptor, proto;
	  if(!ownDesc){
	    if(isObject(proto = $.getProto(target))){
	      return set(proto, propertyKey, V, receiver);
	    }
	    ownDesc = createDesc(0);
	  }
	  if(has(ownDesc, 'value')){
	    if(ownDesc.writable === false || !isObject(receiver))return false;
	    existingDescriptor = $.getDesc(receiver, propertyKey) || createDesc(0);
	    existingDescriptor.value = V;
	    $.setDesc(receiver, propertyKey, existingDescriptor);
	    return true;
	  }
	  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
	}

	$export($export.S, 'Reflect', {set: set});

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.14 Reflect.setPrototypeOf(target, proto)
	var $export  = __webpack_require__(114)
	  , setProto = __webpack_require__(156);

	if(setProto)$export($export.S, 'Reflect', {
	  setPrototypeOf: function setPrototypeOf(target, proto){
	    setProto.check(target, proto);
	    try {
	      setProto.set(target, proto);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export   = __webpack_require__(114)
	  , $includes = __webpack_require__(144)(true);

	$export($export.P, 'Array', {
	  // https://github.com/domenic/Array.prototype.includes
	  includes: function includes(el /*, fromIndex = 0 */){
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	__webpack_require__(229)('includes');

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/mathiasbynens/String.prototype.at
	var $export = __webpack_require__(114)
	  , $at     = __webpack_require__(209)(true);

	$export($export.P, 'String', {
	  at: function at(pos){
	    return $at(this, pos);
	  }
	});

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(114)
	  , $pad    = __webpack_require__(279);

	$export($export.P, 'String', {
	  padLeft: function padLeft(maxLength /*, fillString = ' ' */){
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
	  }
	});

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/ljharb/proposal-string-pad-left-right
	var toLength = __webpack_require__(138)
	  , repeat   = __webpack_require__(220)
	  , defined  = __webpack_require__(133);

	module.exports = function(that, maxLength, fillString, left){
	  var S            = String(defined(that))
	    , stringLength = S.length
	    , fillStr      = fillString === undefined ? ' ' : String(fillString)
	    , intMaxLength = toLength(maxLength);
	  if(intMaxLength <= stringLength)return S;
	  if(fillStr == '')fillStr = ' ';
	  var fillLen = intMaxLength - stringLength
	    , stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
	  if(stringFiller.length > fillLen)stringFiller = stringFiller.slice(0, fillLen);
	  return left ? stringFiller + S : S + stringFiller;
	};

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(114)
	  , $pad    = __webpack_require__(279);

	$export($export.P, 'String', {
	  padRight: function padRight(maxLength /*, fillString = ' ' */){
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
	  }
	});

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(174)('trimLeft', function($trim){
	  return function trimLeft(){
	    return $trim(this, 1);
	  };
	});

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(174)('trimRight', function($trim){
	  return function trimRight(){
	    return $trim(this, 2);
	  };
	});

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/benjamingr/RexExp.escape
	var $export = __webpack_require__(114)
	  , $re     = __webpack_require__(284)(/[\\^$*+?.()|[\]{}]/g, '\\$&');

	$export($export.S, 'RegExp', {escape: function escape(it){ return $re(it); }});


/***/ },
/* 284 */
/***/ function(module, exports) {

	module.exports = function(regExp, replace){
	  var replacer = replace === Object(replace) ? function(part){
	    return replace[part];
	  } : replace;
	  return function(it){
	    return String(it).replace(regExp, replacer);
	  };
	};

/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/WebReflection/9353781
	var $          = __webpack_require__(113)
	  , $export    = __webpack_require__(114)
	  , ownKeys    = __webpack_require__(272)
	  , toIObject  = __webpack_require__(134)
	  , createDesc = __webpack_require__(118);

	$export($export.S, 'Object', {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){
	    var O       = toIObject(object)
	      , setDesc = $.setDesc
	      , getDesc = $.getDesc
	      , keys    = ownKeys(O)
	      , result  = {}
	      , i       = 0
	      , key, D;
	    while(keys.length > i){
	      D = getDesc(O, key = keys[i++]);
	      if(key in result)setDesc(result, key, createDesc(0, D));
	      else result[key] = D;
	    } return result;
	  }
	});

/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	// http://goo.gl/XkBrjD
	var $export = __webpack_require__(114)
	  , $values = __webpack_require__(287)(false);

	$export($export.S, 'Object', {
	  values: function values(it){
	    return $values(it);
	  }
	});

/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	var $         = __webpack_require__(113)
	  , toIObject = __webpack_require__(134)
	  , isEnum    = $.isEnum;
	module.exports = function(isEntries){
	  return function(it){
	    var O      = toIObject(it)
	      , keys   = $.getKeys(O)
	      , length = keys.length
	      , i      = 0
	      , result = []
	      , key;
	    while(length > i)if(isEnum.call(O, key = keys[i++])){
	      result.push(isEntries ? [key, O[key]] : O[key]);
	    } return result;
	  };
	};

/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	// http://goo.gl/XkBrjD
	var $export  = __webpack_require__(114)
	  , $entries = __webpack_require__(287)(true);

	$export($export.S, 'Object', {
	  entries: function entries(it){
	    return $entries(it);
	  }
	});

/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(114);

	$export($export.P, 'Map', {toJSON: __webpack_require__(290)('Map')});

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var forOf   = __webpack_require__(249)
	  , classof = __webpack_require__(158);
	module.exports = function(NAME){
	  return function toJSON(){
	    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
	    var arr = [];
	    forOf(this, false, arr.push, arr);
	    return arr;
	  };
	};

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(114);

	$export($export.P, 'Set', {toJSON: __webpack_require__(290)('Set')});

/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	// JavaScript 1.6 / Strawman array statics shim
	var $       = __webpack_require__(113)
	  , $export = __webpack_require__(114)
	  , $ctx    = __webpack_require__(123)
	  , $Array  = __webpack_require__(116).Array || Array
	  , statics = {};
	var setStatics = function(keys, length){
	  $.each.call(keys.split(','), function(key){
	    if(length == undefined && key in $Array)statics[key] = $Array[key];
	    else if(key in [])statics[key] = $ctx(Function.call, [][key], length);
	  });
	};
	setStatics('pop,reverse,shift,keys,values,entries', 1);
	setStatics('indexOf,every,some,forEach,map,filter,find,findIndex,includes', 3);
	setStatics('join,slice,concat,push,splice,unshift,sort,lastIndexOf,' +
	           'reduce,reduceRight,copyWithin,fill');
	$export($export.S, 'Array', statics);

/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	// ie9- setTimeout & setInterval additional parameters fix
	var global     = __webpack_require__(115)
	  , $export    = __webpack_require__(114)
	  , invoke     = __webpack_require__(130)
	  , partial    = __webpack_require__(294)
	  , navigator  = global.navigator
	  , MSIE       = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
	var wrap = function(set){
	  return MSIE ? function(fn, time /*, ...args */){
	    return set(invoke(
	      partial,
	      [].slice.call(arguments, 2),
	      typeof fn == 'function' ? fn : Function(fn)
	    ), time);
	  } : set;
	};
	$export($export.G + $export.B + $export.F * MSIE, {
	  setTimeout:  wrap(global.setTimeout),
	  setInterval: wrap(global.setInterval)
	});

/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var path      = __webpack_require__(295)
	  , invoke    = __webpack_require__(130)
	  , aFunction = __webpack_require__(124);
	module.exports = function(/* ...pargs */){
	  var fn     = aFunction(this)
	    , length = arguments.length
	    , pargs  = Array(length)
	    , i      = 0
	    , _      = path._
	    , holder = false;
	  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;
	  return function(/* ...args */){
	    var that  = this
	      , $$    = arguments
	      , $$len = $$.length
	      , j = 0, k = 0, args;
	    if(!holder && !$$len)return invoke(fn, pargs, that);
	    args = pargs.slice();
	    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = $$[k++];
	    while($$len > k)args.push($$[k++]);
	    return invoke(fn, args, that);
	  };
	};

/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(115);

/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(114)
	  , $task   = __webpack_require__(252);
	$export($export.G + $export.B, {
	  setImmediate:   $task.set,
	  clearImmediate: $task.clear
	});

/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(228);
	var global      = __webpack_require__(115)
	  , hide        = __webpack_require__(117)
	  , Iterators   = __webpack_require__(211)
	  , ITERATOR    = __webpack_require__(142)('iterator')
	  , NL          = global.NodeList
	  , HTC         = global.HTMLCollection
	  , NLProto     = NL && NL.prototype
	  , HTCProto    = HTC && HTC.prototype
	  , ArrayValues = Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
	if(NLProto && !NLProto[ITERATOR])hide(NLProto, ITERATOR, ArrayValues);
	if(HTCProto && !HTCProto[ITERATOR])hide(HTCProto, ITERATOR, ArrayValues);

/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */

	!(function(global) {
	  "use strict";

	  var hasOwn = Object.prototype.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var iteratorSymbol =
	    typeof Symbol === "function" && Symbol.iterator || "@@iterator";

	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }

	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided, then outerFn.prototype instanceof Generator.
	    var generator = Object.create((outerFn || Generator).prototype);
	    var context = new Context(tryLocsList || []);

	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);

	    return generator;
	  }
	  runtime.wrap = wrap;

	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }

	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";

	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};

	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}

	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunction.displayName = "GeneratorFunction";

	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }

	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };

	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };

	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `value instanceof AwaitArgument` to determine if the yielded value is
	  // meant to be awaited. Some may consider the name of this method too
	  // cutesy, but they are curmudgeons.
	  runtime.awrap = function(arg) {
	    return new AwaitArgument(arg);
	  };

	  function AwaitArgument(arg) {
	    this.arg = arg;
	  }

	  function AsyncIterator(generator) {
	    // This invoke function is written in a style that assumes some
	    // calling function (or Promise) will handle exceptions.
	    function invoke(method, arg) {
	      var result = generator[method](arg);
	      var value = result.value;
	      return value instanceof AwaitArgument
	        ? Promise.resolve(value.arg).then(invokeNext, invokeThrow)
	        : Promise.resolve(value).then(function(unwrapped) {
	            // When a yielded Promise is resolved, its final value becomes
	            // the .value of the Promise<{value,done}> result for the
	            // current iteration. If the Promise is rejected, however, the
	            // result for this iteration will be rejected with the same
	            // reason. Note that rejections of yielded Promises are not
	            // thrown back into the generator function, as is the case
	            // when an awaited Promise is rejected. This difference in
	            // behavior between yield and await is important, because it
	            // allows the consumer to decide what to do with the yielded
	            // rejection (swallow it and continue, manually .throw it back
	            // into the generator, abandon iteration, whatever). With
	            // await, by contrast, there is no opportunity to examine the
	            // rejection reason outside the generator function, so the
	            // only option is to throw it from the await expression, and
	            // let the generator function handle the exception.
	            result.value = unwrapped;
	            return result;
	          });
	    }

	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }

	    var invokeNext = invoke.bind(generator, "next");
	    var invokeThrow = invoke.bind(generator, "throw");
	    var invokeReturn = invoke.bind(generator, "return");
	    var previousPromise;

	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return invoke(method, arg);
	      }

	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : new Promise(function (resolve) {
	          resolve(callInvokeWithMethodAndArg());
	        });
	    }

	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }

	  defineIteratorMethods(AsyncIterator.prototype);

	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );

	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };

	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;

	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }

	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }

	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }

	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          if (method === "return" ||
	              (method === "throw" && delegate.iterator[method] === undefined)) {
	            // A return or throw (when the delegate iterator has no throw
	            // method) always terminates the yield* loop.
	            context.delegate = null;

	            // If the delegate iterator has a return method, give it a
	            // chance to clean up.
	            var returnMethod = delegate.iterator["return"];
	            if (returnMethod) {
	              var record = tryCatch(returnMethod, delegate.iterator, arg);
	              if (record.type === "throw") {
	                // If the return method threw an exception, let that
	                // exception prevail over the original return or throw.
	                method = "throw";
	                arg = record.arg;
	                continue;
	              }
	            }

	            if (method === "return") {
	              // Continue with the outer return, now that the delegate
	              // iterator has been terminated.
	              continue;
	            }
	          }

	          var record = tryCatch(
	            delegate.iterator[method],
	            delegate.iterator,
	            arg
	          );

	          if (record.type === "throw") {
	            context.delegate = null;

	            // Like returning generator.throw(uncaught), but without the
	            // overhead of an extra function call.
	            method = "throw";
	            arg = record.arg;
	            continue;
	          }

	          // Delegate generator ran and handled its own exceptions so
	          // regardless of what the method was, we continue as if it is
	          // "next" with an undefined arg.
	          method = "next";
	          arg = undefined;

	          var info = record.arg;
	          if (info.done) {
	            context[delegate.resultName] = info.value;
	            context.next = delegate.nextLoc;
	          } else {
	            state = GenStateSuspendedYield;
	            return info;
	          }

	          context.delegate = null;
	        }

	        if (method === "next") {
	          if (state === GenStateSuspendedYield) {
	            context.sent = arg;
	          } else {
	            context.sent = undefined;
	          }

	        } else if (method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw arg;
	          }

	          if (context.dispatchException(arg)) {
	            // If the dispatched exception was caught by a catch block,
	            // then let that catch block handle the exception normally.
	            method = "next";
	            arg = undefined;
	          }

	        } else if (method === "return") {
	          context.abrupt("return", arg);
	        }

	        state = GenStateExecuting;

	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;

	          var info = {
	            value: record.arg,
	            done: context.done
	          };

	          if (record.arg === ContinueSentinel) {
	            if (context.delegate && method === "next") {
	              // Deliberately forget the last sent value so that we don't
	              // accidentally pass it on to the delegate.
	              arg = undefined;
	            }
	          } else {
	            return info;
	          }

	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(arg) call above.
	          method = "throw";
	          arg = record.arg;
	        }
	      }
	    };
	  }

	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);

	  Gp[iteratorSymbol] = function() {
	    return this;
	  };

	  Gp.toString = function() {
	    return "[object Generator]";
	  };

	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };

	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }

	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }

	    this.tryEntries.push(entry);
	  }

	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }

	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }

	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();

	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }

	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };

	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }

	      if (typeof iterable.next === "function") {
	        return iterable;
	      }

	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }

	          next.value = undefined;
	          next.done = true;

	          return next;
	        };

	        return next.next = next;
	      }
	    }

	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;

	  function doneResult() {
	    return { value: undefined, done: true };
	  }

	  Context.prototype = {
	    constructor: Context,

	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      this.sent = undefined;
	      this.done = false;
	      this.delegate = null;

	      this.tryEntries.forEach(resetTryEntry);

	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },

	    stop: function() {
	      this.done = true;

	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }

	      return this.rval;
	    },

	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }

	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        return !!caught;
	      }

	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;

	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }

	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");

	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }

	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },

	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }

	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }

	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;

	      if (finallyEntry) {
	        this.next = finallyEntry.finallyLoc;
	      } else {
	        this.complete(record);
	      }

	      return ContinueSentinel;
	    },

	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }

	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = record.arg;
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	    },

	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },

	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }

	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },

	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };

	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(2)))

/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var _syntax = __webpack_require__(300);

	var _syntax2 = _interopRequireDefault(_syntax);

	var _lexicon = __webpack_require__(301);

	function tag(tagname) {
	  return function fn(content, attr) {
	    if (typeof content === "object") {
	      // Curry
	      return function (str) {
	        return fn(str, content);
	      };
	    }

	    if (typeof attr !== "object") {
	      return "<" + tagname + ">" + content + "</" + tagname + ">";
	    } else {

	      var attrstr = Object.keys(attr).map(function (key) {
	        return key + "=\"" + attr[key] + "\"";
	      }).join(" ");

	      return "<" + tagname + " " + attrstr + ">" + content + "</" + tagname + ">";
	    }
	  };
	}

	var mi = tag("mi"),
	    mn = tag("mn"),
	    mo = tag("mo"),
	    mfrac = tag("mfrac"),
	    msup = tag("msup"),
	    msub = tag("msub"),
	    msubsup = tag("msubsup"),
	    munder = tag("munder"),
	    mover = tag("mover"),
	    munderover = tag("munderover"),
	    mrow = tag("mrow"),
	    msqrt = tag("msqrt"),
	    mroot = tag("mroot"),
	    mfenced = tag("mfenced"),
	    mtable = tag("mtable"),
	    mtr = tag("mtr"),
	    mtd = tag("mtd");

	function parser(options) {

	  var decimalMarkRE = options.decimalMark === "." ? "\\." : options.decimalMark,
	      numberRegexp = new RegExp("^" + _lexicon.numbers.digitRange + "+(" + decimalMarkRE + _lexicon.numbers.digitRange + "+)?"),
	      colsplit = splitby(options.colSep),
	      rowsplit = splitby(options.rowSep),
	      newlinesplit = splitby("\n");

	  function splitby(sep) {
	    return function (str) {
	      var split = [],
	          inners = 0,
	          index = 0;

	      for (var i = 0; i < str.length; i += 1) {
	        var rest = str.slice(i),
	            char = str[i];
	        if (rest.startsWith(sep) && !str.slice(0, i).match(/\\(\\{2})*$/)) {
	          if (inners === 0) {
	            split.push(str.slice(index, i));
	            index = i + sep.length;
	          }
	        } else if (char.match(_lexicon.groupings.open.regexp)) {
	          inners += 1;
	        } else if (char.match(_lexicon.groupings.close.regexp)) {
	          inners -= 1;
	        }
	      }

	      split.push(str.slice(index));

	      return split;
	    };
	  }

	  var parse = function parse(_x, _x2, _x3, _x4) {
	    var _again = true;

	    _function: while (_again) {
	      var ascii = _x,
	          mathml = _x2,
	          space = _x3,
	          grouped = _x4;
	      spaces = spacecount = spaceel = _parseone = _parseone2 = el = rest = _splitNextFraction = _splitNextFraction2 = undefined;
	      _again = false;

	      if (!ascii) {
	        return mathml;
	      }

	      if (ascii.match(/^\s/)) {
	        // Dont include the space it if there is a binary infix becoming
	        // a prefix
	        if (ascii.match(/^\s+(\/[^\/]|^[^\^]|_[^_|])/)) {
	          _x = ascii.trim();
	          _x2 = mathml;
	          _x3 = true;
	          _x4 = undefined;
	          _again = true;
	          continue _function;
	        }

	        // Count the number of leading spaces
	        var spaces = ascii.match(/^ +/),
	            spacecount = spaces ? spaces[0].length : 0;

	        if (spacecount > 1) {
	          // spacewidth is a linear function of spacecount
	          var spaceel = "<mspace width=\"" + (spacecount - 1) + "ex\" />";

	          _x = ascii.trim();
	          _x2 = mathml + spaceel;
	          _x3 = true;
	          _x4 = undefined;
	          _again = true;
	          continue _function;
	        }

	        _x = ascii.trim();
	        _x2 = mathml;
	        _x3 = true;
	        _x4 = undefined;
	        _again = true;
	        continue _function;
	      }

	      var _parseone = parseone(ascii, grouped);

	      var _parseone2 = _slicedToArray(_parseone, 2);

	      var el = _parseone2[0];
	      var rest = _parseone2[1];

	      // ## Binary infixes ##

	      // ### Fraction ###
	      if ((rest && rest.trimLeft().startsWith("/") || rest.trimLeft().startsWith("./")) && !rest.trimLeft().match(/^\.?\/\//)) {
	        var _splitNextFraction = splitNextFraction(el, rest);

	        var _splitNextFraction2 = _slicedToArray(_splitNextFraction, 2);

	        el = _splitNextFraction2[0];
	        rest = _splitNextFraction2[1];
	      }

	      _x = rest;
	      _x2 = mathml + el;
	      _x3 = false;
	      _x4 = undefined;
	      _again = true;
	      continue _function;
	    }
	  };

	  function parsegroup(ascii) {
	    // Takes one asciiMath string and returns mathml in one group
	    if (ascii.trim().length === 0) {
	      return "";
	    }
	    var mathml = parse(ascii, "", false, true);

	    return mathml === getlastel(mathml) ? mathml : mrow(mathml);
	  }

	  function parseone(ascii, grouped, lastel) {
	    /**
	     Return a split of the first element parsed to MathML and the rest
	     of the string unparsed.
	     */

	    // TODO: split this up into smaller more readable code

	    if (!ascii) {
	      return ["", ""];
	    }

	    var el = undefined,
	        rest = undefined;

	    var head = ascii[0],
	        tail = ascii.slice(1),
	        nextsymbol = head + (tail.match(/^[A-Za-z]+/) || "");

	    if (ascii.startsWith("sqrt")) {
	      // ## Roots ##

	      var split = parseone(ascii.slice(4).trim(), grouped);

	      el = msqrt(split[0] ? removeSurroundingBrackets(split[0]) : mrow(""));
	      rest = split[1];
	    } else if (ascii.startsWith("root")) {

	      var one = parseone(ascii.slice(4).trimLeft(), grouped),
	          index = one[0] ? removeSurroundingBrackets(one[0]) : mrow(""),
	          two = parseone(one[1].trimLeft(), grouped),
	          base = two[0] ? removeSurroundingBrackets(two[0]) : mrow("");

	      el = mroot(base + index);
	      rest = two[1];
	    } else if (head === "\\" && ascii.length > 1) {
	      // ## Forced opperator ##

	      if (ascii[1].match(/[(\[]/)) {
	        var _stop = findmatching(tail);
	        el = mo(ascii.slice(2, _stop));
	        rest = ascii.slice(_stop + 1);
	      } else {
	        el = mo(ascii[1]);
	        rest = ascii.slice(2);
	      }
	    } else if (_lexicon.accents.contains(nextsymbol)) {

	      // ## Accents ##

	      var accent = _lexicon.accents.get(nextsymbol),
	          next = ascii.slice(nextsymbol.length).trimLeft(),
	          under = accent === "_",
	          ijmatch = next.match(/^\s*\(?([ij])\)?/);

	      if (!under && ijmatch) {
	        // use non-dotted gyphs as to not clutter
	        var letter = ijmatch[1];

	        el = mover(mi(letter === "i" ? "ı" : "ȷ") + mo(accent, { accent: true }));
	        rest = next.slice(ijmatch[0].length);
	      } else {
	        var split = parseone(next),
	            tagfun = under ? munder : mover;

	        el = tagfun(removeSurroundingBrackets(split[0]) + mo(accent, !under && { accent: true }));
	        rest = split[1];
	      }
	    } else if (_syntax2["default"].isfontCommand(ascii)) {

	      // ## Font Commands ##

	      var split = _syntax2["default"].splitfont(ascii);

	      el = tag(split.tagname)(split.text, split.font && { mathvariant: split.font });
	      rest = split.rest;
	    } else if (_syntax2["default"].isgroupStart(ascii) || _syntax2["default"].isvertGroupStart(ascii)) {
	      (function () {

	        // ## Groupings ##

	        var _ref = _syntax2["default"].isgroupStart(ascii) ? _syntax2["default"].splitNextGroup(ascii) : _syntax2["default"].splitNextVert(ascii);

	        var _ref2 = _slicedToArray(_ref, 5);

	        var open = _ref2[1];
	        var group = _ref2[2];
	        var close = _ref2[3];
	        var after = _ref2[4];

	        rest = _lexicon.groupings.open.get(after);
	        var rows = (function () {
	          var lines = newlinesplit(group);
	          return lines.length > 1 ? lines : rowsplit(group);
	        })();

	        if (_syntax2["default"].ismatrixInterior(group.trim(), options.colSep)) {

	          // ### Matrix ##

	          if (group.trim().endsWith(options.colSep)) {
	            // trailing row break
	            group = group.trimRight().slice(0, -1);
	          }

	          var cases = open === "{" && close === "",
	              table = parsetable(group, cases && { columnalign: "center left" });

	          el = mfenced(table, { open: open, close: close });
	        } else if (rows.length > 1) {

	          // ### Column vector ###

	          if (rows.length === 2 && open === "(" && close === ")") {

	            // #### Binomial Coefficient ####

	            // Experimenting with the binomial coefficient
	            // Perhaps I'll remove this later
	            var binom = mfrac(rows.map(parsegroup).join(""), {
	              linethickness: 0
	            });

	            el = mfenced(binom, { open: open, close: close });
	          } else {

	            // #### Single column vector ####

	            var vector = rows.map(colsplit);

	            if (last(vector).length === 1 && last(vector)[0].match(/^\s*$/)) {
	              // A trailing rowbreak
	              vector = vector.slice(0, -1);
	            }

	            var matrix = vector.map(function (row) {
	              return mtr(row.map(compose(mtd, parsegroup)).join(""));
	            }).join("");

	            el = mfenced(mtable(matrix), { open: open, close: close });
	          }
	        } else {

	          // ### A fenced group ###

	          var cols = colsplit(group),
	              els = cols.map(parsegroup).join(""),
	              attrs = { open: open, close: close };

	          if (options.colSep !== ",") {
	            attrs.separators = options.colSep;
	          }
	          el = mfenced(els, attrs);
	        }
	      })();
	    } else if (!grouped && _syntax2["default"].isgroupable(ascii, options)) {

	      // ## Whitespace ##

	      // treat whitespace separated subexpressions as a group
	      var split = splitNextWhitespace(ascii);

	      el = parsegroup(split[0]);
	      rest = split[1];
	    } else if (_lexicon.numbers.isdigit(head)) {

	      // ## Number ##

	      var number = ascii.match(numberRegexp)[0];

	      el = mn(number);
	      rest = tail.slice(number.length - 1);
	    } else if (ascii.match(/^#`[^`]+`/)) {

	      // ## Forced number ##

	      var number = ascii.match(/^#`([^`]+)`/)[1];
	      el = mn(number);
	      rest = ascii.slice(number.length + 3);
	    } else if (ascii.match(new RegExp("^" + _lexicon.operators.regexp.source)) && !_lexicon.identifiers.contains(nextsymbol)) {

	      // ## Operators ##

	      var _syntax$splitNextOperator = _syntax2["default"].splitNextOperator(ascii);

	      var _syntax$splitNextOperator2 = _slicedToArray(_syntax$splitNextOperator, 2);

	      var op = _syntax$splitNextOperator2[0];
	      var next = _syntax$splitNextOperator2[1];
	      var derivative = ascii.startsWith("'");
	      var prefix = contains(["∂", "∇"], op);
	      var stretchy = contains(["|"], op);
	      var mid = ascii.startsWith("| ");
	      var attr = {};
	      if (derivative) {
	        attr.lspace = 0;attr.rspace = 0;
	      }
	      if (prefix) {
	        attr.rspace = 0;
	      }
	      if (stretchy) {
	        attr.stretchy = true;
	      }
	      if (mid) {
	        attr.lspace = "veryverythickmathspace";
	        attr.rspace = "veryverythickmathspace";
	      }

	      el = mo(op, !isempty(attr) && attr);
	      rest = next;
	    } else if (_lexicon.identifiers.contains(nextsymbol)) {

	      // Perhaps a special identifier character
	      var ident = _lexicon.identifiers[nextsymbol];

	      // Uppercase greeks are roman font variant
	      var uppercase = ident.match(/[\u0391-\u03A9\u2100-\u214F\u2200-\u22FF]/);
	      el = uppercase ? mi(ident, { mathvariant: "normal" }) : mi(ident);
	      rest = tail.slice(nextsymbol.length - 1);
	    } else if (head === "O" && tail[0] === "/") {
	      // The special case of the empty set. I suppose there is no
	      // dividing by the latin capital letter O
	      el = mi(_lexicon.identifiers["O/"], { mathvariant: "normal" });
	      rest = tail.slice(1);
	    } else {
	      el = mi(head);
	      rest = tail;
	    }

	    if (rest && rest.trimLeft().match(/\.?[\^_]/)) {

	      if ((lastel ? !lastel.match(/m(sup|over)/) : true) && rest.trim().startsWith("_") && (rest.trim().length <= 1 || !rest.trim()[1].match(/[|_]/))) {
	        var _splitNextSubscript = splitNextSubscript(el, rest);

	        // ### Subscript ###

	        var _splitNextSubscript2 = _slicedToArray(_splitNextSubscript, 2);

	        el = _splitNextSubscript2[0];
	        rest = _splitNextSubscript2[1];
	      } else if (lastel !== "mover" && rest.trim().startsWith("._") && (rest.trim().length <= 2 || !rest.trim()[2].match(/[|_]/))) {
	        var _splitNextUnderscript = splitNextUnderscript(el, rest);

	        // ### Underscript ###

	        var _splitNextUnderscript2 = _slicedToArray(_splitNextUnderscript, 2);

	        el = _splitNextUnderscript2[0];
	        rest = _splitNextUnderscript2[1];
	      } else if ((lastel ? !lastel.match(/m(sub|under)/) : true) && rest.trim().startsWith("^") && (rest.trim().length <= 1 || rest.trim()[1] !== "^")) {
	        var _splitNextSuperscript = splitNextSuperscript(el, rest);

	        // ### Superscript ###

	        var _splitNextSuperscript2 = _slicedToArray(_splitNextSuperscript, 2);

	        el = _splitNextSuperscript2[0];
	        rest = _splitNextSuperscript2[1];
	      } else if (lastel !== "munder" && rest.trim().startsWith(".^") && (rest.trim().length <= 2 || rest.trim()[2] !== "^")) {
	        var _splitNextOverscript = splitNextOverscript(el, rest);

	        // ### Overscript ###

	        var _splitNextOverscript2 = _slicedToArray(_splitNextOverscript, 2);

	        el = _splitNextOverscript2[0];
	        rest = _splitNextOverscript2[1];
	      }
	    }

	    return [el, rest];
	  }

	  function splitNextSubscript(el, rest) {
	    var next = parseone(rest.trim().slice(1).trim(), true, "msub"),
	        sub = next[0] ? removeSurroundingBrackets(next[0]) : mrow("");
	    var ml = undefined,
	        ascii = next[1];

	    // ### Supersubscript ###
	    if (ascii && ascii.trim().startsWith("^") && (ascii.trim().length <= 1 || !ascii.trim()[1] !== "^")) {
	      var next2 = parseone(ascii.trim().slice(1).trim(), true),
	          sup = next2[0] ? removeSurroundingBrackets(next2[0]) : mrow(""),
	          tagfun = _syntax2["default"].shouldGoUnder(el) ? munderover : msubsup;
	      ml = tagfun(el + sub + sup);
	      ascii = next2[1];
	    } else {
	      var tagfun = _syntax2["default"].shouldGoUnder(el) ? munder : msub;
	      ml = tagfun(el + sub);
	    }

	    return [ml, ascii];
	  }

	  function splitNextSuperscript(el, rest) {
	    var next = parseone(rest.trim().slice(1).trim(), true, "msup"),
	        sup = next[0] ? removeSurroundingBrackets(next[0]) : mrow("");
	    var ml = undefined,
	        ascii = next[1];

	    // ### Super- subscript ###
	    if (ascii.trim().startsWith("_") && (ascii.trim().length <= 1 || !ascii.trim()[1].match(/[|_]/))) {
	      var next2 = parseone(ascii.trim().slice(1).trim(), true),
	          sub = next2[0] ? removeSurroundingBrackets(next2[0]) : mrow(""),
	          tagfun = _syntax2["default"].shouldGoUnder(el) ? munderover : msubsup;
	      ml = tagfun(el + sub + sup);
	      ascii = next2[1];
	    } else {
	      var tagfun = _syntax2["default"].shouldGoUnder(el) ? mover : msup;
	      ml = tagfun(el + sup);
	    }

	    return [ml, ascii];
	  }

	  function splitNextUnderscript(el, rest) {
	    var next = parseone(rest.trim().slice(2).trim(), true, "munder"),
	        under = next[0] ? removeSurroundingBrackets(next[0]) : mrow("");
	    var ml = undefined,
	        ascii = next[1];

	    // ### Under- overscript ###
	    var overmatch = ascii.match(/^(\.?\^)[^\^]/);
	    if (overmatch) {
	      var next2 = parseone(ascii.trim().slice(overmatch[1].length).trim(), true),
	          over = next2[0] ? removeSurroundingBrackets(next2[0]) : mrow("");
	      ml = munderover(el + under + over);
	      ascii = next2[1];
	    } else {
	      ml = munder(el + under);
	    }

	    return [ml, ascii];
	  }

	  function splitNextOverscript(el, rest) {
	    var next = parseone(rest.trim().slice(2).trim(), true, "mover"),
	        over = next[0] ? removeSurroundingBrackets(next[0]) : mrow("");
	    var ml = undefined,
	        ascii = next[1];

	    // ### Under- overscript ###
	    var undermatch = ascii.match(/^(\.?_)[^_|]/);
	    if (undermatch) {
	      var next2 = parseone(ascii.trim().slice(undermatch[1].length).trim(), true),
	          under = next2[0] ? removeSurroundingBrackets(next2[0]) : mrow("");
	      ml = munderover(el + under + over);
	      ascii = next2[1];
	    } else {
	      ml = mover(el + over);
	    }

	    return [ml, ascii];
	  }

	  function splitNextFraction(_x5, _x6) {
	    var _again2 = true;

	    _function2: while (_again2) {
	      var el = _x5,
	          rest = _x6;
	      bevelled = rem = next = ml = ascii = split = _parseone3 = _parseone32 = undefined;
	      _again2 = false;

	      var bevelled = rest.trim().startsWith("./"),
	          rem = rest.trim().slice(bevelled ? 2 : 1);
	      var next = undefined,
	          ml = undefined,
	          ascii = undefined;
	      if (rem.startsWith(" ")) {
	        var split = rem.trim().split(" ");
	        next = parsegroup(split[0]);
	        ascii = rem.trimLeft().slice(split[0].length + 1);
	      } else {
	        var _parseone3 = parseone(rem);

	        var _parseone32 = _slicedToArray(_parseone3, 2);

	        next = _parseone32[0];
	        ascii = _parseone32[1];
	      }
	      next = next || mrow("");
	      ml = mfrac(removeSurroundingBrackets(el) + removeSurroundingBrackets(next), bevelled && { bevelled: true });

	      if (ascii && ascii.trim().startsWith("/") || ascii.trim().startsWith("./")) {
	        _x5 = ml;
	        _x6 = ascii;
	        _again2 = true;
	        continue _function2;
	      }
	      return [ml, ascii];
	    }
	  }

	  function splitNextWhitespace(str) {
	    var re = new RegExp("(\\s|" + options.colSep + "|" + options.rowSep + "|$)");
	    var match = str.match(re),
	        head = str.slice(0, match.index),
	        sep = match[0],
	        tail = str.slice(match.index + 1);

	    var next = head,
	        rest = sep + tail;

	    if (!_syntax2["default"].isgroupStart(tail.trim()) && _syntax2["default"].endsInFunc(head)) {
	      var newsplit = splitNextWhitespace(tail);
	      next += sep + newsplit[0];
	      rest = newsplit[1];
	    } else if (head.match(/root$/)) {
	      var split1 = splitNextWhitespace(tail),
	          split2 = splitNextWhitespace(split1[1].trimLeft());
	      next += sep + split1[0] + " " + split2[0];
	      rest = sep + split2[1];
	    }
	    return [next, rest];
	  }

	  function parsetable(matrix, attrs) {
	    var rows = (function () {
	      var lines = colsplit(matrix);
	      return lines.length > 1 ? lines : newlinesplit(matrix);
	    })().map(function (el) {
	      return el.trim().slice(1, -1);
	    });

	    return mtable(rows.map(parserow).join(""), attrs);
	  }

	  function parserow(_x7, _x8) {
	    var _again3 = true;

	    _function3: while (_again3) {
	      var row = _x7,
	          acc = _x8;
	      _parsecell = _parsecell2 = mathml = rest = undefined;
	      _again3 = false;

	      acc = typeof acc === "string" ? acc : "";
	      if (!row || row.length === 0) {
	        return mtr(acc);
	      }

	      var _parsecell = parsecell(row.trim(), "");

	      var _parsecell2 = _slicedToArray(_parsecell, 2);

	      var mathml = _parsecell2[0];
	      var rest = _parsecell2[1];
	      _x7 = rest.trim();
	      _x8 = acc + mathml;
	      _again3 = true;
	      continue _function3;
	    }
	  }

	  function parsecell(_x9, _x10) {
	    var _again4 = true;

	    _function4: while (_again4) {
	      var cell = _x9,
	          acc = _x10;
	      _parseone4 = _parseone42 = mathml = rest = undefined;
	      _again4 = false;

	      if (!cell || cell.length === 0) {
	        return [mtd(acc), ""];
	      }
	      if (cell[0] === options.colSep) {
	        return [mtd(acc), cell.slice(1).trim()];
	      }

	      var _parseone4 = parseone(cell);

	      var _parseone42 = _slicedToArray(_parseone4, 2);

	      var mathml = _parseone42[0];
	      var rest = _parseone42[1];
	      _x9 = rest.trim();
	      _x10 = acc + mathml;
	      _again4 = true;
	      continue _function4;
	    }
	  }

	  return parse;
	}

	function splitlast(mathml) {
	  /**
	   Return a pair of all but last eliment and the last eliment
	   */
	  var lastel = getlastel(mathml),
	      prewels = mathml.slice(0, mathml.lastIndexOf(lastel));

	  return [prewels, lastel];
	}

	function removeSurroundingBrackets(mathml) {
	  var inside = mathml.replace(/^<mfenced[^>]*>/, "").replace(/<\/mfenced>$/, "");
	  if (splitlast(inside)[1] === inside) {
	    return inside;
	  } else {
	    return mrow(inside);
	  }
	}

	function getlastel(xmlstr) {
	  // This breaks the linearity of the implimentation
	  // optimation possible, perhaps an XML parser
	  var tagmatch = xmlstr.match(/<\/(m[a-z]+)>$/);
	  if (!tagmatch) {
	    var spacematch = xmlstr.match(/<mspace\s*([a-z]+="[a-z]")*\s*\?>/);
	    if (spacematch) {
	      var _i = spacematch.match[0].length;
	      return xmlstr.slice(_i);
	    } else {
	      return "";
	    }
	  }

	  var tagname = tagmatch[1];

	  var i = xmlstr.length - (tagname.length + 3),
	      inners = 0;
	  for (i; i >= 0; i -= 1) {
	    if (xmlstr.slice(i).startsWith("<" + tagname)) {
	      if (inners === 0) {
	        break;
	      }
	      inners -= 1;
	    }
	    if (xmlstr.slice(i - 2).startsWith("</" + tagname)) {
	      inners += 1;
	    }
	  }

	  return xmlstr.slice(i);
	}

	function findmatching(str) {
	  var open = str[0],
	      close = open === "(" ? ")" : open === "[" ? "]" : str[0];

	  var inners = 0,
	      index = 0;
	  for (var i = 0; i < str.length; i += 1) {
	    var char = str[i];
	    index += 1;
	    if (char === close) {
	      inners -= 1;
	      if (inners === 0) {
	        break;
	      }
	    } else if (char === open) {
	      inners += 1;
	    }
	  }
	  return index;
	}

	function isempty(obj) {
	  return Object.keys(obj).length === 0;
	}

	function contains(arr, el) {
	  return arr.indexOf(el) >= 0;
	}

	function last(arr) {
	  return arr.slice(-1)[0];
	}

	function compose(f, g) {
	  return function (x) {
	    return f(g(x));
	  };
	}

	parser.getlastel = getlastel;

	exports["default"] = parser;
	module.exports = exports["default"];

/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _lexicon = __webpack_require__(301);

	function splitNextOperator(str) {
	  var re = new RegExp("^" + _lexicon.operators.regexp.source),
	      match = re.exec(str),
	      op = match[0];

	  return [_lexicon.operators.get(op), str.slice(op.length)];
	}

	function isgroupStart(str) {
	  var re = new RegExp("^" + _lexicon.groupings.open.regexp.source);
	  return str.match(re);
	}

	function isgroupable(str, options) {
	  var re = new RegExp("^[0-9A-Za-z+\\-!]{2,}(\\s|" + options.colSep + "|" + options.rowSep + ")");
	  return str.match(re);
	}

	function ismatrixInterior(str, colSep) {
	  return isgroupStart(str) && (function () {
	    var rest = splitNextGroup(str)[4];
	    return rest.trim().startsWith(colSep) || rest.match(/^\s*\n/) && isgroupStart(rest.trim());
	  })();
	}

	var funcEndingRe = new RegExp("(" + _lexicon.identifiers.funs.concat(Object.keys(_lexicon.accents)).concat(["sqrt"]).sort(function (a, b) {
	  return a.length - b.length;
	}).join("|") + ")$");

	function endsInFunc(str) {
	  return str.match(funcEndingRe);
	}

	function splitNextGroup(str) {
	  /** Split the string into `[before, open, group, close, after]` */

	  var openRE = new RegExp("^" + _lexicon.groupings.open.regexp.source),
	      closeRE = new RegExp("^" + _lexicon.groupings.close.regexp.source);

	  var start = undefined,
	      stop = undefined,
	      open = undefined,
	      close = undefined,
	      inners = 0,
	      i = 0;

	  while (i < str.length) {
	    var rest = str.slice(i),
	        openMatch = rest.match(openRE),
	        closeMatch = rest.match(closeRE);

	    if (openMatch) {
	      if (typeof start !== "number") {
	        start = i;
	        open = openMatch[0];
	      }
	      inners += 1;
	      i += openMatch[0].length;
	    } else if (closeMatch) {
	      inners -= 1;
	      if (inners === 0) {
	        close = closeMatch[0];
	        stop = i + (close.length - 1);
	        break;
	      }
	      i += closeMatch[0].length;
	    } else {
	      i += 1;
	    }
	  }

	  if (!open) {
	    return null;
	  }

	  return [start === 0 ? "" : str.slice(0, start), _lexicon.groupings.open.get(open), str.slice(start + open.length, close ? stop - (close.length - 1) : str.length), close ? _lexicon.groupings.close.get(close) : "", stop ? str.slice(stop + 1) : ""];
	}

	function isvertGroupStart(str) {
	  if (!str.startsWith("|")) {
	    return false;
	  }
	  var split = splitNextVert(str);

	  return split && split[0] === "";
	}

	function splitNextVert(str) {
	  function retval(start, stop, double) {
	    return [start === 0 ? "" : str.slice(0, start), double ? "‖" : "|", str.slice(start + (double ? 2 : 1), stop), double ? "‖" : "|", str.slice(stop + (double ? 2 : 1))];
	  }

	  var start = str.indexOf("|"),
	      stop = start + 1,
	      rest = str.slice(start + 1),
	      double = rest.startsWith("|"),
	      re = double ? /\|\|/ : /\|/;

	  if (double) {
	    rest = rest.slice(1);
	    stop += 1;
	  }

	  if (rest.indexOf("|") === -1) {
	    return null;
	  }
	  if (rest.match(/^\.?[_\^]/)) {
	    return null;
	  }

	  while (rest.length > 0) {
	    var split = splitNextGroup(rest),
	        head = split ? split[0] : rest,
	        tail = split ? split[4] : "",
	        match = re.exec(head);

	    if (match) {
	      return retval(start, stop + match.index, double);
	    }

	    stop += split.slice(0, -1).map(dot("length")).reduce(plus);
	    // adjust for slim brackets
	    if (split[1] === "") {
	      stop += 2;
	    } else if (split[1] === "〈") {
	      stop += 1;
	    }
	    if (split[3] === "") {
	      stop += 2;
	    } else if (split[3] === "〉") {
	      stop += 1;
	    }

	    rest = tail;
	  }

	  return null;
	}

	function dot(attr) {
	  return function (obj) {
	    return obj[attr];
	  };
	}

	function plus(a, b) {
	  return a + b;
	}

	// Fonts
	// =====

	function isforcedEl(reEnd) {
	  var re = new RegExp("^" + _lexicon.fonts.regexp.source + "?" + reEnd);
	  return function (str) {
	    return re.exec(str);
	  };
	}

	var isforcedIdentifier = isforcedEl("(`)\\w+`");
	var isforcedText = isforcedEl('(")');

	function isfontCommand(str) {
	  return isforcedIdentifier(str) || isforcedText(str);
	}

	function splitfont(ascii) {
	  var typematch = isforcedIdentifier(ascii) || isforcedText(ascii),
	      type = typematch && typematch[2],
	      tagname = type === '"' ? "mtext" : type === "`" ? "mi" : "";

	  var start = ascii.indexOf(type),
	      stop = start + 1 + ascii.slice(start + 1).indexOf(type),
	      font = start > 0 ? _lexicon.fonts.get(ascii.slice(0, start)) : "";

	  return {
	    tagname: tagname,
	    text: ascii.slice(start + 1, stop),
	    font: font,
	    rest: ascii.slice(stop + 1)
	  };
	}

	var underEls = ["<mi>lim</mi>", "<mo>∑</mo>", "<mo>∏</mo>"];
	function shouldGoUnder(el) {
	  return underEls.indexOf(el) >= 0;
	}

	var syntax = {
	  endsInFunc: endsInFunc,
	  isgroupStart: isgroupStart,
	  isgroupable: isgroupable,
	  isvertGroupStart: isvertGroupStart,
	  splitNextGroup: splitNextGroup,
	  splitNextVert: splitNextVert,
	  splitNextOperator: splitNextOperator,
	  ismatrixInterior: ismatrixInterior,
	  isfontCommand: isfontCommand,
	  splitfont: splitfont,
	  shouldGoUnder: shouldGoUnder
	};

	exports["default"] = syntax;
	module.exports = exports["default"];

/***/ },
/* 301 */
/***/ function(module, exports) {

	// Numbers
	// =======

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var numbers = {};
	var digitRange = "[0-9²³¹¼-¾" + "٠-٩۰-۹߀-߉" + "०-९০-৯৴-৹" + "੦-੯૦-૯୦-୯୲-୷௦-௲" + "౦-౯౸-౾೦-೯൦-൵๐-๙" + "໐-໙༠-༳၀-၉႐-႙፩-፼" + "ᛮ-ᛰ០-៩៰-៹᠐-᠙" + "᥆-᥏᧐-᧚᪀-᪉᪐-᪙" + "᭐-᭙᮰-᮹᱀-᱉᱐-᱙" + "⁰⁴-⁹₀-₉⅐-ↂↅ-↋" + "①-⒛⓪-⓿❶-➓⳽" + "〇〡-〩〸-〺㆒-㆕" + "㈠-㈩㉈-㉏㉑-㉟㊀-㊉㊱-㊿" + "零一二三四五六七八九十百千万億兆京垓𥝱秭穣溝澗正載割分厘毛糸忽微繊沙塵埃" + "꘠-꘩ꛦ-ꛯ꠰-꠵" + "꣐-꣙꤀-꤉꧐-꧙" + "꩐-꩙꯰-꯹０-９]";
	var digitRE = new RegExp(digitRange);

	Object.defineProperties(numbers, {
	  digitRange: { value: digitRange },
	  digitRE: { value: digitRE },
	  isdigit: { value: function value(char) {
	      return char.match(digitRE);
	    } }
	});

	// Identifiers
	// ===========

	var funs = ["sin", "cos", "tan", "csc", "sec", "cot", "sinh", "cosh", "tanh", "log", "ln", "det", "dim", "lim", "mod", "gcd", "lcm", "min", "max"];

	var identifiers = {
	  // Greek uppercase
	  Gamma: "Γ",
	  Delta: "Δ",
	  Theta: "Θ",
	  Lambda: "Λ",
	  Xi: "Ξ",
	  Pi: "Π",
	  Sigma: "Σ",
	  Phi: "Φ",
	  Psi: "Ψ",
	  Omega: "Ω",

	  // Greek lowercase
	  alpha: "α",
	  beta: "β",
	  gamma: "γ",
	  delta: "δ",
	  epsilon: "ɛ",
	  zeta: "ζ",
	  eta: "η",
	  theta: "θ",
	  iota: "ι",
	  kappa: "κ",
	  lambda: "λ",
	  mu: "μ",
	  nu: "ν",
	  xi: "ξ",
	  pi: "π",
	  rho: "ρ",
	  sigma: "σ",
	  tau: "τ",
	  upsilon: "υ",
	  phi: "φ",
	  chi: "χ",
	  psi: "ψ",
	  omega: "ω",

	  // Special symbols
	  "oo": "∞",
	  "O/": "∅",

	  // Blackboard
	  CC: "ℂ",
	  NN: "ℕ",
	  QQ: "ℚ",
	  RR: "ℝ",
	  ZZ: "ℤ"
	};

	funs.forEach(function (fun) {
	  identifiers[fun] = fun;
	});

	Object.defineProperty(identifiers, "contains", {
	  value: function value(char) {
	    return typeof identifiers[char] !== "undefined";
	  }
	});

	Object.defineProperty(identifiers, "funs", {
	  value: funs
	});

	Object.defineProperty(identifiers, "isfun", {
	  value: function value(str) {
	    return funs.indexOf(str) >= 0;
	  }
	});

	// Operators
	// =========

	var operators = {
	  // Operational
	  "*": "·",
	  "**": "∗",
	  "***": "⋆",
	  "//": "/",
	  "|": "|",
	  ":": ":",
	  "'": "′",
	  "''": "″",
	  "'''": "‴",
	  "''''": "⁗",
	  "xx": "×",
	  "-:": "÷",
	  "@": "∘",
	  "o+": "⊕",
	  "ox": "⊗",
	  "o.": "⊙",
	  "!": "!",
	  "sum": "∑",
	  "prod": "∏",
	  "^^": "∧",
	  "^^^": "⋀",
	  "vv": "∨",
	  "vvv": "⋁",
	  "nn": "∩",
	  "nnn": "⋂",
	  "uu": "∪",
	  "uuu": "⋃",

	  // Miscellaneous
	  "int": "∫",
	  "oint": "∮",
	  "dint": "∬",
	  "+-": "±",
	  "del": "∂",
	  "grad": "∇",
	  "aleph": "ℵ",
	  "/_": "∠",
	  "diamond": "⋄",
	  "square": "□",
	  "|__": "⌊",
	  "__|": "⌋",
	  "|~": "⌈",
	  "~|": "⌉",

	  // Relational
	  "=": "=",
	  "!=": "≠",
	  "<": "&lt;",
	  ">": "&gt;",
	  "<=": "≤",
	  ">=": "≥",
	  "-<": "≺",
	  ">-": "≻",
	  "in": "∈",
	  "!in": "∉",
	  "sub": "⊂",
	  "sup": "⊃",
	  "sube": "⊆",
	  "supe": "⊇",
	  "-=": "≡",
	  "==": "≡",
	  "~~": "≈",
	  "prop": "∝",

	  // Arrows
	  "<-": "←",
	  "->": "→",
	  "=>": "⇒",
	  "<=>": "⇔",
	  "|->": "↦",
	  "uarr": "↑",
	  "darr": "↓",
	  "larr": "←",
	  "rarr": "→",
	  "harr": "↔",
	  "lArr": "⇐",
	  "rArr": "⇒",
	  "hArr": "⇔",
	  "iff": "⇔",

	  // Punctuations
	  ",": ",",
	  ":.": "∴",
	  "...": "…",
	  "cdots": "⋯",
	  "ddots": "⋱",
	  "vdots": "⋮",

	  // Logical
	  "if": "if",
	  "otherwise": "otherwise",
	  "and": "and",
	  "or": "or",
	  "not": "¬",
	  "AA": "∀",
	  "EE": "∃",
	  "_|_": "⊥",
	  "TT": "⊤",
	  "|--": "⊢",
	  "|==": "⊨"
	};

	Object.defineProperty(operators, "contains", {
	  value: function value(char) {
	    return typeof operators[char] !== "undefined";
	  }
	});

	Object.defineProperty(operators, "get", {
	  value: function value(char) {
	    return operators[char] || char;
	  }
	});

	Object.defineProperty(operators, "regexp", {
	  value: new RegExp("(" + Object.keys(operators).sort(function (a, b) {
	    return b.length - a.length;
	  }).map(regexpEscape).join("|") + "|[+-<=>|~¬±×÷ϐϑϒϕϰϱϴϵ϶؆؇؈‖′″‴⁀⁄⁒⁡-⁤" + "⁺-⁾₊-₎★☆♠♡♢♣♭♮♯﬩｡-ｨ" + "＋＜＝＞＼＾｜～￢￩￪￫￬" + "∀-⋿⨀-⫿⟀-⟥⦀-⦂" + "⦙-⧿⌁-⏿■-◿⬀-⯿" + "←-⇿⟰-⟿⤀-⥿⃐-⃯]" + ")")
	});

	function regexpEscape(str) {
	  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
	}

	// Groupings
	// =========

	var groupings = {
	  open: { "(:": "⟨", "{:": "" },
	  close: { ":)": "⟩", ":}": "" }
	};

	Object.defineProperty(groupings.open, "regexp", {
	  value: /([[⟦⟨⟪⟬⟮⦃⦅⦇⦉⦋⦍⦏⦑⦓⦕⦗]|[({]:?)/
	});

	Object.defineProperty(groupings.close, "regexp", {
	  value: /([\]⟧⟩⟫⟭⟯⦄⦆⦈⦊⦌⦎⦐⦒⦔⦖⦘]|:?[)}])/
	});

	Object.defineProperty(groupings.open, "get", {
	  value: function value(str) {
	    var match = groupings.open[str];
	    return typeof match === "string" ? match : str;
	  }
	});

	Object.defineProperty(groupings.close, "get", {
	  value: function value(str) {
	    var match = groupings.close[str];
	    return typeof match === "string" ? match : str;
	  }
	});

	Object.freeze(groupings.open);
	Object.freeze(groupings.close);

	// Font
	// ====

	var fonts = {
	  rm: "normal",
	  bf: "bold",
	  it: "italic",
	  bb: "double-struck",
	  cc: "script",
	  tt: "monospace",
	  fr: "fraktur",
	  sf: "sans-serif"
	};

	Object.defineProperty(fonts, "get", {
	  value: function value(str) {
	    return fonts[str];
	  }
	});

	Object.defineProperty(fonts, "regexp", {
	  value: new RegExp("(" + Object.keys(fonts).join("|") + ")")
	});

	// Accents
	// =======

	var accents = {
	  hat: "^",
	  bar: "‾",
	  ul: "_",
	  vec: "→",
	  dot: "⋅",
	  ddot: "⋅⋅"
	};

	Object.defineProperty(accents, "contains", {
	  value: function value(str) {
	    return Object.keys(accents).indexOf(str) >= 0;
	  }
	});

	Object.defineProperty(accents, "get", {
	  value: function value(str) {
	    return accents[str];
	  }
	});

	Object.defineProperty(accents, "regexp", {
	  value: new RegExp("(" + Object.keys(accents).join("|") + ")")
	});

	exports.numbers = numbers;
	exports.identifiers = identifiers;
	exports.operators = operators;
	exports.groupings = groupings;
	exports.fonts = fonts;
	exports.accents = accents;

/***/ }
/******/ ]);