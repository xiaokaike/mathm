"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _syntax = require("./syntax");

var _syntax2 = _interopRequireDefault(_syntax);

var _lexicon = require("./lexicon");

function tag(tagname) {
  return function fn(content, attr) {
    if (typeof content === "object") {
      // Curry
      return function (str) {
        return fn(str, content);
      };
    }

    if (typeof attr !== "object") {
      return "<" + tagname + ">" + content + "</" + tagname + ">";
    } else {

      var attrstr = Object.keys(attr).map(function (key) {
        return key + "=\"" + attr[key] + "\"";
      }).join(" ");

      return "<" + tagname + " " + attrstr + ">" + content + "</" + tagname + ">";
    }
  };
}

var mi = tag("mi"),
    mn = tag("mn"),
    mo = tag("mo"),
    mfrac = tag("mfrac"),
    msup = tag("msup"),
    msub = tag("msub"),
    msubsup = tag("msubsup"),
    munder = tag("munder"),
    mover = tag("mover"),
    munderover = tag("munderover"),
    mrow = tag("mrow"),
    msqrt = tag("msqrt"),
    mroot = tag("mroot"),
    mfenced = tag("mfenced"),
    mtable = tag("mtable"),
    mtr = tag("mtr"),
    mtd = tag("mtd");

function parser(options) {

  var decimalMarkRE = options.decimalMark === "." ? "\\." : options.decimalMark,
      numberRegexp = new RegExp("^" + _lexicon.numbers.digitRange + "+(" + decimalMarkRE + _lexicon.numbers.digitRange + "+)?"),
      colsplit = splitby(options.colSep),
      rowsplit = splitby(options.rowSep),
      newlinesplit = splitby("\n");

  function splitby(sep) {
    return function (str) {
      var split = [],
          inners = 0,
          index = 0;

      for (var i = 0; i < str.length; i += 1) {
        var rest = str.slice(i),
            char = str[i];
        if (rest.startsWith(sep) && !str.slice(0, i).match(/\\(\\{2})*$/)) {
          if (inners === 0) {
            split.push(str.slice(index, i));
            index = i + sep.length;
          }
        } else if (char.match(_lexicon.groupings.open.regexp)) {
          inners += 1;
        } else if (char.match(_lexicon.groupings.close.regexp)) {
          inners -= 1;
        }
      }

      split.push(str.slice(index));

      return split;
    };
  }

  var parse = function parse(_x, _x2, _x3, _x4) {
    var _again = true;

    _function: while (_again) {
      var ascii = _x,
          mathml = _x2,
          space = _x3,
          grouped = _x4;
      spaces = spacecount = spaceel = _parseone = _parseone2 = el = rest = _splitNextFraction = _splitNextFraction2 = undefined;
      _again = false;

      if (!ascii) {
        return mathml;
      }

      if (ascii.match(/^\s/)) {
        // Dont include the space it if there is a binary infix becoming
        // a prefix
        if (ascii.match(/^\s+(\/[^\/]|^[^\^]|_[^_|])/)) {
          _x = ascii.trim();
          _x2 = mathml;
          _x3 = true;
          _x4 = undefined;
          _again = true;
          continue _function;
        }

        // Count the number of leading spaces
        var spaces = ascii.match(/^ +/),
            spacecount = spaces ? spaces[0].length : 0;

        if (spacecount > 1) {
          // spacewidth is a linear function of spacecount
          var spaceel = "<mspace width=\"" + (spacecount - 1) + "ex\" />";

          _x = ascii.trim();
          _x2 = mathml + spaceel;
          _x3 = true;
          _x4 = undefined;
          _again = true;
          continue _function;
        }

        _x = ascii.trim();
        _x2 = mathml;
        _x3 = true;
        _x4 = undefined;
        _again = true;
        continue _function;
      }

      var _parseone = parseone(ascii, grouped);

      var _parseone2 = _slicedToArray(_parseone, 2);

      var el = _parseone2[0];
      var rest = _parseone2[1];

      // ## Binary infixes ##

      // ### Fraction ###
      if ((rest && rest.trimLeft().startsWith("/") || rest.trimLeft().startsWith("./")) && !rest.trimLeft().match(/^\.?\/\//)) {
        var _splitNextFraction = splitNextFraction(el, rest);

        var _splitNextFraction2 = _slicedToArray(_splitNextFraction, 2);

        el = _splitNextFraction2[0];
        rest = _splitNextFraction2[1];
      }

      _x = rest;
      _x2 = mathml + el;
      _x3 = false;
      _x4 = undefined;
      _again = true;
      continue _function;
    }
  };

  function parsegroup(ascii) {
    // Takes one asciiMath string and returns mathml in one group
    if (ascii.trim().length === 0) {
      return "";
    }
    var mathml = parse(ascii, "", false, true);

    return mathml === getlastel(mathml) ? mathml : mrow(mathml);
  }

  function parseone(ascii, grouped, lastel) {
    /**
     Return a split of the first element parsed to MathML and the rest
     of the string unparsed.
     */

    // TODO: split this up into smaller more readable code

    if (!ascii) {
      return ["", ""];
    }

    var el = undefined,
        rest = undefined;

    var head = ascii[0],
        tail = ascii.slice(1),
        nextsymbol = head + (tail.match(/^[A-Za-z]+/) || "");

    if (ascii.startsWith("sqrt")) {
      // ## Roots ##

      var split = parseone(ascii.slice(4).trim(), grouped);

      el = msqrt(split[0] ? removeSurroundingBrackets(split[0]) : mrow(""));
      rest = split[1];
    } else if (ascii.startsWith("root")) {

      var one = parseone(ascii.slice(4).trimLeft(), grouped),
          index = one[0] ? removeSurroundingBrackets(one[0]) : mrow(""),
          two = parseone(one[1].trimLeft(), grouped),
          base = two[0] ? removeSurroundingBrackets(two[0]) : mrow("");

      el = mroot(base + index);
      rest = two[1];
    } else if (head === "\\" && ascii.length > 1) {
      // ## Forced opperator ##

      if (ascii[1].match(/[(\[]/)) {
        var _stop = findmatching(tail);
        el = mo(ascii.slice(2, _stop));
        rest = ascii.slice(_stop + 1);
      } else {
        el = mo(ascii[1]);
        rest = ascii.slice(2);
      }
    } else if (_lexicon.accents.contains(nextsymbol)) {

      // ## Accents ##

      var accent = _lexicon.accents.get(nextsymbol),
          next = ascii.slice(nextsymbol.length).trimLeft(),
          under = accent === "_",
          ijmatch = next.match(/^\s*\(?([ij])\)?/);

      if (!under && ijmatch) {
        // use non-dotted gyphs as to not clutter
        var letter = ijmatch[1];

        el = mover(mi(letter === "i" ? "ı" : "ȷ") + mo(accent, { accent: true }));
        rest = next.slice(ijmatch[0].length);
      } else {
        var split = parseone(next),
            tagfun = under ? munder : mover;

        el = tagfun(removeSurroundingBrackets(split[0]) + mo(accent, !under && { accent: true }));
        rest = split[1];
      }
    } else if (_syntax2["default"].isfontCommand(ascii)) {

      // ## Font Commands ##

      var split = _syntax2["default"].splitfont(ascii);

      el = tag(split.tagname)(split.text, split.font && { mathvariant: split.font });
      rest = split.rest;
    } else if (_syntax2["default"].isgroupStart(ascii) || _syntax2["default"].isvertGroupStart(ascii)) {
      (function () {

        // ## Groupings ##

        var _ref = _syntax2["default"].isgroupStart(ascii) ? _syntax2["default"].splitNextGroup(ascii) : _syntax2["default"].splitNextVert(ascii);

        var _ref2 = _slicedToArray(_ref, 5);

        var open = _ref2[1];
        var group = _ref2[2];
        var close = _ref2[3];
        var after = _ref2[4];

        rest = _lexicon.groupings.open.get(after);
        var rows = (function () {
          var lines = newlinesplit(group);
          return lines.length > 1 ? lines : rowsplit(group);
        })();

        if (_syntax2["default"].ismatrixInterior(group.trim(), options.colSep)) {

          // ### Matrix ##

          if (group.trim().endsWith(options.colSep)) {
            // trailing row break
            group = group.trimRight().slice(0, -1);
          }

          var cases = open === "{" && close === "",
              table = parsetable(group, cases && { columnalign: "center left" });

          el = mfenced(table, { open: open, close: close });
        } else if (rows.length > 1) {

          // ### Column vector ###

          if (rows.length === 2 && open === "(" && close === ")") {

            // #### Binomial Coefficient ####

            // Experimenting with the binomial coefficient
            // Perhaps I'll remove this later
            var binom = mfrac(rows.map(parsegroup).join(""), {
              linethickness: 0
            });

            el = mfenced(binom, { open: open, close: close });
          } else {

            // #### Single column vector ####

            var vector = rows.map(colsplit);

            if (last(vector).length === 1 && last(vector)[0].match(/^\s*$/)) {
              // A trailing rowbreak
              vector = vector.slice(0, -1);
            }

            var matrix = vector.map(function (row) {
              return mtr(row.map(compose(mtd, parsegroup)).join(""));
            }).join("");

            el = mfenced(mtable(matrix), { open: open, close: close });
          }
        } else {

          // ### A fenced group ###

          var cols = colsplit(group),
              els = cols.map(parsegroup).join(""),
              attrs = { open: open, close: close };

          if (options.colSep !== ",") {
            attrs.separators = options.colSep;
          }
          el = mfenced(els, attrs);
        }
      })();
    } else if (!grouped && _syntax2["default"].isgroupable(ascii, options)) {

      // ## Whitespace ##

      // treat whitespace separated subexpressions as a group
      var split = splitNextWhitespace(ascii);

      el = parsegroup(split[0]);
      rest = split[1];
    } else if (_lexicon.numbers.isdigit(head)) {

      // ## Number ##

      var number = ascii.match(numberRegexp)[0];

      el = mn(number);
      rest = tail.slice(number.length - 1);
    } else if (ascii.match(/^#`[^`]+`/)) {

      // ## Forced number ##

      var number = ascii.match(/^#`([^`]+)`/)[1];
      el = mn(number);
      rest = ascii.slice(number.length + 3);
    } else if (ascii.match(new RegExp("^" + _lexicon.operators.regexp.source)) && !_lexicon.identifiers.contains(nextsymbol)) {

      // ## Operators ##

      var _syntax$splitNextOperator = _syntax2["default"].splitNextOperator(ascii);

      var _syntax$splitNextOperator2 = _slicedToArray(_syntax$splitNextOperator, 2);

      var op = _syntax$splitNextOperator2[0];
      var next = _syntax$splitNextOperator2[1];
      var derivative = ascii.startsWith("'");
      var prefix = contains(["∂", "∇"], op);
      var stretchy = contains(["|"], op);
      var mid = ascii.startsWith("| ");
      var attr = {};
      if (derivative) {
        attr.lspace = 0;attr.rspace = 0;
      }
      if (prefix) {
        attr.rspace = 0;
      }
      if (stretchy) {
        attr.stretchy = true;
      }
      if (mid) {
        attr.lspace = "veryverythickmathspace";
        attr.rspace = "veryverythickmathspace";
      }

      el = mo(op, !isempty(attr) && attr);
      rest = next;
    } else if (_lexicon.identifiers.contains(nextsymbol)) {

      // Perhaps a special identifier character
      var ident = _lexicon.identifiers[nextsymbol];

      // Uppercase greeks are roman font variant
      var uppercase = ident.match(/[\u0391-\u03A9\u2100-\u214F\u2200-\u22FF]/);
      el = uppercase ? mi(ident, { mathvariant: "normal" }) : mi(ident);
      rest = tail.slice(nextsymbol.length - 1);
    } else if (head === "O" && tail[0] === "/") {
      // The special case of the empty set. I suppose there is no
      // dividing by the latin capital letter O
      el = mi(_lexicon.identifiers["O/"], { mathvariant: "normal" });
      rest = tail.slice(1);
    } else {
      el = mi(head);
      rest = tail;
    }

    if (rest && rest.trimLeft().match(/\.?[\^_]/)) {

      if ((lastel ? !lastel.match(/m(sup|over)/) : true) && rest.trim().startsWith("_") && (rest.trim().length <= 1 || !rest.trim()[1].match(/[|_]/))) {
        var _splitNextSubscript = splitNextSubscript(el, rest);

        // ### Subscript ###

        var _splitNextSubscript2 = _slicedToArray(_splitNextSubscript, 2);

        el = _splitNextSubscript2[0];
        rest = _splitNextSubscript2[1];
      } else if (lastel !== "mover" && rest.trim().startsWith("._") && (rest.trim().length <= 2 || !rest.trim()[2].match(/[|_]/))) {
        var _splitNextUnderscript = splitNextUnderscript(el, rest);

        // ### Underscript ###

        var _splitNextUnderscript2 = _slicedToArray(_splitNextUnderscript, 2);

        el = _splitNextUnderscript2[0];
        rest = _splitNextUnderscript2[1];
      } else if ((lastel ? !lastel.match(/m(sub|under)/) : true) && rest.trim().startsWith("^") && (rest.trim().length <= 1 || rest.trim()[1] !== "^")) {
        var _splitNextSuperscript = splitNextSuperscript(el, rest);

        // ### Superscript ###

        var _splitNextSuperscript2 = _slicedToArray(_splitNextSuperscript, 2);

        el = _splitNextSuperscript2[0];
        rest = _splitNextSuperscript2[1];
      } else if (lastel !== "munder" && rest.trim().startsWith(".^") && (rest.trim().length <= 2 || rest.trim()[2] !== "^")) {
        var _splitNextOverscript = splitNextOverscript(el, rest);

        // ### Overscript ###

        var _splitNextOverscript2 = _slicedToArray(_splitNextOverscript, 2);

        el = _splitNextOverscript2[0];
        rest = _splitNextOverscript2[1];
      }
    }

    return [el, rest];
  }

  function splitNextSubscript(el, rest) {
    var next = parseone(rest.trim().slice(1).trim(), true, "msub"),
        sub = next[0] ? removeSurroundingBrackets(next[0]) : mrow("");
    var ml = undefined,
        ascii = next[1];

    // ### Supersubscript ###
    if (ascii && ascii.trim().startsWith("^") && (ascii.trim().length <= 1 || !ascii.trim()[1] !== "^")) {
      var next2 = parseone(ascii.trim().slice(1).trim(), true),
          sup = next2[0] ? removeSurroundingBrackets(next2[0]) : mrow(""),
          tagfun = _syntax2["default"].shouldGoUnder(el) ? munderover : msubsup;
      ml = tagfun(el + sub + sup);
      ascii = next2[1];
    } else {
      var tagfun = _syntax2["default"].shouldGoUnder(el) ? munder : msub;
      ml = tagfun(el + sub);
    }

    return [ml, ascii];
  }

  function splitNextSuperscript(el, rest) {
    var next = parseone(rest.trim().slice(1).trim(), true, "msup"),
        sup = next[0] ? removeSurroundingBrackets(next[0]) : mrow("");
    var ml = undefined,
        ascii = next[1];

    // ### Super- subscript ###
    if (ascii.trim().startsWith("_") && (ascii.trim().length <= 1 || !ascii.trim()[1].match(/[|_]/))) {
      var next2 = parseone(ascii.trim().slice(1).trim(), true),
          sub = next2[0] ? removeSurroundingBrackets(next2[0]) : mrow(""),
          tagfun = _syntax2["default"].shouldGoUnder(el) ? munderover : msubsup;
      ml = tagfun(el + sub + sup);
      ascii = next2[1];
    } else {
      var tagfun = _syntax2["default"].shouldGoUnder(el) ? mover : msup;
      ml = tagfun(el + sup);
    }

    return [ml, ascii];
  }

  function splitNextUnderscript(el, rest) {
    var next = parseone(rest.trim().slice(2).trim(), true, "munder"),
        under = next[0] ? removeSurroundingBrackets(next[0]) : mrow("");
    var ml = undefined,
        ascii = next[1];

    // ### Under- overscript ###
    var overmatch = ascii.match(/^(\.?\^)[^\^]/);
    if (overmatch) {
      var next2 = parseone(ascii.trim().slice(overmatch[1].length).trim(), true),
          over = next2[0] ? removeSurroundingBrackets(next2[0]) : mrow("");
      ml = munderover(el + under + over);
      ascii = next2[1];
    } else {
      ml = munder(el + under);
    }

    return [ml, ascii];
  }

  function splitNextOverscript(el, rest) {
    var next = parseone(rest.trim().slice(2).trim(), true, "mover"),
        over = next[0] ? removeSurroundingBrackets(next[0]) : mrow("");
    var ml = undefined,
        ascii = next[1];

    // ### Under- overscript ###
    var undermatch = ascii.match(/^(\.?_)[^_|]/);
    if (undermatch) {
      var next2 = parseone(ascii.trim().slice(undermatch[1].length).trim(), true),
          under = next2[0] ? removeSurroundingBrackets(next2[0]) : mrow("");
      ml = munderover(el + under + over);
      ascii = next2[1];
    } else {
      ml = mover(el + over);
    }

    return [ml, ascii];
  }

  function splitNextFraction(_x5, _x6) {
    var _again2 = true;

    _function2: while (_again2) {
      var el = _x5,
          rest = _x6;
      bevelled = rem = next = ml = ascii = split = _parseone3 = _parseone32 = undefined;
      _again2 = false;

      var bevelled = rest.trim().startsWith("./"),
          rem = rest.trim().slice(bevelled ? 2 : 1);
      var next = undefined,
          ml = undefined,
          ascii = undefined;
      if (rem.startsWith(" ")) {
        var split = rem.trim().split(" ");
        next = parsegroup(split[0]);
        ascii = rem.trimLeft().slice(split[0].length + 1);
      } else {
        var _parseone3 = parseone(rem);

        var _parseone32 = _slicedToArray(_parseone3, 2);

        next = _parseone32[0];
        ascii = _parseone32[1];
      }
      next = next || mrow("");
      ml = mfrac(removeSurroundingBrackets(el) + removeSurroundingBrackets(next), bevelled && { bevelled: true });

      if (ascii && ascii.trim().startsWith("/") || ascii.trim().startsWith("./")) {
        _x5 = ml;
        _x6 = ascii;
        _again2 = true;
        continue _function2;
      }
      return [ml, ascii];
    }
  }

  function splitNextWhitespace(str) {
    var re = new RegExp("(\\s|" + options.colSep + "|" + options.rowSep + "|$)");
    var match = str.match(re),
        head = str.slice(0, match.index),
        sep = match[0],
        tail = str.slice(match.index + 1);

    var next = head,
        rest = sep + tail;

    if (!_syntax2["default"].isgroupStart(tail.trim()) && _syntax2["default"].endsInFunc(head)) {
      var newsplit = splitNextWhitespace(tail);
      next += sep + newsplit[0];
      rest = newsplit[1];
    } else if (head.match(/root$/)) {
      var split1 = splitNextWhitespace(tail),
          split2 = splitNextWhitespace(split1[1].trimLeft());
      next += sep + split1[0] + " " + split2[0];
      rest = sep + split2[1];
    }
    return [next, rest];
  }

  function parsetable(matrix, attrs) {
    var rows = (function () {
      var lines = colsplit(matrix);
      return lines.length > 1 ? lines : newlinesplit(matrix);
    })().map(function (el) {
      return el.trim().slice(1, -1);
    });

    return mtable(rows.map(parserow).join(""), attrs);
  }

  function parserow(_x7, _x8) {
    var _again3 = true;

    _function3: while (_again3) {
      var row = _x7,
          acc = _x8;
      _parsecell = _parsecell2 = mathml = rest = undefined;
      _again3 = false;

      acc = typeof acc === "string" ? acc : "";
      if (!row || row.length === 0) {
        return mtr(acc);
      }

      var _parsecell = parsecell(row.trim(), "");

      var _parsecell2 = _slicedToArray(_parsecell, 2);

      var mathml = _parsecell2[0];
      var rest = _parsecell2[1];
      _x7 = rest.trim();
      _x8 = acc + mathml;
      _again3 = true;
      continue _function3;
    }
  }

  function parsecell(_x9, _x10) {
    var _again4 = true;

    _function4: while (_again4) {
      var cell = _x9,
          acc = _x10;
      _parseone4 = _parseone42 = mathml = rest = undefined;
      _again4 = false;

      if (!cell || cell.length === 0) {
        return [mtd(acc), ""];
      }
      if (cell[0] === options.colSep) {
        return [mtd(acc), cell.slice(1).trim()];
      }

      var _parseone4 = parseone(cell);

      var _parseone42 = _slicedToArray(_parseone4, 2);

      var mathml = _parseone42[0];
      var rest = _parseone42[1];
      _x9 = rest.trim();
      _x10 = acc + mathml;
      _again4 = true;
      continue _function4;
    }
  }

  return parse;
}

function splitlast(mathml) {
  /**
   Return a pair of all but last eliment and the last eliment
   */
  var lastel = getlastel(mathml),
      prewels = mathml.slice(0, mathml.lastIndexOf(lastel));

  return [prewels, lastel];
}

function removeSurroundingBrackets(mathml) {
  var inside = mathml.replace(/^<mfenced[^>]*>/, "").replace(/<\/mfenced>$/, "");
  if (splitlast(inside)[1] === inside) {
    return inside;
  } else {
    return mrow(inside);
  }
}

function getlastel(xmlstr) {
  // This breaks the linearity of the implimentation
  // optimation possible, perhaps an XML parser
  var tagmatch = xmlstr.match(/<\/(m[a-z]+)>$/);
  if (!tagmatch) {
    var spacematch = xmlstr.match(/<mspace\s*([a-z]+="[a-z]")*\s*\?>/);
    if (spacematch) {
      var _i = spacematch.match[0].length;
      return xmlstr.slice(_i);
    } else {
      return "";
    }
  }

  var tagname = tagmatch[1];

  var i = xmlstr.length - (tagname.length + 3),
      inners = 0;
  for (i; i >= 0; i -= 1) {
    if (xmlstr.slice(i).startsWith("<" + tagname)) {
      if (inners === 0) {
        break;
      }
      inners -= 1;
    }
    if (xmlstr.slice(i - 2).startsWith("</" + tagname)) {
      inners += 1;
    }
  }

  return xmlstr.slice(i);
}

function findmatching(str) {
  var open = str[0],
      close = open === "(" ? ")" : open === "[" ? "]" : str[0];

  var inners = 0,
      index = 0;
  for (var i = 0; i < str.length; i += 1) {
    var char = str[i];
    index += 1;
    if (char === close) {
      inners -= 1;
      if (inners === 0) {
        break;
      }
    } else if (char === open) {
      inners += 1;
    }
  }
  return index;
}

function isempty(obj) {
  return Object.keys(obj).length === 0;
}

function contains(arr, el) {
  return arr.indexOf(el) >= 0;
}

function last(arr) {
  return arr.slice(-1)[0];
}

function compose(f, g) {
  return function (x) {
    return f(g(x));
  };
}

parser.getlastel = getlastel;

exports["default"] = parser;
module.exports = exports["default"];